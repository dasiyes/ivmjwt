/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/test/tmain.dart
       |import 'package:test/test.dart';
       |import 'utclasses/jwk_test.dart';
       |import 'utclasses/jwt_test.dart';
       |
       |/// The ivmJWT package test suites
       |///
      1|void main() {
      2|  group('ivmJWT unit tests', () {
       |    /// Test suite for ivmJWT's classes unit tests
       |    ///
      2|    test('JWK and JWKS object initiation and creation', () {
      1|      initJwkJwks();
      1|      createJwkJwks();
       |    });
       |
      1|    test('JWT init and creation', initJWT);
       |
      2|    test('Own token verify', () async {
      1|      verifyOwnIssuedJWT();
       |    });
       |
      2|    test('Unit tests _verifyJWTRS256', () async {
      1|      testIvmCheckIntegrity();
      1|      testIvmCheckClaims();
      1|      testIvmCheckSignature();
       |    });
       |  });
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/test/utclasses/jwk_test.dart
       |import 'dart:convert' show json;
       |import 'package:ivmjwt/ivmjwt.dart';
       |import 'package:pointycastle/pointycastle.dart';
       |import 'package:test/test.dart';
       |
       |/// Unit testing the JWK and JWKS classes
      1|void initJwkJwks() {
       |  /// T1:
       |  /// kty is mandatory property and JWK cannot be created without it
       |  /// expected result: throw exception
       |  ///
      1|  expect(
      2|      () => IvmRS256JWK(''),
      3|      throwsA(predicate((e) =>
      1|          e is Exception &&
      2|          e.toString() == 'Exception: Unacceptable value for the key type!')));
       |
       |  /// T2:
       |  /// kty not in ['EC', 'RSA', 'oct']
       |  ///
      1|  expect(
      2|      () => IvmRS256JWK('SMTH'),
      3|      throwsA(predicate((e) =>
      1|          e is Exception &&
      2|          e.toString() == 'Exception: Unacceptable value for the key type!')));
       |
       |  /// T3:
       |  /// kty IS IN ['EC', 'RSA', 'oct']
       |  ///
      3|  expect(IvmRS256JWK('RSA'), isA<IvmRS256JWK>());
       |
       |  /// T4:
       |  /// A JWKS must have a "keys" attribute
       |  ///
      1|  expect(
      3|      () => IvmRS256JWKS({}),
      3|      throwsA(predicate((e) =>
      1|          e is Exception &&
      2|          e.toString() ==
       |              'Exception: Invalid structure of the object with keys!')));
       |
       |  /// T5:
       |  /// Init correct with "keys" attribute
       |  ///
      5|  expect(IvmRS256JWKS({'keys': []}), isA<IvmRS256JWKS>());
       |
       |  /// T6:
       |  /// Load a key from real JSON. Check the loaded values?
       |  ///
       |  const keys = '''{
       |    "keys": [
       |        {
       |          "kty": "RSA",
       |          "use": "sig",
       |          "kid": "dedc012d07f52aedfd5f97784e1bcbe23c19724d",
       |          "e": "AQAB",
       |          "alg": "RS256",
       |          "n": "sV158-MQ-5-sP2iTJibiMap1ug8tNY97laOud3Se_3jd4INq36NwhLpgU3FC5SCfJOs9wehTLzv_hBuo-sW0JNjAEtMEE-SDtx5486gjymDR-5Iwv7bgt25tD0cDgiboZLt1RLn-nP-V3zgYHZa_s9zLjpNyArsWWcSh6tWe2R8yW6BqS8l4_9z8jkKeyAwWmdpkY8BtKS0zZ9yljiCxKvs8CKjfHmrayg45sZ8V1-aRcjtR2ECxATHjE8L96_oNddZ-rj2axf2vTmnkx3OvIMgx0tZ0ycMG6Wy8wxxaR5ir2LV3Gkyfh72U7tI8Q1sokPmH6G62JcduNY66jEQlvQ"
       |        },
       |        {
       |          "alg": "RS256",
       |          "e": "AQAB",
       |          "n": "syWuIlYmoWSl5rBQGOtYGwO5OCCZnhoWBCyl-x5gby5ofc4HNhBoVVMUggk-f_MH-pyMI5yRYsS_aPQ2bmSox2s4i9cPhxqtSAYMhTPwSwQ2BROC7xxi_N0ovp5Ivut5q8TwAn5kQZa_jR9d7JO20BUB7UqbMkBsqg2J8QTtMJ9YtA5BmUn4Y6vhIjTFtvrA6iM4i1cKoUD5Rirt5CYpcKwsLxBZbVk4E4rqgv7G0UlWt6NAs-z7XDkchlNBVpMUuiUBzxHl4LChc7dsWXRaO5vhu3j_2WnxuWCQZPlGoB51jD_ynZ027hhIcoa_tXg28_qb5Al78ZttiRCQDKueAQ",
       |          "use": "sig",
       |          "kid": "2e3025f26b595f96eac907cc2b9471422bcaeb93",
       |          "kty": "RSA"
       |        }
       |      ]
       |    }''';
      1|  final jJWKS = json.decode(keys) as Map<String, dynamic>;
      1|  final jwkSet = IvmRS256JWKS.fromJson(jJWKS);
       |
      2|  expect(jwkSet, isA<IvmRS256JWKS>());
      1|  expect(jwkSet, isNotNull);
      3|  expect(jwkSet.keys.containsKey('keys'), true);
      3|  expect(jwkSet.keys.length, 1);
      1|  final aKey = jwkSet.getKeyByIndex(0);
      2|  expect(aKey, isA<IvmRS256JWK>());
      2|  expect(aKey.alg, 'RS256');
      2|  expect(aKey.n, isNotNull);
      1|  final key2 = jwkSet.getKeyByKid('2e3025f26b595f96eac907cc2b9471422bcaeb93');
      2|  expect(key2, isA<IvmRS256JWK>());
      2|  expect(key2.alg, 'RS256');
      2|  expect(key2.n, isNotNull);
      3|  expect(key2.n.length, 342);
       |}
       |
      1|void createJwkJwks() {
       |  /// T1:
       |  /// Create a new JWK from json
       |  ///
      2|  final jwk = IvmRS256JWK.fromJson({
       |    'kty': 'RSA',
       |    'alg': 'RS256',
       |    'use': 'sig',
       |    'kid': 'IVM66',
       |    'n':
       |        'b4-mNzh4g22qyPPl41terrV5E9EIVoXW3h490HaBgd1LH9DrM-P_WfH_BkB1_QB8ZOB13rhT3I-A7LjubhWVx0Mwex-qenrcvgCOHgy1mifEy_L1yJ8dP5G8mJ39QVkX3uhOO1bIdDXvU7NHmpz_MQB7jJLuW-KfHtlWsoza5f7nVQrqOJdMMvzjnVwi3OfGR9wMaBZp-z_4FSSV1gs4l5zr-kKTrJa40jrU-WQ_0cKhOVDGkCwvxPvvygfWNRlv1ZMCC_9A88l-NLNoVDSLbP-DAUMj8jNTNfAPZ0w5-_tqPi9AU9lqN1nlzZNkYUXUEck_8o7YCTlay6WPNIYkoQ==',
       |    'e': 'AQAB'
       |  });
      2|  expect(jwk, isA<IvmRS256JWK>());
       |
       |  /// T2:
       |  /// Check the expected attributes values from the T1 above.
       |  ///
      2|  expect(jwk.kty, 'RSA');
      2|  expect(jwk.alg, 'RS256');
      2|  expect(jwk.kid, 'IVM66');
       |
       |  /// T3:
       |  /// test the function getRSAPublicKey
       |  ///
      3|  expect(jwk.getRSAPublicKey(), isA<RSAPublicKey>());
      2|  expect(jwk.getRSAPublicKey(), isNotNull);
       |
       |  /// T4:
       |  /// create a new JWKS from JSON
       |  ///
      2|  final jwks = IvmRS256JWKS.fromJson({
      1|    'keys': [
      1|      {'kty': 'RSA', 'alg': 'RS256', 'use': 'sig', 'kid': 'XXX66'},
      1|      {'kty': 'EC', 'alg': 'HS256', 'use': 'sig', 'kid': 'IVM04'}
       |    ]
       |  });
      2|  expect(jwks, isA<IvmRS256JWKS>());
      1|  expect(jwks, isNotNull);
      3|  expect(jwks.getKeyByIndex(0), isA<IvmRS256JWK>());
      3|  expect(jwks.getKeyByIndex(1).kty, 'EC');
      3|  expect(jwks.getKeyByIndex(0).kid, 'XXX66');
      3|  expect(jwks.getKeyByKid('IVM04'), isA<IvmRS256JWK>());
      3|  expect(jwks.getKeyByKid('IVM04').alg, 'HS256');
       |
       |  /// T5:
       |  /// test the method addJWK a JWK to the list
       |  ///
      1|  jwks.addJWK(jwk);
      2|  expect(jwks, isA<IvmRS256JWKS>());
      3|  expect(jwks.getKeyByIndex(2), isA<IvmRS256JWK>());
      3|  expect(jwks.getKeyByIndex(2).kid, 'IVM66');
      3|  expect(jwks.getKeyByKid('IVM66').alg, 'RS256');
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/test/utclasses/jwt_test.dart
       |import 'package:ivmjwt/ivmjwt.dart';
       |import 'package:pointycastle/pointycastle.dart';
       |import 'package:test/test.dart';
       |import 'dart:convert';
       |
       |/// Unit testing the JWT object
       |///
      1|void initJWT() {
       |  // TODO: [dev] implement JWT test suite
       |  /// T1:
       |  /// Check the segment header init
       |  ///
       |  final segHeader =
      1|      SegmentHeader(alg: 'RS256', typ: 'JWT', cty: 'sig', kid: 'IVM512');
      2|  expect(segHeader, isA<SegmentHeader>());
      1|  expect(segHeader, isNotNull);
      2|  expect(segHeader.kid, 'IVM512');
       |
      1|  final jsonHeader = json.decode(
       |          '{"alg": "RS256", "typ": "JWT", "cty": "JWS", "kid": "IVM512"}')
       |      as Map<String, dynamic>;
      1|  final segHeader2 = SegmentHeader.fromJson(jsonHeader);
      2|  expect(segHeader2, isA<SegmentHeader>());
      1|  expect(segHeader2, isNotNull);
      2|  expect(segHeader2.cty, 'JWS');
       |
       |  /// T2:
       |  /// Check the segment payload init
       |  ///
       |}
       |
      1|void verifyOwnIssuedJWT() async {
       |  // Creating the claims
      1|  final _claims = json.decode(
       |          '{\"iss\": \"Ivmanto.com\", \"maxAge\": 7200, \"ivmanto\": \"dev\"}')
       |      as Map<String, dynamic>;
       |
       |  /// Instantiate segment payload and ivmJWT objects
      1|  final segmentPayload = SegmentPayload.fromJson(_claims);
      1|  final ivmjwt = IvmJWT(segmentPayload);
       |
       |  /// call the issue method for RS256 signed token creation.
      2|  final obj = await ivmjwt.issueJWTRS256();
      2|  final token = obj['token'].toString();
      2|  final keys = obj['publicKey'].toString();
      1|  final segments = token.split('.');
       |
       |  // expect the token to not be empty
      2|  expect(token.isNotEmpty, true);
       |  // expect the keys to  not be empty
      2|  expect(keys.isNotEmpty, true);
      2|  expect(keys.contains('keys'), true);
      3|  expect(segments.length == 3, true);
       |
       |  /// Verification of the own issued token
       |  ///
      2|  final result = await IvmJWT.decodeJWTRS256(token, keys);
      2|  expect(result.containsKey('iss'), true);
      2|  expect(result['iss'], 'Ivmanto.com');
      2|  expect(result.containsKey('ivmanto'), true);
      2|  expect(result['ivmanto'], 'dev');
      2|  expect(result.containsKey('exp'), true);
       |}
       |
       |/// Units testing _verifyJWTRS256 method
       |///
       |/// tests Integrity
       |///
      1|void testIvmCheckIntegrity() async {
       |  // Creating the claims
      1|  final _claims = json.decode(
       |          '{\"iss\": \"Ivmanto.dev\", \"maxAge\": 7200, \"ivmanto\": \"verify\"}')
       |      as Map<String, dynamic>;
       |
       |  /// Instantiate segment payload and ivmJWT objects
      1|  final segmentPayload = SegmentPayload.fromJson(_claims);
      1|  final ivmjwt = IvmJWT(segmentPayload);
       |
       |  /// call the issue method for RS256 signed token creation.
      2|  final obj = await ivmjwt.issueJWTRS256();
      2|  final token = obj['token'].toString();
      2|  await IvmJWT.decodeJWTRS256(token, '');
       |}
       |
       |/// tests Claims
       |///
      1|void testIvmCheckClaims() async {}
       |
       |/// test Signature
       |///
      1|void testIvmCheckSignature() async {}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/jwt/registered_jwt_claims.dart
       |part of '../../ivmjwt.dart';
       |
       |/// Registered JWT Claims
       |///
       |/// Handles registered fields of JWT Claims
       |abstract class RegisteredClaims {
      0|  RegisteredClaims(
       |      {this.iss, this.sub, this.aud, this.exp, this.nbf, this.iat, this.jti});
       |
       |  /// 4.1.1. "iss" (Issuer) Claim
       |  /// The "iss" (issuer) claim identifies the principal that issued the JWT. The processing of this claim is generally application specific. The "iss" value is a case-sensitive string containing a StringOrURI value. Use of this claim is OPTIONAL.
       |  String iss;
       |
       |  /// 4.1.2. "sub" (Subject) Claim
       |  /// The "sub" (subject) claim identifies the principal that is the subject of the JWT. The claims in a JWT are normally statements about the subject. The subject value MUST either be scoped to be locally unique in the context of the issuer or be globally unique. The processing of this claim is generally application specific. The "sub" value is a case-sensitive string containing a StringOrURI value. Use of this claim is OPTIONAL.
       |  String sub;
       |
       |  /// 4.1.3. "aud" (Audience) Claim
       |  /// The "aud" (audience) claim identifies the recipients that the JWT is intended for. Each principal intended to process the JWT MUST identify itself with a value in the audience claim. If the principal processing the claim does not identify itself with a value in the "aud" claim when this claim is present, then the JWT MUST be rejected. In the general case, the "aud" value is an array of case- sensitive strings, each containing a StringOrURI value. In the special case when the JWT has one audience, the "aud" value MAY be a single case-sensitive string containing a StringOrURI value. The interpretation of audience values is generally application specific. Use of this claim is OPTIONAL.
       |  List<String> aud;
       |
       |  /// 4.1.4. "exp" (Expiration Time) Claim
       |  /// The "exp" (expiration time) claim identifies the expiration time on or after which the JWT MUST NOT be accepted for processing. The processing of the "exp" claim requires that the current date/time MUST be before the expiration date/time listed in the "exp" claim. Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew. Its value MUST be a number containing a NumericDate value. Use of this claim is OPTIONAL.
       |  int exp;
       |
       |  /// 4.1.5. "nbf" (Not Before) Claim
       |  /// The "nbf" (not before) claim identifies the time before which the JWT MUST NOT be accepted for processing. The processing of the "nbf" claim requires that the current date/time MUST be after or equal to the not-before date/time listed in the "nbf" claim. Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew. Its value MUST be a number containing a NumericDate value. Use of this claim is OPTIONAL.
       |  int nbf;
       |
       |  /// 4.1.6. "iat" (Issued At) Claim
       |  /// The "iat" (issued at) claim identifies the time at which the JWT was issued. This claim can be used to determine the age of the JWT. Its value MUST be a number containing a NumericDate value. Use of this claim is OPTIONAL.
       |  int iat;
       |
       |  /// 4.1.7. "jti" (JWT ID) Claim
       |  /// The "jti" (JWT ID) claim provides a unique identifier for the JWT. The identifier value MUST be assigned in a manner that ensures that there is a negligible probability that the same value will be accidentally assigned to a different data object; if the application uses multiple issuers, collisions MUST be prevented among values produced by different issuers as well. The "jti" claim can be used to prevent the JWT from being replayed. The "jti" value is a case- sensitive string. Use of this claim is OPTIONAL.
       |  String jti;
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/rsa/ivm_key_pair.dart
       |part of '../../ivmjwt.dart';
       |
       |/// Generate RSA key pair
       |///
       |/// Overview by [pointycastle]:
       |/// The RSA (Rivest Shamir Adleman) algorithm is an asymmetric cryptographic algorithm (also known as a public-key algorithm). It uses two keys: a public key that is used for encrypting data and verifying signatures, and a private key that is used for decrypting data and creating signatures.
       |///
       |
       |class IvmKeyPair {
      1|  IvmKeyPair({this.ivmBitStrength});
       |
       |  /// The pair of Keys
       |  AsymmetricKeyPair<RSAPublicKey, RSAPrivateKey> _pair;
       |  int ivmBitStrength;
       |  Uuid _kid;
       |
       |  /// To generate a pair of RSA keys:
       |  ///
       |  /// 1. Obtain a SecureRandom number generator.
       |  /// 2. Instantiate an RSAKeyGenrator object.
       |  /// 3. Initialize the key generator object with the secure random number generator and other parameters.
       |  /// 4. Invoke the object's generateKeyPair method.
       |
      1|  AsymmetricKeyPair<RSAPublicKey, RSAPrivateKey> _generateRSAKeyPair(
       |      SecureRandom secureRandom,
       |      {int bitStrength = 2048}) {
       |    // create an RSA key generator and initialize it
       |
      1|    final keyGen = RSAKeyGenerator()
      2|      ..init(ParametersWithRandom(
      2|          RSAKeyGeneratorParameters(BigInt.parse('65537'), bitStrength, 64),
       |          secureRandom));
       |
       |    // Use the generator
      1|    final pair = keyGen.generateKeyPair();
       |
       |    // Cast the generated key pair into the RSA key types
      1|    final ivmPublic = pair.publicKey as RSAPublicKey;
      1|    final ivmPrivate = pair.privateKey as RSAPrivateKey;
      4|    this._kid = Uuid(uuid.v1());
       |
       |    // return the generated keys!
      1|    return AsymmetricKeyPair<RSAPublicKey, RSAPrivateKey>(
       |        ivmPublic, ivmPrivate);
       |  }
       |
       |  /// The entire function is from PointyCastle example
       |  ///
      1|  SecureRandom _ivmSecureRandom() {
      1|    final secureRandom = FortunaRandom();
       |
      1|    final seedSource = Random.secure();
      1|    final seeds = <int>[];
      2|    for (var i = 0; i < 32; i++) {
      2|      seeds.add(seedSource.nextInt(255));
       |    }
      3|    secureRandom.seed(KeyParameter(Uint8List.fromList(seeds)));
       |
       |    return secureRandom;
       |  }
       |
       |  /// Trigger the generation and get the pair
       |  ///
       |  /// This method will generate a new key pair from the the same instance of the
       |  /// class. The pair will have a new key id but the same bit strength define
       |  /// in the class instantiation.
       |  ///
      1|  void generateAPair() {
      2|    _kid = Uuid.nil;
      3|    _pair = _generateRSAKeyPair(_ivmSecureRandom(),
      1|        bitStrength: ivmBitStrength ?? 2048);
       |  }
       |
       |  /// Getter for the keyPair
      0|  AsymmetricKeyPair<RSAPublicKey, RSAPrivateKey> get keyPair {
      0|    if (_pair == null) {
      0|      generateAPair();
      0|      return this._pair;
       |    }
      0|    return _pair;
       |  }
       |
       |  /// Getter for the public key in RSAPublicKey format
      0|  RSAPublicKey get publicKey {
      0|    if (_pair == null) {
      0|      generateAPair();
       |    }
      0|    return _pair.publicKey;
       |  }
       |
       |  /// Getter for the private key in RSAPrivateKey format
      1|  RSAPrivateKey get privateKey {
      1|    if (_pair == null) {
      0|      generateAPair();
       |    }
      2|    return _pair.privateKey;
       |  }
       |
       |  /// Getter for the keyPair ID.
      1|  Uuid get kid {
      1|    if (_pair == null) {
      0|      return Uuid.nil;
       |    }
      1|    return _kid;
       |  }
       |
       |  /// Get the public key as JWK
       |  /// According to [RFC7518 section 6.3.1] for RSA Public key the memebers [n](modulus) and [e](exponent) MUST be presented alongside with mandatory [kty]: key.
       |  ///
       |  /// Algorithm is handled by [RFC7518 section 7.1.1] as registration template.
       |  /// For this key pair the default alg is RS256.
      1|  Map<String, dynamic> getPublicKeyAsJWK() {
      1|    if (_pair != null) {
       |      /// Get the public key's modulus
       |      final n =
      5|          base64Url.encode(Utilities.writeBigInt(_pair.publicKey.modulus));
       |
       |      /// Get the public key's exponent
       |      final e = base64Url
      5|          .encode(Utilities.writeBigInt(_pair.publicKey.publicExponent));
       |
       |      /// Get the keys' id
      1|      final k = kid;
       |
      1|      final rsaJWK = <String, dynamic>{
       |        'kty': 'RSA',
      1|        'n': '$n',
      1|        'e': '$e',
       |        'alg': 'RS256',
       |        'use': 'sig',
       |        'kid': '$k'
      1|      };
       |
       |      return rsaJWK;
       |    } else {
       |      return null;
       |    }
       |  }
       |
       |  /// Get the private key as JWK
       |  ///
       |  /// According to [RFC7518 section 6.3.2] for RSA Private key.
       |  /// In addition to the members used to represent RSA public keys, the
       |  /// following members are used to represent RSA private keys. The
       |  /// parameter "d" is REQUIRED for RSA private keys. The others enable
       |  /// optimizations and SHOULD be included by producers of JWKs
       |  /// representing RSA private keys. If the producer includes any of the
       |  /// other private key parameters, then all of the others MUST be present,
       |  /// with the exception of "oth", which MUST only be present when more
       |  /// than two prime factors were used.
       |  ///
      0|  Map<String, dynamic> getPrivateKeyAsJWK() {
       |    // TODO: [dev] think of use-case that make sense since the private key should not be shared!
      0|    throw UnimplementedError();
       |  }
       |
       |  /// Get the public key PEM string
       |  ///
      0|  String getPublicKeyAsPEM() {
       |    // TODO: [JWT-10] [dev] Implement public key as PEM
      0|    throw UnimplementedError();
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/jwt/segment_payload.dart
       |part of '../../ivmjwt.dart';
       |
       |/*
       |  * JWT Claims Set by [RFC7519]:
       |      A JSON object that contains the claims conveyed by the JWT.
       |  * Claim
       |      A piece of information asserted about a subject.  A claim is
       |      represented as a name/value pair consisting of a Claim Name and a
       |      Claim Value. 
       |*/
       |/// JWT's Claims Set
       |///
       |/// This call instance will be used to bring the token's claims
       |/// according to the standard RFC7519.
       |/// It also implements the standard`s registered claims.
       |class SegmentPayload implements RegisteredClaims {
       |  /*
       |   * JSON Web Token (JWT) Overview by [RFC7519]:
       |   JWTs represent a set of claims as a JSON object that is encoded in a
       |   JWS and/or JWE structure.  This JSON object is the JWT Claims Set.
       |   As per Section 4 of RFC 7159 [RFC7159]:, the JSON object consists of
       |   zero or more name/value pairs (or members), where the names are
       |   strings and the values are arbitrary JSON values.  These members are
       |   the claims represented by the JWT.  This JSON object MAY contain
       |   whitespace and/or line breaks before or after any JSON values or
       |   structural characters, in accordance with Section 2 of RFC 7159
       |   [RFC7159]:.
       |  */
       |  /// Instantiate the Claims Set with optional registered claims
       |  ///
      1|  SegmentPayload(
       |      {this.iss, this.sub, this.aud, this.exp, this.nbf, this.iat, this.jti});
       |
       |  /// Instantiate the Claims Set from a json object.
       |  ///
      1|  factory SegmentPayload.fromJson(Map<String, dynamic> json) =>
      1|      _SegmentPayloadFromJson(json);
       |
       |  /// Converts the SegmentPayload object back to a json
       |  ///
      2|  Map<String, dynamic> toJson() => _SegmentPayloadToJson(this);
       |
      1|  void _fromElement(Map<String, Object> initial) {
      1|    initial.entries
      6|        .forEach((element) => _properties[element.key] = element.value);
       |  }
       |
       |  /// Private properties map. Used for adding custom object properties.
       |  ///
       |  final _properties = <String, Object>{};
       |
       |  @override
       |  List<String> aud;
       |
       |  @override
       |  int exp;
       |
       |  @override
       |  int iat;
       |
       |  @override
       |  String iss;
       |
       |  @override
       |  String jti;
       |
       |  @override
       |  int nbf;
       |
       |  @override
       |  String sub;
       |
       |  /// Customizing the class to support any custom fields/kyes in the claims set
       |  ///
      0|  @override
       |  dynamic noSuchMethod(Invocation invocation) {
      0|    if (invocation.isAccessor) {
      0|      final realName = MirrorSystem.getName(invocation.memberName);
      0|      if (invocation.isSetter) {
       |        // for setter realname looks like "prop=" so we remove the "="
      0|        final name = realName.substring(0, realName.length - 1);
      0|        _properties[name] = invocation.positionalArguments.first;
       |        return;
       |      } else {
      0|        return _properties[realName];
       |      }
       |    }
      0|    return super.noSuchMethod(invocation);
       |  }
       |}
       |
       |/// Instantiate SegmentPayload object from a json object
       |///
       |//  ignore: non_constant_identifier_names
      1|SegmentPayload _SegmentPayloadFromJson(Map<String, dynamic> jpld) {
       |  // Converting aud value to a list
      1|  var audList = <String>[];
      3|  if (jpld['aud'].toString().startsWith('[')) {
      0|    audList = jpld['aud'] as List<String>;
       |  } else {
      3|    audList.add(jpld['aud'].toString());
       |  }
       |
       |  // Calculating exp from maxAge or
       |  // if exists - verify if its value is in the future
      1|  if (jpld['maxAge'] != null) {
       |    try {
      3|      final ma = int.parse(jpld['maxAge'].toString());
      3|      jpld['exp'] = Utilities.currentTimeInSMS() + ma;
       |    } catch (e) {
      0|      jpld['exp'] = Utilities.currentTimeInSMS() + 3600;
       |    }
       |  } else {
      0|    if (jpld['exp'] == null) {
      0|      jpld['exp'] = Utilities.currentTimeInSMS() + 3600;
       |    }
       |  }
       |
       |  // Instntiate the object
      1|  final sgp = SegmentPayload(
      2|    iss: jpld['iss'].toString(),
      2|    sub: jpld['sub'].toString(),
       |    aud: audList,
      1|    exp: jpld['exp'] as int,
      1|    nbf: jpld['nbf'] as int,
      1|    iat: jpld['iat'] as int,
      2|    jti: jpld['jti'].toString(),
       |  );
       |
       |  // Get the list of the object's properties
      1|  final spFields = Utilities.getObjectDefNames(sgp, 'fields');
       |
       |  // Go over all json elements
      2|  jpld.forEach((key, value) {
       |    // if the key is not in the current Object
      1|    if (!spFields.contains(key)) {
      4|      sgp._fromElement({'$key': value.toString()});
       |    } else {
      3|      sgp._fromElement({'$key': value});
       |    }
       |  });
       |
       |  return sgp;
       |}
       |
       |/// Converts the SegmentPayload object back to a json
       |///
       |// ignore: non_constant_identifier_names
      1|Map<String, dynamic> _SegmentPayloadToJson(SegmentPayload instance) {
      1|  final val = <String, dynamic>{};
       |
      3|  instance._properties.forEach((String key, dynamic value) {
       |    if (value != null) {
      1|      val[key] = value;
       |    }
       |  });
       |
       |  return val;
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/jwt/jwt.dart
       |part of '../../ivmjwt.dart';
       |
       |/// Abstract by [RFC7519]:
       |///
       |/// JSON Web Token (JWT) is a compact, URL-safe means of representing
       |/// claims to be transferred between two parties. The claims in a JWT
       |/// are encoded as a JSON object that is used as the payload of a JSON
       |/// Web Signature (JWS) structure or as the plaintext of a JSON Web
       |/// Encryption (JWE) structure, enabling the claims to be digitally
       |/// signed or integrity protected with a Message Authentication Code
       |/// (MAC) and/or encrypted.
       |///
       |abstract class JWT extends Object {
       |  /// JSON Web Token (JWT)
       |  ///    A string representing a set of claims as a JSON object that is
       |  ///    encoded in a JWS or JWE, enabling the claims to be digitally
       |  ///    signed or MACed and/or encrypted.
       |  ///
      1|  JWT(this.claimsSet);
       |
       |  /// JWT JOSE Header by [RFC7519]:
       |  ///
       |  SegmentHeader header;
       |
       |  /// JWT Claims Set by [RFC7519]:
       |  ///
       |  SegmentPayload claimsSet;
       |
       |  /// Create RS256 signed token and return this JWT alongside witht the
       |  /// public key that can be used to verify it.
       |  ///
       |  Future<Map<String, dynamic>> issueJWTRS256();
       |
       |  /// Create RS256 signed token with provided private key to be signed with
       |  ///
       |  Future<String> signJWTRS256(RSAPrivateKey pvK);
       |
       |  /// Verify RS256 signed JWT. Unsigned token MUST NOT be verified.
       |  ///
      0|  static Future<bool> _verifyJWTRS256(String token, String jwks) async {
       |    return false;
       |  }
       |
       |  /// decode the token payload and header and return it as json representation
       |  ///
      0|  static Future<Map<String, dynamic>> decodeJWTRS256(
       |      String token, String jwks) async {
      0|    final result = <String, dynamic>{};
      0|    if (await _verifyJWTRS256(token, jwks)) {
       |      return result;
       |    }
       |    return null;
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/jwk/ivm_jwk.dart
       |part of '../../ivmjwt.dart';
       |
       |/// Ivmaanto's implementation of JWK
       |///
       |/// This implementation is to handle RS256 tokens
       |///
       |class IvmRS256JWK extends JWK {
      1|  IvmRS256JWK(String kty,
       |      {this.alg,
       |      this.use,
       |      // ignore: non_constant_identifier_names
       |      this.key_ops,
       |      this.kid,
       |      this.n,
       |      this.e})
      1|      : super(kty, alg: alg, use: use, key_ops: key_ops, kid: kid, n: n, e: e);
       |
      1|  factory IvmRS256JWK.fromJson(Map<String, dynamic> json) =>
      1|      _IvmRS256JWKFromJson(json);
       |
       |  @override
       |  String _kty;
       |
       |  @override
       |  String alg;
       |
       |  @override
       |  String d;
       |
       |  @override
       |  String dp;
       |
       |  @override
       |  String dq;
       |
       |  @override
       |  String e;
       |
       |  @override
       |  // ignore: non_constant_identifier_names
       |  String key_ops;
       |
       |  @override
       |  String kid;
       |
       |  @override
       |  String n;
       |
       |  @override
       |  String p;
       |
       |  @override
       |  String q;
       |
       |  @override
       |  String qi;
       |
       |  @override
       |  String use;
       |
       |  /// Extract the public key from JWK json format as RSAPublicKey
       |  ///
      1|  RSAPublicKey getRSAPublicKey() {
      3|    final _eBytes = base64Url.decode(base64Url.normalize(e));
      3|    final _nBytes = base64Url.decode(base64Url.normalize(n));
       |
      1|    final modulus = Utilities.readBytes(_nBytes);
      1|    final exponent = Utilities.readBytes(_eBytes);
       |
      1|    return RSAPublicKey(modulus, exponent);
       |  }
       |}
       |
       |/// Factory method to load JWK from json object
       |///
       |// ignore: non_constant_identifier_names
      1|IvmRS256JWK _IvmRS256JWKFromJson(Map<String, dynamic> json) {
       |  try {
      3|    final pk = IvmRS256JWK(json['kty'].toString(),
      2|        alg: json['alg'].toString(),
      2|        use: json['use'].toString(),
      2|        kid: json['kid'].toString(),
      2|        n: json['n'].toString(),
      2|        e: json['e'].toString());
       |    return pk;
       |  } catch (e) {
       |    rethrow;
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/rsa/ivm_verifier.dart
       |part of '../../ivmjwt.dart';
       |
       |/// RSA Verifier
       |///
       |/// by [pointycastle]:
       |/// To verify a signature:
       |///
       |/// 1. Obtain an RSAPublicKey.
       |/// 2. Instantiate an RSASigner with the desired Digest algorithm object and algorithm identifier.
       |/// 3. Initialize the object for verification with the public key.
       |/// 4. Invoke the object's verifySignature method with the data that was supposedly signed and the signature.
       |///
       |class IvmVerifierRSA256 {
      1|  IvmVerifierRSA256(
       |      RSAPublicKey publicKey, Uint8List signedData, Uint8List signature) {
       |    if (publicKey == null) {
      0|      throw Exception('Invalid key provided!');
       |    }
      1|    _publicKey = publicKey;
      1|    if (signedData == null || signedData.isEmpty) {
      0|      throw Exception('Signed data not provided!');
       |    }
      1|    _signedData = signedData;
      1|    if (signature == null || signature.isEmpty) {
      0|      throw Exception('Signature is not provided!');
       |    }
      1|    _signature = signature;
       |  }
       |  RSAPublicKey _publicKey;
       |  Uint8List _signedData;
       |  Uint8List _signature;
       |
       |  /// PointyCastle example
      1|  bool rsaVerify(
       |      RSAPublicKey publicKey, Uint8List signedData, Uint8List signature) {
      1|    final sig = RSASignature(signature);
       |
      2|    final verifier = RSASigner(SHA256Digest(), '0609608648016503040201');
       |
      1|    verifier.init(
      1|        false, PublicKeyParameter<RSAPublicKey>(publicKey)); // false=verify
       |
       |    try {
      1|      return verifier.verifySignature(signedData, sig);
      0|    } on ArgumentError {
       |      return false; // for Pointy Castle 1.0.2 when signature has been modified
       |    }
       |  }
       |
      1|  bool verifyRS256() {
      4|    return rsaVerify(_publicKey, _signedData, _signature);
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/jwt/segment_header.dart
       |part of '../../ivmjwt.dart';
       |
       |/**
       | * JOSE Header by [RFC7519]
       |   For a JWT object, the members of the JSON object represented by the
       |   JOSE Header describe the cryptographic operations applied to the JWT
       |   and optionally, additional properties of the JWT.  Depending upon
       |   whether the JWT is a JWS or JWE, the corresponding rules for the JOSE
       |   Header values apply.
       |   This specification further specifies the use of the following Header
       |   Parameters in both the cases where the JWT is a JWS and where it is a
       |   JWE.
       |*/
       |/// The JWT Header Definition
       |///
       |/// This class defines the JOSE Header properties
       |///
       |@JsonSerializable(nullable: false, includeIfNull: false)
       |class SegmentHeader {
       |  /**
       |   * The "typ" (type) Header Parameter defined by [JWS] RFC7515 and [JWE] RFC7516 
       |   * is used by JWT applications to declare the media type [IANA.MediaTypes] of
       |   * this complete JWT.
       |  */
       |  /**
       |   * The "cty" (content type) Header Parameter defined by [JWS] RFC7515 and 
       |   * [JWE] RFC7516 is used by this specification to convey structural 
       |   * information about the JWT.
       |   */
       |  /// Instantiating the SegmentHeader with optional properties
       |  ///
      1|  SegmentHeader({this.alg, this.typ, this.cty, this.kid});
       |
       |  /// Instantiating the SegmentHeader object from json object
       |  ///
      1|  factory SegmentHeader.fromJson(Map<String, dynamic> json) =>
      1|      _$SegmentHeaderFromJson(json);
       |
       |  /// Converting the object instance back to json object
       |  ///
      2|  Map<String, dynamic> toJson() => _$SegmentHeaderToJson(this);
       |
       |  @JsonKey(nullable: false)
       |  final String alg;
       |  @JsonKey(nullable: true, includeIfNull: true)
       |  final String typ;
       |  @JsonKey(nullable: true, includeIfNull: false)
       |  final String cty;
       |  @JsonKey(nullable: true, includeIfNull: false)
       |  final String kid;
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/jwk/ivm_jwks.dart
       |part of '../../ivmjwt.dart';
       |
       |/// Ivmanto's implementation of JWKS
       |///
       |/// The set of JWKs will be provided to the verification function
       |/// of RS256 signed tokens
       |///
       |class IvmRS256JWKS extends JWKS {
      2|  IvmRS256JWKS(this._jwks) : super(_jwks);
       |
      1|  factory IvmRS256JWKS.fromJson(Map<String, dynamic> json) =>
      1|      _IvmRS256JWKSFromJson(json);
       |
       |  @override
       |  Map<String, List> _jwks;
       |
       |  @override
       |  String _kty;
       |
       |  @override
       |  String alg;
       |
       |  @override
       |  String d;
       |
       |  @override
       |  String dp;
       |
       |  @override
       |  String dq;
       |
       |  @override
       |  String e;
       |
       |  @override
       |  // ignore: non_constant_identifier_names
       |  String key_ops;
       |
       |  @override
       |  String kid;
       |
       |  @override
       |  String kty;
       |
       |  @override
       |  String n;
       |
       |  @override
       |  String p;
       |
       |  @override
       |  String q;
       |
       |  @override
       |  String qi;
       |
       |  @override
       |  String use;
       |
      1|  @override
       |  IvmRS256JWK getKeyByIndex(int index) {
      3|    return _jwks['keys'][index] as IvmRS256JWK;
       |  }
       |
      1|  @override
       |  IvmRS256JWK getKeyByKid(String kid) {
      2|    final keysArray = _jwks['keys'] as List<IvmRS256JWK>;
      2|    for (var key in keysArray) {
      2|      if (key.kid == kid) {
       |        return key;
       |      }
       |    }
       |    return null;
       |  }
       |
       |  /// Add existing JWK to the JWKS list
      1|  void addJWK(IvmRS256JWK key) {
       |    if (key != null) {
      3|      _jwks['keys'].add(key);
       |    }
       |  }
       |}
       |
       |// ignore: non_constant_identifier_names
      1|IvmRS256JWKS _IvmRS256JWKSFromJson(Map<String, dynamic> json) {
       |  /// [e] general excption to throw from this method
      1|  final e = Exception('Invalid structure of the object with keys!');
       |
      1|  final listJWKs = <IvmRS256JWK>[];
       |
      2|  if (json.keys.contains('keys')) {
      4|    if (json['keys'].runtimeType.toString().startsWith('List')) {
      1|      final keys = json['keys'] as List;
       |
      2|      for (var element in keys) {
       |        try {
      1|          final key = IvmRS256JWK.fromJson(element as Map<String, dynamic>);
      1|          listJWKs.add(key);
       |        } catch (e) {
       |          rethrow;
       |        }
       |      }
       |
       |      /// Building the json object with the keys
      1|      final objKeys = <String, List<IvmRS256JWK>>{'keys': listJWKs};
       |
       |      /// Instantiate the JWKS object
       |      ///
      1|      final jwks = IvmRS256JWKS(objKeys);
       |      return jwks;
       |    } else {
       |      throw e;
       |    }
       |  } else {
       |    throw e;
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/jwk/jwks.dart
       |part of '../../ivmjwt.dart';
       |
       |/// JWK Set [RFC7517-5]
       |///
       |/// A JWK Set is a JSON object that represents a set of JWKs. The JSON object MUST have a "keys" member, with its value being an array of JWKs. This JSON object MAY contain whitespace and/or line breaks.
       |///
       |/// The member names within a JWK Set MUST be unique; JWK Set parsers MUST either reject JWK Sets with duplicate member names or use a JSON parser that returns only the lexically last duplicate member name, as specified in Section 15.12 ("The JSON Object") of ECMAScript 5.1 [ECMAScript]:.
       |///
       |/// Additional members can be present in the JWK Set; if not understood by implementations encountering them, they MUST be ignored. Parameters for representing additional properties of JWK Sets should either be registered in the IANA "JSON Web Key Set Parameters" registry established by Section 8.4 or be a value that contains a Collision-Resistant Name.
       |///
       |/// Implementations SHOULD ignore JWKs within a JWK Set that use "kty" (key type) values that are not understood by them, that are missing required members, or for which values are out of the supported ranges.
       |abstract class JWKS implements JWK {
      1|  JWKS(Map<String, List> jwks) {
      1|    final e = Exception('Invalid structure of the object with keys!');
      3|    if (!_jwks.keys.contains('keys')) {
       |      throw e;
       |    } else {
      5|      if (!_jwks['keys'].runtimeType.toString().startsWith('List')) {
       |        throw e;
       |      }
       |    }
      1|    _jwks = jwks;
       |  }
       |
       |  /// "keys" Parameter
       |  ///
       |  /// The value of the "keys" parameter is an array of JWK values. By default, the order of the JWK values within the array does not imply an order of preference among them, although applications of JWK Sets can choose to assign a meaning to the order for their purposes, if desired.
       |  Map<String, List> _jwks;
       |
       |  /// Set the object value
       |  ///
      0|  set keys(Map<String, List> value) {
      0|    if (!_jwks.keys.contains('keys')) {
       |      throw e;
       |    } else {
      0|      if (!_jwks.keys.runtimeType.toString().startsWith('List')) {
       |        throw e;
       |      } else {
      0|        _jwks = value;
       |      }
       |    }
       |  }
       |
       |  /// Get the entire object as a map
       |  ///
      1|  Map<String, List> get keys {
      1|    return _jwks;
       |  }
       |
       |  /// Get the List of JWKs
       |  ///
      0|  Iterable<String> getKeysAsList() {
      0|    return _jwks.keys;
       |  }
       |
       |  /// Get a single JWKey by its index from the set
       |  ///
       |  JWK getKeyByIndex(int index);
       |
       |  /// Get a JWKey by its property kid (key ID)
       |  ///
       |  JWK getKeyByKid(String kid);
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/rsa/ivm_signer.dart
       |part of '../../ivmjwt.dart';
       |
       |/// RSA Signer
       |///
       |/// by [pointycastle]:
       |/// To create a signature:
       |///
       |/// 1. Obtain an RSAPrivateKey.
       |/// 2. Instantiate an RSASigner with the desired Digest algorithm object and an algorithm identifier.
       |/// 3. Initialize the object for signing with the private key.
       |/// 4. Invoke the object's generateSignature method with the data being signed.
       |///
       |/// RS256 (RSA Signature with SHA-256)
       |/// [source](https://stackoverflow.com/questions/39239051/rs256-vs-hs256-whats-the-difference)
       |///
       |/// Algorithm	  | Object Identifier	    | Hexadecimal encoding of DER
       |/// MD2	          1.2.840.113549.2.2	    06082a864886f70d0202
       |/// MD4	          1.2.840.113549.2.4	    06082a864886f70d0204
       |/// MD5	          1.2.840.113549.2.5	    06082a864886f70d0205
       |/// RIPEMD-128	  1.3.36.3.2.2	          06052b24030202
       |/// RIPEMD-160	  1.3.36.3.2.1	          06052b24030201
       |/// RIPEMD-256	  1.3.36.3.2.3	          06052b24030203
       |/// SHA-1	        1.3.14.3.2.26	          06052b0e03021a
       |/// SHA-224	      2.16.840.1.101.3.4.2.4	0609608648016503040204
       |/// SHA-256	      2.16.840.1.101.3.4.2.1	0609608648016503040201
       |/// SHA-384	      2.16.840.1.101.3.4.2.2	0609608648016503040202
       |/// SHA-512	      2.16.840.1.101.3.4.2.3	0609608648016503040203
       |///
       |class IvmSignerRSA256 {
       |  RSAPrivateKey _privateKey;
       |  Uint8List _dataToSign;
       |  Uint8List _signedBytes;
       |
       |  // ignore: sort_constructors_first
      1|  IvmSignerRSA256(RSAPrivateKey privateKey, Uint8List dataToSign) {
       |    if (privateKey == null) {
      0|      throw Exception('Invalid key provided!');
       |    }
      1|    _privateKey = privateKey;
      1|    if (dataToSign == null || dataToSign.isEmpty) {
      0|      throw Exception('No data to sign!');
       |    }
      1|    _dataToSign = dataToSign;
       |  }
       |
       |  /// PointyCastle example
      1|  Uint8List rsaSign(RSAPrivateKey privateKey, Uint8List dataToSign) {
      2|    final signer = RSASigner(SHA256Digest(), '0609608648016503040201');
       |
      1|    signer.init(
      1|        true, PrivateKeyParameter<RSAPrivateKey>(privateKey)); // true=sign
       |
      1|    final sig = signer.generateSignature(dataToSign, normalize: true);
       |
      1|    return sig.bytes;
       |  }
       |
      1|  Uint8List get signedBytes {
      1|    if (_signedBytes == null) {
      3|      return rsaSign(_privateKey, _dataToSign);
       |    }
      0|    return _signedBytes;
       |  }
       |
      1|  String getBase64Signature() {
      2|    _signedBytes ??= signedBytes;
      2|    return base64Url.encode(_signedBytes);
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/utilities.dart
       |part of '../ivmjwt.dart';
       |
       |/// Utilities for IvmJWT
       |///
       |class Utilities {
       |  /// Decodes Base64Url encoded strings
       |  /// [encodedString] the string in Base64 format
      1|  static Future<String> base64UrlDecode(String encodedString,
       |      // ignore: avoid_positional_boolean_parameters
       |      [bool decodeL1 = false]) async {
       |    // Decode in List of integers. Note: base64 normalization required!
      2|    final encIntList = base64Url.decode(base64Url.normalize(encodedString));
       |
       |    // Decode in UTF string
       |    try {
       |      if (decodeL1) {
      0|        return latin1.decode(encIntList);
       |      }
       |      // return utf8.decode(encIntList, allowMalformed: false);
      1|      return utf8.decode(encIntList, allowMalformed: false);
       |    } catch (e) {
       |      rethrow;
       |    }
       |  }
       |
       |  /// Encoding to Base64 String
       |  /// [source] is the string to be encoded in Base64
      0|  static Future<String> base64UrlEncode(String source,
       |      // ignore: avoid_positional_boolean_parameters
       |      [bool encodeL1 = false]) async {
       |    try {
       |      Uint8List bytes;
       |      if (encodeL1) {
      0|        bytes = latin1.encode(source);
       |      } else {
      0|        bytes = Uint8List.fromList(utf8.encode(source));
       |        //does not work: bytes = Uint8List.fromList(source.codeUnits);
       |      }
      0|      return base64Url.encode(bytes);
       |    } catch (e) {
      0|      throw Exception('Error while base64Url encoding! $e');
       |    }
       |  }
       |
       |  /// Get Object Data tool
       |  ///
       |  /// [what] parameter defines if the method will return object's fields or methods
       |  ///
      1|  static List<String> getObjectDefNames(Object obj, String what) {
       |    // Prep the result list
      1|    final result = <String>[];
       |    // ignore: prefer_typing_uninitialized_variables
       |    var defMirror;
       |
       |    try {
      1|      final instanceMirror = reflect(obj);
      1|      defMirror = instanceMirror.type;
       |    } catch (e) {
      0|      throw Exception('Error while getting the mirror system! $e.');
       |    }
       |
      3|    for (var v in defMirror.declarations.values) {
      1|      if (what == 'fields' ||
      0|          what == 'field' ||
      0|          what == 'properties' ||
      0|          what == 'property') {
      1|        if (v is VariableMirror) {
      2|          final fname = MirrorSystem.getName(v.simpleName);
      1|          result.add(fname);
       |        }
      0|      } else if (what == 'method' || what == 'methods') {
      0|        if (v is MethodMirror) {
      0|          final mname = MirrorSystem.getName(v.simpleName);
      0|          result.add(mname);
       |        }
       |      }
       |    }
       |    // Return the list
       |    return result;
       |  }
       |
       |  // << =========/*  dart-lang/sdk team examples functions */================ >>
       |
       |  /// Reads Uint8List array into a BigInt.
       |  ///
       |  /// [readBytes] and [writeBigInt] are functions' examples given in GitHub
       |  /// (https://github.com/dart-lang/sdk/issues/32803) from dart-lang/sdk team.
       |  ///
      1|  static BigInt readBytes(Uint8List bytes) {
      1|    BigInt read(int start, int end) {
      2|      if (end - start <= 4) {
       |        var result = 0;
      3|        for (var i = end - 1; i >= start; i--) {
      3|          result = result * 256 + bytes[i];
       |        }
      1|        return BigInt.from(result);
       |      }
      3|      final mid = start + ((end - start) >> 1);
      2|      final result = read(start, mid) +
      6|          read(mid, end) * (BigInt.one << ((mid - start) * 8));
       |      return result;
       |    }
       |
      2|    return read(0, bytes.length);
       |  }
       |
      1|  static Uint8List writeBigInt(BigInt number) {
       |    // Not handling negative numbers. Decide how you want to do that.
      3|    final bytes = (number.bitLength + 7) >> 3;
      1|    final b256 = BigInt.from(256);
      1|    final result = Uint8List(bytes);
      2|    for (var i = 0; i < bytes; i++) {
      3|      result[i] = number.remainder(b256).toInt();
       |      // ignore: parameter_assignments
      1|      number = number >> 8;
       |    }
       |    return result;
       |  }
       |
       |  // << ============/* PointyCastle examples */============================ >>
       |
       |  /// Alternative functions [decodeBigInt] and [encodeBigInt] from the
       |  /// PointyCastle library for converting between Uint8List and BigInt.
       |  ///
       |  /// Decode a BigInt from bytes in big-endian encoding.
       |  ///
      0|  static BigInt decodeBigInt(List<int> bytes) {
      0|    var result = BigInt.from(0);
      0|    for (var i = 0; i < bytes.length; i++) {
      0|      result += BigInt.from(bytes[bytes.length - i - 1]) << (8 * i);
       |    }
       |    return result;
       |  }
       |
       |  /// Encode a BigInt into bytes using big-endian encoding.
      0|  static Uint8List encodeBigInt(BigInt number) {
       |    // Not handling negative numbers. Decide how you want to do that.
       |
      0|    final _byteMask = BigInt.from(0xff);
       |
      0|    final size = (number.bitLength + 7) >> 3;
      0|    final result = Uint8List(size);
      0|    for (var i = 0; i < size; i++) {
      0|      result[size - i - 1] = (number & _byteMask).toInt();
       |      // ignore: parameter_assignments
      0|      number = number >> 8;
       |    }
       |    return result;
       |  }
       |
       |  /// Seconds/miliseconds since EPOCH
       |  ///
       |  /// @param String measure - default to "s", defines the measure of the returned result. Accepts "s" for seconds or "ms" for miliseconds.
       |  ///
      1|  static int currentTimeInSMS({String measure = 's'}) {
      2|    final ms = DateTime.now().millisecondsSinceEpoch;
      1|    if (measure == 'ms') {
       |      return ms;
       |    }
      2|    return (ms / 1000).round();
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/jwk/jwk.dart
       |part of '../../ivmjwt.dart';
       |
       |/// JWK - JSON Web Key [RFC7517]
       |///
       |/// [Ivmanto]: This class will respect RFC7517 but not in any mean implement it in full.
       |///
       |/// Abstract according to [RFC7517]:
       |/// A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data
       |///    structure that represents a cryptographic key.  This specification
       |///    also defines a JWK Set JSON data structure that represents a set of
       |///    JWKs.  Cryptographic algorithms and identifiers for use with this
       |///    specification are described in the separate JSON Web Algorithms (JWA)
       |///    specification and IANA registries established by that specification.
       |abstract class JWK {
       |  /// "kty" by  [RFC7517]:
       |  ///
       |  /// The "kty" (key type) parameter identifies the cryptographic algorithm
       |  ///  family used with the key, such as "RSA" or "EC".  "kty" values should
       |  ///  either be registered in the IANA "JSON Web Key Types" registry
       |  ///  established by [JWA] or be a value that contains a Collision-
       |  ///  Resistant Name.  The "kty" value is a case-sensitive string.  This
       |  ///  member MUST be present in a JWK.
       |  ///
       |  // ignore: avoid_unused_constructor_parameters, non_constant_identifier_names
      1|  JWK(String kty,
       |      {this.use, this.alg, this.kid, this.key_ops, this.n, this.e}) {
      2|    if (['EC', 'RSA', 'oct'].contains(kty)) {
      1|      _kty = kty;
       |    } else {
      1|      throw Exception('Unacceptable value for the key type!');
       |    }
       |  }
       |
       |  /// Instantiate an object from a json object
      0|  JWK.fromJson(Map<String, dynamic> json);
       |
       |  /// "kty" (Key Type) Parameter
       |  ///
       |  /// The "kty" (key type) parameter identifies the cryptographic algorithm family used with the key, such as "RSA" or "EC". "kty" values should either be registered in the IANA "JSON Web Key Types" registry established by [JWA] or be a value that contains a Collision- Resistant Name. The "kty" value is a case-sensitive string. This member [MUST] be present in a JWK.
       |  ///
       |  /// A list of defined "kty" values can be found in the IANA "JSON Web Key Types" registry established by [JWA]; the initial contents of this registry are the values defined in [RFC7518 Section 6.1]: of [JWA]:.
       |  ///
       |  String _kty;
       |
       |  /// "use" (Public Key Use) Parameter
       |  ///
       |  /// The "use" (public key use) parameter identifies the intended use of the public key. The "use" parameter is employed to indicate whether a public key is used for encrypting data or verifying the signature on data.
       |  /// Values defined by this specification are:
       |  ///   o  "sig" (signature)
       |  ///   o  "enc" (encryption)
       |  ///
       |  /// Other values MAY be used. The "use" value is a case-sensitive string. Use of the "use" member is OPTIONAL, unless the application requires its presence.
       |  String use;
       |
       |  /// "alg" (Algorithm) Parameter
       |  ///
       |  /// The "alg" (algorithm) parameter identifies the algorithm intended for use with the key. The values used should either be registered in the IANA "JSON Web Signature and Encryption Algorithms" registry established by [JWA] or be a value that contains a Collision- Resistant Name. The "alg" value is a case-sensitive ASCII string. Use of this member is OPTIONAL.
       |  ///
       |  String alg;
       |
       |  /// "kid" (Key ID) Parameter
       |  ///
       |  /// The "kid" (key ID) parameter is used to match a specific key. This is used, for instance, to choose among a set of keys within a JWK Set during key rollover. The structure of the "kid" value is unspecified. When "kid" values are used within a JWK Set, different keys within the JWK Set SHOULD use distinct "kid" values. (One example in which different keys might use the same "kid" value is if they have different "kty" (key type) values but are considered to be equivalent alternatives by the application using them.) The "kid" value is a case-sensitive string. Use of this member is OPTIONAL. When used with JWS or JWE, the "kid" value is used to match a JWS or JWE "kid" Header Parameter value.
       |  String kid;
       |
       |  /// "key_ops" (Key Operations) Parameter
       |  ///
       |  /// The "key_ops" (key operations) parameter identifies the operation(s) for which the key is intended to be used. The "key_ops" parameter is intended for use cases in which public, private, or symmetric keys may be present.
       |  ///
       |  // ignore: non_constant_identifier_names
       |  String key_ops;
       |
       |  /// Parameters for RSA Public Keys
       |  /// ==============================
       |  ///
       |  /// "n" (Modulus) Parameter
       |  /// The "n" (modulus) parameter contains the modulus value for the RSA public key. It is represented as a Base64urlUInt-encoded value.
       |  ///
       |  String n;
       |
       |  /// "e" (Exponent) Parameter
       |  ///
       |  /// The "e" (exponent) parameter contains the exponent value for the RSA public key. It is represented as a Base64urlUInt-encoded value.
       |  ///
       |  String e;
       |
       |  /// Parameters for RSA Private Keys
       |  /// ===============================
       |  ///
       |  /// [NOTE:] This library doe not make use fo these keys as of the initial version.
       |  ///
       |  /// "d" (Private Exponent) Parameter
       |  /// The "d" (private exponent) parameter contains the private exponent value for the RSA private key. It is represented as a Base64urlUInt- encoded value.
       |  ///
       |  String d;
       |
       |  /// "p" (First Prime Factor) Parameter
       |  /// The "p" (first prime factor) parameter contains the first prime factor. It is represented as a Base64urlUInt-encoded value.
       |  ///
       |  String p;
       |
       |  /// "q" (Second Prime Factor) Parameter
       |  ///
       |  /// The "q" (second prime factor) parameter contains the second prime factor. It is represented as a Base64urlUInt-encoded value.
       |  ///
       |  String q;
       |
       |  /// "dp" (First Factor CRT Exponent) Parameter
       |  ///
       |  /// The "dp" (first factor CRT exponent) parameter contains the Chinese Remainder Theorem (CRT) exponent of the first factor. It is represented as a Base64urlUInt-encoded value.
       |  ///
       |  String dp;
       |
       |  ///  "dq" (Second Factor CRT Exponent) Parameter
       |  ///
       |  /// The "dq" (second factor CRT exponent) parameter contains the CRT exponent of the second factor. It is represented as a Base64urlUInt- encoded value.
       |  ///
       |  String dq;
       |
       |  /// "qi" (First CRT Coefficient) Parameter
       |  ///
       |  /// The "qi" (first CRT coefficient) parameter contains the CRT coefficient of the second factor. It is represented as a Base64urlUInt-encoded value.
       |  ///
       |  String qi;
       |
      0|  set kty(String value) {
      0|    if (['EC', 'RSA', 'oct'].contains(value)) {
      0|      _kty = value;
       |    }
       |  }
       |
      1|  String get kty {
      1|    return _kty;
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/ivm_jwt.dart
       |part of '../ivmjwt.dart';
       |
       |/**
       | * Creating a JWT by [RFC7519 section 7.1]
       |   To create a JWT, the following steps are performed.  The order of the
       |   steps is not significant in cases where there are no dependencies
       |   between the inputs and outputs of the steps.
       |   1.  Create a JWT Claims Set containing the desired claims.  Note that
       |      * whitespace is explicitly allowed in the representation and no
       |      * canonicalization need be performed before encoding.
       |   2.  Let the Message be the octets of the UTF-8 representation of the
       |      *  JWT Claims Set.
       |   3.  Create a JOSE Header containing the desired set of Header
       |      * Parameters.  The JWT MUST conform to either the [JWS] or [JWE]
       |      *  specification.  Note that whitespace is explicitly allowed in the
       |      *  representation and no canonicalization need be performed before
       |      *  encoding.
       |   4.  Depending upon whether the JWT is a JWS or JWE, there are two
       |       * cases:
       |       *  If the JWT is a JWS, create a JWS using the Message as the JWS
       |       *   Payload; all steps specified in [JWS] for creating a JWS MUST
       |       *   be followed.
       |       *  Else, if the JWT is a JWE, create a JWE using the Message as
       |       *   the plaintext for the JWE; all steps specified in [JWE] for
       |       *   creating a JWE MUST be followed.
       |   5.  If a nested signing or encryption operation will be performed,
       |       * let the Message be the JWS or JWE, and return to Step 3, using a
       |       * "cty" (content type) value of "JWT" in the new JOSE Header
       |       * created in that step.
       |   6.  Otherwise, let the resulting JWT be the JWS or JWE.
       | */
       |
       |/// Ivmanto JWT
       |///
       |/// The Ivmanto`s JWT class with issue and verify methods for RS256 signed tokens
       |///
       |class IvmJWT extends JWT {
       |  // Instantiate the object IvmJWT by providing the payload (claims) at
       |  // the time of creation. This require an object SegmentPayload object
       |  // to be created before hand.
      2|  IvmJWT(this._claimsSet) : super(_claimsSet);
       |
       |  final SegmentPayload _claimsSet;
       |
       |  /// Issue RS256 signed JWT [RFC7519]:
       |  ///
       |  /// follow the steps from [RFC7519 section 7.1] - referenced above in
       |  /// this class
       |  @override
      1|  Future<Map<String, dynamic>> issueJWTRS256() async {
       |    // The token claims check - this._claimsSet
       |    // TODO: [dev] verify the steps 1 to 6 from the plan above are in place.
       |
       |    /// 1. Generate key pair
       |    ///
       |    IvmKeyPair ivmkp;
       |    try {
      1|      ivmkp = IvmKeyPair(ivmBitStrength: 2048);
      1|      ivmkp.generateAPair();
       |    } catch (e) {
      0|      throw Exception('Error raised while generating key pair! $e.');
       |    }
       |
      1|    final prvKey = ivmkp.privateKey;
      1|    final kid = ivmkp.kid;
       |
       |    // Get the public key as JWK
      2|    final kpPublicKey = json.encode(ivmkp.getPublicKeyAsJWK());
       |
       |    // Get the public key as element of JWKS
       |    // final arrayPK = <Map<String, dynamic>>[kpPublicKey];
      1|    final jwks = '{\"keys\": [${kpPublicKey}]}';
       |
       |    /// 2. Build the dataToSign bytes list from the provided in paramaters
       |    /// header and payload segments.
       |    ///
       |    final _header =
      2|        '{\"alg\": \"RS256\", \"typ\": \"JWT\", \"kid\": \"${kid.toString()}\"}';
       |
      3|    final _claimsStr = json.encode(_claimsSet.toJson());
      3|    final dataToSign = Uint8List.fromList('${_header}.${_claimsStr}'.codeUnits);
       |
       |    /// 3. Use function [sign] to sign the segments data with the private key
       |    /// from step-1.
       |    ///
       |    try {
      1|      final sign = IvmSignerRSA256(prvKey, dataToSign);
       |
       |      /// 4. Compose the 3 segments of the JWToken as Base64 string separated
       |      /// with comma (.)
       |      ///
      2|      final segment1 = base64Url.encode(_header.codeUnits);
      2|      final segment2 = base64Url.encode(_claimsStr.codeUnits);
      1|      final segment3 = sign.getBase64Signature();
       |
       |      // Returning the token and the publicKey as JWKS
      1|      return {
      1|        'token': '${segment1}.${segment2}.${segment3}',
       |        'publicKey': '$jwks'
      1|      };
       |      // <<<<
       |
       |    } catch (e) {
      0|      throw Exception(
      0|          'Error has raised while preparing and signing the token! $e.');
       |    }
       |  }
       |
       |  /// Verify JWT RS256 signed token
       |  ///
       |  /// This method will verify JWT [token] signed with RS256 algorithm.
       |  /// [jwks] is expected key set containing the public key that signed the token. The string content should represent a valid json object.
       |  ///
      1|  static Future<bool> _verifyJWTRS256(String token, String jwks) async {
       |    /// Verification proprties
       |    SegmentHeader vSegHeader;
       |    SegmentPayload vSegPayload;
       |    var validAlg = false;
       |    var validJWKS = false;
       |    var validSignature = false;
       |    var timeValid = false;
       |
       |    // validate params
      1|    if (token.isEmpty) {
       |      return false;
       |    }
      1|    if (jwks.isEmpty) {
       |      return false;
       |    }
       |    // Step-1 Check the token integrity
      2|    final _integrity = await _checkTokenIntegrity(token);
       |
       |    // In integrity object the key "valid" is the bool result of the integrity validation.
      1|    if (_integrity['valid'] as bool) {
       |      try {
       |        // ... set the Header object to be sent to step-2 checking signature
      3|        final headerJson = json.decode(_integrity['header'].toString())
       |            as Map<String, dynamic>;
      1|        vSegHeader = SegmentHeader.fromJson(headerJson);
       |      } catch (e) {
      0|        throw Exception('Error while getting header object values! $e.');
       |      }
       |
       |      // A valid header MUST have a key 'alg' and its value MUST NOT be 'none';
       |      try {
      2|        validAlg = vSegHeader.alg != 'none' &&
      2|            vSegHeader.alg != '' &&
      1|            vSegHeader.alg != null;
       |      } catch (e) {
      0|        throw Exception('Invalid verification of mandatory header values! $e.');
       |      }
       |
       |      try {
       |        // ... set the Payload (claims) object to be sent to step-2 checking signature
      3|        final payloadJson = json.decode(_integrity['payload'].toString())
       |            as Map<String, dynamic>;
       |
      1|        vSegPayload = SegmentPayload.fromJson(payloadJson);
       |      } catch (e) {
      0|        throw Exception(
      0|            'Invalid verification of mandatory payload values! $e.');
       |      }
       |      // Throw exception if the token's integrity validation resolved (very unlikely) to False.
       |    } else {
      0|      throw Exception('Token integrity validation has failed!');
       |    }
       |
       |    /// For signature verification the [jwks] is required.
       |    /// It must run over json validation first.
       |    //
       |    // Verify if the jwks is a valid JSON
      1|    final jv = JsonValidator();
       |    try {
      1|      if (jv == null || jwks.isEmpty) {
      0|        print('   *** wrong validator');
       |      }
      2|      validJWKS = await jv.validate(jwks);
       |    } catch (e) {
      0|      throw Exception('Error validating the provided JWKs value to json! $e.');
       |    }
       |
       |    // Step-2 Check the signature
       |
      2|    if (vSegHeader.toJson().toString() != null &&
      2|        vSegPayload.toJson().toString() != null &&
       |        validAlg &&
       |        validJWKS) {
       |      /// [header] the token header string
       |      /// [payload] the token payload
       |      /// [token] the original token value supplied to this function
       |      /// [alg] the signing algorithm as defined in the token header
       |      /// [jwks] set of keys to get the public key from it.
       |      /// [kid] is the key id that will be used to identify the exact JWK from the set.
       |      ///
      2|      validSignature = await _verifyRS256Signature(
      2|          header: _integrity['header'].toString(),
      2|          payload: _integrity['payload'].toString(),
       |          token: token,
      1|          alg: vSegHeader.alg,
       |          jwks: jwks,
      1|          kid: vSegHeader.kid);
       |    } else {
      0|      throw Exception('The token signature verification not possible!');
       |    }
       |
       |    // Step-3: Verify the token time validity: exp and if exist iat & nbf
       |    // temp: validSignature temporary removed
       |    if (vSegHeader != null && vSegPayload != null && validAlg && validJWKS
       |        // temp removed: && validSignature
       |        ) {
       |      // Verifies the exp part of the token payload segment with now().
       |      // 180 seconds will be added to now() value as further processing time
       |      // to ensure the token validity in the next 3 minutes
      2|      timeValid = await _verifyClaims(vSegPayload);
       |    } else {
      0|      throw Exception('The token claims verification not possible!');
       |    }
       |
       |    return vSegHeader != null &&
       |        vSegPayload != null &&
       |        validAlg &&
       |        validJWKS &&
       |        // temp removed: validSignature &&
       |        timeValid;
       |  } // end of verifyJWTRS256
       |
       |  /// Decode the provided [token] using the [jwks] set.
       |  ///
      1|  static Future<Map<String, dynamic>> decodeJWTRS256(
       |      String token, String jwks) async {
      2|    if (await _verifyJWTRS256(token, jwks)) {
       |      Map<String, dynamic> decodedPayload;
       |
       |      /// decode payload
       |      try {
       |        // Split the token to segments
      1|        final tokenSegments = token.split('.');
      3|        final jwtPayload = await Utilities.base64UrlDecode(tokenSegments[1]);
       |
      1|        decodedPayload = json.decode(jwtPayload) as Map<String, dynamic>;
       |      } catch (e) {
      0|        throw Exception('Error decoding payload segment! $e.');
       |      }
       |      // TODO: consider to combine the header segment as part of the payload?
      0|      return decodedPayload ?? {};
       |    } else {
       |      return null;
       |    }
       |  }
       |
       |  /// Create a new JWT token and sign it with the provided private key
       |  ///
      0|  @override
       |  Future<String> signJWTRS256(RSAPrivateKey privateKey,
       |      [String strClaims, Map<String, dynamic> mapClaims]) {
       |    // TODO: [JWT-11] implement sign JWT with provided private key
      0|    throw UnimplementedError();
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/ivmjwt.g.dart
       |// GENERATED CODE - DO NOT MODIFY BY HAND
       |
       |part of ivmjwt;
       |
       |// **************************************************************************
       |// JsonSerializableGenerator
       |// **************************************************************************
       |
      1|SegmentHeader _$SegmentHeaderFromJson(Map<String, dynamic> json) {
      1|  return SegmentHeader(
      1|    alg: json['alg'] as String,
      1|    typ: json['typ'] as String,
      1|    cty: json['cty'] as String,
      1|    kid: json['kid'] as String,
       |  );
       |}
       |
      1|Map<String, dynamic> _$SegmentHeaderToJson(SegmentHeader instance) {
      1|  final val = <String, dynamic>{
      1|    'alg': instance.alg,
      1|    'typ': instance.typ,
       |  };
       |
      1|  void writeNotNull(String key, dynamic value) {
       |    if (value != null) {
      1|      val[key] = value;
       |    }
       |  }
       |
      2|  writeNotNull('cty', instance.cty);
      2|  writeNotNull('kid', instance.kid);
       |  return val;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/test_core.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |@Deprecated('package:test_core is not intended for general use. '
       |    'Please use package:test.')
       |library test_core;
       |
       |import 'dart:async';
       |
       |import 'package:meta/meta.dart' show isTest, isTestGroup;
       |import 'package:path/path.dart' as p;
       |import 'package:test_api/backend.dart'; //ignore: deprecated_member_use
       |import 'package:test_api/src/backend/declarer.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/invoker.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/frontend/timeout.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/utils.dart'; // ignore: implementation_imports
       |
       |import 'src/runner/engine.dart';
       |import 'src/runner/plugin/environment.dart';
       |import 'src/runner/reporter/expanded.dart';
       |import 'src/runner/runner_suite.dart';
       |import 'src/runner/suite.dart';
       |import 'src/util/print_sink.dart';
       |
       |export 'package:matcher/matcher.dart';
       |// Hide implementations which don't support being run directly.
       |// This file is an almost direct copy of import below, but with the global
       |// declarer added.
       |//ignore: deprecated_member_use
       |export 'package:test_api/test_api.dart'
       |    hide test, group, setUp, setUpAll, tearDown, tearDownAll;
       |
       |/// The global declarer.
       |///
       |/// This is used if a test file is run directly, rather than through the runner.
       |Declarer _globalDeclarer;
       |
       |/// Gets the declarer for the current scope.
       |///
       |/// When using the runner, this returns the [Zone]-scoped declarer that's set by
       |/// [IsolateListener] or [IframeListener]. If the test file is run directly,
       |/// this returns [_globalDeclarer] (and sets it up on the first call).
      1|Declarer get _declarer {
      1|  var declarer = Declarer.current;
       |  if (declarer != null) return declarer;
       |  if (_globalDeclarer != null) return _globalDeclarer;
       |
       |  // Since there's no Zone-scoped declarer, the test file is being run directly.
       |  // In order to run the tests, we set up our own Declarer via
       |  // [_globalDeclarer], and schedule a microtask to run the tests once they're
       |  // finished being defined.
      1|  _globalDeclarer = Declarer();
      2|  scheduleMicrotask(() async {
      2|    var suite = RunnerSuite(const PluginEnvironment(), SuiteConfiguration.empty,
      3|        _globalDeclarer.build(), SuitePlatform(Runtime.vm, os: currentOSGuess),
      2|        path: p.prettyUri(Uri.base));
       |
      1|    var engine = Engine();
      2|    engine.suiteSink.add(suite);
      2|    engine.suiteSink.close();
      2|    ExpandedReporter.watch(engine, PrintSink(),
       |        color: true, printPath: false, printPlatform: false);
       |
      5|    var success = await runZoned(() => Invoker.guard(engine.run),
      1|        zoneValues: {#test.declarer: _globalDeclarer});
       |    if (success) return null;
      0|    print('');
      0|    unawaited(Future.error('Dummy exception to set exit code.'));
       |  });
       |  return _globalDeclarer;
       |}
       |
       |// TODO(nweiz): This and other top-level functions should throw exceptions if
       |// they're called after the declarer has finished declaring.
       |/// Creates a new test case with the given description (converted to a string)
       |/// and body.
       |///
       |/// The description will be added to the descriptions of any surrounding
       |/// [group]s. If [testOn] is passed, it's parsed as a [platform selector][]; the
       |/// test will only be run on matching platforms.
       |///
       |/// [platform selector]: https://github.com/dart-lang/test/tree/master/pkgs/test#platform-selectors
       |///
       |/// If [timeout] is passed, it's used to modify or replace the default timeout
       |/// of 30 seconds. Timeout modifications take precedence in suite-group-test
       |/// order, so [timeout] will also modify any timeouts set on the group or suite.
       |///
       |/// If [skip] is a String or `true`, the test is skipped. If it's a String, it
       |/// should explain why the test is skipped; this reason will be printed instead
       |/// of running the test.
       |///
       |/// If [tags] is passed, it declares user-defined tags that are applied to the
       |/// test. These tags can be used to select or skip the test on the command line,
       |/// or to do bulk test configuration. All tags should be declared in the
       |/// [package configuration file][configuring tags]. The parameter can be an
       |/// [Iterable] of tag names, or a [String] representing a single tag.
       |///
       |/// If [retry] is passed, the test will be retried the provided number of times
       |/// before being marked as a failure.
       |///
       |/// [configuring tags]: https://github.com/dart-lang/test/blob/master/doc/package_config.md#configuring-tags
       |///
       |/// [onPlatform] allows tests to be configured on a platform-by-platform
       |/// basis. It's a map from strings that are parsed as [PlatformSelector]s to
       |/// annotation classes: [Timeout], [Skip], or lists of those. These
       |/// annotations apply only on the given platforms. For example:
       |///
       |///     test('potentially slow test', () {
       |///       // ...
       |///     }, onPlatform: {
       |///       // This test is especially slow on Windows.
       |///       'windows': Timeout.factor(2),
       |///       'browser': [
       |///         Skip('TODO: add browser support'),
       |///         // This will be slow on browsers once it works on them.
       |///         Timeout.factor(2)
       |///       ]
       |///     });
       |///
       |/// If multiple platforms match, the annotations apply in order as through
       |/// they were in nested groups.
       |///
       |/// If the `solo` flag is `true`, only tests and groups marked as
       |/// "solo" will be be run. This only restricts tests *within this test
       |/// suite*tests in other suites will run as normal. We recommend that users
       |/// avoid this flag if possible and instead use the test runner flag `-n` to
       |/// filter tests by name.
      1|@isTest
       |void test(description, dynamic Function() body,
       |    {String testOn,
       |    Timeout timeout,
       |    skip,
       |    tags,
       |    Map<String, dynamic> onPlatform,
       |    int retry,
       |    @deprecated bool solo = false}) {
      3|  _declarer.test(description.toString(), body,
       |      testOn: testOn,
       |      timeout: timeout,
       |      skip: skip,
       |      onPlatform: onPlatform,
       |      tags: tags,
       |      retry: retry,
       |      solo: solo);
       |
       |  // Force dart2js not to inline this function. We need it to be separate from
       |  // `main()` in JS stack traces in order to properly determine the line and
       |  // column where the test was defined. See sdk#26705.
       |  return;
       |  return; // ignore: dead_code
       |}
       |
       |/// Creates a group of tests.
       |///
       |/// A group's description (converted to a string) is included in the descriptions
       |/// of any tests or sub-groups it contains. [setUp] and [tearDown] are also scoped
       |/// to the containing group.
       |///
       |/// If [testOn] is passed, it's parsed as a [platform selector][]; the test will
       |/// only be run on matching platforms.
       |///
       |/// [platform selector]: https://github.com/dart-lang/test/tree/master/pkgs/test#platform-selectors
       |///
       |/// If [timeout] is passed, it's used to modify or replace the default timeout
       |/// of 30 seconds. Timeout modifications take precedence in suite-group-test
       |/// order, so [timeout] will also modify any timeouts set on the suite, and will
       |/// be modified by any timeouts set on individual tests.
       |///
       |/// If [skip] is a String or `true`, the group is skipped. If it's a String, it
       |/// should explain why the group is skipped; this reason will be printed instead
       |/// of running the group's tests.
       |///
       |/// If [tags] is passed, it declares user-defined tags that are applied to the
       |/// test. These tags can be used to select or skip the test on the command line,
       |/// or to do bulk test configuration. All tags should be declared in the
       |/// [package configuration file][configuring tags]. The parameter can be an
       |/// [Iterable] of tag names, or a [String] representing a single tag.
       |///
       |/// [configuring tags]: https://github.com/dart-lang/test/blob/master/doc/package_config.md#configuring-tags
       |///
       |/// [onPlatform] allows groups to be configured on a platform-by-platform
       |/// basis. It's a map from strings that are parsed as [PlatformSelector]s to
       |/// annotation classes: [Timeout], [Skip], or lists of those. These
       |/// annotations apply only on the given platforms. For example:
       |///
       |///     group('potentially slow tests', () {
       |///       // ...
       |///     }, onPlatform: {
       |///       // These tests are especially slow on Windows.
       |///       'windows': Timeout.factor(2),
       |///       'browser': [
       |///         Skip('TODO: add browser support'),
       |///         // They'll be slow on browsers once it works on them.
       |///         Timeout.factor(2)
       |///       ]
       |///     });
       |///
       |/// If multiple platforms match, the annotations apply in order as through
       |/// they were in nested groups.
       |///
       |/// If the `solo` flag is `true`, only tests and groups marked as
       |/// "solo" will be be run. This only restricts tests *within this test
       |/// suite*tests in other suites will run as normal. We recommend that users
       |/// avoid this flag if possible, and instead use the test runner flag `-n` to
       |/// filter tests by name.
      1|@isTestGroup
       |void group(description, dynamic Function() body,
       |    {String testOn,
       |    Timeout timeout,
       |    skip,
       |    tags,
       |    Map<String, dynamic> onPlatform,
       |    int retry,
       |    @deprecated bool solo = false}) {
      3|  _declarer.group(description.toString(), body,
       |      testOn: testOn,
       |      timeout: timeout,
       |      skip: skip,
       |      tags: tags,
       |      onPlatform: onPlatform,
       |      retry: retry,
       |      solo: solo);
       |
       |  // Force dart2js not to inline this function. We need it to be separate from
       |  // `main()` in JS stack traces in order to properly determine the line and
       |  // column where the test was defined. See sdk#26705.
       |  return;
       |  return; // ignore: dead_code
       |}
       |
       |/// Registers a function to be run before tests.
       |///
       |/// This function will be called before each test is run. [callback] may be
       |/// asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, it applies only to tests in that
       |/// group. [callback] will be run after any set-up callbacks in parent groups or
       |/// at the top level.
       |///
       |/// Each callback at the top level or in a given group will be run in the order
       |/// they were declared.
      0|void setUp(dynamic Function() callback) => _declarer.setUp(callback);
       |
       |/// Registers a function to be run after tests.
       |///
       |/// This function will be called after each test is run. [callback] may be
       |/// asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, it applies only to tests in that
       |/// group. [callback] will be run before any tear-down callbacks in parent
       |/// groups or at the top level.
       |///
       |/// Each callback at the top level or in a given group will be run in the
       |/// reverse of the order they were declared.
       |///
       |/// See also [addTearDown], which adds tear-downs to a running test.
      0|void tearDown(dynamic Function() callback) => _declarer.tearDown(callback);
       |
       |/// Registers a function to be run once before all tests.
       |///
       |/// [callback] may be asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, [callback] will run before all tests
       |/// in that group. It will be run after any [setUpAll] callbacks in parent
       |/// groups or at the top level. It won't be run if none of the tests in the
       |/// group are run.
       |///
       |/// **Note**: This function makes it very easy to accidentally introduce hidden
       |/// dependencies between tests that should be isolated. In general, you should
       |/// prefer [setUp], and only use [setUpAll] if the callback is prohibitively
       |/// slow.
      0|void setUpAll(dynamic Function() callback) => _declarer.setUpAll(callback);
       |
       |/// Registers a function to be run once after all tests.
       |///
       |/// If this is called within a test group, [callback] will run after all tests
       |/// in that group. It will be run before any [tearDownAll] callbacks in parent
       |/// groups or at the top level. It won't be run if none of the tests in the
       |/// group are run.
       |///
       |/// **Note**: This function makes it very easy to accidentally introduce hidden
       |/// dependencies between tests that should be isolated. In general, you should
       |/// prefer [tearDown], and only use [tearDownAll] if the callback is
       |/// prohibitively slow.
      0|void tearDownAll(dynamic Function() callback) =>
      0|    _declarer.tearDownAll(callback);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/meta-1.2.4/lib/meta.dart
       |// Copyright (c) 2016, the Dart project authors. Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Annotations that developers can use to express the intentions that otherwise
       |/// can't be deduced by statically analyzing the source code.
       |///
       |/// See also `@deprecated` and `@override` in the `dart:core` library.
       |///
       |/// Annotations provide semantic information that tools can use to provide a
       |/// better user experience. For example, an IDE might not autocomplete the name
       |/// of a function that's been marked `@deprecated`, or it might display the
       |/// function's name differently.
       |///
       |/// For information on installing and importing this library, see the [meta
       |/// package on pub.dev](https://pub.dev/packages/meta). For examples of using
       |/// annotations, see
       |/// [Metadata](https://dart.dev/guides/language/language-tour#metadata) in the
       |/// language tour.
       |library meta;
       |
       |/// Used to annotate a function `f`. Indicates that `f` always throws an
       |/// exception. Any functions that override `f`, in class inheritance, are also
       |/// expected to conform to this contract.
       |///
       |/// Tools, such as the analyzer, can use this to understand whether a block of
       |/// code "exits". For example:
       |///
       |/// ```dart
       |/// @alwaysThrows toss() { throw 'Thrown'; }
       |///
       |/// int fn(bool b) {
       |///   if (b) {
       |///     return 0;
       |///   } else {
       |///     toss();
       |///     print("Hello.");
       |///   }
       |/// }
       |/// ```
       |///
       |/// Without the annotation on `toss`, it would look as though `fn` doesn't
       |/// always return a value. The annotation shows that `fn` does always exit. In
       |/// addition, the annotation reveals that any statements following a call to
       |/// `toss` (like the `print` call) are dead code.
       |///
       |/// Tools, such as the analyzer, can also expect this contract to be enforced;
       |/// that is, tools may emit warnings if a function with this annotation
       |/// _doesn't_ always throw.
       |const _AlwaysThrows alwaysThrows = _AlwaysThrows();
       |
       |/// Used to annotate a parameter of an instance method that overrides another
       |/// method.
       |///
       |/// Indicates that this parameter may have a tighter type than the parameter on
       |/// its superclass. The actual argument will be checked at runtime to ensure it
       |/// is a subtype of the overridden parameter type.
       |///
       |@Deprecated('Use the `covariant` modifier instead')
       |const _Checked checked = _Checked();
       |
       |/// Used to annotate a method, getter or top-level getter or function to
       |/// indicate that the value obtained by invoking it should not be stored in a
       |/// field or top-level variable. The annotation can also be applied to a class
       |/// to implicitly annotate all of the valid members of the class, or applied to
       |/// a library to annotate all of the valid members of the library, including
       |/// classes. If a value returned by an element marked as `doNotStore` is returned
       |/// from a function or getter, that function or getter should be similarly
       |/// annotated.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with anything other than a library, class,
       |///   method or getter, top-level getter or function, or
       |/// * an invocation of a member that has this annotation is returned by a method,
       |///   getter or function that is not similarly annotated as `doNotStore`, or
       |/// * an invocation of a member that has this annotation is assigned to a field
       |///   or top-level variable.
       |const _DoNotStore doNotStore = _DoNotStore();
       |
       |/// Used to annotate a library, or any declaration that is part of the public
       |/// interface of a library (such as top-level members, class members, and
       |/// function parameters) to indicate that the annotated API is experimental and
       |/// may be removed or changed at any-time without updating the version of the
       |/// containing package, despite the fact that it would otherwise be a breaking
       |/// change.
       |///
       |/// If the annotation is applied to a library then it is equivalent to applying
       |/// the annotation to all of the top-level members of the library. Applying the
       |/// annotation to a class does *not* apply the annotation to subclasses, but
       |/// does apply the annotation to members of the class.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with a declaration that is not part of the
       |///   public interface of a library (such as a local variable or a declaration
       |///   that is private) or a directive other than the first directive in the
       |///   library, or
       |/// * the declaration is referenced by a package that has not explicitly
       |///   indicated its intention to use experimental APIs (details TBD).
       |const _Experimental experimental = _Experimental();
       |
       |/// Used to annotate an instance or static method `m`. Indicates that `m` must
       |/// either be abstract or must return a newly allocated object or `null`. In
       |/// addition, every method that either implements or overrides `m` is implicitly
       |/// annotated with this same annotation.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with anything other than a method, or
       |/// * a method that has this annotation can return anything other than a newly
       |///   allocated object or `null`.
       |const _Factory factory = _Factory();
       |
       |/// Used to annotate a class `C`. Indicates that `C` and all subtypes of `C`
       |/// must be immutable.
       |///
       |/// A class is immutable if all of the instance fields of the class, whether
       |/// defined directly or inherited, are `final`.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |/// * the annotation is associated with anything other than a class, or
       |/// * a class that has this annotation or extends, implements or mixes in a
       |///   class that has this annotation is not immutable.
       |const Immutable immutable = Immutable();
       |
       |/// Used to annotate a declaration which should only be used from within the
       |/// package in which it is declared, and which should not be exposed from said
       |/// package's public API.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the declaration is declared in a package's public API, or is exposed from
       |///   a package's public API, or
       |/// * the declaration is private, an unnamed extension, a static member of a
       |///   private class, mixin, or extension, a value of a private enum, or a
       |///   constructor of a private class, or
       |/// * the declaration is referenced outside the package in which it is declared.
       |const _Internal internal = _Internal();
       |
       |/// Used to annotate a test framework function that runs a single test.
       |///
       |/// Tools, such as IDEs, can show invocations of such function in a file
       |/// structure view to help the user navigating in large test files.
       |///
       |/// The first parameter of the function must be the description of the test.
       |const _IsTest isTest = _IsTest();
       |
       |/// Used to annotate a test framework function that runs a group of tests.
       |///
       |/// Tools, such as IDEs, can show invocations of such function in a file
       |/// structure view to help the user navigating in large test files.
       |///
       |/// The first parameter of the function must be the description of the group.
       |const _IsTestGroup isTestGroup = _IsTestGroup();
       |
       |/// Used to annotate a const constructor `c`. Indicates that any invocation of
       |/// the constructor must use the keyword `const` unless one or more of the
       |/// arguments to the constructor is not a compile-time constant.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with anything other than a const constructor,
       |///   or
       |/// * an invocation of a constructor that has this annotation is not invoked
       |///   using the `const` keyword unless one or more of the arguments to the
       |///   constructor is not a compile-time constant.
       |const _Literal literal = _Literal();
       |
       |/// Used to annotate an instance method `m`. Indicates that every invocation of
       |/// a method that overrides `m` must also invoke `m`. In addition, every method
       |/// that overrides `m` is implicitly annotated with this same annotation.
       |///
       |/// Note that private methods with this annotation cannot be validly overridden
       |/// outside of the library that defines the annotated method.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with anything other than an instance method,
       |///   or
       |/// * a method that overrides a method that has this annotation can return
       |///   without invoking the overridden method.
       |const _MustCallSuper mustCallSuper = _MustCallSuper();
       |
       |/// Used to annotate an instance member (method, getter, setter, operator, or
       |/// field) `m` in a class `C` or mixin `M`. Indicates that `m` should not be
       |/// overridden in any classes that extend or mixin `C` or `M`.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with anything other than an instance member,
       |/// * the annotation is associated with an abstract member (because subclasses
       |///   are required to override the member),
       |/// * the annotation is associated with an extension method,
       |/// * the annotation is associated with a member `m` in class `C`, and there is
       |///   a class `D` or mixin `M`, that extends or mixes in `C`, that declares an
       |///   overriding member `m`.
       |const _NonVirtual nonVirtual = _NonVirtual();
       |
       |/// Used to annotate a class, mixin, or extension declaration `C`. Indicates
       |/// that any type arguments declared on `C` are to be treated as optional.
       |/// Tools such as the analyzer and linter can use this information to suppress
       |/// warnings that would otherwise require type arguments on `C` to be provided.
       |const _OptionalTypeArgs optionalTypeArgs = _OptionalTypeArgs();
       |
       |/// Used to annotate an instance member (method, getter, setter, operator, or
       |/// field) `m` in a class `C`. If the annotation is on a field it applies to the
       |/// getter, and setter if appropriate, that are induced by the field. Indicates
       |/// that `m` should only be invoked from instance methods of `C` or classes that
       |/// extend, implement or mix in `C`, either directly or indirectly. Additionally
       |/// indicates that `m` should only be invoked on `this`, whether explicitly or
       |/// implicitly.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with anything other than an instance member,
       |///   or
       |/// * an invocation of a member that has this annotation is used outside of an
       |///   instance member defined on a class that extends or mixes in (or a mixin
       |///   constrained to) the class in which the protected member is defined.
       |/// * an invocation of a member that has this annotation is used within an
       |///   instance method, but the receiver is something other than `this`.
       |const _Protected protected = _Protected();
       |
       |/// Used to annotate a named parameter `p` in a method or function `f`.
       |/// Indicates that every invocation of `f` must include an argument
       |/// corresponding to `p`, despite the fact that `p` would otherwise be an
       |/// optional parameter.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with anything other than a named parameter,
       |/// * the annotation is associated with a named parameter in a method `m1` that
       |///   overrides a method `m0` and `m0` defines a named parameter with the same
       |///   name that does not have this annotation, or
       |/// * an invocation of a method or function does not include an argument
       |///   corresponding to a named parameter that has this annotation.
       |const Required required = Required();
       |
       |/// Annotation marking a class as not allowed as a super-type.
       |///
       |/// Classes in the same package as the marked class may extend, implement or
       |/// mix-in the annotated class.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with anything other than a class,
       |/// * the annotation is associated with a class `C`, and there is a class or
       |///   mixin `D`, which extends, implements, mixes in, or constrains to `C`, and
       |///   `C` and `D` are declared in different packages.
       |const _Sealed sealed = _Sealed();
       |
       |/// Used to annotate a field that is allowed to be overridden in Strong Mode.
       |///
       |/// Deprecated: Most of strong mode is now the default in 2.0, but the notion of
       |/// virtual fields was dropped, so this annotation no longer has any meaning.
       |/// Uses of the annotation should be removed.
       |@Deprecated('No longer has meaning')
       |const _Virtual virtual = _Virtual();
       |
       |/// Used to annotate an instance member that was made public so that it could be
       |/// overridden but that is not intended to be referenced from outside the
       |/// defining library.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with a declaration other than a public
       |///   instance member in a class or mixin, or
       |/// * the member is referenced outside of the defining library.
       |const _VisibleForOverriding visibleForOverriding = _VisibleForOverriding();
       |
       |/// Used to annotate a declaration that was made public, so that it is more
       |/// visible than otherwise necessary, to make code testable.
       |///
       |/// Tools, such as the analyzer, can provide feedback if
       |///
       |/// * the annotation is associated with a declaration not in the `lib` folder
       |///   of a package, or a private declaration, or a declaration in an unnamed
       |///   static extension, or
       |/// * the declaration is referenced outside of its defining library or a
       |///   library which is in the `test` folder of the defining package.
       |const _VisibleForTesting visibleForTesting = _VisibleForTesting();
       |
       |/// Used to annotate a class.
       |///
       |/// See [immutable] for more details.
       |class Immutable {
       |  /// A human-readable explanation of the reason why the class is immutable.
       |  final String reason;
       |
       |  /// Initialize a newly created instance to have the given [reason].
      0|  const Immutable([this.reason = '']);
       |}
       |
       |/// Used to annotate a named parameter `p` in a method or function `f`.
       |///
       |/// See [required] for more details.
       |class Required {
       |  /// A human-readable explanation of the reason why the annotated parameter is
       |  /// required. For example, the annotation might look like:
       |  ///
       |  ///     ButtonWidget({
       |  ///         Function onHover,
       |  ///         @Required('Buttons must do something when pressed')
       |  ///         Function onPressed,
       |  ///         ...
       |  ///     }) ...
       |  final String reason;
       |
       |  /// Initialize a newly created instance to have the given [reason].
      0|  const Required([this.reason = '']);
       |}
       |
       |class _AlwaysThrows {
      0|  const _AlwaysThrows();
       |}
       |
       |class _Checked {
      0|  const _Checked();
       |}
       |
       |class _DoNotStore {
      0|  const _DoNotStore();
       |}
       |
       |class _Experimental {
      0|  const _Experimental();
       |}
       |
       |class _Factory {
      0|  const _Factory();
       |}
       |
       |class _Internal {
      0|  const _Internal();
       |}
       |
       |class _IsTest {
      0|  const _IsTest();
       |}
       |
       |class _IsTestGroup {
      0|  const _IsTestGroup();
       |}
       |
       |class _Literal {
      0|  const _Literal();
       |}
       |
       |class _MustCallSuper {
      0|  const _MustCallSuper();
       |}
       |
       |class _NonVirtual {
      0|  const _NonVirtual();
       |}
       |
       |class _OptionalTypeArgs {
      0|  const _OptionalTypeArgs();
       |}
       |
       |class _Protected {
      0|  const _Protected();
       |}
       |
       |class _Sealed {
      0|  const _Sealed();
       |}
       |
       |@Deprecated('No longer has meaning')
       |class _Virtual {
      0|  const _Virtual();
       |}
       |
       |class _VisibleForOverriding {
      0|  const _VisibleForOverriding();
       |}
       |
       |class _VisibleForTesting {
      0|  const _VisibleForTesting();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/path.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A comprehensive, cross-platform path manipulation library.
       |///
       |/// The path library was designed to be imported with a prefix, though you don't
       |/// have to if you don't want to:
       |///
       |///     import 'package:path/path.dart' as p;
       |///
       |/// The most common way to use the library is through the top-level functions.
       |/// These manipulate path strings based on your current working directory and
       |/// the path style (POSIX, Windows, or URLs) of the host platform. For example:
       |///
       |///     p.join('directory', 'file.txt');
       |///
       |/// This calls the top-level [join] function to join "directory" and "file.txt"
       |/// using the current platform's directory separator.
       |///
       |/// If you want to work with paths for a specific platform regardless of the
       |/// underlying platform that the program is running on, you can create a
       |/// [Context] and give it an explicit [Style]:
       |///
       |///     var context = p.Context(style: Style.windows);
       |///     context.join('directory', 'file.txt');
       |///
       |/// This will join "directory" and "file.txt" using the Windows path separator,
       |/// even when the program is run on a POSIX machine.
       |import 'src/context.dart';
       |import 'src/style.dart';
       |
       |export 'src/context.dart' hide createInternal;
       |export 'src/path_exception.dart';
       |export 'src/path_map.dart';
       |export 'src/path_set.dart';
       |export 'src/style.dart';
       |
       |/// A default context for manipulating POSIX paths.
      0|final Context posix = Context(style: Style.posix);
       |
       |/// A default context for manipulating Windows paths.
      0|final Context windows = Context(style: Style.windows);
       |
       |/// A default context for manipulating URLs.
       |///
       |/// URL path equality is undefined for paths that differ only in their
       |/// percent-encoding or only in the case of their host segment.
      0|final Context url = Context(style: Style.url);
       |
       |/// The system path context.
       |///
       |/// This differs from a context created with [new Context] in that its
       |/// [Context.current] is always the current working directory, rather than being
       |/// set once when the context is created.
      3|final Context context = createInternal();
       |
       |/// Returns the [Style] of the current context.
       |///
       |/// This is the style that all top-level path functions will use.
      3|Style get style => context.style;
       |
       |/// Gets the path to the current working directory.
       |///
       |/// In the browser, this means the current URL, without the last file segment.
      1|String get current {
       |  // If the current working directory gets deleted out from under the program,
       |  // accessing it will throw an IO exception. In order to avoid transient
       |  // errors, if we already have a cached working directory, catch the error and
       |  // use that.
       |  Uri uri;
       |  try {
      1|    uri = Uri.base;
      0|  } on Exception {
       |    if (_current != null) return _current;
       |    rethrow;
       |  }
       |
       |  // Converting the base URI to a file path is pretty slow, and the base URI
       |  // rarely changes in practice, so we cache the result here.
      1|  if (uri == _currentUriBase) return _current;
       |  _currentUriBase = uri;
       |
      3|  if (Style.platform == Style.url) {
      0|    _current = uri.resolve('.').toString();
       |  } else {
      1|    final path = uri.toFilePath();
       |    // Remove trailing '/' or '\' unless it is the only thing left
       |    // (for instance the root on Linux).
      2|    final lastIndex = path.length - 1;
       |    assert(path[lastIndex] == '/' || path[lastIndex] == '\\');
      2|    _current = lastIndex == 0 ? path : path.substring(0, lastIndex);
       |  }
       |  return _current;
       |}
       |
       |/// The last value returned by [Uri.base].
       |///
       |/// This is used to cache the current working directory.
       |Uri _currentUriBase;
       |
       |/// The last known value of the current working directory.
       |///
       |/// This is cached because [current] is called frequently but rarely actually
       |/// changes.
       |String _current;
       |
       |/// Gets the path separator for the current platform. This is `\` on Windows
       |/// and `/` on other platforms (including the browser).
      0|String get separator => context.separator;
       |
       |/// Creates a new path by appending the given path parts to [current].
       |/// Equivalent to [join()] with [current] as the first argument. Example:
       |///
       |///     p.absolute('path', 'to/foo'); // -> '/your/current/dir/path/to/foo'
      0|String absolute(String part1,
       |        [String part2,
       |        String part3,
       |        String part4,
       |        String part5,
       |        String part6,
       |        String part7]) =>
      0|    context.absolute(part1, part2, part3, part4, part5, part6, part7);
       |
       |/// Gets the part of [path] after the last separator.
       |///
       |///     p.basename('path/to/foo.dart'); // -> 'foo.dart'
       |///     p.basename('path/to');          // -> 'to'
       |///
       |/// Trailing separators are ignored.
       |///
       |///     p.basename('path/to/'); // -> 'to'
      0|String basename(String path) => context.basename(path);
       |
       |/// Gets the part of [path] after the last separator, and without any trailing
       |/// file extension.
       |///
       |///     p.basenameWithoutExtension('path/to/foo.dart'); // -> 'foo'
       |///
       |/// Trailing separators are ignored.
       |///
       |///     p.basenameWithoutExtension('path/to/foo.dart/'); // -> 'foo'
      0|String basenameWithoutExtension(String path) =>
      0|    context.basenameWithoutExtension(path);
       |
       |/// Gets the part of [path] before the last separator.
       |///
       |///     p.dirname('path/to/foo.dart'); // -> 'path/to'
       |///     p.dirname('path/to');          // -> 'path'
       |///
       |/// Trailing separators are ignored.
       |///
       |///     p.dirname('path/to/'); // -> 'path'
       |///
       |/// If an absolute path contains no directories, only a root, then the root
       |/// is returned.
       |///
       |///     p.dirname('/');  // -> '/' (posix)
       |///     p.dirname('c:\');  // -> 'c:\' (windows)
       |///
       |/// If a relative path has no directories, then '.' is returned.
       |///
       |///     p.dirname('foo');  // -> '.'
       |///     p.dirname('');  // -> '.'
      0|String dirname(String path) => context.dirname(path);
       |
       |/// Gets the file extension of [path]: the portion of [basename] from the last
       |/// `.` to the end (including the `.` itself).
       |///
       |///     p.extension('path/to/foo.dart');    // -> '.dart'
       |///     p.extension('path/to/foo');         // -> ''
       |///     p.extension('path.to/foo');         // -> ''
       |///     p.extension('path/to/foo.dart.js'); // -> '.js'
       |///
       |/// If the file name starts with a `.`, then that is not considered the
       |/// extension:
       |///
       |///     p.extension('~/.bashrc');    // -> ''
       |///     p.extension('~/.notes.txt'); // -> '.txt'
       |///
       |/// Takes an optional parameter `level` which makes possible to return
       |/// multiple extensions having `level` number of dots. If `level` exceeds the
       |/// number of dots, the full extension is returned. The value of `level` must
       |/// be greater than 0, else `RangeError` is thrown.
       |///
       |///     p.extension('foo.bar.dart.js', 2);   // -> '.dart.js
       |///     p.extension('foo.bar.dart.js', 3);   // -> '.bar.dart.js'
       |///     p.extension('foo.bar.dart.js', 10);  // -> '.bar.dart.js'
       |///     p.extension('path/to/foo.bar.dart.js', 2);  // -> '.dart.js'
      0|String extension(String path, [int level = 1]) =>
      0|    context.extension(path, level);
       |
       |/// Returns the root of [path], if it's absolute, or the empty string if it's
       |/// relative.
       |///
       |///     // Unix
       |///     p.rootPrefix('path/to/foo'); // -> ''
       |///     p.rootPrefix('/path/to/foo'); // -> '/'
       |///
       |///     // Windows
       |///     p.rootPrefix(r'path\to\foo'); // -> ''
       |///     p.rootPrefix(r'C:\path\to\foo'); // -> r'C:\'
       |///     p.rootPrefix(r'\\server\share\a\b'); // -> r'\\server\share'
       |///
       |///     // URL
       |///     p.rootPrefix('path/to/foo'); // -> ''
       |///     p.rootPrefix('https://dart.dev/path/to/foo');
       |///       // -> 'https://dart.dev'
      0|String rootPrefix(String path) => context.rootPrefix(path);
       |
       |/// Returns `true` if [path] is an absolute path and `false` if it is a
       |/// relative path.
       |///
       |/// On POSIX systems, absolute paths start with a `/` (forward slash). On
       |/// Windows, an absolute path starts with `\\`, or a drive letter followed by
       |/// `:/` or `:\`. For URLs, absolute paths either start with a protocol and
       |/// optional hostname (e.g. `https://dart.dev`, `file://`) or with a `/`.
       |///
       |/// URLs that start with `/` are known as "root-relative", since they're
       |/// relative to the root of the current URL. Since root-relative paths are still
       |/// absolute in every other sense, [isAbsolute] will return true for them. They
       |/// can be detected using [isRootRelative].
      0|bool isAbsolute(String path) => context.isAbsolute(path);
       |
       |/// Returns `true` if [path] is a relative path and `false` if it is absolute.
       |/// On POSIX systems, absolute paths start with a `/` (forward slash). On
       |/// Windows, an absolute path starts with `\\`, or a drive letter followed by
       |/// `:/` or `:\`.
      0|bool isRelative(String path) => context.isRelative(path);
       |
       |/// Returns `true` if [path] is a root-relative path and `false` if it's not.
       |///
       |/// URLs that start with `/` are known as "root-relative", since they're
       |/// relative to the root of the current URL. Since root-relative paths are still
       |/// absolute in every other sense, [isAbsolute] will return true for them. They
       |/// can be detected using [isRootRelative].
       |///
       |/// No POSIX and Windows paths are root-relative.
      0|bool isRootRelative(String path) => context.isRootRelative(path);
       |
       |/// Joins the given path parts into a single path using the current platform's
       |/// [separator]. Example:
       |///
       |///     p.join('path', 'to', 'foo'); // -> 'path/to/foo'
       |///
       |/// If any part ends in a path separator, then a redundant separator will not
       |/// be added:
       |///
       |///     p.join('path/', 'to', 'foo'); // -> 'path/to/foo
       |///
       |/// If a part is an absolute path, then anything before that will be ignored:
       |///
       |///     p.join('path', '/to', 'foo'); // -> '/to/foo'
      0|String join(String part1,
       |        [String part2,
       |        String part3,
       |        String part4,
       |        String part5,
       |        String part6,
       |        String part7,
       |        String part8]) =>
      0|    context.join(part1, part2, part3, part4, part5, part6, part7, part8);
       |
       |/// Joins the given path parts into a single path using the current platform's
       |/// [separator]. Example:
       |///
       |///     p.joinAll(['path', 'to', 'foo']); // -> 'path/to/foo'
       |///
       |/// If any part ends in a path separator, then a redundant separator will not
       |/// be added:
       |///
       |///     p.joinAll(['path/', 'to', 'foo']); // -> 'path/to/foo
       |///
       |/// If a part is an absolute path, then anything before that will be ignored:
       |///
       |///     p.joinAll(['path', '/to', 'foo']); // -> '/to/foo'
       |///
       |/// For a fixed number of parts, [join] is usually terser.
      0|String joinAll(Iterable<String> parts) => context.joinAll(parts);
       |
       |/// Splits [path] into its components using the current platform's [separator].
       |///
       |///     p.split('path/to/foo'); // -> ['path', 'to', 'foo']
       |///
       |/// The path will *not* be normalized before splitting.
       |///
       |///     p.split('path/../foo'); // -> ['path', '..', 'foo']
       |///
       |/// If [path] is absolute, the root directory will be the first element in the
       |/// array. Example:
       |///
       |///     // Unix
       |///     p.split('/path/to/foo'); // -> ['/', 'path', 'to', 'foo']
       |///
       |///     // Windows
       |///     p.split(r'C:\path\to\foo'); // -> [r'C:\', 'path', 'to', 'foo']
       |///     p.split(r'\\server\share\path\to\foo');
       |///       // -> [r'\\server\share', 'foo', 'bar', 'baz']
       |///
       |///     // Browser
       |///     p.split('https://dart.dev/path/to/foo');
       |///       // -> ['https://dart.dev', 'path', 'to', 'foo']
      0|List<String> split(String path) => context.split(path);
       |
       |/// Canonicalizes [path].
       |///
       |/// This is guaranteed to return the same path for two different input paths
       |/// if and only if both input paths point to the same location. Unlike
       |/// [normalize], it returns absolute paths when possible and canonicalizes
       |/// ASCII case on Windows.
       |///
       |/// Note that this does not resolve symlinks.
       |///
       |/// If you want a map that uses path keys, it's probably more efficient to
       |/// pass [equals] and [hash] to [new HashMap] than it is to canonicalize every
       |/// key.
      0|String canonicalize(String path) => context.canonicalize(path);
       |
       |/// Normalizes [path], simplifying it by handling `..`, and `.`, and
       |/// removing redundant path separators whenever possible.
       |///
       |/// Note that this is *not* guaranteed to return the same result for two
       |/// equivalent input paths. For that, see [canonicalize]. Or, if you're using
       |/// paths as map keys, pass [equals] and [hash] to [new HashMap].
       |///
       |///     p.normalize('path/./to/..//file.text'); // -> 'path/file.txt'
      0|String normalize(String path) => context.normalize(path);
       |
       |/// Attempts to convert [path] to an equivalent relative path from the current
       |/// directory.
       |///
       |///     // Given current directory is /root/path:
       |///     p.relative('/root/path/a/b.dart'); // -> 'a/b.dart'
       |///     p.relative('/root/other.dart'); // -> '../other.dart'
       |///
       |/// If the [from] argument is passed, [path] is made relative to that instead.
       |///
       |///     p.relative('/root/path/a/b.dart', from: '/root/path'); // -> 'a/b.dart'
       |///     p.relative('/root/other.dart', from: '/root/path');
       |///       // -> '../other.dart'
       |///
       |/// If [path] and/or [from] are relative paths, they are assumed to be relative
       |/// to the current directory.
       |///
       |/// Since there is no relative path from one drive letter to another on Windows,
       |/// or from one hostname to another for URLs, this will return an absolute path
       |/// in those cases.
       |///
       |///     // Windows
       |///     p.relative(r'D:\other', from: r'C:\home'); // -> 'D:\other'
       |///
       |///     // URL
       |///     p.relative('https://dart.dev', from: 'https://pub.dev');
       |///       // -> 'https://dart.dev'
      0|String relative(String path, {String from}) =>
      0|    context.relative(path, from: from);
       |
       |/// Returns `true` if [child] is a path beneath `parent`, and `false` otherwise.
       |///
       |///     p.isWithin('/root/path', '/root/path/a'); // -> true
       |///     p.isWithin('/root/path', '/root/other'); // -> false
       |///     p.isWithin('/root/path', '/root/path') // -> false
      0|bool isWithin(String parent, String child) => context.isWithin(parent, child);
       |
       |/// Returns `true` if [path1] points to the same location as [path2], and
       |/// `false` otherwise.
       |///
       |/// The [hash] function returns a hash code that matches these equality
       |/// semantics.
      0|bool equals(String path1, String path2) => context.equals(path1, path2);
       |
       |/// Returns a hash code for [path] such that, if [equals] returns `true` for two
       |/// paths, their hash codes are the same.
       |///
       |/// Note that the same path may have different hash codes on different platforms
       |/// or with different [current] directories.
      0|int hash(String path) => context.hash(path);
       |
       |/// Removes a trailing extension from the last part of [path].
       |///
       |///     p.withoutExtension('path/to/foo.dart'); // -> 'path/to/foo'
      0|String withoutExtension(String path) => context.withoutExtension(path);
       |
       |/// Returns [path] with the trailing extension set to [extension].
       |///
       |/// If [path] doesn't have a trailing extension, this just adds [extension] to
       |/// the end.
       |///
       |///     p.setExtension('path/to/foo.dart', '.js') // -> 'path/to/foo.js'
       |///     p.setExtension('path/to/foo.dart.js', '.map')
       |///       // -> 'path/to/foo.dart.map'
       |///     p.setExtension('path/to/foo', '.js') // -> 'path/to/foo.js'
      0|String setExtension(String path, String extension) =>
      0|    context.setExtension(path, extension);
       |
       |/// Returns the path represented by [uri], which may be a [String] or a [Uri].
       |///
       |/// For POSIX and Windows styles, [uri] must be a `file:` URI. For the URL
       |/// style, this will just convert [uri] to a string.
       |///
       |///     // POSIX
       |///     p.fromUri('file:///path/to/foo') // -> '/path/to/foo'
       |///
       |///     // Windows
       |///     p.fromUri('file:///C:/path/to/foo') // -> r'C:\path\to\foo'
       |///
       |///     // URL
       |///     p.fromUri('https://dart.dev/path/to/foo')
       |///       // -> 'https://dart.dev/path/to/foo'
       |///
       |/// If [uri] is relative, a relative path will be returned.
       |///
       |///     p.fromUri('path/to/foo'); // -> 'path/to/foo'
      0|String fromUri(uri) => context.fromUri(uri);
       |
       |/// Returns the URI that represents [path].
       |///
       |/// For POSIX and Windows styles, this will return a `file:` URI. For the URL
       |/// style, this will just convert [path] to a [Uri].
       |///
       |///     // POSIX
       |///     p.toUri('/path/to/foo')
       |///       // -> Uri.parse('file:///path/to/foo')
       |///
       |///     // Windows
       |///     p.toUri(r'C:\path\to\foo')
       |///       // -> Uri.parse('file:///C:/path/to/foo')
       |///
       |///     // URL
       |///     p.toUri('https://dart.dev/path/to/foo')
       |///       // -> Uri.parse('https://dart.dev/path/to/foo')
       |///
       |/// If [path] is relative, a relative URI will be returned.
       |///
       |///     p.toUri('path/to/foo') // -> Uri.parse('path/to/foo')
      0|Uri toUri(String path) => context.toUri(path);
       |
       |/// Returns a terse, human-readable representation of [uri].
       |///
       |/// [uri] can be a [String] or a [Uri]. If it can be made relative to the
       |/// current working directory, that's done. Otherwise, it's returned as-is. This
       |/// gracefully handles non-`file:` URIs for [Style.posix] and [Style.windows].
       |///
       |/// The returned value is meant for human consumption, and may be either URI-
       |/// or path-formatted.
       |///
       |///     // POSIX at "/root/path"
       |///     p.prettyUri('file:///root/path/a/b.dart'); // -> 'a/b.dart'
       |///     p.prettyUri('https://dart.dev/'); // -> 'https://dart.dev'
       |///
       |///     // Windows at "C:\root\path"
       |///     p.prettyUri('file:///C:/root/path/a/b.dart'); // -> r'a\b.dart'
       |///     p.prettyUri('https://dart.dev/'); // -> 'https://dart.dev'
       |///
       |///     // URL at "https://dart.dev/root/path"
       |///     p.prettyUri('https://dart.dev/root/path/a/b.dart'); // -> r'a/b.dart'
       |///     p.prettyUri('file:///root/path'); // -> 'file:///root/path'
      3|String prettyUri(uri) => context.prettyUri(uri);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/declarer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:collection/collection.dart';
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../frontend/timeout.dart';
       |import '../util/test.dart';
       |import 'group.dart';
       |import 'group_entry.dart';
       |import 'invoker.dart';
       |import 'metadata.dart';
       |import 'test.dart';
       |
       |/// A class that manages the state of tests as they're declared.
       |///
       |/// A nested tree of Declarers tracks the current group, set-up, and tear-down
       |/// functions. Each Declarer in the tree corresponds to a group. This tree is
       |/// tracked by a zone-scoped "current" Declarer; the current declarer can be set
       |/// for a block using [Declarer.declare], and it can be accessed using
       |/// [Declarer.current].
       |class Declarer {
       |  /// The parent declarer, or `null` if this corresponds to the root group.
       |  final Declarer _parent;
       |
       |  /// The name of the current test group, including the name of any parent
       |  /// groups.
       |  ///
       |  /// This is `null` if this is the root group.
       |  final String _name;
       |
       |  /// The metadata for this group, including the metadata of any parent groups
       |  /// and of the test suite.
       |  final Metadata _metadata;
       |
       |  /// The set of variables that are valid for platform selectors, in addition to
       |  /// the built-in variables that are allowed everywhere.
       |  final Set<String> _platformVariables;
       |
       |  /// The stack trace for this group.
       |  final Trace _trace;
       |
       |  /// Whether to collect stack traces for [GroupEntry]s.
       |  final bool _collectTraces;
       |
       |  /// Whether to disable retries of tests.
       |  final bool _noRetry;
       |
       |  /// The set-up functions to run for each test in this group.
       |  final _setUps = <dynamic Function()>[];
       |
       |  /// The tear-down functions to run for each test in this group.
       |  final _tearDowns = <dynamic Function()>[];
       |
       |  /// The set-up functions to run once for this group.
       |  final _setUpAlls = <dynamic Function()>[];
       |
       |  /// The default timeout for synthetic tests.
       |  final _timeout = Timeout(Duration(minutes: 12));
       |
       |  /// The trace for the first call to [setUpAll].
       |  ///
       |  /// All [setUpAll]s are run in a single logical test, so they can only have
       |  /// one trace. The first trace is most often correct, since the first
       |  /// [setUpAll] is always run and the rest are only run if that one succeeds.
       |  Trace _setUpAllTrace;
       |
       |  /// The tear-down functions to run once for this group.
       |  final _tearDownAlls = <Function()>[];
       |
       |  /// The trace for the first call to [tearDownAll].
       |  ///
       |  /// All [tearDownAll]s are run in a single logical test, so they can only have
       |  /// one trace. The first trace matches [_setUpAllTrace].
       |  Trace _tearDownAllTrace;
       |
       |  /// The children of this group, either tests or sub-groups.
       |  final _entries = <GroupEntry>[];
       |
       |  /// Whether [build] has been called for this declarer.
       |  bool _built = false;
       |
       |  /// The tests and/or groups that have been flagged as solo.
       |  final _soloEntries = <GroupEntry>[];
       |
       |  /// Whether any tests and/or groups have been flagged as solo.
      3|  bool get _solo => _soloEntries.isNotEmpty;
       |
       |  /// The current zone-scoped declarer.
      3|  static Declarer get current => Zone.current[#test.declarer] as Declarer;
       |
       |  /// Creates a new declarer for the root group.
       |  ///
       |  /// This is the implicit group that exists outside of any calls to `group()`.
       |  /// If [metadata] is passed, it's used as the metadata for the implicit root
       |  /// group.
       |  ///
       |  /// The [platformVariables] are the set of variables that are valid for
       |  /// platform selectors in test and group metadata, in addition to the built-in
       |  /// variables that are allowed everywhere.
       |  ///
       |  /// If [collectTraces] is `true`, this will set [GroupEntry.trace] for all
       |  /// entries built by the declarer. Note that this can be noticeably slow when
       |  /// thousands of tests are being declared (see #457).
       |  ///
       |  /// If [noRetry] is `true` tests will be run at most once.
      1|  Declarer(
       |      {Metadata metadata,
       |      Set<String> platformVariables,
       |      bool collectTraces = false,
       |      bool noRetry = false})
      1|      : this._(
       |            null,
       |            null,
      1|            metadata ?? Metadata(),
       |            platformVariables ?? const UnmodifiableSetView.empty(),
       |            collectTraces,
       |            null,
       |            noRetry);
       |
      1|  Declarer._(this._parent, this._name, this._metadata, this._platformVariables,
       |      this._collectTraces, this._trace, this._noRetry);
       |
       |  /// Runs [body] with this declarer as [Declarer.current].
       |  ///
       |  /// Returns the return value of [body].
      1|  T declare<T>(T Function() body) =>
      2|      runZoned(body, zoneValues: {#test.declarer: this});
       |
       |  /// Defines a test case with the given name and body.
      1|  void test(String name, dynamic Function() body,
       |      {String testOn,
       |      Timeout timeout,
       |      skip,
       |      Map<String, dynamic> onPlatform,
       |      tags,
       |      int retry,
       |      bool solo = false}) {
      1|    _checkNotBuilt('test');
       |
      1|    var newMetadata = Metadata.parse(
       |        testOn: testOn,
       |        timeout: timeout,
       |        skip: skip,
       |        onPlatform: onPlatform,
       |        tags: tags,
      1|        retry: _noRetry ? 0 : retry);
      2|    newMetadata.validatePlatformSelectors(_platformVariables);
      2|    var metadata = _metadata.merge(newMetadata);
       |
      5|    _entries.add(LocalTest(_prefix(name), metadata, () async {
      1|      var parents = <Declarer>[];
      1|      for (var declarer = this; declarer != null; declarer = declarer._parent) {
      1|        parents.add(declarer);
       |      }
       |
       |      // Register all tear-down functions in all declarers. Iterate through
       |      // parents outside-in so that the Invoker gets the functions in the order
       |      // they were declared in source.
      2|      for (var declarer in parents.reversed) {
      1|        for (var tearDown in declarer._tearDowns) {
      0|          Invoker.current.addTearDown(tearDown);
       |        }
       |      }
       |
      3|      await runZoned(() async {
      2|        await _runSetUps();
      2|        await body();
       |      },
       |          // Make the declarer visible to running tests so that they'll throw
       |          // useful errors when calling `test()` and `group()` within a test.
      1|          zoneValues: {#test.declarer: this});
      1|    }, trace: _collectTraces ? Trace.current(2) : null, guarded: false));
       |
       |    if (solo) {
      0|      _soloEntries.add(_entries.last);
       |    }
       |  }
       |
       |  /// Creates a group of tests.
      1|  void group(String name, void Function() body,
       |      {String testOn,
       |      Timeout timeout,
       |      skip,
       |      Map<String, dynamic> onPlatform,
       |      tags,
       |      int retry,
       |      bool solo = false}) {
      1|    _checkNotBuilt('group');
       |
      1|    var newMetadata = Metadata.parse(
       |        testOn: testOn,
       |        timeout: timeout,
       |        skip: skip,
       |        onPlatform: onPlatform,
       |        tags: tags,
      1|        retry: _noRetry ? 0 : retry);
      2|    newMetadata.validatePlatformSelectors(_platformVariables);
      2|    var metadata = _metadata.merge(newMetadata);
      1|    var trace = _collectTraces ? Trace.current(2) : null;
       |
      3|    var declarer = Declarer._(this, _prefix(name), metadata, _platformVariables,
      2|        _collectTraces, trace, _noRetry);
      2|    declarer.declare(() {
       |      // Cast to dynamic to avoid the analyzer complaining about us using the
       |      // result of a void method.
      1|      var result = (body as dynamic)();
      1|      if (result is! Future) return;
      0|      throw ArgumentError('Groups may not be async.');
       |    });
      3|    _entries.add(declarer.build());
       |
      1|    if (solo || declarer._solo) {
      0|      _soloEntries.add(_entries.last);
       |    }
       |  }
       |
       |  /// Returns [name] prefixed with this declarer's group name.
      4|  String _prefix(String name) => _name == null ? name : '$_name $name';
       |
       |  /// Registers a function to be run before each test in this group.
      0|  void setUp(dynamic Function() callback) {
      0|    _checkNotBuilt('setUp');
      0|    _setUps.add(callback);
       |  }
       |
       |  /// Registers a function to be run after each test in this group.
      0|  void tearDown(dynamic Function() callback) {
      0|    _checkNotBuilt('tearDown');
      0|    _tearDowns.add(callback);
       |  }
       |
       |  /// Registers a function to be run once before all tests.
      0|  void setUpAll(dynamic Function() callback) {
      0|    _checkNotBuilt('setUpAll');
      0|    if (_collectTraces) _setUpAllTrace ??= Trace.current(2);
      0|    _setUpAlls.add(callback);
       |  }
       |
       |  /// Registers a function to be run once after all tests.
      0|  void tearDownAll(dynamic Function() callback) {
      0|    _checkNotBuilt('tearDownAll');
      0|    if (_collectTraces) _tearDownAllTrace ??= Trace.current(2);
      0|    _tearDownAlls.add(callback);
       |  }
       |
       |  /// Like [tearDownAll], but called from within a running [setUpAll] test to
       |  /// dynamically add a [tearDownAll].
      0|  void addTearDownAll(dynamic Function() callback) =>
      0|      _tearDownAlls.add(callback);
       |
       |  /// Finalizes and returns the group being declared.
       |  ///
       |  /// **Note**: The tests in this group must be run in a [Invoker.guard]
       |  /// context; otherwise, test errors won't be captured.
      1|  Group build() {
      1|    _checkNotBuilt('build');
       |
      1|    _built = true;
      3|    var entries = _entries.map((entry) {
      1|      if (_solo && !_soloEntries.contains(entry)) {
      0|        entry = LocalTest(
      0|            entry.name,
      0|            entry.metadata
      0|                .change(skip: true, skipReason: 'does not have "solo"'),
       |            null);
       |      }
       |      return entry;
      1|    }).toList();
       |
      2|    return Group(_name, entries,
      1|        metadata: _metadata,
      1|        trace: _trace,
      1|        setUpAll: _setUpAll,
      1|        tearDownAll: _tearDownAll);
       |  }
       |
       |  /// Throws a [StateError] if [build] has been called.
       |  ///
       |  /// [name] should be the name of the method being called.
      1|  void _checkNotBuilt(String name) {
      1|    if (!_built) return;
      0|    throw StateError("Can't call $name() once tests have begun running.");
       |  }
       |
       |  /// Run the set-up functions for this and any parent groups.
       |  ///
       |  /// If no set-up functions are declared, this returns a [Future] that
       |  /// completes immediately.
      1|  Future _runSetUps() async {
      4|    if (_parent != null) await _parent._runSetUps();
      3|    await Future.forEach(_setUps, (setUp) => setUp());
       |  }
       |
       |  /// Returns a [Test] that runs the callbacks in [_setUpAll].
      1|  Test get _setUpAll {
      2|    if (_setUpAlls.isEmpty) return null;
       |
      0|    return LocalTest(_prefix('(setUpAll)'), _metadata.change(timeout: _timeout),
      0|        () {
      0|      return runZoned(() => Future.forEach(_setUpAlls, (setUp) => setUp()),
       |          // Make the declarer visible to running scaffolds so they can add to
       |          // the declarer's `tearDownAll()` list.
      0|          zoneValues: {#test.declarer: this});
      0|    }, trace: _setUpAllTrace, guarded: false, isScaffoldAll: true);
       |  }
       |
       |  /// Returns a [Test] that runs the callbacks in [_tearDownAll].
      1|  Test get _tearDownAll {
       |    // We have to create a tearDownAll if there's a setUpAll, since it might
       |    // dynamically add tear-down code using [addTearDownAll].
      4|    if (_setUpAlls.isEmpty && _tearDownAlls.isEmpty) return null;
       |
      0|    return LocalTest(
      0|        _prefix('(tearDownAll)'), _metadata.change(timeout: _timeout), () {
      0|      return runZoned(() {
      0|        return Invoker.current.unclosable(() async {
      0|          while (_tearDownAlls.isNotEmpty) {
      0|            await errorsDontStopTest(_tearDownAlls.removeLast());
       |          }
       |        });
       |      },
       |          // Make the declarer visible to running scaffolds so they can add to
       |          // the declarer's `tearDownAll()` list.
      0|          zoneValues: {#test.declarer: this});
      0|    }, trace: _tearDownAllTrace, guarded: false, isScaffoldAll: true);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/invoker.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../frontend/expect.dart';
       |import '../util/test.dart';
       |import '../utils.dart';
       |import 'closed_exception.dart';
       |import 'declarer.dart';
       |import 'group.dart';
       |import 'live_test.dart';
       |import 'live_test_controller.dart';
       |import 'message.dart';
       |import 'metadata.dart';
       |import 'state.dart';
       |import 'suite.dart';
       |import 'suite_platform.dart';
       |import 'test.dart';
       |
       |/// A test in this isolate.
       |class LocalTest extends Test {
       |  @override
       |  final String name;
       |  @override
       |  final Metadata metadata;
       |  @override
       |  final Trace trace;
       |
       |  /// Whether this is a test defined using `setUpAll()` or `tearDownAll()`.
       |  final bool isScaffoldAll;
       |
       |  /// The test body.
       |  final Function() _body;
       |
       |  /// Whether the test is run in its own error zone.
       |  final bool _guarded;
       |
       |  /// Creates a new [LocalTest].
       |  ///
       |  /// If [guarded] is `true`, the test is run in its own error zone, and any
       |  /// errors that escape that zone cause the test to fail. If it's `false`, it's
       |  /// the caller's responsiblity to invoke [LiveTest.run] in the context of a
       |  /// call to [Invoker.guard].
      1|  LocalTest(this.name, this.metadata, this._body,
       |      {this.trace, bool guarded = true, this.isScaffoldAll = false})
       |      : _guarded = guarded;
       |
      1|  LocalTest._(this.name, this.metadata, this._body, this.trace, this._guarded,
       |      this.isScaffoldAll);
       |
       |  /// Loads a single runnable instance of this test.
      1|  @override
       |  LiveTest load(Suite suite, {Iterable<Group> groups}) {
      2|    var invoker = Invoker._(suite, this, groups: groups, guarded: _guarded);
      1|    return invoker.liveTest;
       |  }
       |
      1|  @override
       |  Test forPlatform(SuitePlatform platform) {
      3|    if (!metadata.testOn.evaluate(platform)) return null;
      6|    return LocalTest._(name, metadata.forPlatform(platform), _body, trace,
      2|        _guarded, isScaffoldAll);
       |  }
       |}
       |
       |/// The class responsible for managing the lifecycle of a single local test.
       |///
       |/// The current invoker is accessible within the zone scope of the running test
       |/// using [Invoker.current]. It's used to track asynchronous callbacks and
       |/// report asynchronous errors.
       |class Invoker {
       |  /// The live test being driven by the invoker.
       |  ///
       |  /// This provides a view into the state of the test being executed.
      2|  LiveTest get liveTest => _controller;
       |  LiveTestController _controller;
       |
       |  /// Whether to run this test in its own error zone.
       |  final bool _guarded;
       |
       |  /// Whether the test can be closed in the current zone.
      4|  bool get _closable => Zone.current[_closableKey] as bool;
       |
       |  /// An opaque object used as a key in the zone value map to identify
       |  /// [_closable].
       |  ///
       |  /// This is an instance variable to ensure that multiple invokers don't step
       |  /// on one anothers' toes.
       |  final _closableKey = Object();
       |
       |  /// Whether the test has been closed.
       |  ///
       |  /// Once the test is closed, [expect] and [expectAsync] will throw
       |  /// [ClosedException]s whenever accessed to help the test stop executing as
       |  /// soon as possible.
      4|  bool get closed => _closable && _onCloseCompleter.isCompleted;
       |
       |  /// A future that completes once the test has been closed.
      0|  Future<void> get onClose => _closable
      0|      ? _onCloseCompleter.future
       |      // If we're in an unclosable block, return a future that will never
       |      // complete.
      0|      : Completer<void>().future;
       |  final _onCloseCompleter = Completer<void>();
       |
       |  /// The test being run.
      3|  LocalTest get _test => liveTest.test as LocalTest;
       |
       |  /// The outstanding callback counter for the current zone.
      0|  _AsyncCounter get _outstandingCallbacks {
      0|    var counter = Zone.current[_counterKey] as _AsyncCounter;
       |    if (counter != null) return counter;
      0|    throw StateError("Can't add or remove outstanding callbacks outside "
       |        'of a test body.');
       |  }
       |
       |  /// All the zones created by [waitForOutstandingCallbacks], in the order they
       |  /// were created.
       |  ///
       |  /// This is used to throw timeout errors in the most recent zone.
       |  final _outstandingCallbackZones = <Zone>[];
       |
       |  /// An opaque object used as a key in the zone value map to identify
       |  /// [_outstandingCallbacks].
       |  ///
       |  /// This is an instance variable to ensure that multiple invokers don't step
       |  /// on one anothers' toes.
       |  final _counterKey = Object();
       |
       |  /// The number of times this [liveTest] has been run.
       |  int _runCount = 0;
       |
       |  /// The current invoker, or `null` if none is defined.
       |  ///
       |  /// An invoker is only set within the zone scope of a running test.
      1|  static Invoker get current {
       |    // TODO(nweiz): Use a private symbol when dart2js supports it (issue 17526).
      2|    return Zone.current[#test.invoker] as Invoker;
       |  }
       |
       |  /// Runs [callback] in a zone where unhandled errors from [LiveTest]s are
       |  /// caught and dispatched to the appropriate [Invoker].
      1|  static T guard<T>(T Function() callback) =>
      2|      runZoned(callback, zoneSpecification: ZoneSpecification(
       |          // Use [handleUncaughtError] rather than [onError] so we can
       |          // capture [zone] and with it the outstanding callback counter for
       |          // the zone in which [error] was thrown.
      0|          handleUncaughtError: (self, _, zone, error, stackTrace) {
      0|        var invoker = zone[#test.invoker] as Invoker;
       |        if (invoker != null) {
      0|          self.parent.run(() => invoker._handleError(zone, error, stackTrace));
       |        } else {
      0|          self.parent.handleUncaughtError(error, stackTrace);
       |        }
       |      }));
       |
       |  /// The timer for tracking timeouts.
       |  ///
       |  /// This will be `null` until the test starts running.
       |  Timer _timeoutTimer;
       |
       |  /// The tear-down functions to run when this test finishes.
       |  final _tearDowns = <Function()>[];
       |
       |  /// Messages to print if and when this test fails.
       |  final _printsOnFailure = <String>[];
       |
      1|  Invoker._(Suite suite, LocalTest test,
       |      {Iterable<Group> groups, bool guarded = true})
       |      : _guarded = guarded {
      2|    _controller = LiveTestController(
      3|        suite, test, _onRun, _onCloseCompleter.complete,
       |        groups: groups);
       |  }
       |
       |  /// Runs [callback] after this test completes.
       |  ///
       |  /// The [callback] may return a [Future]. Like all tear-downs, callbacks are
       |  /// run in the reverse of the order they're declared.
      0|  void addTearDown(dynamic Function() callback) {
      0|    if (closed) throw ClosedException();
       |
      0|    if (_test.isScaffoldAll) {
      0|      Declarer.current.addTearDownAll(callback);
       |    } else {
      0|      _tearDowns.add(callback);
       |    }
       |  }
       |
       |  /// Tells the invoker that there's a callback running that it should wait for
       |  /// before considering the test successful.
       |  ///
       |  /// Each call to [addOutstandingCallback] should be followed by a call to
       |  /// [removeOutstandingCallback] once the callback is no longer running. Note
       |  /// that only successful tests wait for outstanding callbacks; as soon as a
       |  /// test experiences an error, any further calls to [addOutstandingCallback]
       |  /// or [removeOutstandingCallback] will do nothing.
       |  ///
       |  /// Throws a [ClosedException] if this test has been closed.
      0|  void addOutstandingCallback() {
      0|    if (closed) throw ClosedException();
      0|    _outstandingCallbacks.increment();
       |  }
       |
       |  /// Tells the invoker that a callback declared with [addOutstandingCallback]
       |  /// is no longer running.
      0|  void removeOutstandingCallback() {
      0|    heartbeat();
      0|    _outstandingCallbacks.decrement();
       |  }
       |
       |  /// Runs [fn] and completes once [fn] and all outstanding callbacks registered
       |  /// within [fn] have completed.
       |  ///
       |  /// Outstanding callbacks registered within [fn] will *not* be registered as
       |  /// outstanding callback outside of [fn].
      1|  Future<void> waitForOutstandingCallbacks(FutureOr<void> Function() fn) {
      1|    heartbeat();
       |
       |    Zone zone;
      1|    var counter = _AsyncCounter();
      2|    runZoned(() async {
      1|      zone = Zone.current;
      2|      _outstandingCallbackZones.add(zone);
      2|      await fn();
      1|      counter.decrement();
      2|    }, zoneValues: {_counterKey: counter});
       |
      3|    return counter.onZero.whenComplete(() {
      2|      _outstandingCallbackZones.remove(zone);
       |    });
       |  }
       |
       |  /// Runs [fn] in a zone where [closed] is always `false`.
       |  ///
       |  /// This is useful for running code that should be able to register callbacks
       |  /// and interact with the test framework normally even when the invoker is
       |  /// closed, for example cleanup code.
      1|  T unclosable<T>(T Function() fn) {
      1|    heartbeat();
       |
      3|    return runZoned(fn, zoneValues: {_closableKey: false});
       |  }
       |
       |  /// Notifies the invoker that progress is being made.
       |  ///
       |  /// Each heartbeat resets the timeout timer. This helps ensure that
       |  /// long-running tests that still make progress don't time out.
      1|  void heartbeat() {
      2|    if (liveTest.isComplete) return;
      3|    if (_timeoutTimer != null) _timeoutTimer.cancel();
       |
       |    const defaultTimeout = Duration(seconds: 30);
      5|    var timeout = liveTest.test.metadata.timeout.apply(defaultTimeout);
       |    if (timeout == null) return;
      0|    String message() {
      0|      var message = 'Test timed out after ${niceDuration(timeout)}.';
      0|      if (timeout == defaultTimeout) {
      0|        message += ' See https://pub.dev/packages/test#timeouts';
       |      }
       |      return message;
       |    }
       |
      2|    _timeoutTimer = Zone.root.createTimer(timeout, () {
      0|      _outstandingCallbackZones.last.run(() {
      0|        _handleError(Zone.current, TimeoutException(message(), timeout));
       |      });
       |    });
       |  }
       |
       |  /// Marks the current test as skipped.
       |  ///
       |  /// If passed, [message] is emitted as a skip message.
       |  ///
       |  /// Note that this *does not* mark the test as complete. That is, it sets
       |  /// the result to [Result.skipped], but doesn't change the state.
      0|  void skip([String message]) {
      0|    if (liveTest.state.shouldBeDone) {
       |      // Set the state explicitly so we don't get an extra error about the test
       |      // failing after being complete.
      0|      _controller.setState(const State(Status.complete, Result.error));
      0|      throw 'This test was marked as skipped after it had already completed. '
       |          'Make sure to use\n'
       |          '[expectAsync] or the [completes] matcher when testing async code.';
       |    }
       |
      0|    if (message != null) _controller.message(Message.skip(message));
       |    // TODO: error if the test is already complete.
      0|    _controller.setState(const State(Status.pending, Result.skipped));
       |  }
       |
       |  /// Prints [message] if and when this test fails.
      0|  void printOnFailure(String message) {
      0|    message = message.trim();
      0|    if (liveTest.state.result.isFailing) {
      0|      print('\n$message');
       |    } else {
      0|      _printsOnFailure.add(message);
       |    }
       |  }
       |
       |  /// Notifies the invoker of an asynchronous error.
       |  ///
       |  /// The [zone] is the zone in which the error was thrown.
      0|  void _handleError(Zone zone, error, [StackTrace stackTrace]) {
       |    // Ignore errors propagated from previous test runs
      0|    if (_runCount != zone[#runCount]) return;
       |
       |    // Get the chain information from the zone in which the error was thrown.
      0|    zone.run(() {
       |      if (stackTrace == null) {
      0|        stackTrace = Chain.current();
       |      } else {
      0|        stackTrace = Chain.forTrace(stackTrace);
       |      }
       |    });
       |
       |    // Store these here because they'll change when we set the state below.
      0|    var shouldBeDone = liveTest.state.shouldBeDone;
       |
      0|    if (error is! TestFailure) {
      0|      _controller.setState(const State(Status.complete, Result.error));
      0|    } else if (liveTest.state.result != Result.error) {
      0|      _controller.setState(const State(Status.complete, Result.failure));
       |    }
       |
      0|    _controller.addError(error, stackTrace);
      0|    zone.run(() => _outstandingCallbacks.complete());
       |
      0|    if (!liveTest.test.metadata.chainStackTraces) {
      0|      _printsOnFailure.add('Consider enabling the flag chain-stack-traces to '
       |          'receive more detailed exceptions.\n'
       |          "For example, 'pub run test --chain-stack-traces'.");
       |    }
       |
      0|    if (_printsOnFailure.isNotEmpty) {
      0|      print(_printsOnFailure.join('\n\n'));
      0|      _printsOnFailure.clear();
       |    }
       |
       |    // If a test was supposed to be done but then had an error, that indicates
       |    // that it was poorly-written and could be flaky.
       |    if (!shouldBeDone) return;
       |
       |    // However, users don't think of load tests as "tests", so the error isn't
       |    // helpful for them.
      0|    if (liveTest.suite.isLoadSuite) return;
       |
      0|    _handleError(
      0|        zone,
       |        'This test failed after it had already completed. Make sure to use '
       |        '[expectAsync]\n'
       |        'or the [completes] matcher when testing async code.',
       |        stackTrace);
       |  }
       |
       |  /// The method that's run when the test is started.
      1|  void _onRun() {
      2|    _controller.setState(const State(Status.running, Result.success));
       |
      2|    _runCount++;
      2|    Chain.capture(() {
      2|      _guardIfGuarded(() {
      2|        runZoned(() async {
      3|          _outstandingCallbackZones.add(Zone.current);
       |
       |          // Run the test asynchronously so that the "running" state change
       |          // has a chance to hit its event handler(s) before the test produces
       |          // an error. If an error is emitted before the first state change is
       |          // handled, we can end up with [onError] callbacks firing before the
       |          // corresponding [onStateChange], which violates the timing
       |          // guarantees.
       |          //
       |          // Use the event loop over the microtask queue to avoid starvation.
      3|          await Future(() {});
       |
      4|          await waitForOutstandingCallbacks(_test._body);
      5|          await waitForOutstandingCallbacks(() => unclosable(_runTearDowns));
       |
      3|          if (_timeoutTimer != null) _timeoutTimer.cancel();
       |
      4|          if (liveTest.state.result != Result.success &&
      0|              _runCount < liveTest.test.metadata.retry + 1) {
      0|            _controller.message(Message.print('Retry: ${liveTest.test.name}'));
      0|            _onRun();
       |            return;
       |          }
       |
      6|          _controller.setState(State(Status.complete, liveTest.state.result));
       |
      3|          _controller.completer.complete();
       |        },
      1|            zoneValues: {
       |              #test.invoker: this,
      1|              _closableKey: true,
      1|              #runCount: _runCount,
       |            },
       |            zoneSpecification:
      1|                ZoneSpecification(print: (_, __, ___, line) => _print(line)));
       |      });
      4|    }, when: liveTest.test.metadata.chainStackTraces, errorZone: false);
       |  }
       |
       |  /// Runs [callback], in a [Invoker.guard] context if [_guarded] is `true`.
      1|  void _guardIfGuarded(void Function() callback) {
      1|    if (_guarded) {
      0|      Invoker.guard(callback);
       |    } else {
      1|      callback();
       |    }
       |  }
       |
       |  /// Prints [text] as a message to [_controller].
      0|  void _print(String text) => _controller.message(Message.print(text));
       |
       |  /// Run [_tearDowns] in reverse order.
      1|  Future<void> _runTearDowns() async {
      2|    while (_tearDowns.isNotEmpty) {
      0|      await errorsDontStopTest(_tearDowns.removeLast());
       |    }
       |  }
       |}
       |
       |/// A manually incremented/decremented counter that completes a [Future] the
       |/// first time it reaches zero or is forcefully completed.
       |class _AsyncCounter {
       |  var _count = 1;
       |
       |  /// A Future that completes the first time the counter reaches 0.
      3|  Future<void> get onZero => _completer.future;
       |  final _completer = Completer<void>();
       |
      0|  void increment() {
      0|    _count++;
       |  }
       |
      1|  void decrement() {
      2|    _count--;
      2|    if (_count != 0) return;
      2|    if (_completer.isCompleted) return;
      2|    _completer.complete();
       |  }
       |
       |  /// Force [onZero] to complete.
       |  ///
       |  /// No effect if [onZero] has already completed.
      0|  void complete() {
      0|    if (!_completer.isCompleted) _completer.complete();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/timeout.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:string_scanner/string_scanner.dart';
       |
       |/// A regular expression that matches text until a letter or whitespace.
       |///
       |/// This is intended to scan through a number without actually encoding the full
       |/// Dart number grammar. It doesn't stop on "e" because that can be a component
       |/// of numbers.
      0|final _untilUnit = RegExp(r'[^a-df-z\s]+', caseSensitive: false);
       |
       |/// A regular expression that matches a time unit.
      0|final _unit = RegExp(r'([um]s|[dhms])', caseSensitive: false);
       |
       |/// A regular expression that matches a section of whitespace.
      0|final _whitespace = RegExp(r'\s+');
       |
       |/// A class representing a modification to the default timeout for a test.
       |///
       |/// By default, a test will time out after 30 seconds. With [new Timeout], that
       |/// can be overridden entirely; with [Timeout.factor], it can be scaled
       |/// relative to the default.
       |class Timeout {
       |  /// A constant indicating that a test should never time out.
       |  static const none = Timeout._none();
       |
       |  /// The timeout duration.
       |  ///
       |  /// If set, this overrides the default duration entirely. It's `null` for
       |  /// timeouts with a non-null [scaleFactor] and for [Timeout.none].
       |  final Duration duration;
       |
       |  /// The timeout factor.
       |  ///
       |  /// The default timeout will be multiplied by this to get the new timeout.
       |  /// Thus a factor of 2 means that the test will take twice as long to time
       |  /// out, and a factor of 0.5 means that it will time out twice as quickly.
       |  ///
       |  /// This is `null` for timeouts with a non-null [duration] and for
       |  /// [Timeout.none].
       |  final num scaleFactor;
       |
       |  /// Declares an absolute timeout that overrides the default.
      1|  const Timeout(this.duration) : scaleFactor = null;
       |
       |  /// Declares a relative timeout that scales the default.
      1|  const Timeout.factor(this.scaleFactor) : duration = null;
       |
      0|  const Timeout._none()
       |      : scaleFactor = null,
       |        duration = null;
       |
       |  /// Parse the timeout from a user-provided string.
       |  ///
       |  /// This supports the following formats:
       |  ///
       |  /// * `Number "x"`, which produces a relative timeout with the given scale
       |  ///   factor.
       |  ///
       |  /// * `(Number ("d" | "h" | "m" | "s" | "ms" | "us") (" ")?)+`, which produces
       |  ///   an absolute timeout with the duration given by the sum of the given
       |  ///   units.
       |  ///
       |  /// * `"none"`, which produces [Timeout.none].
       |  ///
       |  /// Throws a [FormatException] if [timeout] is not in a valid format
      0|  factory Timeout.parse(String timeout) {
      0|    var scanner = StringScanner(timeout);
       |
       |    // First check for the string "none".
      0|    if (scanner.scan('none')) {
      0|      scanner.expectDone();
       |      return Timeout.none;
       |    }
       |
       |    // Scan a number. This will be either a time unit or a scale factor.
      0|    scanner.expect(_untilUnit, name: 'number');
      0|    var number = double.parse(scanner.lastMatch[0]);
       |
       |    // A number followed by "x" is a scale factor.
      0|    if (scanner.scan('x') || scanner.scan('X')) {
      0|      scanner.expectDone();
      0|      return Timeout.factor(number);
       |    }
       |
       |    // Parse time units until none are left. The condition is in the middle of
       |    // the loop because we've already parsed the first number.
       |    var microseconds = 0.0;
       |    while (true) {
      0|      scanner.expect(_unit, name: 'unit');
      0|      microseconds += _microsecondsFor(number, scanner.lastMatch[0]);
       |
      0|      scanner.scan(_whitespace);
       |
       |      // Scan the next number, if it's avaialble.
      0|      if (!scanner.scan(_untilUnit)) break;
      0|      number = double.parse(scanner.lastMatch[0]);
       |    }
       |
      0|    scanner.expectDone();
      0|    return Timeout(Duration(microseconds: microseconds.round()));
       |  }
       |
       |  /// Returns the number of microseconds in [number] [unit]s.
      0|  static double _microsecondsFor(double number, String unit) {
       |    switch (unit) {
      0|      case 'd':
      0|        return number * 24 * 60 * 60 * 1000000;
      0|      case 'h':
      0|        return number * 60 * 60 * 1000000;
      0|      case 'm':
      0|        return number * 60 * 1000000;
      0|      case 's':
      0|        return number * 1000000;
      0|      case 'ms':
      0|        return number * 1000;
      0|      case 'us':
       |        return number;
       |      default:
      0|        throw ArgumentError('Unknown unit $unit.');
       |    }
       |  }
       |
       |  /// Returns a new [Timeout] that merges [this] with [other].
       |  ///
       |  /// [Timeout.none] takes precedence over everything. If timeout is
       |  /// [Timeout.none] and [other] declares a [duration], that takes precedence.
       |  /// Otherwise, this timeout's [duration] or [factor] are multiplied by
       |  /// [other]'s [factor].
      1|  Timeout merge(Timeout other) {
      2|    if (this == none || other == none) return none;
      1|    if (other.duration != null) return Timeout(other.duration);
      1|    if (duration != null) return Timeout(duration * other.scaleFactor);
      4|    return Timeout.factor(scaleFactor * other.scaleFactor);
       |  }
       |
       |  /// Returns a new [Duration] from applying [this] to [base].
       |  ///
       |  /// If this is [none], returns `null`.
      1|  Duration apply(Duration base) {
      1|    if (this == none) return null;
      3|    return duration ?? base * scaleFactor;
       |  }
       |
      0|  @override
      0|  int get hashCode => duration.hashCode ^ 5 * scaleFactor.hashCode;
       |
      1|  @override
       |  bool operator ==(other) =>
      1|      other is Timeout &&
      3|      other.duration == duration &&
      3|      other.scaleFactor == scaleFactor;
       |
      0|  @override
       |  String toString() {
      0|    if (duration != null) return duration.toString();
      0|    if (scaleFactor != null) return '${scaleFactor}x';
       |    return 'none';
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/utils.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:convert';
       |import 'dart:math' as math;
       |import 'dart:typed_data';
       |
       |import 'package:async/async.dart';
       |import 'package:collection/collection.dart';
       |import 'package:matcher/matcher.dart';
       |import 'package:path/path.dart' as p;
       |import 'package:stream_channel/stream_channel.dart';
       |import 'package:term_glyph/term_glyph.dart' as glyph;
       |
       |import 'backend/operating_system.dart';
       |
       |/// A transformer that decodes bytes using UTF-8 and splits them on newlines.
      0|final lineSplitter = StreamTransformer<List<int>, String>(
       |    (stream, cancelOnError) => utf8.decoder
       |        .bind(stream)
       |        .transform(const LineSplitter())
       |        .listen(null, cancelOnError: cancelOnError));
       |
       |/// A [StreamChannelTransformer] that converts a chunked string channel to a
       |/// line-by-line channel.
       |///
       |/// Note that this is only safe for channels whose messages are guaranteed not
       |/// to contain newlines.
      0|final chunksToLines = StreamChannelTransformer<String, String>(
       |    const LineSplitter(),
       |    StreamSinkTransformer.fromHandlers(
       |        handleData: (data, sink) => sink.add('$data\n')));
       |
       |/// A regular expression to match the exception prefix that some exceptions'
       |/// [Object.toString] values contain.
      0|final _exceptionPrefix = RegExp(r'^([A-Z][a-zA-Z]*)?(Exception|Error): ');
       |
       |/// A regular expression matching a single vowel.
      0|final _vowel = RegExp('[aeiou]');
       |
       |/// Directories that are specific to OS X.
       |///
       |/// This is used to try to distinguish OS X and Linux in [currentOSGuess].
      2|final _macOSDirectories = {
       |  '/Applications',
       |  '/Library',
       |  '/Network',
       |  '/System',
       |  '/Users',
       |};
       |
       |/// Returns the best guess for the current operating system without using
       |/// `dart:io`.
       |///
       |/// This is useful for running test files directly and skipping tests as
       |/// appropriate. The only OS-specific information we have is the current path,
       |/// which we try to use to figure out the OS.
      3|final OperatingSystem currentOSGuess = (() {
      3|  if (p.style == p.Style.url) return OperatingSystem.none;
      3|  if (p.style == p.Style.windows) return OperatingSystem.windows;
      4|  if (_macOSDirectories.any(p.current.startsWith)) return OperatingSystem.macOS;
       |  return OperatingSystem.linux;
      1|})();
       |
       |/// A regular expression matching a hyphenated identifier.
       |///
       |/// This is like a standard Dart identifier, except that it can also contain
       |/// hyphens.
      0|final _hyphenatedIdentifier = RegExp(r'[a-zA-Z_-][a-zA-Z0-9_-]*');
       |
       |/// Like [_hyphenatedIdentifier], but anchored so that it must match the entire
       |/// string.
      0|final anchoredHyphenatedIdentifier =
       |    RegExp('^${_hyphenatedIdentifier.pattern}\$');
       |
       |/// A pair of values.
       |class Pair<E, F> {
       |  E first;
       |  F last;
       |
      0|  Pair(this.first, this.last);
       |
      0|  @override
      0|  String toString() => '($first, $last)';
       |
      0|  @override
       |  bool operator ==(other) {
      0|    if (other is! Pair) return false;
      0|    return other.first == first && other.last == last;
       |  }
       |
      0|  @override
      0|  int get hashCode => first.hashCode ^ last.hashCode;
       |}
       |
       |/// Get a string description of an exception.
       |///
       |/// Many exceptions include the exception class name at the beginning of their
       |/// [toString], so we remove that if it exists.
      0|String getErrorMessage(error) =>
      0|    error.toString().replaceFirst(_exceptionPrefix, '');
       |
       |/// Indent each line in [string] by [size] spaces.
       |///
       |/// If [first] is passed, it's used in place of the first line's indentation and
       |/// [size] defaults to `first.length`. Otherwise, [size] defaults to 2.
      0|String indent(String string, {int size, String first}) {
      0|  size ??= first == null ? 2 : first.length;
      0|  return prefixLines(string, ' ' * size, first: first);
       |}
       |
       |/// Returns a sentence fragment listing the elements of [iter].
       |///
       |/// This converts each element of [iter] to a string and separates them with
       |/// commas and/or [conjunction] where appropriate. The [conjunction] defaults to
       |/// "and".
      0|String toSentence(Iterable iter, {String conjunction}) {
      0|  if (iter.length == 1) return iter.first.toString();
       |
      0|  var result = iter.take(iter.length - 1).join(', ');
      0|  if (iter.length > 2) result += ',';
      0|  return "$result ${conjunction ?? 'and'} ${iter.last}";
       |}
       |
       |/// Returns [name] if [number] is 1, or the plural of [name] otherwise.
       |///
       |/// By default, this just adds "s" to the end of [name] to get the plural. If
       |/// [plural] is passed, that's used instead.
      0|String pluralize(String name, int number, {String plural}) {
      0|  if (number == 1) return name;
       |  if (plural != null) return plural;
      0|  return '${name}s';
       |}
       |
       |/// Returns [noun] with an indefinite article ("a" or "an") added, based on
       |/// whether its first letter is a vowel.
      0|String a(String noun) => noun.startsWith(_vowel) ? 'an $noun' : 'a $noun';
       |
       |/// A regular expression matching terminal color codes.
      0|final _colorCode = RegExp('\u001b\\[[0-9;]+m');
       |
       |/// Returns [str] without any color codes.
      0|String withoutColors(String str) => str.replaceAll(_colorCode, '');
       |
       |/// Like [mergeMaps], but assumes both maps are unmodifiable and so avoids
       |/// creating a new map unnecessarily.
       |///
       |/// The return value *may or may not* be unmodifiable.
      0|Map<K, V> mergeUnmodifiableMaps<K, V>(Map<K, V> map1, Map<K, V> map2,
       |    {V Function(V, V) value}) {
      0|  if (map1.isEmpty) return map2;
      0|  if (map2.isEmpty) return map1;
      0|  return mergeMaps(map1, map2, value: value);
       |}
       |
       |/// Truncates [text] to fit within [maxLength].
       |///
       |/// This will try to truncate along word boundaries and preserve words both at
       |/// the beginning and the end of [text].
      0|String truncate(String text, int maxLength) {
       |  // Return the full message if it fits.
      0|  if (text.length <= maxLength) return text;
       |
       |  // If we can fit the first and last three words, do so.
      0|  var words = text.split(' ');
      0|  if (words.length > 1) {
      0|    var i = words.length;
      0|    var length = words.first.length + 4;
       |    do {
      0|      i--;
      0|      length += 1 + words[i].length;
      0|    } while (length <= maxLength && i > 0);
      0|    if (length > maxLength || i == 0) i++;
      0|    if (i < words.length - 4) {
       |      // Require at least 3 words at the end.
      0|      var buffer = StringBuffer();
      0|      buffer.write(words.first);
      0|      buffer.write(' ...');
      0|      for (; i < words.length; i++) {
      0|        buffer.write(' ');
      0|        buffer.write(words[i]);
       |      }
      0|      return buffer.toString();
       |    }
       |  }
       |
       |  // Otherwise truncate to return the trailing text, but attempt to start at
       |  // the beginning of a word.
      0|  var result = text.substring(text.length - maxLength + 4);
      0|  var firstSpace = result.indexOf(' ');
      0|  if (firstSpace > 0) {
      0|    result = result.substring(firstSpace);
       |  }
      0|  return '...$result';
       |}
       |
       |/// Returns a human-friendly representation of [duration].
      0|String niceDuration(Duration duration) {
      0|  var minutes = duration.inMinutes;
      0|  var seconds = duration.inSeconds % 60;
      0|  var decaseconds = (duration.inMilliseconds % 1000) ~/ 100;
       |
      0|  var buffer = StringBuffer();
      0|  if (minutes != 0) buffer.write('$minutes minutes');
       |
      0|  if (minutes == 0 || seconds != 0) {
      0|    if (minutes != 0) buffer.write(', ');
      0|    buffer.write(seconds);
      0|    if (decaseconds != 0) buffer.write('.$decaseconds');
      0|    buffer.write(' seconds');
       |  }
       |
      0|  return buffer.toString();
       |}
       |
       |/// Returns a single-subscription stream that emits the results of [operations]
       |/// in the order they complete.
       |///
       |/// If the subscription is canceled, any pending operations are canceled as
       |/// well.
      0|Stream<T> inCompletionOrder<T>(Iterable<CancelableOperation<T>> operations) {
      0|  var operationSet = operations.toSet();
      0|  var controller = StreamController<T>(
       |      sync: true,
      0|      onCancel: () {
      0|        return Future.wait(operationSet.map((operation) => operation.cancel()));
       |      });
       |
      0|  for (var operation in operationSet) {
      0|    operation.value
      0|        .then((value) => controller.add(value))
      0|        .catchError(controller.addError)
      0|        .whenComplete(() {
      0|      operationSet.remove(operation);
      0|      if (operationSet.isEmpty) controller.close();
       |    });
       |  }
       |
      0|  return controller.stream;
       |}
       |
       |/// Returns a random base64 string containing [bytes] bytes of data.
       |///
       |/// [seed] is passed to [math.Random].
      0|String randomBase64(int bytes, {int seed}) {
      0|  var random = math.Random(seed);
      0|  var data = Uint8List(bytes);
      0|  for (var i = 0; i < bytes; i++) {
      0|    data[i] = random.nextInt(256);
       |  }
      0|  return base64Encode(data);
       |}
       |
       |/// Throws an [ArgumentError] if [message] isn't recursively JSON-safe.
      0|void ensureJsonEncodable(Object message) {
       |  if (message == null ||
      0|      message is String ||
      0|      message is num ||
      0|      message is bool) {
       |    // JSON-encodable, hooray!
      0|  } else if (message is List) {
      0|    for (var element in message) {
      0|      ensureJsonEncodable(element);
       |    }
      0|  } else if (message is Map) {
      0|    message.forEach((key, value) {
      0|      if (key is! String) {
      0|        throw ArgumentError("$message can't be JSON-encoded.");
       |      }
       |
      0|      ensureJsonEncodable(value);
       |    });
       |  } else {
      0|    throw ArgumentError.value("$message can't be JSON-encoded.");
       |  }
       |}
       |
       |/// Indents [text], and adds a bullet at the beginning.
      0|String addBullet(String text) =>
      0|    prefixLines(text, '  ', first: '${glyph.bullet} ');
       |
       |/// Converts [strings] to a bulleted list.
      0|String bullet(Iterable<String> strings) => strings.map(addBullet).join('\n');
       |
       |/// Prepends each line in [text] with [prefix].
       |///
       |/// If [first] or [last] is passed, the first and last lines, respectively, are
       |/// prefixed with those instead. If [single] is passed, it's used if there's
       |/// only a single line; otherwise, [first], [last], or [prefix] is used, in that
       |/// order of precedence.
      0|String prefixLines(String text, String prefix,
       |    {String first, String last, String single}) {
       |  first ??= prefix;
       |  last ??= prefix;
       |  single ??= first ?? last ?? prefix;
       |
      0|  var lines = text.split('\n');
      0|  if (lines.length == 1) return '$single$text';
       |
      0|  var buffer = StringBuffer('$first${lines.first}\n');
       |
       |  // Write out all but the first and last lines with [prefix].
      0|  for (var line in lines.skip(1).take(lines.length - 2)) {
      0|    buffer.writeln('$prefix$line');
       |  }
      0|  buffer.write('$last${lines.last}');
      0|  return buffer.toString();
       |}
       |
       |/// Returns a pretty-printed representation of [value].
       |///
       |/// The matcher package doesn't expose its pretty-print function directly, but
       |/// we can use it through StringDescription.
      0|String prettyPrint(value) =>
      0|    StringDescription().addDescriptionOf(value).toString();
       |
       |/// Indicates to tools that [future] is intentionally not `await`-ed.
       |///
       |/// In an `async` context, it is normally expected that all [Future]s are
       |/// awaited, and that is the basis of the lint `unawaited_futures`. However,
       |/// there are times where one or more futures are intentionally not awaited.
       |/// This function may be used to ignore a particular future. It silences the
       |/// `unawaited_futures` lint.
      0|void unawaited(Future<void> future) {}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/engine.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:collection';
       |import 'dart:math';
       |
       |import 'package:async/async.dart' hide Result;
       |import 'package:collection/collection.dart';
       |import 'package:pedantic/pedantic.dart';
       |import 'package:pool/pool.dart';
       |import 'package:test_api/src/backend/group.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/invoker.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/live_test.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/live_test_controller.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/message.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/state.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/test.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/util/iterable_set.dart'; // ignore: implementation_imports
       |
       |import 'coverage_stub.dart' if (dart.library.io) 'coverage.dart';
       |import 'live_suite.dart';
       |import 'live_suite_controller.dart';
       |import 'load_suite.dart';
       |import 'runner_suite.dart';
       |
       |/// An [Engine] manages a run that encompasses multiple test suites.
       |///
       |/// Test suites are provided by passing them into [suiteSink]. Once all suites
       |/// have been provided, the user should close [suiteSink] to indicate this.
       |/// [run] won't terminate until [suiteSink] is closed. Suites will be run in the
       |/// order they're provided to [suiteSink]. Tests within those suites will
       |/// likewise be run in the order they're declared.
       |///
       |/// The current status of every test is visible via [liveTests]. [onTestStarted]
       |/// can also be used to be notified when a test is about to be run.
       |///
       |/// The engine has some special logic for [LoadSuite]s and the tests they
       |/// contain, referred to as "load tests". Load tests exist to provide visibility
       |/// into the process of loading test files, but as long as that process is
       |/// proceeding normally users usually don't care about it, so the engine only
       |/// surfaces running load tests (that is, includes them in [liveTests] and other
       |/// collections) under specific circumstances.
       |///
       |/// If only load tests are running, exactly one load test will be in [active]
       |/// and [liveTests]. If this test passes, it will be removed from both [active]
       |/// and [liveTests] and *will not* be added to [passed]. If at any point a load
       |/// test fails, it will be added to [failed] and [liveTests].
       |///
       |/// The test suite loaded by a load suite will be automatically be run by the
       |/// engine; it doesn't need to be added to [suiteSink] manually.
       |///
       |/// Load tests will always be emitted through [onTestStarted] so users can watch
       |/// their event streams once they start running.
       |class Engine {
       |  /// Whether [run] has been called yet.
       |  var _runCalled = false;
       |
       |  /// Whether [close] has been called.
       |  var _closed = false;
       |
       |  /// Whether [close] was called before all the tests finished running.
       |  ///
       |  /// This is `null` if close hasn't been called and the tests are still
       |  /// running, `true` if close was called before the tests finished running, and
       |  /// `false` if the tests finished running before close was called.
       |  bool _closedBeforeDone;
       |
       |  /// The coverage output directory.
       |  String _coverage;
       |
       |  /// A pool that limits the number of test suites running concurrently.
       |  final Pool _runPool;
       |
       |  /// A completer that will complete when this engine is unpaused.
       |  ///
       |  /// `null` if this engine is not paused.
       |  Completer _pauseCompleter;
       |
       |  /// A future that completes once this is unpaused.
       |  ///
       |  /// If this engine isn't paused, this future completes immediately.
      1|  Future get _onUnpaused =>
      2|      _pauseCompleter == null ? Future.value() : _pauseCompleter.future;
       |
       |  /// Whether all tests passed or were skipped.
       |  ///
       |  /// This fires once all tests have completed and [suiteSink] has been closed.
       |  /// This will be `null` if [close] was called before all the tests finished
       |  /// running.
      1|  Future<bool> get success async {
      7|    await Future.wait(<Future>[_group.future, _runPool.done], eagerError: true);
      1|    if (_closedBeforeDone) return null;
      3|    return liveTests.every((liveTest) =>
      3|        liveTest.state.result.isPassing &&
      3|        liveTest.state.status == Status.complete);
       |  }
       |
       |  /// A group of futures for each test suite.
       |  final _group = FutureGroup();
       |
       |  /// All of the engine's stream subscriptions.
       |  final _subscriptions = <StreamSubscription>{};
       |
       |  /// A sink used to pass [RunnerSuite]s in to the engine to run.
       |  ///
       |  /// Suites may be added as quickly as they're available; the Engine will only
       |  /// run as many as necessary at a time based on its concurrency settings.
       |  ///
       |  /// Suites added to the sink will be closed by the engine based on its
       |  /// internal logic.
      4|  Sink<RunnerSuite> get suiteSink => DelegatingSink(_suiteController.sink);
       |  final _suiteController = StreamController<RunnerSuite>();
       |
       |  /// All the [RunnerSuite]s added to [suiteSink] so far.
       |  ///
       |  /// Note that if a [LoadSuite] is added, this will only contain that suite,
       |  /// not the suite it loads.
      0|  Set<RunnerSuite> get addedSuites => UnmodifiableSetView(_addedSuites);
       |  final _addedSuites = <RunnerSuite>{};
       |
       |  /// A broadcast stream that emits each [RunnerSuite] as it's added to the
       |  /// engine via [suiteSink].
       |  ///
       |  /// Note that if a [LoadSuite] is added, this will only return that suite, not
       |  /// the suite it loads.
       |  ///
       |  /// This is guaranteed to fire after the suite is added to [addedSuites].
      0|  Stream<RunnerSuite> get onSuiteAdded => _onSuiteAddedController.stream;
       |  final _onSuiteAddedController = StreamController<RunnerSuite>.broadcast();
       |
       |  /// All the currently-known suites that have run or are running.
       |  ///
       |  /// These are [LiveSuite]s, representing the in-progress state of each suite
       |  /// as its component tests are being run.
       |  ///
       |  /// Note that unlike [addedSuites], for suites that are loaded using
       |  /// [LoadSuite]s, both the [LoadSuite] and the suite it loads will eventually
       |  /// be in this set.
      0|  Set<LiveSuite> get liveSuites => UnmodifiableSetView(_liveSuites);
       |  final _liveSuites = <LiveSuite>{};
       |
       |  /// A broadcast stream that emits each [LiveSuite] as it's loaded.
       |  ///
       |  /// Note that unlike [onSuiteAdded], for suites that are loaded using
       |  /// [LoadSuite]s, both the [LoadSuite] and the suite it loads will eventually
       |  /// be emitted by this stream.
      0|  Stream<LiveSuite> get onSuiteStarted => _onSuiteStartedController.stream;
       |  final _onSuiteStartedController = StreamController<LiveSuite>.broadcast();
       |
       |  /// All the currently-known tests that have run or are running.
       |  ///
       |  /// These are [LiveTest]s, representing the in-progress state of each test.
       |  /// Tests that have not yet begun running are marked [Status.pending]; tests
       |  /// that have finished are marked [Status.complete].
       |  ///
       |  /// This is guaranteed to contain the same tests as the union of [passed],
       |  /// [skipped], [failed], and [active].
       |  ///
       |  /// [LiveTest.run] must not be called on these tests.
      1|  Set<LiveTest> get liveTests =>
      7|      UnionSet.from([passed, skipped, failed, IterableSet(active)],
       |          disjoint: true);
       |
       |  /// A stream that emits each [LiveTest] as it's about to start running.
       |  ///
       |  /// This is guaranteed to fire before [LiveTest.onStateChange] first fires.
      3|  Stream<LiveTest> get onTestStarted => _onTestStartedGroup.stream;
       |  final _onTestStartedGroup = StreamGroup<LiveTest>.broadcast();
       |
       |  /// The set of tests that have completed and been marked as passing.
      3|  Set<LiveTest> get passed => _passedGroup.set;
       |  final _passedGroup = UnionSetController<LiveTest>(disjoint: true);
       |
       |  /// The set of tests that have completed and been marked as skipped.
      3|  Set<LiveTest> get skipped => _skippedGroup.set;
       |  final _skippedGroup = UnionSetController<LiveTest>(disjoint: true);
       |
       |  /// The set of tests that have completed and been marked as failing or error.
      3|  Set<LiveTest> get failed => _failedGroup.set;
       |  final _failedGroup = UnionSetController<LiveTest>(disjoint: true);
       |
       |  /// The tests that are still running, in the order they begain running.
      3|  List<LiveTest> get active => UnmodifiableListView(_active);
       |  final _active = QueueList<LiveTest>();
       |
       |  /// The set of tests that have been marked for restarting.
       |  ///
       |  /// This is always a subset of [active]. Once a test in here has finished
       |  /// running, it's run again.
       |  final _restarted = <LiveTest>{};
       |
       |  /// The tests from [LoadSuite]s that are still running, in the order they
       |  /// began running.
       |  ///
       |  /// This is separate from [active] because load tests aren't always surfaced.
       |  final _activeLoadTests = <LiveTest>{};
       |
       |  /// Whether this engine is idlethat is, not currently executing a test.
      0|  bool get isIdle => _group.isIdle;
       |
       |  /// A broadcast stream that fires an event whenever [isIdle] switches from
       |  /// `false` to `true`.
      0|  Stream get onIdle => _group.onIdle;
       |
       |  // TODO(nweiz): Use interface libraries to take a Configuration even when
       |  // dart:io is unavailable.
       |  /// Creates an [Engine] that will run all tests provided via [suiteSink].
       |  ///
       |  /// [concurrency] controls how many suites are loaded and ran at once, and
       |  /// defaults to 1.
      1|  Engine({int concurrency, String coverage})
      1|      : _runPool = Pool(concurrency ?? 1),
       |        _coverage = coverage {
      4|    _group.future.then((_) {
      2|      _onTestStartedGroup.close();
      2|      _onSuiteStartedController.close();
      1|      _closedBeforeDone ??= false;
      1|    }).catchError((_) {
       |      // Don't top-level errors. They'll be thrown via [success] anyway.
       |    });
       |  }
       |
       |  /// Creates an [Engine] that will run all tests in [suites].
       |  ///
       |  /// An engine constructed this way will automatically close its [suiteSink],
       |  /// meaning that no further suites may be provided.
       |  ///
       |  /// [concurrency] controls how many suites are run at once. If [runSkipped] is
       |  /// `true`, skipped tests will be run as though they weren't skipped.
      0|  factory Engine.withSuites(List<RunnerSuite> suites,
       |      {int concurrency, String coverage}) {
      0|    var engine = Engine(concurrency: concurrency, coverage: coverage);
      0|    for (var suite in suites) {
      0|      engine.suiteSink.add(suite);
       |    }
      0|    engine.suiteSink.close();
       |    return engine;
       |  }
       |
       |  /// Runs all tests in all suites defined by this engine.
       |  ///
       |  /// This returns `true` if all tests succeed, and `false` otherwise. It will
       |  /// only return once all tests have finished running and [suiteSink] has been
       |  /// closed.
      1|  Future<bool> run() {
      1|    if (_runCalled) {
      0|      throw StateError('Engine.run() may not be called more than once.');
       |    }
      1|    _runCalled = true;
       |
       |    StreamSubscription subscription;
      4|    subscription = _suiteController.stream.listen((suite) {
      2|      _addedSuites.add(suite);
      2|      _onSuiteAddedController.add(suite);
       |
      3|      _group.add(() async {
      3|        var resource = await _runPool.request();
       |        LiveSuiteController controller;
       |        try {
      1|          if (suite is LoadSuite) {
      0|            await _onUnpaused;
      0|            controller = await _addLoadSuite(suite);
       |            if (controller == null) return;
       |          } else {
      1|            controller = LiveSuiteController(suite);
       |          }
       |
      2|          _addLiveSuite(controller.liveSuite);
       |
      1|          if (_closed) return;
      6|          await _runGroup(controller, controller.liveSuite.suite.group, []);
      1|          controller.noMoreLiveTests();
      1|          if (_coverage != null) await writeCoverage(_coverage, controller);
       |        } finally {
      3|          resource.allowRelease(() => controller?.close());
       |        }
      1|      }());
      1|    }, onDone: () {
      2|      _subscriptions.remove(subscription);
      2|      _onSuiteAddedController.close();
      2|      _group.close();
      2|      _runPool.close();
       |    });
      2|    _subscriptions.add(subscription);
       |
      1|    return success;
       |  }
       |
       |  /// Runs all the entries in [group] in sequence.
       |  ///
       |  /// [suiteController] is the controller fo the suite that contains [group].
       |  /// [parents] is a list of groups that contain [group]. It may be modified,
       |  /// but it's guaranteed to be in its original state once this function has
       |  /// finished.
      1|  Future _runGroup(LiveSuiteController suiteController, Group group,
       |      List<Group> parents) async {
      1|    parents.add(group);
       |    try {
      3|      var suiteConfig = suiteController.liveSuite.suite.config;
      3|      var skipGroup = !suiteConfig.runSkipped && group.metadata.skip;
       |      var setUpAllSucceeded = true;
      1|      if (!skipGroup && group.setUpAll != null) {
      0|        var liveTest = group.setUpAll
      0|            .load(suiteController.liveSuite.suite, groups: parents);
      0|        await _runLiveTest(suiteController, liveTest, countSuccess: false);
      0|        setUpAllSucceeded = liveTest.state.result.isPassing;
       |      }
       |
      1|      if (!_closed && setUpAllSucceeded) {
       |        // shuffle the group entries
      2|        var entries = group.entries.toList();
      1|        if (suiteConfig.testRandomizeOrderingSeed != null &&
      0|            suiteConfig.testRandomizeOrderingSeed > 0) {
      0|          entries.shuffle(Random(suiteConfig.testRandomizeOrderingSeed));
       |        }
       |
      2|        for (var entry in entries) {
      1|          if (_closed) return;
       |
      1|          if (entry is Group) {
      2|            await _runGroup(suiteController, entry, parents);
      3|          } else if (!suiteConfig.runSkipped && entry.metadata.skip) {
      0|            await _runSkippedTest(suiteController, entry as Test, parents);
       |          } else {
       |            var test = entry as Test;
      2|            await _runLiveTest(suiteController,
      3|                test.load(suiteController.liveSuite.suite, groups: parents));
       |          }
       |        }
       |      }
       |
       |      // Even if we're closed or setUpAll failed, we want to run all the
       |      // teardowns to ensure that any state is properly cleaned up.
      1|      if (!skipGroup && group.tearDownAll != null) {
      0|        var liveTest = group.tearDownAll
      0|            .load(suiteController.liveSuite.suite, groups: parents);
      0|        await _runLiveTest(suiteController, liveTest, countSuccess: false);
      0|        if (_closed) await liveTest.close();
       |      }
       |    } finally {
      1|      parents.remove(group);
       |    }
       |  }
       |
       |  /// Runs [liveTest] using [suiteController].
       |  ///
       |  /// If [countSuccess] is `true` (the default), the test is put into [passed]
       |  /// if it succeeds. Otherwise, it's removed from [liveTests] entirely.
      1|  Future _runLiveTest(LiveSuiteController suiteController, LiveTest liveTest,
       |      {bool countSuccess = true}) async {
      2|    await _onUnpaused;
      2|    _active.add(liveTest);
       |
       |    // If there were no active non-load tests, the current active test would
       |    // have been a load test. In that case, remove it, since now we have a
       |    // non-load test to add.
      4|    if (_active.first.suite is LoadSuite) _active.removeFirst();
       |
       |    StreamSubscription subscription;
      3|    subscription = liveTest.onStateChange.listen((state) {
      2|      if (state.status != Status.complete) return;
      2|      _active.remove(liveTest);
       |
       |      // If we're out of non-load tests, surface a load test.
      4|      if (_active.isEmpty && _activeLoadTests.isNotEmpty) {
      0|        _active.add(_activeLoadTests.first);
       |      }
      0|    }, onDone: () {
      0|      _subscriptions.remove(subscription);
       |    });
      2|    _subscriptions.add(subscription);
       |
      1|    suiteController.reportLiveTest(liveTest, countSuccess: countSuccess);
       |
       |    // Schedule a microtask to ensure that [onTestStarted] fires before the
       |    // first [LiveTest.onStateChange] event.
      3|    await Future.microtask(liveTest.run);
       |
       |    // Once the test finishes, use [new Future] to do a coarse-grained event
       |    // loop pump to avoid starving non-microtask events.
      3|    await Future(() {});
       |
      2|    if (!_restarted.contains(liveTest)) return;
      0|    await _runLiveTest(suiteController, liveTest.copy(),
       |        countSuccess: countSuccess);
      0|    _restarted.remove(liveTest);
       |  }
       |
       |  /// Runs a dummy [LiveTest] for a test marked as "skip".
       |  ///
       |  /// [suiteController] is the controller for the suite that contains [test].
       |  /// [parents] is a list of groups that contain [test].
      0|  Future _runSkippedTest(LiveSuiteController suiteController, Test test,
       |      List<Group> parents) async {
      0|    await _onUnpaused;
      0|    var skipped = LocalTest(test.name, test.metadata, () {}, trace: test.trace);
       |
       |    LiveTestController controller;
       |    controller =
      0|        LiveTestController(suiteController.liveSuite.suite, skipped, () {
      0|      controller.setState(const State(Status.running, Result.success));
      0|      controller.setState(const State(Status.running, Result.skipped));
       |
      0|      if (skipped.metadata.skipReason != null) {
       |        controller
      0|            .message(Message.skip('Skip: ${skipped.metadata.skipReason}'));
       |      }
       |
      0|      controller.setState(const State(Status.complete, Result.skipped));
      0|      controller.completer.complete();
      0|    }, () {}, groups: parents);
       |
      0|    return await _runLiveTest(suiteController, controller);
       |  }
       |
       |  /// Closes [liveTest] and tells the engine to re-run it once it's done
       |  /// running.
       |  ///
       |  /// Returns the same future as [LiveTest.close].
      0|  Future restartTest(LiveTest liveTest) async {
      0|    if (_activeLoadTests.contains(liveTest)) {
      0|      throw ArgumentError("Can't restart a load test.");
       |    }
       |
      0|    if (!_active.contains(liveTest)) {
      0|      throw StateError("Can't restart inactive test "
      0|          '\"${liveTest.test.name}\".');
       |    }
       |
      0|    _restarted.add(liveTest);
      0|    _active.remove(liveTest);
      0|    await liveTest.close();
       |  }
       |
       |  /// Runs [suite] and returns the [LiveSuiteController] for the suite it loads.
       |  ///
       |  /// Returns `null` if the suite fails to load.
      0|  Future<LiveSuiteController> _addLoadSuite(LoadSuite suite) async {
      0|    var controller = LiveSuiteController(suite);
      0|    _addLiveSuite(controller.liveSuite);
       |
      0|    var liveTest = suite.test.load(suite);
      0|    _activeLoadTests.add(liveTest);
       |
       |    // Only surface the load test if there are no other tests currently running.
      0|    if (_active.isEmpty) _active.add(liveTest);
       |
       |    StreamSubscription subscription;
      0|    subscription = liveTest.onStateChange.listen((state) {
      0|      if (state.status != Status.complete) return;
      0|      _activeLoadTests.remove(liveTest);
       |
       |      // Only one load test will be active at any given time, and it will always
       |      // be the only active test. Remove it and, if possible, surface another
       |      // load test.
      0|      if (_active.isNotEmpty && _active.first.suite == suite) {
      0|        _active.remove(liveTest);
      0|        if (_activeLoadTests.isNotEmpty) _active.add(_activeLoadTests.last);
       |      }
      0|    }, onDone: () {
      0|      _subscriptions.remove(subscription);
       |    });
      0|    _subscriptions.add(subscription);
       |
      0|    controller.reportLiveTest(liveTest, countSuccess: false);
      0|    controller.noMoreLiveTests();
       |
       |    // Schedule a microtask to ensure that [onTestStarted] fires before the
       |    // first [LiveTest.onStateChange] event.
      0|    await Future.microtask(liveTest.run);
       |
      0|    var innerSuite = await suite.suite;
       |    if (innerSuite == null) return null;
       |
      0|    var innerController = LiveSuiteController(innerSuite);
      0|    unawaited(innerController.liveSuite.onClose.whenComplete(() {
       |      // When the main suite is closed, close the load suite and its test as
       |      // well. This doesn't release any resources, but it does close streams
       |      // which indicates that the load test won't experience an error in the
       |      // future.
      0|      liveTest.close();
      0|      controller.close();
       |    }));
       |
       |    return innerController;
       |  }
       |
       |  /// Add [liveSuite] and the information it exposes to the engine's
       |  /// informational streams and collections.
      1|  void _addLiveSuite(LiveSuite liveSuite) {
      2|    _liveSuites.add(liveSuite);
      2|    _onSuiteStartedController.add(liveSuite);
       |
      3|    _onTestStartedGroup.add(liveSuite.onTestStarted);
      3|    _passedGroup.add(liveSuite.passed);
      3|    _skippedGroup.add(liveSuite.skipped);
      3|    _failedGroup.add(liveSuite.failed);
       |  }
       |
       |  /// Pauses the engine.
       |  ///
       |  /// This pauses all streams and keeps any new suites from being loaded or
       |  /// tests from being run until [resume] is called.
       |  ///
       |  /// This does nothing if the engine is already paused. Pauses are *not*
       |  /// cumulative.
      0|  void pause() {
      0|    if (_pauseCompleter != null) return;
      0|    _pauseCompleter = Completer();
      0|    for (var subscription in _subscriptions) {
      0|      subscription.pause();
       |    }
       |  }
       |
      0|  void resume() {
      0|    if (_pauseCompleter == null) return;
      0|    _pauseCompleter.complete();
      0|    _pauseCompleter = null;
      0|    for (var subscription in _subscriptions) {
      0|      subscription.resume();
       |    }
       |  }
       |
       |  /// Signals that the caller is done paying attention to test results and the
       |  /// engine should release any resources it has allocated.
       |  ///
       |  /// Any actively-running tests are also closed. VM tests are allowed to finish
       |  /// running so that any modifications they've made to the filesystem can be
       |  /// cleaned up.
       |  ///
       |  /// **Note that closing the engine is not the same as closing [suiteSink].**
       |  /// Closing [suiteSink] indicates that no more input will be provided, closing
       |  /// the engine indicates that no more output should be emitted.
      0|  Future close() async {
      0|    _closed = true;
      0|    if (_closedBeforeDone != null) _closedBeforeDone = true;
      0|    await _suiteController.close();
      0|    await _onSuiteAddedController.close();
       |
       |    // Close the running tests first so that we're sure to wait for them to
       |    // finish before we close their suites and cause them to become unloaded.
      0|    var allLiveTests = liveTests.toSet()..addAll(_activeLoadTests);
      0|    var futures = allLiveTests.map((liveTest) => liveTest.close()).toList();
       |
       |    // Closing the run pool will close the test suites as soon as their tests
       |    // are done. For browser suites this is effectively immediate since their
       |    // tests shut down as soon as they're closed, but for VM suites we may need
       |    // to wait for tearDowns or tearDownAlls to run.
      0|    futures.add(_runPool.close());
      0|    await Future.wait(futures, eagerError: true);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/plugin/environment.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../environment.dart';
       |
       |/// The default environment for platform plugins.
       |class PluginEnvironment implements Environment {
       |  @override
       |  final supportsDebugging = false;
      0|  @override
      0|  Stream get onRestart => StreamController.broadcast().stream;
       |
      0|  const PluginEnvironment();
       |
      0|  @override
       |  Uri get observatoryUrl => null;
       |
      0|  @override
       |  Uri get remoteDebuggerUrl => null;
       |
      0|  @override
      0|  CancelableOperation displayPause() => throw UnsupportedError(
       |      'PluginEnvironment.displayPause is not supported.');
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/reporter/expanded.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:test_api/src/backend/live_test.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/message.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/state.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/utils.dart'; // ignore: implementation_imports
       |
       |import '../engine.dart';
       |import '../load_exception.dart';
       |import '../load_suite.dart';
       |import '../reporter.dart';
       |
       |/// A reporter that prints each test on its own line.
       |///
       |/// This is currently used in place of [CompactReporter] by `lib/test.dart`,
       |/// which can't transitively import `dart:io` but still needs access to a runner
       |/// so that test files can be run directly. This means that until issue 6943 is
       |/// fixed, this must not import `dart:io`.
       |class ExpandedReporter implements Reporter {
       |  /// Whether the reporter should emit terminal color escapes.
       |  final bool _color;
       |
       |  /// The terminal escape for green text, or the empty string if this is Windows
       |  /// or not outputting to a terminal.
       |  final String _green;
       |
       |  /// The terminal escape for red text, or the empty string if this is Windows
       |  /// or not outputting to a terminal.
       |  final String _red;
       |
       |  /// The terminal escape for yellow text, or the empty string if this is
       |  /// Windows or not outputting to a terminal.
       |  final String _yellow;
       |
       |  /// The terminal escape for gray text, or the empty string if this is
       |  /// Windows or not outputting to a terminal.
       |  final String _gray;
       |
       |  /// The terminal escape for bold text, or the empty string if this is
       |  /// Windows or not outputting to a terminal.
       |  final String _bold;
       |
       |  /// The terminal escape for removing test coloring, or the empty string if
       |  /// this is Windows or not outputting to a terminal.
       |  final String _noColor;
       |
       |  /// The engine used to run the tests.
       |  final Engine _engine;
       |
       |  /// Whether the path to each test's suite should be printed.
       |  final bool _printPath;
       |
       |  /// Whether the platform each test is running on should be printed.
       |  final bool _printPlatform;
       |
       |  /// A stopwatch that tracks the duration of the full run.
       |  final _stopwatch = Stopwatch();
       |
       |  /// The size of `_engine.passed` last time a progress notification was
       |  /// printed.
       |  int _lastProgressPassed;
       |
       |  /// The size of `_engine.skipped` last time a progress notification was
       |  /// printed.
       |  int _lastProgressSkipped;
       |
       |  /// The size of `_engine.failed` last time a progress notification was
       |  /// printed.
       |  int _lastProgressFailed;
       |
       |  /// The message printed for the last progress notification.
       |  String _lastProgressMessage;
       |
       |  /// The suffix added to the last progress notification.
       |  String _lastProgressSuffix;
       |
       |  /// Whether the reporter is paused.
       |  var _paused = false;
       |
       |  /// The set of all subscriptions to various streams.
       |  final _subscriptions = <StreamSubscription>{};
       |
       |  final StringSink _sink;
       |
       |  // TODO(nweiz): Get configuration from [Configuration.current] once we have
       |  // cross-platform imports.
       |  /// Watches the tests run by [engine] and prints their results to the
       |  /// terminal.
       |  ///
       |  /// If [color] is `true`, this will use terminal colors; if it's `false`, it
       |  /// won't. If [printPath] is `true`, this will print the path name as part of
       |  /// the test description. Likewise, if [printPlatform] is `true`, this will
       |  /// print the platform as part of the test description.
      1|  static ExpandedReporter watch(Engine engine, StringSink sink,
       |      {bool color = true, bool printPath = true, bool printPlatform = true}) {
      1|    return ExpandedReporter._(engine, sink,
       |        color: color, printPath: printPath, printPlatform: printPlatform);
       |  }
       |
      1|  ExpandedReporter._(this._engine, this._sink,
       |      {bool color = true, bool printPath = true, bool printPlatform = true})
       |      : _printPath = printPath,
       |        _printPlatform = printPlatform,
       |        _color = color,
       |        _green = color ? '\u001b[32m' : '',
       |        _red = color ? '\u001b[31m' : '',
       |        _yellow = color ? '\u001b[33m' : '',
       |        _gray = color ? '\u001b[1;30m' : '',
       |        _bold = color ? '\u001b[1m' : '',
       |        _noColor = color ? '\u001b[0m' : '' {
      6|    _subscriptions.add(_engine.onTestStarted.listen(_onTestStarted));
       |
       |    /// Convert the future to a stream so that the subscription can be paused or
       |    /// canceled.
      7|    _subscriptions.add(_engine.success.asStream().listen(_onDone));
       |  }
       |
      0|  @override
       |  void pause() {
      0|    if (_paused) return;
      0|    _paused = true;
       |
      0|    _stopwatch.stop();
       |
      0|    for (var subscription in _subscriptions) {
      0|      subscription.pause();
       |    }
       |  }
       |
      0|  @override
       |  void resume() {
      0|    if (!_paused) return;
      0|    _stopwatch.start();
       |
      0|    for (var subscription in _subscriptions) {
      0|      subscription.resume();
       |    }
       |  }
       |
      0|  @override
       |  void cancel() {
      0|    for (var subscription in _subscriptions) {
      0|      subscription.cancel();
       |    }
      0|    _subscriptions.clear();
       |  }
       |
       |  /// A callback called when the engine begins running [liveTest].
      1|  void _onTestStarted(LiveTest liveTest) {
      2|    if (liveTest.suite is! LoadSuite) {
      4|      if (!_stopwatch.isRunning) _stopwatch.start();
       |
       |      // If this is the first non-load test to start, print a progress line so
       |      // the user knows what's running.
      6|      if (_engine.active.length == 1) _progressLine(_description(liveTest));
       |
       |      // The engine surfaces load tests when there are no other tests running,
       |      // but because the expanded reporter's output is always visible, we don't
       |      // emit information about them unless they fail.
      3|      _subscriptions.add(liveTest.onStateChange
      3|          .listen((state) => _onStateChange(liveTest, state)));
      0|    } else if (_engine.active.length == 1 &&
      0|        _engine.active.first == liveTest &&
      0|        liveTest.test.name.startsWith('compiling ')) {
       |      // Print a progress line for load tests that come from compiling JS, since
       |      // that takes a long time.
      0|      _progressLine(_description(liveTest));
       |    }
       |
      3|    _subscriptions.add(liveTest.onError
      1|        .listen((error) => _onError(liveTest, error.error, error.stackTrace)));
       |
      4|    _subscriptions.add(liveTest.onMessage.listen((message) {
      0|      _progressLine(_description(liveTest));
      0|      var text = message.text;
      0|      if (message.type == MessageType.skip) text = '  $_yellow$text$_noColor';
      0|      _sink.writeln(text);
       |    }));
       |  }
       |
       |  /// A callback called when [liveTest]'s state becomes [state].
      1|  void _onStateChange(LiveTest liveTest, State state) {
      2|    if (state.status != Status.complete) return;
       |
       |    // If any tests are running, display the name of the oldest active
       |    // test.
      3|    if (_engine.active.isNotEmpty) {
      0|      _progressLine(_description(_engine.active.first));
       |    }
       |  }
       |
       |  /// A callback called when [liveTest] throws [error].
      0|  void _onError(LiveTest liveTest, error, StackTrace stackTrace) {
      0|    if (liveTest.state.status != Status.complete) return;
       |
      0|    _progressLine(_description(liveTest), suffix: ' $_bold$_red[E]$_noColor');
       |
      0|    if (error is! LoadException) {
      0|      _sink..writeln(indent('$error'))..writeln(indent('$stackTrace'));
       |      return;
       |    }
       |
       |    // TODO - what type is this?
      0|    _sink.writeln(indent((error as dynamic).toString(color: _color) as String));
       |
       |    // Only print stack traces for load errors that come from the user's code.
      0|    if (error.innerError is! FormatException && error.innerError is! String) {
      0|      _sink.writeln(indent('$stackTrace'));
       |    }
       |  }
       |
       |  /// A callback called when the engine is finished running tests.
       |  ///
       |  /// [success] will be `true` if all tests passed, `false` if some tests
       |  /// failed, and `null` if the engine was closed prematurely.
      1|  void _onDone(bool success) {
       |    // A null success value indicates that the engine was closed before the
       |    // tests finished running, probably because of a signal from the user, in
       |    // which case we shouldn't print summary information.
       |    if (success == null) return;
       |
      3|    if (_engine.liveTests.isEmpty) {
      0|      _sink.writeln('No tests ran.');
       |    } else if (!success) {
      0|      for (var liveTest in _engine.active) {
      0|        _progressLine(_description(liveTest),
      0|            suffix: ' - did not complete $_bold$_red[E]$_noColor');
       |      }
      0|      _progressLine('Some tests failed.', color: _red);
      3|    } else if (_engine.passed.isEmpty) {
      0|      _progressLine('All tests skipped.');
       |    } else {
      1|      _progressLine('All tests passed!');
       |    }
       |  }
       |
       |  /// Prints a line representing the current state of the tests.
       |  ///
       |  /// [message] goes after the progress report. If [color] is passed, it's used
       |  /// as the color for [message]. If [suffix] is passed, it's added to the end
       |  /// of [message].
      1|  void _progressLine(String message, {String color, String suffix}) {
       |    // Print nothing if nothing has changed since the last progress line.
      5|    if (_engine.passed.length == _lastProgressPassed &&
      0|        _engine.skipped.length == _lastProgressSkipped &&
      0|        _engine.failed.length == _lastProgressFailed &&
      0|        message == _lastProgressMessage &&
       |        // Don't re-print just because a suffix was removed.
      0|        (suffix == null || suffix == _lastProgressSuffix)) {
       |      return;
       |    }
       |
      4|    _lastProgressPassed = _engine.passed.length;
      4|    _lastProgressSkipped = _engine.skipped.length;
      4|    _lastProgressFailed = _engine.failed.length;
      1|    _lastProgressMessage = message;
      1|    _lastProgressSuffix = suffix;
       |
      0|    if (suffix != null) message += suffix;
       |    color ??= '';
      2|    var duration = _stopwatch.elapsed;
      1|    var buffer = StringBuffer();
       |
       |    // \r moves back to the beginning of the current line.
      3|    buffer.write('${_timeString(duration)} ');
      2|    buffer.write(_green);
      1|    buffer.write('+');
      4|    buffer.write(_engine.passed.length);
      2|    buffer.write(_noColor);
       |
      3|    if (_engine.skipped.isNotEmpty) {
      0|      buffer.write(_yellow);
      0|      buffer.write(' ~');
      0|      buffer.write(_engine.skipped.length);
      0|      buffer.write(_noColor);
       |    }
       |
      3|    if (_engine.failed.isNotEmpty) {
      0|      buffer.write(_red);
      0|      buffer.write(' -');
      0|      buffer.write(_engine.failed.length);
      0|      buffer.write(_noColor);
       |    }
       |
      1|    buffer.write(': ');
      1|    buffer.write(color);
      1|    buffer.write(message);
      2|    buffer.write(_noColor);
       |
      3|    _sink.writeln(buffer.toString());
       |  }
       |
       |  /// Returns a representation of [duration] as `MM:SS`.
      1|  String _timeString(Duration duration) {
      4|    return "${duration.inMinutes.toString().padLeft(2, '0')}:"
      4|        "${(duration.inSeconds % 60).toString().padLeft(2, '0')}";
       |  }
       |
       |  /// Returns a description of [liveTest].
       |  ///
       |  /// This differs from the test's own description in that it may also include
       |  /// the suite's name.
      1|  String _description(LiveTest liveTest) {
      2|    var name = liveTest.test.name;
       |
      1|    if (_printPath &&
      0|        liveTest.suite is! LoadSuite &&
      0|        liveTest.suite.path != null) {
      0|      name = '${liveTest.suite.path}: $name';
       |    }
       |
      1|    if (_printPlatform) {
      0|      name = '[${liveTest.suite.platform.runtime.name}] $name';
       |    }
       |
      2|    if (liveTest.suite is LoadSuite) name = '$_bold$_gray$name$_noColor';
       |
       |    return name;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/runner_suite.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |import 'package:stream_channel/stream_channel.dart';
       |import 'package:test_api/src/backend/group.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/suite.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/suite_platform.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/test.dart'; // ignore: implementation_imports
       |
       |import 'environment.dart';
       |import 'suite.dart';
       |
       |/// A suite produced and consumed by the test runner that has runner-specific
       |/// logic and lifecycle management.
       |///
       |/// This is separated from [Suite] because the backend library (which will
       |/// eventually become its own package) is primarily for test code itself to use,
       |/// for which the [RunnerSuite] APIs don't make sense.
       |///
       |/// A [RunnerSuite] can be produced and controlled using a
       |/// [RunnerSuiteController].
       |class RunnerSuite extends Suite {
       |  final RunnerSuiteController _controller;
       |
       |  /// The environment in which this suite runs.
      0|  Environment get environment => _controller._environment;
       |
       |  /// The configuration for this suite.
      3|  SuiteConfiguration get config => _controller._config;
       |
       |  /// Whether the suite is paused for debugging.
       |  ///
       |  /// When using a dev inspector, this may also mean that the entire browser is
       |  /// paused.
      0|  bool get isDebugging => _controller._isDebugging;
       |
       |  /// A broadcast stream that emits an event whenever the suite is paused for
       |  /// debugging or resumed afterwards.
       |  ///
       |  /// The event is `true` when debugging starts and `false` when it ends.
      0|  Stream<bool> get onDebugging => _controller._onDebuggingController.stream;
       |
       |  /// Returns a channel that communicates with the remote suite.
       |  ///
       |  /// This connects to a channel created by code in the test worker calling
       |  /// `suiteChannel()` from `remote_platform_helpers.dart` with the same name.
       |  /// It can be used used to send and receive any JSON-serializable object.
      0|  StreamChannel channel(String name) => _controller.channel(name);
       |
       |  /// A shortcut constructor for creating a [RunnerSuite] that never goes into
       |  /// debugging mode and doesn't support suite channels.
      1|  factory RunnerSuite(Environment environment, SuiteConfiguration config,
       |      Group group, SuitePlatform platform,
       |      {String path, Function() onClose}) {
       |    var controller =
      1|        RunnerSuiteController._local(environment, config, onClose: onClose);
      1|    var suite = RunnerSuite._(controller, group, path, platform);
      2|    controller._suite = Future.value(suite);
       |    return suite;
       |  }
       |
      1|  RunnerSuite._(
       |      this._controller, Group group, String path, SuitePlatform platform)
      1|      : super(group, platform, path: path);
       |
      0|  @override
       |  RunnerSuite filter(bool Function(Test) callback) {
      0|    var filtered = group.filter(callback);
      0|    filtered ??= Group.root([], metadata: metadata);
      0|    return RunnerSuite._(_controller, filtered, path, platform);
       |  }
       |
       |  /// Closes the suite and releases any resources associated with it.
      3|  Future close() => _controller._close();
       |
       |  /// Collects a hit-map containing merged coverage.
       |  ///
       |  /// Result is suitable for input to the coverage formatters provided by
       |  /// `package:coverage`.
      0|  Future<Map<String, dynamic>> gatherCoverage() async =>
      0|      (await _controller._gatherCoverage?.call()) ?? {};
       |}
       |
       |/// A class that exposes and controls a [RunnerSuite].
       |class RunnerSuiteController {
       |  /// The suite controlled by this controller.
      0|  Future<RunnerSuite> get suite => _suite;
       |  Future<RunnerSuite> _suite;
       |
       |  /// The backing value for [suite.environment].
       |  final Environment _environment;
       |
       |  /// The configuration for this suite.
       |  final SuiteConfiguration _config;
       |
       |  /// A channel that communicates with the remote suite.
       |  final MultiChannel _suiteChannel;
       |
       |  /// The function to call when the suite is closed.
       |  final Function() _onClose;
       |
       |  /// The backing value for [suite.isDebugging].
       |  bool _isDebugging = false;
       |
       |  /// The controller for [suite.onDebugging].
       |  final _onDebuggingController = StreamController<bool>.broadcast();
       |
       |  /// The channel names that have already been used.
       |  final _channelNames = <String>{};
       |
       |  /// Collects a hit-map containing merged coverage.
       |  final Future<Map<String, dynamic>> Function() _gatherCoverage;
       |
      0|  RunnerSuiteController(this._environment, this._config, this._suiteChannel,
       |      Future<Group> groupFuture, SuitePlatform platform,
       |      {String path,
       |      Function() onClose,
       |      Future<Map<String, dynamic>> Function() gatherCoverage})
       |      : _onClose = onClose,
       |        _gatherCoverage = gatherCoverage {
      0|    _suite =
      0|        groupFuture.then((group) => RunnerSuite._(this, group, path, platform));
       |  }
       |
       |  /// Used by [new RunnerSuite] to create a runner suite that's not loaded from
       |  /// an external source.
      1|  RunnerSuiteController._local(this._environment, this._config,
       |      {Function() onClose,
       |      Future<Map<String, dynamic>> Function() gatherCoverage})
       |      : _suiteChannel = null,
       |        _onClose = onClose,
       |        _gatherCoverage = gatherCoverage;
       |
       |  /// Sets whether the suite is paused for debugging.
       |  ///
       |  /// If this is different than [suite.isDebugging], this will automatically
       |  /// send out an event along [suite.onDebugging].
      0|  void setDebugging(bool debugging) {
      0|    if (debugging == _isDebugging) return;
      0|    _isDebugging = debugging;
      0|    _onDebuggingController.add(debugging);
       |  }
       |
       |  /// Returns a channel that communicates with the remote suite.
       |  ///
       |  /// This connects to a channel created by code in the test worker calling
       |  /// `suiteChannel()` from `remote_platform_helpers.dart` with the same name.
       |  /// It can be used used to send and receive any JSON-serializable object.
       |  ///
       |  /// This is exposed on the [RunnerSuiteController] so that runner plugins can
       |  /// communicate with the workers they spawn before the associated [suite] is
       |  /// fully loaded.
      0|  StreamChannel channel(String name) {
      0|    if (!_channelNames.add(name)) {
      0|      throw StateError('Duplicate RunnerSuite.channel() connection "$name".');
       |    }
       |
      0|    var channel = _suiteChannel.virtualChannel();
      0|    _suiteChannel.sink
      0|        .add({'type': 'suiteChannel', 'name': name, 'id': channel.id});
       |    return channel;
       |  }
       |
       |  /// The backing function for [suite.close].
      4|  Future _close() => _closeMemo.runOnce(() async {
      3|        await _onDebuggingController.close();
      1|        if (_onClose != null) await _onClose();
       |      });
       |  final _closeMemo = AsyncMemoizer();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/suite.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:boolean_selector/boolean_selector.dart';
       |import 'package:collection/collection.dart';
       |import 'package:source_span/source_span.dart';
       |
       |import 'package:test_api/src/backend/metadata.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/platform_selector.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/suite_platform.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/runtime.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/frontend/timeout.dart'; // ignore: implementation_imports
       |
       |import 'runtime_selection.dart';
       |
       |/// Suite-level configuration.
       |///
       |/// This tracks configuration that can differ from suite to suite.
       |class SuiteConfiguration {
       |  /// Empty configuration with only default values.
       |  ///
       |  /// Using this is slightly more efficient than manually constructing a new
       |  /// configuration with no arguments.
      3|  static final empty = SuiteConfiguration._();
       |
       |  /// Whether JavaScript stack traces should be left as-is or converted to
       |  /// Dart-like traces.
      0|  bool get jsTrace => _jsTrace ?? false;
       |  final bool _jsTrace;
       |
       |  /// Whether skipped tests should be run.
      2|  bool get runSkipped => _runSkipped ?? false;
       |  final bool _runSkipped;
       |
       |  /// The path to a mirror of this package containing HTML that points to
       |  /// precompiled JS.
       |  ///
       |  /// This is used by the internal Google test runner so that test compilation
       |  /// can more effectively make use of Google's build tools.
       |  final String precompiledPath;
       |
       |  /// Additional arguments to pass to dart2js.
       |  ///
       |  /// Note that this if multiple suites run the same JavaScript on different
       |  /// runtimes, and they have different [dart2jsArgs], only one (undefined)
       |  /// suite's arguments will be used.
       |  final List<String> dart2jsArgs;
       |
       |  /// The patterns to match against test names to decide which to run, or `null`
       |  /// if all tests should be run.
       |  ///
       |  /// All patterns must match in order for a test to be run.
       |  final Set<Pattern> patterns;
       |
       |  /// The set of runtimes on which to run tests.
      0|  List<String> get runtimes => _runtimes == null
       |      ? const ['vm']
      0|      : List.unmodifiable(_runtimes.map((runtime) => runtime.name));
       |  final List<RuntimeSelection> _runtimes;
       |
       |  /// Only run tests whose tags match this selector.
       |  ///
       |  /// When [merge]d, this is intersected with the other configuration's included
       |  /// tags.
       |  final BooleanSelector includeTags;
       |
       |  /// Do not run tests whose tags match this selector.
       |  ///
       |  /// When [merge]d, this is unioned with the other configuration's
       |  /// excluded tags.
       |  final BooleanSelector excludeTags;
       |
       |  /// Configuration for particular tags.
       |  ///
       |  /// The keys are tag selectors, and the values are configurations for tests
       |  /// whose tags match those selectors.
       |  final Map<BooleanSelector, SuiteConfiguration> tags;
       |
       |  /// Configuration for particular platforms.
       |  ///
       |  /// The keys are platform selectors, and the values are configurations for
       |  /// those platforms. These configuration should only contain test-level
       |  /// configuration fields, but that isn't enforced.
       |  final Map<PlatformSelector, SuiteConfiguration> onPlatform;
       |
       |  /// The seed with which to shuffle the test order.
       |  /// Default value is null if not provided and will not change the test order.
       |  /// The same seed will shuffle the tests in the same way every time.
       |  final int testRandomizeOrderingSeed;
       |
       |  /// The global test metadata derived from this configuration.
      0|  Metadata get metadata {
      0|    if (tags.isEmpty && onPlatform.isEmpty) return _metadata;
      0|    return _metadata.change(
      0|        forTag: tags.map((key, config) => MapEntry(key, config.metadata)),
       |        onPlatform:
      0|            onPlatform.map((key, config) => MapEntry(key, config.metadata)));
       |  }
       |
       |  final Metadata _metadata;
       |
       |  /// The set of tags that have been declared in any way in this configuration.
      0|  Set<String> get knownTags {
      0|    if (_knownTags != null) return _knownTags;
       |
      0|    var known = includeTags.variables.toSet()
      0|      ..addAll(excludeTags.variables)
      0|      ..addAll(_metadata.tags);
       |
      0|    for (var selector in tags.keys) {
      0|      known.addAll(selector.variables);
       |    }
       |
      0|    for (var configuration in _children) {
      0|      known.addAll(configuration.knownTags);
       |    }
       |
      0|    _knownTags = UnmodifiableSetView(known);
      0|    return _knownTags;
       |  }
       |
       |  Set<String> _knownTags;
       |
       |  /// All child configurations that may be selected under various circumstances.
       |  Iterable<SuiteConfiguration> get _children sync* {
       |    yield* tags.values;
       |    yield* onPlatform.values;
       |  }
       |
      0|  factory SuiteConfiguration(
       |      {bool jsTrace,
       |      bool runSkipped,
       |      Iterable<String> dart2jsArgs,
       |      String precompiledPath,
       |      Iterable<Pattern> patterns,
       |      Iterable<RuntimeSelection> runtimes,
       |      BooleanSelector includeTags,
       |      BooleanSelector excludeTags,
       |      Map<BooleanSelector, SuiteConfiguration> tags,
       |      Map<PlatformSelector, SuiteConfiguration> onPlatform,
       |      int testRandomizeOrderingSeed,
       |
       |      // Test-level configuration
       |      Timeout timeout,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      bool skip,
       |      int retry,
       |      String skipReason,
       |      PlatformSelector testOn,
       |      Iterable<String> addTags}) {
      0|    var config = SuiteConfiguration._(
       |        jsTrace: jsTrace,
       |        runSkipped: runSkipped,
       |        dart2jsArgs: dart2jsArgs,
       |        precompiledPath: precompiledPath,
       |        patterns: patterns,
       |        runtimes: runtimes,
       |        includeTags: includeTags,
       |        excludeTags: excludeTags,
       |        tags: tags,
       |        onPlatform: onPlatform,
       |        testRandomizeOrderingSeed: testRandomizeOrderingSeed,
      0|        metadata: Metadata(
       |            timeout: timeout,
       |            verboseTrace: verboseTrace,
       |            chainStackTraces: chainStackTraces,
       |            skip: skip,
       |            retry: retry,
       |            skipReason: skipReason,
       |            testOn: testOn,
       |            tags: addTags));
      0|    return config._resolveTags();
       |  }
       |
       |  /// Creates new SuiteConfiguration.
       |  ///
       |  /// Unlike [new SuiteConfiguration], this assumes [tags] is already
       |  /// resolved.
      1|  SuiteConfiguration._(
       |      {bool jsTrace,
       |      bool runSkipped,
       |      Iterable<String> dart2jsArgs,
       |      this.precompiledPath,
       |      Iterable<Pattern> patterns,
       |      Iterable<RuntimeSelection> runtimes,
       |      BooleanSelector includeTags,
       |      BooleanSelector excludeTags,
       |      Map<BooleanSelector, SuiteConfiguration> tags,
       |      Map<PlatformSelector, SuiteConfiguration> onPlatform,
       |      int testRandomizeOrderingSeed,
       |      Metadata metadata})
       |      : _jsTrace = jsTrace,
       |        _runSkipped = runSkipped,
      1|        dart2jsArgs = _list(dart2jsArgs) ?? const [],
      1|        patterns = UnmodifiableSetView(patterns?.toSet() ?? {}),
      1|        _runtimes = _list(runtimes),
       |        includeTags = includeTags ?? BooleanSelector.all,
       |        excludeTags = excludeTags ?? BooleanSelector.none,
      1|        tags = _map(tags),
      1|        onPlatform = _map(onPlatform),
       |        testRandomizeOrderingSeed = testRandomizeOrderingSeed,
      1|        _metadata = metadata ?? Metadata.empty;
       |
       |  /// Creates a new [SuiteConfiguration] that takes its configuration from
       |  /// [metadata].
      0|  factory SuiteConfiguration.fromMetadata(Metadata metadata) =>
      0|      SuiteConfiguration._(
      0|          tags: metadata.forTag.map((key, child) =>
      0|              MapEntry(key, SuiteConfiguration.fromMetadata(child))),
      0|          onPlatform: metadata.onPlatform.map((key, child) =>
      0|              MapEntry(key, SuiteConfiguration.fromMetadata(child))),
      0|          metadata: metadata.change(forTag: {}, onPlatform: {}));
       |
       |  /// Returns an unmodifiable copy of [input].
       |  ///
       |  /// If [input] is `null` or empty, this returns `null`.
      1|  static List<T> _list<T>(Iterable<T> input) {
       |    if (input == null) return null;
      0|    var list = List<T>.unmodifiable(input);
      0|    if (list.isEmpty) return null;
       |    return list;
       |  }
       |
       |  /// Returns an unmodifiable copy of [input] or an empty unmodifiable map.
      1|  static Map<K, V> _map<K, V>(Map<K, V> input) {
      0|    if (input == null || input.isEmpty) return const {};
      0|    return Map.unmodifiable(input);
       |  }
       |
       |  /// Merges this with [other].
       |  ///
       |  /// For most fields, if both configurations have values set, [other]'s value
       |  /// takes precedence. However, certain fields are merged together instead.
       |  /// This is indicated in those fields' documentation.
      0|  SuiteConfiguration merge(SuiteConfiguration other) {
      0|    if (this == SuiteConfiguration.empty) return other;
      0|    if (other == SuiteConfiguration.empty) return this;
       |
      0|    var config = SuiteConfiguration._(
      0|        jsTrace: other._jsTrace ?? _jsTrace,
      0|        runSkipped: other._runSkipped ?? _runSkipped,
      0|        dart2jsArgs: dart2jsArgs.toList()..addAll(other.dart2jsArgs),
      0|        precompiledPath: other.precompiledPath ?? precompiledPath,
      0|        patterns: patterns.union(other.patterns),
      0|        runtimes: other._runtimes ?? _runtimes,
      0|        includeTags: includeTags.intersection(other.includeTags),
      0|        excludeTags: excludeTags.union(other.excludeTags),
      0|        tags: _mergeConfigMaps(tags, other.tags),
      0|        onPlatform: _mergeConfigMaps(onPlatform, other.onPlatform),
       |        testRandomizeOrderingSeed:
      0|            other.testRandomizeOrderingSeed ?? testRandomizeOrderingSeed,
      0|        metadata: metadata.merge(other.metadata));
      0|    return config._resolveTags();
       |  }
       |
       |  /// Returns a copy of this configuration with the given fields updated.
       |  ///
       |  /// Note that unlike [merge], this has no merging behaviorthe old value is
       |  /// always replaced by the new one.
      0|  SuiteConfiguration change(
       |      {bool jsTrace,
       |      bool runSkipped,
       |      Iterable<String> dart2jsArgs,
       |      String precompiledPath,
       |      Iterable<Pattern> patterns,
       |      Iterable<RuntimeSelection> runtimes,
       |      BooleanSelector includeTags,
       |      BooleanSelector excludeTags,
       |      Map<BooleanSelector, SuiteConfiguration> tags,
       |      Map<PlatformSelector, SuiteConfiguration> onPlatform,
       |      int testRandomizeOrderingSeed,
       |
       |      // Test-level configuration
       |      Timeout timeout,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      bool skip,
       |      int retry,
       |      String skipReason,
       |      PlatformSelector testOn,
       |      Iterable<String> addTags}) {
      0|    var config = SuiteConfiguration._(
      0|        jsTrace: jsTrace ?? _jsTrace,
      0|        runSkipped: runSkipped ?? _runSkipped,
      0|        dart2jsArgs: dart2jsArgs?.toList() ?? this.dart2jsArgs,
      0|        precompiledPath: precompiledPath ?? this.precompiledPath,
      0|        patterns: patterns ?? this.patterns,
      0|        runtimes: runtimes ?? _runtimes,
      0|        includeTags: includeTags ?? this.includeTags,
      0|        excludeTags: excludeTags ?? this.excludeTags,
      0|        tags: tags ?? this.tags,
      0|        onPlatform: onPlatform ?? this.onPlatform,
       |        testRandomizeOrderingSeed:
       |            testRandomizeOrderingSeed ?? testRandomizeOrderingSeed,
      0|        metadata: _metadata.change(
       |            timeout: timeout,
       |            verboseTrace: verboseTrace,
       |            chainStackTraces: chainStackTraces,
       |            skip: skip,
       |            retry: retry,
       |            skipReason: skipReason,
       |            testOn: testOn,
      0|            tags: addTags?.toSet()));
      0|    return config._resolveTags();
       |  }
       |
       |  /// Throws a [FormatException] if this refers to any undefined runtimes.
      0|  void validateRuntimes(List<Runtime> allRuntimes) {
       |    var validVariables =
      0|        allRuntimes.map((runtime) => runtime.identifier).toSet();
      0|    _metadata.validatePlatformSelectors(validVariables);
       |
      0|    if (_runtimes != null) {
      0|      for (var selection in _runtimes) {
       |        if (!allRuntimes
      0|            .any((runtime) => runtime.identifier == selection.name)) {
      0|          if (selection.span != null) {
      0|            throw SourceSpanFormatException(
      0|                'Unknown platform "${selection.name}".', selection.span);
       |          } else {
      0|            throw FormatException('Unknown platform "${selection.name}".');
       |          }
       |        }
       |      }
       |    }
       |
      0|    onPlatform.forEach((selector, config) {
      0|      selector.validate(validVariables);
      0|      config.validateRuntimes(allRuntimes);
       |    });
       |  }
       |
       |  /// Returns a copy of this with all platform-specific configuration from
       |  /// [onPlatform] resolved.
      0|  SuiteConfiguration forPlatform(SuitePlatform platform) {
      0|    if (onPlatform.isEmpty) return this;
       |
       |    var config = this;
      0|    onPlatform.forEach((platformSelector, platformConfig) {
      0|      if (!platformSelector.evaluate(platform)) return;
      0|      config = config.merge(platformConfig);
       |    });
      0|    return config.change(onPlatform: {});
       |  }
       |
       |  /// Merges two maps whose values are [SuiteConfiguration]s.
       |  ///
       |  /// Any overlapping keys in the maps have their configurations merged in the
       |  /// returned map.
      0|  Map<T, SuiteConfiguration> _mergeConfigMaps<T>(
       |          Map<T, SuiteConfiguration> map1, Map<T, SuiteConfiguration> map2) =>
      0|      mergeMaps(map1, map2,
      0|          value: (config1, config2) => config1.merge(config2));
       |
      0|  SuiteConfiguration _resolveTags() {
       |    // If there's no tag-specific configuration, or if none of it applies, just
       |    // return the configuration as-is.
      0|    if (_metadata.tags.isEmpty || tags.isEmpty) return this;
       |
       |    // Otherwise, resolve the tag-specific components.
      0|    var newTags = Map<BooleanSelector, SuiteConfiguration>.from(tags);
      0|    var merged = tags.keys.fold(empty, (SuiteConfiguration merged, selector) {
      0|      if (!selector.evaluate(_metadata.tags.contains)) return merged;
      0|      return merged.merge(newTags.remove(selector));
       |    });
       |
      0|    if (merged == empty) return this;
      0|    return change(tags: newTags).merge(merged);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/util/print_sink.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |class PrintSink implements StringSink {
       |  final _buffer = StringBuffer();
       |
      0|  @override
       |  void write(Object obj) {
      0|    _buffer.write(obj);
      0|    _flush();
       |  }
       |
      0|  @override
       |  void writeAll(Iterable objects, [String separator = '']) {
      0|    _buffer.writeAll(objects, separator ?? '');
      0|    _flush();
       |  }
       |
      0|  @override
       |  void writeCharCode(int charCode) {
      0|    _buffer.writeCharCode(charCode);
      0|    _flush();
       |  }
       |
      1|  @override
       |  void writeln([Object obj = '']) {
      2|    _buffer.writeln(obj ?? '');
      1|    _flush();
       |  }
       |
       |  /// [print] if the content available ends with a newline.
      1|  void _flush() {
      3|    if ('$_buffer'.endsWith('\n')) {
      2|      print(_buffer);
      2|      _buffer.clear();
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/test_api.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |@Deprecated('package:test_api is not intended for general use. '
       |    'Please use package:test.')
       |library test_api;
       |
       |import 'dart:async';
       |
       |import 'package:meta/meta.dart';
       |
       |import 'src/backend/declarer.dart';
       |import 'src/backend/invoker.dart';
       |import 'src/frontend/timeout.dart';
       |
       |export 'package:matcher/matcher.dart';
       |
       |export 'src/frontend/expect.dart' hide formatFailure;
       |export 'src/frontend/expect_async.dart';
       |export 'src/frontend/future_matchers.dart';
       |export 'src/frontend/never_called.dart';
       |export 'src/frontend/on_platform.dart';
       |export 'src/frontend/prints_matcher.dart';
       |export 'src/frontend/retry.dart';
       |export 'src/frontend/skip.dart';
       |export 'src/frontend/spawn_hybrid.dart';
       |export 'src/frontend/stream_matcher.dart';
       |export 'src/frontend/stream_matchers.dart';
       |export 'src/frontend/tags.dart';
       |export 'src/frontend/test_on.dart';
       |export 'src/frontend/throws_matcher.dart';
       |export 'src/frontend/throws_matchers.dart';
       |export 'src/frontend/timeout.dart';
       |export 'src/frontend/utils.dart';
       |
       |// test_core does not support running tests directly, so the Declarer should
       |// always be on the Zone.
      0|Declarer get _declarer => Zone.current[#test.declarer] as Declarer;
       |
       |// TODO(nweiz): This and other top-level functions should throw exceptions if
       |// they're called after the declarer has finished declaring.
       |/// Creates a new test case with the given description (converted to a string)
       |/// and body.
       |///
       |/// The description will be added to the descriptions of any surrounding
       |/// [group]s. If [testOn] is passed, it's parsed as a [platform selector][]; the
       |/// test will only be run on matching platforms.
       |///
       |/// [platform selector]: https://github.com/dart-lang/test/tree/master/pkgs/test#platform-selectors
       |///
       |/// If [timeout] is passed, it's used to modify or replace the default timeout
       |/// of 30 seconds. Timeout modifications take precedence in suite-group-test
       |/// order, so [timeout] will also modify any timeouts set on the group or suite.
       |///
       |/// If [skip] is a String or `true`, the test is skipped. If it's a String, it
       |/// should explain why the test is skipped; this reason will be printed instead
       |/// of running the test.
       |///
       |/// If [tags] is passed, it declares user-defined tags that are applied to the
       |/// test. These tags can be used to select or skip the test on the command line,
       |/// or to do bulk test configuration. All tags should be declared in the
       |/// [package configuration file][configuring tags]. The parameter can be an
       |/// [Iterable] of tag names, or a [String] representing a single tag.
       |///
       |/// If [retry] is passed, the test will be retried the provided number of times
       |/// before being marked as a failure.
       |///
       |/// [configuring tags]: https://github.com/dart-lang/test/blob/master/doc/package_config.md#configuring-tags
       |///
       |/// [onPlatform] allows tests to be configured on a platform-by-platform
       |/// basis. It's a map from strings that are parsed as [PlatformSelector]s to
       |/// annotation classes: [Timeout], [Skip], or lists of those. These
       |/// annotations apply only on the given platforms. For example:
       |///
       |///     test('potentially slow test', () {
       |///       // ...
       |///     }, onPlatform: {
       |///       // This test is especially slow on Windows.
       |///       'windows': Timeout.factor(2),
       |///       'browser': [
       |///         Skip('TODO: add browser support'),
       |///         // This will be slow on browsers once it works on them.
       |///         Timeout.factor(2)
       |///       ]
       |///     });
       |///
       |/// If multiple platforms match, the annotations apply in order as through
       |/// they were in nested groups.
       |///
       |/// If the `solo` flag is `true`, only tests and groups marked as
       |/// "solo" will be be run. This only restricts tests *within this test
       |/// suite*tests in other suites will run as normal. We recommend that users
       |/// avoid this flag if possible and instead use the test runner flag `-n` to
       |/// filter tests by name.
      0|@isTest
       |void test(description, dynamic Function() body,
       |    {String testOn,
       |    Timeout timeout,
       |    skip,
       |    tags,
       |    Map<String, dynamic> onPlatform,
       |    int retry,
       |    @deprecated bool solo = false}) {
      0|  _declarer.test(description.toString(), body,
       |      testOn: testOn,
       |      timeout: timeout,
       |      skip: skip,
       |      onPlatform: onPlatform,
       |      tags: tags,
       |      retry: retry,
       |      solo: solo);
       |
       |  // Force dart2js not to inline this function. We need it to be separate from
       |  // `main()` in JS stack traces in order to properly determine the line and
       |  // column where the test was defined. See sdk#26705.
       |  return;
       |  return; // ignore: dead_code
       |}
       |
       |/// Creates a group of tests.
       |///
       |/// A group's description (converted to a string) is included in the descriptions
       |/// of any tests or sub-groups it contains. [setUp] and [tearDown] are also scoped
       |/// to the containing group.
       |///
       |/// If [testOn] is passed, it's parsed as a [platform selector][]; the test will
       |/// only be run on matching platforms.
       |///
       |/// [platform selector]: https://github.com/dart-lang/test/tree/master/pkgs/test#platform-selectors
       |///
       |/// If [timeout] is passed, it's used to modify or replace the default timeout
       |/// of 30 seconds. Timeout modifications take precedence in suite-group-test
       |/// order, so [timeout] will also modify any timeouts set on the suite, and will
       |/// be modified by any timeouts set on individual tests.
       |///
       |/// If [skip] is a String or `true`, the group is skipped. If it's a String, it
       |/// should explain why the group is skipped; this reason will be printed instead
       |/// of running the group's tests.
       |///
       |/// If [tags] is passed, it declares user-defined tags that are applied to the
       |/// test. These tags can be used to select or skip the test on the command line,
       |/// or to do bulk test configuration. All tags should be declared in the
       |/// [package configuration file][configuring tags]. The parameter can be an
       |/// [Iterable] of tag names, or a [String] representing a single tag.
       |///
       |/// [configuring tags]: https://github.com/dart-lang/test/blob/master/doc/package_config.md#configuring-tags
       |///
       |/// [onPlatform] allows groups to be configured on a platform-by-platform
       |/// basis. It's a map from strings that are parsed as [PlatformSelector]s to
       |/// annotation classes: [Timeout], [Skip], or lists of those. These
       |/// annotations apply only on the given platforms. For example:
       |///
       |///     group('potentially slow tests', () {
       |///       // ...
       |///     }, onPlatform: {
       |///       // These tests are especially slow on Windows.
       |///       'windows': Timeout.factor(2),
       |///       'browser': [
       |///         Skip('TODO: add browser support'),
       |///         // They'll be slow on browsers once it works on them.
       |///         Timeout.factor(2)
       |///       ]
       |///     });
       |///
       |/// If multiple platforms match, the annotations apply in order as through
       |/// they were in nested groups.
       |///
       |/// If the `solo` flag is `true`, only tests and groups marked as
       |/// "solo" will be be run. This only restricts tests *within this test
       |/// suite*tests in other suites will run as normal. We recommend that users
       |/// avoid this flag if possible, and instead use the test runner flag `-n` to
       |/// filter tests by name.
      0|@isTestGroup
       |void group(description, dynamic Function() body,
       |    {String testOn,
       |    Timeout timeout,
       |    skip,
       |    tags,
       |    Map<String, dynamic> onPlatform,
       |    int retry,
       |    @deprecated bool solo = false}) {
      0|  _declarer.group(description.toString(), body,
       |      testOn: testOn,
       |      timeout: timeout,
       |      skip: skip,
       |      tags: tags,
       |      onPlatform: onPlatform,
       |      retry: retry,
       |      solo: solo);
       |
       |  // Force dart2js not to inline this function. We need it to be separate from
       |  // `main()` in JS stack traces in order to properly determine the line and
       |  // column where the test was defined. See sdk#26705.
       |  return;
       |  return; // ignore: dead_code
       |}
       |
       |/// Registers a function to be run before tests.
       |///
       |/// This function will be called before each test is run. [callback] may be
       |/// asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, it applies only to tests in that
       |/// group. [callback] will be run after any set-up callbacks in parent groups or
       |/// at the top level.
       |///
       |/// Each callback at the top level or in a given group will be run in the order
       |/// they were declared.
      0|void setUp(dynamic Function() callback) => _declarer.setUp(callback);
       |
       |/// Registers a function to be run after tests.
       |///
       |/// This function will be called after each test is run. [callback] may be
       |/// asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, it applies only to tests in that
       |/// group. [callback] will be run before any tear-down callbacks in parent
       |/// groups or at the top level.
       |///
       |/// Each callback at the top level or in a given group will be run in the
       |/// reverse of the order they were declared.
       |///
       |/// See also [addTearDown], which adds tear-downs to a running test.
      0|void tearDown(dynamic Function() callback) => _declarer.tearDown(callback);
       |
       |/// Registers a function to be run after the current test.
       |///
       |/// This is called within a running test, and adds a tear-down only for the
       |/// current test. It allows testing libraries to add cleanup logic as soon as
       |/// there's something to clean up.
       |///
       |/// The [callback] is run before any callbacks registered with [tearDown]. Like
       |/// [tearDown], the most recently registered callback is run first.
       |///
       |/// If this is called from within a [setUpAll] or [tearDownAll] callback, it
       |/// instead runs the function after *all* tests in the current test suite.
      0|void addTearDown(dynamic Function() callback) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('addTearDown() may only be called within a test.');
       |  }
       |
      0|  Invoker.current.addTearDown(callback);
       |}
       |
       |/// Registers a function to be run once before all tests.
       |///
       |/// [callback] may be asynchronous; if so, it must return a [Future].
       |///
       |/// If this is called within a test group, [callback] will run before all tests
       |/// in that group. It will be run after any [setUpAll] callbacks in parent
       |/// groups or at the top level. It won't be run if none of the tests in the
       |/// group are run.
       |///
       |/// **Note**: This function makes it very easy to accidentally introduce hidden
       |/// dependencies between tests that should be isolated. In general, you should
       |/// prefer [setUp], and only use [setUpAll] if the callback is prohibitively
       |/// slow.
      0|void setUpAll(dynamic Function() callback) => _declarer.setUpAll(callback);
       |
       |/// Registers a function to be run once after all tests.
       |///
       |/// If this is called within a test group, [callback] will run after all tests
       |/// in that group. It will be run before any [tearDownAll] callbacks in parent
       |/// groups or at the top level. It won't be run if none of the tests in the
       |/// group are run.
       |///
       |/// **Note**: This function makes it very easy to accidentally introduce hidden
       |/// dependencies between tests that should be isolated. In general, you should
       |/// prefer [tearDown], and only use [tearDownAll] if the callback is
       |/// prohibitively slow.
      0|void tearDownAll(dynamic Function() callback) =>
      0|    _declarer.tearDownAll(callback);
       |
       |/// Registers an exception that was caught for the current test.
      0|void registerException(error, [StackTrace stackTrace]) {
       |  // This will usually forward directly to [Invoker.current.handleError], but
       |  // going through the zone API allows other zones to consistently see errors.
      0|  Zone.current.handleUncaughtError(error, stackTrace);
       |}
       |
       |/// Prints [message] if and when the current test fails.
       |///
       |/// This is intended for test infrastructure to provide debugging information
       |/// without cluttering the output for successful tests. Note that unlike
       |/// [print], each individual message passed to [printOnFailure] will be
       |/// separated by a blank line.
      0|void printOnFailure(String message) => Invoker.current.printOnFailure(message);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/expect.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |import 'package:meta/meta.dart';
       |
       |import '../backend/closed_exception.dart';
       |import '../backend/invoker.dart';
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |
       |/// An exception thrown when a test assertion fails.
       |class TestFailure {
       |  final String message;
       |
      0|  TestFailure(this.message);
       |
      0|  @override
      0|  String toString() => message;
       |}
       |
       |/// The type used for functions that can be used to build up error reports
       |/// upon failures in [expect].
       |@Deprecated('Will be removed in 0.13.0.')
       |typedef ErrorFormatter = String Function(dynamic actual, Matcher matcher,
       |    String reason, Map matchState, bool verbose);
       |
       |/// Assert that [actual] matches [matcher].
       |///
       |/// This is the main assertion function. [reason] is optional and is typically
       |/// not supplied, as a reason is generated from [matcher]; if [reason]
       |/// is included it is appended to the reason generated by the matcher.
       |///
       |/// [matcher] can be a value in which case it will be wrapped in an
       |/// [equals] matcher.
       |///
       |/// If the assertion fails a [TestFailure] is thrown.
       |///
       |/// If [skip] is a String or `true`, the assertion is skipped. The arguments are
       |/// still evaluated, but [actual] is not verified to match [matcher]. If
       |/// [actual] is a [Future], the test won't complete until the future emits a
       |/// value.
       |///
       |/// If [skip] is a string, it should explain why the assertion is skipped; this
       |/// reason will be printed when running the test.
       |///
       |/// Certain matchers, like [completion] and [throwsA], either match or fail
       |/// asynchronously. When you use [expect] with these matchers, it ensures that
       |/// the test doesn't complete until the matcher has either matched or failed. If
       |/// you want to wait for the matcher to complete before continuing the test, you
       |/// can call [expectLater] instead and `await` the result.
      1|void expect(actual, matcher,
       |    {String reason,
       |    skip,
       |    @Deprecated('Will be removed in 0.13.0.') bool verbose = false,
       |    @Deprecated('Will be removed in 0.13.0.') ErrorFormatter formatter}) {
      1|  _expect(actual, matcher,
       |      reason: reason, skip: skip, verbose: verbose, formatter: formatter);
       |}
       |
       |/// Just like [expect], but returns a [Future] that completes when the matcher
       |/// has finished matching.
       |///
       |/// For the [completes] and [completion] matchers, as well as [throwsA] and
       |/// related matchers when they're matched against a [Future], the returned
       |/// future completes when the matched future completes. For the [prints]
       |/// matcher, it completes when the future returned by the callback completes.
       |/// Otherwise, it completes immediately.
       |///
       |/// If the matcher fails asynchronously, that failure is piped to the returned
       |/// future where it can be handled by user code.
      0|Future expectLater(actual, matcher, {String reason, skip}) =>
      0|    _expect(actual, matcher, reason: reason, skip: skip);
       |
       |/// The implementation of [expect] and [expectLater].
      1|Future _expect(actual, matcher,
       |    {String reason, skip, bool verbose = false, ErrorFormatter formatter}) {
      0|  formatter ??= (actual, matcher, reason, matchState, verbose) {
      0|    var mismatchDescription = StringDescription();
      0|    matcher.describeMismatch(actual, mismatchDescription, matchState, verbose);
       |
      0|    return formatFailure(matcher, actual, mismatchDescription.toString(),
       |        reason: reason);
       |  };
       |
      1|  if (Invoker.current == null) {
      0|    throw StateError('expect() may only be called within a test.');
       |  }
       |
      2|  if (Invoker.current.closed) throw ClosedException();
       |
      0|  if (skip != null && skip is! bool && skip is! String) {
      0|    throw ArgumentError.value(skip, 'skip', 'must be a bool or a String');
       |  }
       |
      1|  matcher = wrapMatcher(matcher);
      0|  if (skip != null && skip != false) {
       |    String message;
      0|    if (skip is String) {
      0|      message = 'Skip expect: $skip';
       |    } else if (reason != null) {
      0|      message = 'Skip expect ($reason).';
       |    } else {
      0|      var description = StringDescription().addDescriptionOf(matcher);
      0|      message = 'Skip expect ($description).';
       |    }
       |
      0|    Invoker.current.skip(message);
      0|    return Future.sync(() {});
       |  }
       |
      1|  if (matcher is AsyncMatcher) {
       |    // Avoid async/await so that expect() throws synchronously when possible.
      1|    var result = matcher.matchAsync(actual);
      1|    expect(result,
      5|        anyOf([equals(null), TypeMatcher<Future>(), TypeMatcher<String>()]),
       |        reason: 'matchAsync() may only return a String, a Future, or null.');
       |
      1|    if (result is String) {
      0|      fail(formatFailure(matcher as Matcher, actual, result, reason: reason));
      1|    } else if (result is Future) {
      0|      Invoker.current.addOutstandingCallback();
      0|      return result.then((realResult) {
       |        if (realResult == null) return;
      0|        fail(formatFailure(matcher as Matcher, actual, realResult as String,
       |            reason: reason));
      0|      }).whenComplete(() {
       |        // Always remove this, in case the failure is caught and handled
       |        // gracefully.
      0|        Invoker.current.removeOutstandingCallback();
       |      });
       |    }
       |
      2|    return Future.sync(() {});
       |  }
       |
      1|  var matchState = {};
       |  try {
      1|    if ((matcher as Matcher).matches(actual, matchState)) {
      2|      return Future.sync(() {});
       |    }
       |  } catch (e, trace) {
      0|    reason ??= '$e at $trace';
       |  }
      0|  fail(formatter(actual, matcher as Matcher, reason, matchState, verbose));
       |}
       |
       |/// Convenience method for throwing a new [TestFailure] with the provided
       |/// [message].
      0|@alwaysThrows
      0|Null fail(String message) => throw TestFailure(message);
       |
       |// The default error formatter.
      0|@Deprecated('Will be removed in 0.13.0.')
       |String formatFailure(Matcher expected, actual, String which, {String reason}) {
      0|  var buffer = StringBuffer();
      0|  buffer.writeln(indent(prettyPrint(expected), first: 'Expected: '));
      0|  buffer.writeln(indent(prettyPrint(actual), first: '  Actual: '));
      0|  if (which.isNotEmpty) buffer.writeln(indent(which, first: '   Which: '));
      0|  if (reason != null) buffer.writeln(reason);
      0|  return buffer.toString();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/expect_async.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../backend/invoker.dart';
       |import '../util/placeholder.dart';
       |import 'expect.dart';
       |
       |// Function types returned by expectAsync# methods.
       |
       |typedef Func0<T> = T Function();
       |typedef Func1<T, A> = T Function([A a]);
       |typedef Func2<T, A, B> = T Function([A a, B b]);
       |typedef Func3<T, A, B, C> = T Function([A a, B b, C c]);
       |typedef Func4<T, A, B, C, D> = T Function([A a, B b, C c, D d]);
       |typedef Func5<T, A, B, C, D, E> = T Function([A a, B b, C c, D d, E e]);
       |typedef Func6<T, A, B, C, D, E, F> = T Function([A a, B b, C c, D d, E e, F f]);
       |
       |/// A wrapper for a function that ensures that it's called the appropriate
       |/// number of times.
       |///
       |/// The containing test won't be considered to have completed successfully until
       |/// this function has been called the appropriate number of times.
       |///
       |/// The wrapper function is accessible via [func]. It supports up to six
       |/// optional and/or required positional arguments, but no named arguments.
       |class _ExpectedFunction<T> {
       |  /// The wrapped callback.
       |  final Function _callback;
       |
       |  /// The minimum number of calls that are expected to be made to the function.
       |  ///
       |  /// If fewer calls than this are made, the test will fail.
       |  final int _minExpectedCalls;
       |
       |  /// The maximum number of calls that are expected to be made to the function.
       |  ///
       |  /// If more calls than this are made, the test will fail.
       |  final int _maxExpectedCalls;
       |
       |  /// A callback that should return whether the function is not expected to have
       |  /// any more calls.
       |  ///
       |  /// This will be called after every time the function is run. The test case
       |  /// won't be allowed to terminate until it returns `true`.
       |  ///
       |  /// This may be `null`. If so, the function is considered to be done after
       |  /// it's been run once.
       |  final bool Function() _isDone;
       |
       |  /// A descriptive name for the function.
       |  final String _id;
       |
       |  /// An optional description of why the function is expected to be called.
       |  ///
       |  /// If not passed, this will be an empty string.
       |  final String _reason;
       |
       |  /// The number of times the function has been called.
       |  int _actualCalls = 0;
       |
       |  /// The test invoker in which this function was wrapped.
      0|  Invoker get _invoker => _zone[#test.invoker] as Invoker;
       |
       |  /// The zone in which this function was wrapped.
       |  final Zone _zone;
       |
       |  /// Whether this function has been called the requisite number of times.
       |  bool _complete;
       |
       |  /// Wraps [callback] in a function that asserts that it's called at least
       |  /// [minExpected] times and no more than [maxExpected] times.
       |  ///
       |  /// If passed, [id] is used as a descriptive name fo the function and [reason]
       |  /// as a reason it's expected to be called. If [isDone] is passed, the test
       |  /// won't be allowed to complete until it returns `true`.
      0|  _ExpectedFunction(Function callback, int minExpected, int maxExpected,
       |      {String id, String reason, bool Function() isDone})
       |      : _callback = callback,
       |        _minExpectedCalls = minExpected,
       |        _maxExpectedCalls =
      0|            (maxExpected == 0 && minExpected > 0) ? minExpected : maxExpected,
       |        _isDone = isDone,
      0|        _reason = reason == null ? '' : '\n$reason',
      0|        _zone = Zone.current,
      0|        _id = _makeCallbackId(id, callback) {
      0|    if (_invoker == null) {
      0|      throw StateError('[expectAsync] was called outside of a test.');
      0|    } else if (maxExpected > 0 && minExpected > maxExpected) {
      0|      throw ArgumentError('max ($maxExpected) may not be less than count '
       |          '($minExpected).');
       |    }
       |
      0|    if (isDone != null || minExpected > 0) {
      0|      _invoker.addOutstandingCallback();
      0|      _complete = false;
       |    } else {
      0|      _complete = true;
       |    }
       |  }
       |
       |  /// Tries to find a reasonable name for [callback].
       |  ///
       |  /// If [id] is passed, uses that. Otherwise, tries to determine a name from
       |  /// calling `toString`. If no name can be found, returns the empty string.
      0|  static String _makeCallbackId(String id, Function callback) {
      0|    if (id != null) return '$id ';
       |
       |    // If the callback is not an anonymous closure, try to get the
       |    // name.
      0|    var toString = callback.toString();
       |    var prefix = "Function '";
      0|    var start = toString.indexOf(prefix);
      0|    if (start == -1) return '';
       |
      0|    start += prefix.length;
      0|    var end = toString.indexOf("'", start);
      0|    if (end == -1) return '';
      0|    return '${toString.substring(start, end)} ';
       |  }
       |
       |  /// Returns a function that has the same number of positional arguments as the
       |  /// wrapped function (up to a total of 6).
      0|  Function get func {
      0|    if (_callback is Function(Null, Null, Null, Null, Null Nulll)) return max6;
      0|    if (_callback is Function(Null, Null, Null, Null, Null)) return max5;
      0|    if (_callback is Function(Null, Null, Null, Null)) return max4;
      0|    if (_callback is Function(Null, Null, Null)) return max3;
      0|    if (_callback is Function(Null, Null)) return max2;
      0|    if (_callback is Function(Null)) return max1;
      0|    if (_callback is Function()) return max0;
       |
      0|    _invoker.removeOutstandingCallback();
      0|    throw ArgumentError(
       |        'The wrapped function has more than 6 required arguments');
       |  }
       |
       |  // This indirection is critical. It ensures the returned function has an
       |  // argument count of zero.
      0|  T max0() => max6();
       |
      0|  T max1([Object a0 = placeholder]) => max6(a0);
       |
      0|  T max2([Object a0 = placeholder, Object a1 = placeholder]) => max6(a0, a1);
       |
      0|  T max3(
       |          [Object a0 = placeholder,
       |          Object a1 = placeholder,
       |          Object a2 = placeholder]) =>
      0|      max6(a0, a1, a2);
       |
      0|  T max4(
       |          [Object a0 = placeholder,
       |          Object a1 = placeholder,
       |          Object a2 = placeholder,
       |          Object a3 = placeholder]) =>
      0|      max6(a0, a1, a2, a3);
       |
      0|  T max5(
       |          [Object a0 = placeholder,
       |          Object a1 = placeholder,
       |          Object a2 = placeholder,
       |          Object a3 = placeholder,
       |          Object a4 = placeholder]) =>
      0|      max6(a0, a1, a2, a3, a4);
       |
      0|  T max6(
       |          [Object a0 = placeholder,
       |          Object a1 = placeholder,
       |          Object a2 = placeholder,
       |          Object a3 = placeholder,
       |          Object a4 = placeholder,
       |          Object a5 = placeholder]) =>
      0|      _run([a0, a1, a2, a3, a4, a5].where((a) => a != placeholder));
       |
       |  /// Runs the wrapped function with [args] and returns its return value.
      0|  T _run(Iterable args) {
       |    // Note that in the old test, this returned `null` if it encountered an
       |    // error, where now it just re-throws that error because Zone machinery will
       |    // pass it to the invoker anyway.
       |    try {
      0|      _actualCalls++;
      0|      if (_invoker.liveTest.state.shouldBeDone) {
      0|        throw 'Callback ${_id}called ($_actualCalls) after test case '
      0|            '${_invoker.liveTest.test.name} had already completed.$_reason';
      0|      } else if (_maxExpectedCalls >= 0 && _actualCalls > _maxExpectedCalls) {
      0|        throw TestFailure('Callback ${_id}called more times than expected '
      0|            '($_maxExpectedCalls).$_reason');
       |      }
       |
      0|      return Function.apply(_callback, args.toList()) as T;
       |    } finally {
      0|      _afterRun();
       |    }
       |  }
       |
       |  /// After each time the function is run, check to see if it's complete.
      0|  void _afterRun() {
      0|    if (_complete) return;
      0|    if (_minExpectedCalls > 0 && _actualCalls < _minExpectedCalls) return;
      0|    if (_isDone != null && !_isDone()) return;
       |
       |    // Mark this callback as complete and remove it from the test case's
       |    // oustanding callback count; if that hits zero the test is done.
      0|    _complete = true;
      0|    _invoker.removeOutstandingCallback();
       |  }
       |}
       |
       |/// This function is deprecated because it doesn't work well with strong mode.
       |/// Use [expectAsync0], [expectAsync1],
       |/// [expectAsync2], [expectAsync3], [expectAsync4], [expectAsync5], or
       |/// [expectAsync6] instead.
      0|@Deprecated('Will be removed in 0.13.0')
       |Function expectAsync(Function callback,
       |    {int count = 1, int max = 0, String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsync() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction(callback, count, max, id: id, reason: reason).func;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 0 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with zero arguments. See also
       |/// [expectAsync1], [expectAsync2], [expectAsync3], [expectAsync4],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
      0|Func0<T> expectAsync0<T>(T Function() callback,
       |    {int count = 1, int max = 0, String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsync0() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, count, max, id: id, reason: reason)
      0|      .max0;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 1 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with one argument. See also
       |/// [expectAsync0], [expectAsync2], [expectAsync3], [expectAsync4],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
      0|Func1<T, A> expectAsync1<T, A>(T Function(A) callback,
       |    {int count = 1, int max = 0, String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsync1() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, count, max, id: id, reason: reason)
      0|      .max1;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 2 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with two arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync3], [expectAsync4],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
      0|Func2<T, A, B> expectAsync2<T, A, B>(T Function(A, B) callback,
       |    {int count = 1, int max = 0, String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsync2() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, count, max, id: id, reason: reason)
      0|      .max2;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 3 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with three arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync2], [expectAsync4],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
      0|Func3<T, A, B, C> expectAsync3<T, A, B, C>(T Function(A, B, C) callback,
       |    {int count = 1, int max = 0, String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsync3() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, count, max, id: id, reason: reason)
      0|      .max3;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 4 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with four arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync2], [expectAsync3],
       |/// [expectAsync5], and [expectAsync6] for callbacks with different arity.
      0|Func4<T, A, B, C, D> expectAsync4<T, A, B, C, D>(
       |    T Function(A, B, C, D) callback,
       |    {int count = 1,
       |    int max = 0,
       |    String id,
       |    String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsync4() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, count, max, id: id, reason: reason)
      0|      .max4;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 5 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with five arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync2], [expectAsync3],
       |/// [expectAsync4], and [expectAsync6] for callbacks with different arity.
      0|Func5<T, A, B, C, D, E> expectAsync5<T, A, B, C, D, E>(
       |    T Function(A, B, C, D, E) callback,
       |    {int count = 1,
       |    int max = 0,
       |    String id,
       |    String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsync5() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, count, max, id: id, reason: reason)
      0|      .max5;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 6 is expected to be
       |/// called [count] number of times (by default 1).
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// The test framework will wait for the callback to run the [count] times
       |/// before it considers the current test to be complete.
       |///
       |/// [max] can be used to specify an upper bound on the number of calls; if this
       |/// is exceeded the test will fail. If [max] is `0` (the default), the callback
       |/// is expected to be called exactly [count] times. If [max] is `-1`, the
       |/// callback is allowed to be called any number of times greater than [count].
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with six arguments. See also
       |/// [expectAsync0], [expectAsync1], [expectAsync2], [expectAsync3],
       |/// [expectAsync4], and [expectAsync5] for callbacks with different arity.
      0|Func6<T, A, B, C, D, E, F> expectAsync6<T, A, B, C, D, E, F>(
       |    T Function(A, B, C, D, E, F) callback,
       |    {int count = 1,
       |    int max = 0,
       |    String id,
       |    String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsync6() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, count, max, id: id, reason: reason)
      0|      .max6;
       |}
       |
       |/// This function is deprecated because it doesn't work well with strong mode.
       |/// Use [expectAsyncUntil0], [expectAsyncUntil1],
       |/// [expectAsyncUntil2], [expectAsyncUntil3], [expectAsyncUntil4],
       |/// [expectAsyncUntil5], or [expectAsyncUntil6] instead.
      0|@Deprecated('Will be removed in 0.13.0')
       |Function expectAsyncUntil(Function callback, bool Function() isDone,
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsyncUntil() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .func;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 0 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with zero arguments. See also
       |/// [expectAsyncUntil1], [expectAsyncUntil2], [expectAsyncUntil3],
       |/// [expectAsyncUntil4], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
      0|Func0<T> expectAsyncUntil0<T>(T Function() callback, bool Function() isDone,
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsyncUntil0() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max0;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 1 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with one argument. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil2], [expectAsyncUntil3],
       |/// [expectAsyncUntil4], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
      0|Func1<T, A> expectAsyncUntil1<T, A>(
       |    T Function(A) callback, bool Function() isDone,
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsyncUntil1() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max1;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 2 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with two arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil3],
       |/// [expectAsyncUntil4], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
      0|Func2<T, A, B> expectAsyncUntil2<T, A, B>(
       |    T Function(A, B) callback, bool Function() isDone,
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsyncUntil2() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max2;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 3 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with three arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil2],
       |/// [expectAsyncUntil4], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
      0|Func3<T, A, B, C> expectAsyncUntil3<T, A, B, C>(
       |    T Function(A, B, C) callback, bool Function() isDone,
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsyncUntil3() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max3;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 4 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with four arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil2],
       |/// [expectAsyncUntil3], [expectAsyncUntil5], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
      0|Func4<T, A, B, C, D> expectAsyncUntil4<T, A, B, C, D>(
       |    T Function(A, B, C, D) callback, bool Function() isDone,
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsyncUntil4() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max4;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 5 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with five arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil2],
       |/// [expectAsyncUntil3], [expectAsyncUntil4], and [expectAsyncUntil6] for
       |/// callbacks with different arity.
      0|Func5<T, A, B, C, D, E> expectAsyncUntil5<T, A, B, C, D, E>(
       |    T Function(A, B, C, D, E) callback, bool Function() isDone,
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsyncUntil5() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max5;
       |}
       |
       |/// Informs the framework that the given [callback] of arity 6 is expected to be
       |/// called until [isDone] returns true.
       |///
       |/// Returns a wrapped function that should be used as a replacement of the
       |/// original callback.
       |///
       |/// [isDone] is called after each time the function is run. Only when it returns
       |/// true will the callback be considered complete.
       |///
       |/// Both [id] and [reason] are optional and provide extra information about the
       |/// callback when debugging. [id] should be the name of the callback, while
       |/// [reason] should be the reason the callback is expected to be called.
       |///
       |/// This method takes callbacks with six arguments. See also
       |/// [expectAsyncUntil0], [expectAsyncUntil1], [expectAsyncUntil2],
       |/// [expectAsyncUntil3], [expectAsyncUntil4], and [expectAsyncUntil5] for
       |/// callbacks with different arity.
      0|Func6<T, A, B, C, D, E, F> expectAsyncUntil6<T, A, B, C, D, E, F>(
       |    T Function(A, B, C, D, E, F) callback, bool Function() isDone,
       |    {String id, String reason}) {
      0|  if (Invoker.current == null) {
      0|    throw StateError('expectAsyncUntil() may only be called within a test.');
       |  }
       |
      0|  return _ExpectedFunction<T>(callback, 0, -1,
       |          id: id, reason: reason, isDone: isDone)
      0|      .max6;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/future_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |import 'expect.dart';
       |import 'utils.dart';
       |
       |/// Matches a [Future] that completes successfully with any value.
       |///
       |/// This creates an asynchronous expectation. The call to [expect] will return
       |/// immediately and execution will continue. Later, when the future completes,
       |/// the expectation against [matcher] will run. To wait for the future to
       |/// complete and the expectation to run use [expectLater] and wait on the
       |/// returned future.
       |///
       |/// To test that a Future completes with an exception, you can use [throws] and
       |/// [throwsA].
      0|final Matcher completes = const _Completes(null);
       |
       |/// Matches a [Future] that completes succesfully with a value that matches
       |/// [matcher].
       |///
       |/// This creates an asynchronous expectation. The call to [expect] will return
       |/// immediately and execution will continue. Later, when the future completes,
       |/// the expectation against [matcher] will run. To wait for the future to
       |/// complete and the expectation to run use [expectLater] and wait on the
       |/// returned future.
       |///
       |/// To test that a Future completes with an exception, you can use [throws] and
       |/// [throwsA].
      0|Matcher completion(matcher, [@deprecated String description]) =>
      0|    _Completes(wrapMatcher(matcher));
       |
       |class _Completes extends AsyncMatcher {
       |  final Matcher _matcher;
       |
      0|  const _Completes(this._matcher);
       |
       |  // Avoid async/await so we synchronously start listening to [item].
      0|  @override
       |  dynamic /*FutureOr<String>*/ matchAsync(item) {
      0|    if (item is! Future) return 'was not a Future';
       |
      0|    return item.then((value) async {
      0|      if (_matcher == null) return null;
       |
       |      String result;
      0|      if (_matcher is AsyncMatcher) {
      0|        result = await (_matcher as AsyncMatcher).matchAsync(value) as String;
       |        if (result == null) return null;
       |      } else {
      0|        var matchState = {};
      0|        if (_matcher.matches(value, matchState)) return null;
      0|        result = _matcher
      0|            .describeMismatch(value, StringDescription(), matchState, false)
      0|            .toString();
       |      }
       |
      0|      var buffer = StringBuffer();
      0|      buffer.writeln(indent(prettyPrint(value), first: 'emitted '));
      0|      if (result.isNotEmpty) buffer.writeln(indent(result, first: '  which '));
      0|      return buffer.toString().trimRight();
       |    });
       |  }
       |
      0|  @override
       |  Description describe(Description description) {
      0|    if (_matcher == null) {
      0|      description.add('completes successfully');
       |    } else {
      0|      description.add('completes to a value that ').addDescriptionOf(_matcher);
       |    }
       |    return description;
       |  }
       |}
       |
       |/// Matches a [Future] that does not complete.
       |///
       |/// Note that this creates an asynchronous expectation. The call to
       |/// `expect()` that includes this will return immediately and execution will
       |/// continue.
      0|final Matcher doesNotComplete = const _DoesNotComplete();
       |
       |class _DoesNotComplete extends Matcher {
      0|  const _DoesNotComplete();
       |
      0|  @override
       |  Description describe(Description description) {
      0|    description.add('does not complete');
       |    return description;
       |  }
       |
      0|  @override
       |  bool matches(item, Map matchState) {
      0|    if (item is! Future) return false;
      0|    item.then((value) {
      0|      fail('Future was not expected to complete but completed with a value of '
       |          '$value');
       |    });
      0|    expect(pumpEventQueue(), completes);
       |    return true;
       |  }
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description description, Map matchState, bool verbose) {
      0|    if (item is! Future) return description.add('$item is not a Future');
       |    return description;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/never_called.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../util/placeholder.dart';
       |import '../utils.dart';
       |import 'expect.dart';
       |import 'future_matchers.dart';
       |import 'utils.dart';
       |
       |/// Returns a function that causes the test to fail if it's called.
       |///
       |/// This can safely be passed in place of any callback that takes ten or fewer
       |/// positional parameters. For example:
       |///
       |/// ```
       |/// // Asserts that the stream never emits an event.
       |/// stream.listen(neverCalled);
       |/// ```
       |///
       |/// This also ensures that the test doesn't complete until a call to
       |/// [pumpEventQueue] finishes, so that the callback has a chance to be called.
      0|Null Function(
       |    [Object,
       |    Object,
       |    Object,
       |    Object,
       |    Object,
       |    Object,
       |    Object,
       |    Object,
       |    Object,
       |    Object]) get neverCalled {
       |  // Make sure the test stays alive long enough to call the function if it's
       |  // going to.
      0|  expect(pumpEventQueue(), completes);
       |
      0|  var zone = Zone.current;
      0|  return (
       |      [a1 = placeholder,
       |      a2 = placeholder,
       |      a3 = placeholder,
       |      a4 = placeholder,
       |      a5 = placeholder,
       |      a6 = placeholder,
       |      a7 = placeholder,
       |      a8 = placeholder,
       |      a9 = placeholder,
       |      a10 = placeholder]) {
      0|    var arguments = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]
      0|        .where((argument) => argument != placeholder)
      0|        .toList();
       |
      0|    zone.handleUncaughtError(
      0|        TestFailure(
      0|            'Callback should never have been called, but it was called with' +
      0|                (arguments.isEmpty
       |                    ? ' no arguments.'
      0|                    : ':\n${bullet(arguments.map(prettyPrint))}')),
      0|        zone.run(() => Chain.current()));
       |    return null;
       |  };
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/on_platform.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation for platform-specific customizations for a test suite.
       |///
       |/// See [the README][onPlatform].
       |///
       |/// [onPlatform]: https://github.com/dart-lang/test/tree/master/pkgs/test#platform-specific-configuration
       |class OnPlatform {
       |  final Map<String, dynamic> annotationsByPlatform;
       |
      0|  const OnPlatform(this.annotationsByPlatform);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/prints_matcher.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |import 'expect.dart';
       |
       |/// Matches a [Function] that prints text that matches [matcher].
       |///
       |/// [matcher] may be a String or a [Matcher].
       |///
       |/// If the function this runs against returns a [Future], all text printed by
       |/// the function (using [Zone] scoping) until that Future completes is matched.
       |///
       |/// This only tracks text printed using the [print] function.
       |///
       |/// This returns an [AsyncMatcher], so [expect] won't complete until the matched
       |/// function does.
      0|Matcher prints(matcher) => _Prints(wrapMatcher(matcher));
       |
       |class _Prints extends AsyncMatcher {
       |  final Matcher _matcher;
       |
      0|  _Prints(this._matcher);
       |
       |  // Avoid async/await so we synchronously fail if the function is
       |  // synchronous.
      0|  @override
       |  dynamic /*FutureOr<String>*/ matchAsync(item) {
      0|    if (item is! Function()) return 'was not a unary Function';
       |
      0|    var buffer = StringBuffer();
      0|    var result = runZoned(item as Function(),
      0|        zoneSpecification: ZoneSpecification(print: (_, __, ____, line) {
      0|      buffer.writeln(line);
       |    }));
       |
      0|    return result is Future
      0|        ? result.then((_) => _check(buffer.toString()))
      0|        : _check(buffer.toString());
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('prints ').addDescriptionOf(_matcher);
       |
       |  /// Verifies that [actual] matches [_matcher] and returns a [String]
       |  /// description of the failure if it doesn't.
      0|  String _check(String actual) {
      0|    var matchState = {};
      0|    if (_matcher.matches(actual, matchState)) return null;
       |
      0|    var result = _matcher
      0|        .describeMismatch(actual, StringDescription(), matchState, false)
      0|        .toString();
       |
      0|    var buffer = StringBuffer();
      0|    if (actual.isEmpty) {
      0|      buffer.writeln('printed nothing');
       |    } else {
      0|      buffer.writeln(indent(prettyPrint(actual), first: 'printed '));
       |    }
      0|    if (result.isNotEmpty) buffer.writeln(indent(result, first: '  which '));
      0|    return buffer.toString().trimRight();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/retry.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation for marking a test to be retried.
       |///
       |/// A test with retries enabled will be re-run if it fails for a reason
       |/// other than [TestFailure].
       |class Retry {
       |  /// The number of times the test will be retried.
       |  final int count;
       |
       |  /// Marks a test to be retried.
      0|  const Retry(this.count);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/skip.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation for marking a test suite as skipped.
       |class Skip {
       |  /// The reason the test suite is skipped, or `null` if no reason is given.
       |  final String reason;
       |
       |  /// Marks a suite as skipped.
       |  ///
       |  /// If [reason] is passed, it's included in the test output as the reason the
       |  /// test is skipped.
      0|  const Skip([this.reason]);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/spawn_hybrid.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:convert';
       |
       |import 'package:async/async.dart';
       |import 'package:path/path.dart' as p;
       |import 'package:stream_channel/stream_channel.dart';
       |
       |import '../../test_api.dart';
       |import '../backend/invoker.dart';
       |import '../util/remote_exception.dart';
       |import '../utils.dart';
       |
       |/// A transformer that handles messages from the spawned isolate and ensures
       |/// that messages sent to it are JSON-encodable.
       |///
       |/// The spawned isolate sends three kinds of messages. Data messages are emitted
       |/// as data events, error messages are emitted as error events, and print
       |/// messages are printed using `print()`.
       |// package:test will only send a `Map` across this channel, but users of
       |// `hybridMain` can send any json encodeable type.
      0|final _transformer = StreamChannelTransformer<dynamic, dynamic>(
       |    StreamTransformer.fromHandlers(handleData: (message, sink) {
       |  switch (message['type'] as String) {
       |    case 'data':
       |      sink.add(message['data']);
       |      break;
       |
       |    case 'print':
       |      print(message['line']);
       |      break;
       |
       |    case 'error':
       |      var error = RemoteException.deserialize(message['error']);
       |      sink.addError(error.error, error.stackTrace);
       |      break;
       |  }
       |}), StreamSinkTransformer.fromHandlers(handleData: (message, sink) {
       |  // This is called synchronously from the user's `Sink.add()` call, so if
       |  // [ensureJsonEncodable] throws here they'll get a helpful stack trace.
       |  ensureJsonEncodable(message);
       |  sink.add(message);
       |}));
       |
       |/// Spawns a VM isolate for the given [uri], which may be a [Uri] or a [String].
       |///
       |/// This allows browser tests to spawn servers with which they can communicate
       |/// to test client/server interactions. It can also be used by VM tests to
       |/// easily spawn an isolate.
       |///
       |/// The Dart file at [uri] must define a top-level `hybridMain()` function that
       |/// takes a `StreamChannel` argument and, optionally, an `Object` argument to
       |/// which [message] will be passed. Note that [message] must be JSON-encodable.
       |/// For example:
       |///
       |/// ```dart
       |/// import "package:stream_channel/stream_channel.dart";
       |///
       |/// hybridMain(StreamChannel channel, Object message) {
       |///   // ...
       |/// }
       |/// ```
       |///
       |/// If [uri] is relative, it will be interpreted relative to the `file:` URL for
       |/// the test suite being executed. If it's root-relative (that is, if it begins
       |/// with `/`) it will be interpreted relative to the root of the package (the
       |/// directory that contains `pubspec.yaml`, *not* the `test/` directory). If
       |/// it's a `package:` URL, it will be resolved using the current package's
       |/// dependency constellation.
       |///
       |/// Returns a [StreamChannel] that's connected to the channel passed to
       |/// `hybridMain()`. Only JSON-encodable objects may be sent through this
       |/// channel. If the channel is closed, the hybrid isolate is killed. If the
       |/// isolate is killed, the channel's stream will emit a "done" event.
       |///
       |/// Any unhandled errors loading or running the hybrid isolate will be emitted
       |/// as errors over the channel's stream. Any calls to `print()` in the hybrid
       |/// isolate will be printed as though they came from the test that created the
       |/// isolate.
       |///
       |/// Code in the hybrid isolate is not considered to be running in a test
       |/// context, so it can't access test functions like `expect()` and
       |/// `expectAsync()`.
       |///
       |/// By default, the hybrid isolate is automatically killed when the test
       |/// finishes running. If [stayAlive] is `true`, it won't be killed until the
       |/// entire test suite finishes running.
       |///
       |/// **Note**: If you use this API, be sure to add a dependency on the
       |/// **`stream_channel` package, since you're using its API as well!
      0|StreamChannel spawnHybridUri(uri, {Object message, bool stayAlive = false}) {
       |  Uri parsedUrl;
      0|  if (uri is Uri) {
       |    parsedUrl = uri;
      0|  } else if (uri is String) {
      0|    parsedUrl = Uri.parse(uri);
       |  } else {
      0|    throw ArgumentError.value(uri, 'uri', 'must be a Uri or a String.');
       |  }
       |
       |  String absoluteUri;
      0|  if (parsedUrl.scheme.isEmpty) {
      0|    var isRootRelative = parsedUrl.path.startsWith('/');
       |
       |    // If we're running in a browser context, the working directory is already
       |    // relative to the test file, whereas on the VM the working directory is the
       |    // root of the package.
      0|    if (p.style == p.Style.url) {
       |      if (isRootRelative) {
       |        // A root-relative URL is interpreted as relative to the package root,
       |        // which means placing it beneath the URL secret.
      0|        var secret = Uri.encodeComponent(Uri.base.pathSegments[0]);
      0|        absoluteUri = p.absolute('/$secret$parsedUrl');
      0|        print('Uri.base: ${Uri.base}');
      0|        print('absoluteUri: ${absoluteUri}');
       |      } else {
      0|        absoluteUri = p.absolute(parsedUrl.toString());
       |      }
       |    } else {
       |      if (isRootRelative) {
       |        // We assume that the current path is the package root. `pub run`
       |        // enforces this currently, but at some point it would probably be good
       |        // to pass in an explicit root.
      0|        absoluteUri = p.url
      0|            .join(p.toUri(p.current).toString(), parsedUrl.path.substring(1));
       |      } else {
      0|        var suitePath = Invoker.current.liveTest.suite.path;
      0|        absoluteUri = p.url.join(
      0|            p.url.dirname(p.toUri(p.absolute(suitePath)).toString()),
      0|            parsedUrl.toString());
       |      }
       |    }
       |  } else {
      0|    absoluteUri = uri.toString();
       |  }
       |
      0|  return _spawn(absoluteUri, message, stayAlive: stayAlive);
       |}
       |
       |/// Spawns a VM isolate that runs the given [dartCode], which is loaded as the
       |/// contents of a Dart library.
       |///
       |/// This allows browser tests to spawn servers with which they can communicate
       |/// to test client/server interactions. It can also be used by VM tests to
       |/// easily spawn an isolate.
       |///
       |/// The [dartCode] must define a top-level `hybridMain()` function that takes a
       |/// `StreamChannel` argument and, optionally, an `Object` argument to which
       |/// [message] will be passed. Note that [message] must be JSON-encodable. For
       |/// example:
       |///
       |/// ```dart
       |/// import "package:stream_channel/stream_channel.dart";
       |///
       |/// hybridMain(StreamChannel channel, Object message) {
       |///   // ...
       |/// }
       |/// ```
       |///
       |/// Returns a [StreamChannel] that's connected to the channel passed to
       |/// `hybridMain()`. Only JSON-encodable objects may be sent through this
       |/// channel. If the channel is closed, the hybrid isolate is killed. If the
       |/// isolate is killed, the channel's stream will emit a "done" event.
       |///
       |/// Any unhandled errors loading or running the hybrid isolate will be emitted
       |/// as errors over the channel's stream. Any calls to `print()` in the hybrid
       |/// isolate will be printed as though they came from the test that created the
       |/// isolate.
       |///
       |/// Code in the hybrid isolate is not considered to be running in a test
       |/// context, so it can't access test functions like `expect()` and
       |/// `expectAsync()`.
       |///
       |/// By default, the hybrid isolate is automatically killed when the test
       |/// finishes running. If [stayAlive] is `true`, it won't be killed until the
       |/// entire test suite finishes running.
       |///
       |/// **Note**: If you use this API, be sure to add a dependency on the
       |/// **`stream_channel` package, since you're using its API as well!
      0|StreamChannel spawnHybridCode(String dartCode,
       |    {Object message, bool stayAlive = false}) {
      0|  var uri = Uri.dataFromString(dartCode,
       |      encoding: utf8, mimeType: 'application/dart');
      0|  return _spawn(uri.toString(), message, stayAlive: stayAlive);
       |}
       |
       |/// Like [spawnHybridUri], but doesn't take [Uri] objects and doesn't handle
       |/// relative URLs.
      0|StreamChannel _spawn(String uri, Object message, {bool stayAlive = false}) {
      0|  var channel = Zone.current[#test.runner.test_channel] as MultiChannel;
       |  if (channel == null) {
      0|    throw UnsupportedError("Can't connect to the test runner.\n"
       |        'spawnHybridUri() is currently only supported within "pub run test".');
       |  }
       |
      0|  ensureJsonEncodable(message);
       |
      0|  var virtualChannel = channel.virtualChannel();
       |  StreamChannel isolateChannel = virtualChannel;
      0|  channel.sink.add({
       |    'type': 'spawn-hybrid-uri',
       |    'url': uri,
       |    'message': message,
      0|    'channel': virtualChannel.id
       |  });
       |
       |  if (!stayAlive) {
      0|    var disconnector = Disconnector();
      0|    addTearDown(() => disconnector.disconnect());
      0|    isolateChannel = isolateChannel.transform(disconnector);
       |  }
       |
      0|  return isolateChannel.transform(_transformer);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/stream_matcher.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |import 'format_stack_trace.dart';
       |
       |/// A matcher that matches events from [Stream]s or [StreamQueue]s.
       |///
       |/// Stream matchers are designed to make it straightforward to create complex
       |/// expectations for streams, and to interleave expectations with the rest of a
       |/// test. They can be used on a [Stream] to match all events it emits:
       |///
       |/// ```dart
       |/// expect(stream, emitsInOrder([
       |///   // Values match individual events.
       |///   "Ready.",
       |///
       |///   // Matchers also run against individual events.
       |///   startsWith("Loading took"),
       |///
       |///   // Stream matchers can be nested. This asserts that one of two events are
       |///   // emitted after the "Loading took" line.
       |///   emitsAnyOf(["Succeeded!", "Failed!"]),
       |///
       |///   // By default, more events are allowed after the matcher finishes
       |///   // matching. This asserts instead that the stream emits a done event and
       |///   // nothing else.
       |///   emitsDone
       |/// ]));
       |/// ```
       |///
       |/// It can also match a [StreamQueue], in which case it consumes the matched
       |/// events. The call to [expect] returns a [Future] that completes when the
       |/// matcher is done matching. You can `await` this to consume different events
       |/// at different times:
       |///
       |/// ```dart
       |/// var stdout = StreamQueue(stdoutLineStream);
       |///
       |/// // Ignore lines from the process until it's about to emit the URL.
       |/// await expectLater(stdout, emitsThrough('WebSocket URL:'));
       |///
       |/// // Parse the next line as a URL.
       |/// var url = Uri.parse(await stdout.next);
       |/// expect(url.host, equals('localhost'));
       |///
       |/// // You can match against the same StreamQueue multiple times.
       |/// await expectLater(stdout, emits('Waiting for connection...'));
       |/// ```
       |///
       |/// Users can call [new StreamMatcher] to create custom matchers.
       |abstract class StreamMatcher extends Matcher {
       |  /// The description of this matcher.
       |  ///
       |  /// This is in the subjunctive mood, which means it can be used after the word
       |  /// "should". For example, it might be "emit the right events".
       |  String get description;
       |
       |  /// Creates a new [StreamMatcher] described by [description] that matches
       |  /// events with [matchQueue].
       |  ///
       |  /// The [matchQueue] callback is used to implement [StreamMatcher.matchQueue],
       |  /// and should follow all the guarantees of that method. In particular:
       |  ///
       |  /// * If it matches successfully, it should return `null` and possibly consume
       |  ///   events.
       |  /// * If it fails to match, consume no events and return a description of the
       |  ///   failure.
       |  /// * The description should be in past tense.
       |  /// * The description should be gramatically valid when used after "the
       |  ///   stream""emitted the wrong events", for example.
       |  ///
       |  /// The [matchQueue] callback may return the empty string to indicate a
       |  /// failure if it has no information to add beyond the description of the
       |  /// failure and the events actually emitted by the stream.
       |  ///
       |  /// The [description] should be in the subjunctive mood. This means that it
       |  /// should be grammatically valid when used after the word "should". For
       |  /// example, it might be "emit the right events".
       |  factory StreamMatcher(
       |          Future<String> Function(StreamQueue) matchQueue, String description) =
       |      _StreamMatcher;
       |
       |  /// Tries to match events emitted by [queue].
       |  ///
       |  /// If this matches successfully, it consumes the matching events from [queue]
       |  /// and returns `null`.
       |  ///
       |  /// If this fails to match, it doesn't consume any events and returns a
       |  /// description of the failure. This description is in the past tense, and
       |  /// could grammatically be used after "the stream". For example, it might
       |  /// return "emitted the wrong events".
       |  ///
       |  /// The description string may also be empty, which indicates that the
       |  /// matcher's description and the events actually emitted by the stream are
       |  /// enough to understand the failure.
       |  ///
       |  /// If the queue emits an error, that error is re-thrown unless otherwise
       |  /// indicated by the matcher.
       |  Future<String> matchQueue(StreamQueue queue);
       |}
       |
       |/// A concrete implementation of [StreamMatcher].
       |///
       |/// This is separate from the original type to hide the private [AsyncMatcher]
       |/// interface.
       |class _StreamMatcher extends AsyncMatcher implements StreamMatcher {
       |  @override
       |  final String description;
       |
       |  /// The callback used to implement [matchQueue].
       |  final Future<String> Function(StreamQueue) _matchQueue;
       |
      0|  _StreamMatcher(this._matchQueue, this.description);
       |
      0|  @override
      0|  Future<String> matchQueue(StreamQueue queue) => _matchQueue(queue);
       |
      0|  @override
       |  dynamic /*FutureOr<String>*/ matchAsync(item) {
       |    StreamQueue queue;
       |    var shouldCancelQueue = false;
      0|    if (item is StreamQueue) {
       |      queue = item;
      0|    } else if (item is Stream) {
      0|      queue = StreamQueue(item);
       |      shouldCancelQueue = true;
       |    } else {
       |      return 'was not a Stream or a StreamQueue';
       |    }
       |
       |    // Avoid async/await in the outer method so that we synchronously error out
       |    // for an invalid argument type.
      0|    var transaction = queue.startTransaction();
      0|    var copy = transaction.newQueue();
      0|    return matchQueue(copy).then((result) async {
       |      // Accept the transaction if the result is null, indicating that the match
       |      // succeeded.
       |      if (result == null) {
      0|        transaction.commit(copy);
       |        return null;
       |      }
       |
       |      // Get a list of events emitted by the stream so we can emit them as part
       |      // of the error message.
      0|      var replay = transaction.newQueue();
      0|      var events = <Result>[];
       |      var subscription = Result.captureStreamTransformer
      0|          .bind(replay.rest)
      0|          .listen(events.add, onDone: () => events.add(null));
       |
       |      // Wait on a timer tick so all buffered events are emitted.
      0|      await Future.delayed(Duration.zero);
      0|      unawaited(subscription.cancel());
       |
      0|      var eventsString = events.map((event) {
       |        if (event == null) {
       |          return 'x Stream closed.';
      0|        } else if (event.isValue) {
      0|          return addBullet(event.asValue.value.toString());
       |        } else {
      0|          var error = event.asError;
      0|          var chain = formatStackTrace(error.stackTrace);
      0|          var text = '${error.error}\n$chain';
      0|          return prefixLines(text, '  ', first: '! ');
       |        }
      0|      }).join('\n');
      0|      if (eventsString.isEmpty) eventsString = 'no events';
       |
      0|      transaction.reject();
       |
      0|      var buffer = StringBuffer();
      0|      buffer.writeln(indent(eventsString, first: 'emitted '));
      0|      if (result.isNotEmpty) buffer.writeln(indent(result, first: '  which '));
      0|      return buffer.toString().trimRight();
      0|    }, onError: (error) {
      0|      transaction.reject();
       |      throw error;
      0|    }).then((result) {
      0|      if (shouldCancelQueue) queue.cancel();
       |      return result;
       |    });
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('should ').add(this.description);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/stream_matchers.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |import 'stream_matcher.dart';
       |import 'throws_matcher.dart';
       |
       |/// Returns a [StreamMatcher] that asserts that the stream emits a "done" event.
      0|final emitsDone = StreamMatcher(
       |    (queue) async => (await queue.hasNext) ? '' : null, 'be done');
       |
       |/// Returns a [StreamMatcher] for [matcher].
       |///
       |/// If [matcher] is already a [StreamMatcher], it's returned as-is. If it's any
       |/// other [Matcher], this matches a single event that matches that matcher. If
       |/// it's any other Object, this matches a single event that's equal to that
       |/// object.
       |///
       |/// This functions like [wrapMatcher] for [StreamMatcher]s: it can convert any
       |/// matcher-like value into a proper [StreamMatcher].
      0|StreamMatcher emits(matcher) {
      0|  if (matcher is StreamMatcher) return matcher;
      0|  var wrapped = wrapMatcher(matcher);
       |
      0|  var matcherDescription = wrapped.describe(StringDescription());
       |
      0|  return StreamMatcher((queue) async {
      0|    if (!await queue.hasNext) return '';
       |
      0|    var matchState = {};
      0|    var actual = await queue.next;
      0|    if (wrapped.matches(actual, matchState)) return null;
       |
      0|    var mismatchDescription = StringDescription();
      0|    wrapped.describeMismatch(actual, mismatchDescription, matchState, false);
       |
      0|    if (mismatchDescription.length == 0) return '';
      0|    return 'emitted an event that $mismatchDescription';
       |  },
       |      // TODO(nweiz): add "should" once matcher#42 is fixed.
      0|      'emit an event that $matcherDescription');
       |}
       |
       |/// Returns a [StreamMatcher] that matches a single error event that matches
       |/// [matcher].
      0|StreamMatcher emitsError(matcher) {
      0|  var wrapped = wrapMatcher(matcher);
      0|  var matcherDescription = wrapped.describe(StringDescription());
      0|  var throwsMatcher = throwsA(wrapped) as AsyncMatcher;
       |
      0|  return StreamMatcher(
      0|      (queue) => throwsMatcher.matchAsync(queue.next) as Future<String>,
       |      // TODO(nweiz): add "should" once matcher#42 is fixed.
      0|      'emit an error that $matcherDescription');
       |}
       |
       |/// Returns a [StreamMatcher] that allows (but doesn't require) [matcher] to
       |/// match the stream.
       |///
       |/// This matcher always succeeds; if [matcher] doesn't match, this just consumes
       |/// no events.
      0|StreamMatcher mayEmit(matcher) {
      0|  var streamMatcher = emits(matcher);
      0|  return StreamMatcher((queue) async {
      0|    await queue.withTransaction(
      0|        (copy) async => (await streamMatcher.matchQueue(copy)) == null);
       |    return null;
      0|  }, 'maybe ${streamMatcher.description}');
       |}
       |
       |/// Returns a [StreamMatcher] that matches the stream if at least one of
       |/// [matchers] matches.
       |///
       |/// If multiple matchers match the stream, this chooses the matcher that
       |/// consumes as many events as possible.
       |///
       |/// If any matchers match the stream, no errors from other matchers are thrown.
       |/// If no matchers match and multiple matchers threw errors, the first error is
       |/// re-thrown.
      0|StreamMatcher emitsAnyOf(Iterable matchers) {
      0|  var streamMatchers = matchers.map(emits).toList();
      0|  if (streamMatchers.isEmpty) {
      0|    throw ArgumentError('matcher may not be empty');
       |  }
       |
      0|  if (streamMatchers.length == 1) return streamMatchers.first;
      0|  var description = 'do one of the following:\n' +
      0|      bullet(streamMatchers.map((matcher) => matcher.description));
       |
      0|  return StreamMatcher((queue) async {
      0|    var transaction = queue.startTransaction();
       |
       |    // Allocate the failures list ahead of time so that its order matches the
       |    // order of [matchers], and thus the order the matchers will be listed in
       |    // the description.
      0|    var failures = List<String>(matchers.length);
       |
       |    // The first error thrown. If no matchers match and this exists, we rethrow
       |    // it.
       |    Object firstError;
       |    StackTrace firstStackTrace;
       |
      0|    var futures = <Future>[];
       |    StreamQueue consumedMost;
      0|    for (var i = 0; i < matchers.length; i++) {
      0|      futures.add(() async {
      0|        var copy = transaction.newQueue();
       |
       |        String result;
       |        try {
      0|          result = await streamMatchers[i].matchQueue(copy);
       |        } catch (error, stackTrace) {
       |          if (firstError == null) {
       |            firstError = error;
       |            firstStackTrace = stackTrace;
       |          }
       |          return;
       |        }
       |
       |        if (result != null) {
      0|          failures[i] = result;
       |        } else if (consumedMost == null ||
      0|            consumedMost.eventsDispatched < copy.eventsDispatched) {
       |          consumedMost = copy;
       |        }
      0|      }());
       |    }
       |
      0|    await Future.wait(futures);
       |
       |    if (consumedMost == null) {
      0|      transaction.reject();
       |      if (firstError != null) {
      0|        await Future.error(firstError, firstStackTrace);
       |      }
       |
      0|      var failureMessages = <String>[];
      0|      for (var i = 0; i < matchers.length; i++) {
      0|        var message = 'failed to ${streamMatchers[i].description}';
      0|        if (failures[i].isNotEmpty) {
      0|          message += message.contains('\n') ? '\n' : ' ';
      0|          message += 'because it ${failures[i]}';
       |        }
       |
      0|        failureMessages.add(message);
       |      }
       |
      0|      return 'failed all options:\n${bullet(failureMessages)}';
       |    } else {
      0|      transaction.commit(consumedMost);
       |      return null;
       |    }
       |  }, description);
       |}
       |
       |/// Returns a [StreamMatcher] that matches the stream if each matcher in
       |/// [matchers] matches, one after another.
       |///
       |/// If any matcher fails to match, this fails and consumes no events.
      0|StreamMatcher emitsInOrder(Iterable matchers) {
      0|  var streamMatchers = matchers.map(emits).toList();
      0|  if (streamMatchers.length == 1) return streamMatchers.first;
       |
      0|  var description = 'do the following in order:\n' +
      0|      bullet(streamMatchers.map((matcher) => matcher.description));
       |
      0|  return StreamMatcher((queue) async {
      0|    for (var i = 0; i < streamMatchers.length; i++) {
      0|      var matcher = streamMatchers[i];
      0|      var result = await matcher.matchQueue(queue);
       |      if (result == null) continue;
       |
      0|      var newResult = "didn't ${matcher.description}";
      0|      if (result.isNotEmpty) {
      0|        newResult += newResult.contains('\n') ? '\n' : ' ';
      0|        newResult += 'because it $result';
       |      }
       |      return newResult;
       |    }
       |    return null;
       |  }, description);
       |}
       |
       |/// Returns a [StreamMatcher] that matches any number of events followed by
       |/// events that match [matcher].
       |///
       |/// This consumes all events matched by [matcher], as well as all events before.
       |/// If the stream emits a done event without matching [matcher], this fails and
       |/// consumes no events.
      0|StreamMatcher emitsThrough(matcher) {
      0|  var streamMatcher = emits(matcher);
      0|  return StreamMatcher((queue) async {
      0|    var failures = <String>[];
       |
      0|    Future<bool> tryHere() => queue.withTransaction((copy) async {
      0|          var result = await streamMatcher.matchQueue(copy);
       |          if (result == null) return true;
      0|          failures.add(result);
       |          return false;
       |        });
       |
      0|    while (await queue.hasNext) {
      0|      if (await tryHere()) return null;
      0|      await queue.next;
       |    }
       |
       |    // Try after the queue is done in case the matcher can match an empty
       |    // stream.
      0|    if (await tryHere()) return null;
       |
      0|    var result = 'never did ${streamMatcher.description}';
       |
       |    var failureMessages =
      0|        bullet(failures.where((failure) => failure.isNotEmpty));
      0|    if (failureMessages.isNotEmpty) {
      0|      result += result.contains('\n') ? '\n' : ' ';
      0|      result += 'because it:\n$failureMessages';
       |    }
       |
       |    return result;
      0|  }, 'eventually ${streamMatcher.description}');
       |}
       |
       |/// Returns a [StreamMatcher] that matches any number of events that match
       |/// [matcher].
       |///
       |/// This consumes events until [matcher] no longer matches. It always succeeds;
       |/// if [matcher] doesn't match, this just consumes no events. It never rethrows
       |/// errors.
      0|StreamMatcher mayEmitMultiple(matcher) {
      0|  var streamMatcher = emits(matcher);
       |
      0|  var description = streamMatcher.description;
      0|  description += description.contains('\n') ? '\n' : ' ';
      0|  description += 'zero or more times';
       |
      0|  return StreamMatcher((queue) async {
      0|    while (await _tryMatch(queue, streamMatcher)) {
       |      // Do nothing; the matcher presumably already consumed events.
       |    }
       |    return null;
       |  }, description);
       |}
       |
       |/// Returns a [StreamMatcher] that matches a stream that never matches
       |/// [matcher].
       |///
       |/// This doesn't complete until the stream emits a done event. It never consumes
       |/// any events. It never re-throws errors.
      0|StreamMatcher neverEmits(matcher) {
      0|  var streamMatcher = emits(matcher);
      0|  return StreamMatcher((queue) async {
       |    var events = 0;
       |    var matched = false;
      0|    await queue.withTransaction((copy) async {
      0|      while (await copy.hasNext) {
      0|        matched = await _tryMatch(copy, streamMatcher);
       |        if (matched) return false;
       |
      0|        events++;
       |
       |        try {
      0|          await copy.next;
       |        } catch (_) {
       |          // Ignore errors events.
       |        }
       |      }
       |
      0|      matched = await _tryMatch(copy, streamMatcher);
       |      return false;
       |    });
       |
       |    if (!matched) return null;
      0|    return "after $events ${pluralize('event', events)} did "
      0|        '${streamMatcher.description}';
      0|  }, 'never ${streamMatcher.description}');
       |}
       |
       |/// Returns whether [matcher] matches [queue] at its current position.
       |///
       |/// This treats errors as failures to match.
      0|Future<bool> _tryMatch(StreamQueue queue, StreamMatcher matcher) {
      0|  return queue.withTransaction((copy) async {
       |    try {
      0|      return (await matcher.matchQueue(copy)) == null;
       |    } catch (_) {
       |      return false;
       |    }
       |  });
       |}
       |
       |/// Returns a [StreamMatcher] that matches the stream if each matcher in
       |/// [matchers] matches, in any order.
       |///
       |/// If any matcher fails to match, this fails and consumes no events. If the
       |/// matchers match in multiple different possible orders, this chooses the order
       |/// that consumes as many events as possible.
       |///
       |/// If any sequence of matchers matches the stream, no errors from other
       |/// sequences are thrown. If no sequences match and multiple sequences throw
       |/// errors, the first error is re-thrown.
       |///
       |/// Note that checking every ordering of [matchers] is O(n!) in the worst case,
       |/// so this should only be called when there are very few [matchers].
      0|StreamMatcher emitsInAnyOrder(Iterable matchers) {
      0|  var streamMatchers = matchers.map(emits).toSet();
      0|  if (streamMatchers.length == 1) return streamMatchers.first;
      0|  var description = 'do the following in any order:\n' +
      0|      bullet(streamMatchers.map((matcher) => matcher.description));
       |
      0|  return StreamMatcher(
      0|      (queue) async => await _tryInAnyOrder(queue, streamMatchers) ? null : '',
       |      description);
       |}
       |
       |/// Returns whether [queue] matches [matchers] in any order.
      0|Future<bool> _tryInAnyOrder(
       |    StreamQueue queue, Set<StreamMatcher> matchers) async {
      0|  if (matchers.length == 1) {
      0|    return await matchers.first.matchQueue(queue) == null;
       |  }
       |
      0|  var transaction = queue.startTransaction();
       |  StreamQueue consumedMost;
       |
       |  // The first error thrown. If no matchers match and this exists, we rethrow
       |  // it.
       |  Object firstError;
       |  StackTrace firstStackTrace;
       |
      0|  await Future.wait(matchers.map((matcher) async {
      0|    var copy = transaction.newQueue();
       |    try {
      0|      if (await matcher.matchQueue(copy) != null) return;
       |    } catch (error, stackTrace) {
       |      if (firstError == null) {
       |        firstError = error;
       |        firstStackTrace = stackTrace;
       |      }
       |      return;
       |    }
       |
      0|    var rest = Set<StreamMatcher>.from(matchers);
      0|    rest.remove(matcher);
       |
       |    try {
      0|      if (!await _tryInAnyOrder(copy, rest)) return;
       |    } catch (error, stackTrace) {
       |      if (firstError == null) {
       |        firstError = error;
       |        firstStackTrace = stackTrace;
       |      }
       |      return;
       |    }
       |
       |    if (consumedMost == null ||
      0|        consumedMost.eventsDispatched < copy.eventsDispatched) {
       |      consumedMost = copy;
       |    }
       |  }));
       |
       |  if (consumedMost == null) {
      0|    transaction.reject();
      0|    if (firstError != null) await Future.error(firstError, firstStackTrace);
       |    return false;
       |  } else {
      0|    transaction.commit(consumedMost);
       |    return true;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/tags.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation for applying a set of user-defined tags to a test suite.
       |///
       |/// See [the documentation on tagging tests][tagging tests].
       |///
       |/// [tagging tests]: https://github.com/dart-lang/test/blob/master/README.md#tagging-tests
       |class Tags {
       |  /// The tags for the test suite.
      0|  Set<String> get tags => _tags.toSet();
       |
       |  final Iterable<String> _tags;
       |
       |  /// Applies a set of user-defined tags to a test suite.
      0|  const Tags(this._tags);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/test_on.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation indicating which platforms a test suite supports.
       |///
       |/// For the full syntax of [expression], see [the README][].
       |///
       |/// [the README]: https://github.com/dart-lang/test/tree/master/pkgs/test#platform-selectors
       |class TestOn {
       |  /// The expression specifying the platform.
       |  final String expression;
       |
      0|  const TestOn(this.expression);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/throws_matcher.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../utils.dart';
       |import 'async_matcher.dart';
       |import 'format_stack_trace.dart';
       |
       |/// This function is deprecated.
       |///
       |/// Use [throwsA] instead. We strongly recommend that you add assertions about
       |/// at least the type of the error, but you can write `throwsA(anything)` to
       |/// mimic the behavior of this matcher.
       |@Deprecated('Will be removed in 0.13.0')
       |const Matcher throws = Throws();
       |
       |/// This can be used to match three kinds of objects:
       |///
       |/// * A [Function] that throws an exception when called. The function cannot
       |///   take any arguments. If you want to test that a function expecting
       |///   arguments throws, wrap it in another zero-argument function that calls
       |///   the one you want to test.
       |///
       |/// * A [Future] that completes with an exception. Note that this creates an
       |///   asynchronous expectation. The call to `expect()` that includes this will
       |///   return immediately and execution will continue. Later, when the future
       |///   completes, the actual expectation will run.
       |///
       |/// * A [Function] that returns a [Future] that completes with an exception.
       |///
       |/// In all three cases, when an exception is thrown, this will test that the
       |/// exception object matches [matcher]. If [matcher] is not an instance of
       |/// [Matcher], it will implicitly be treated as `equals(matcher)`.
      3|Matcher throwsA(matcher) => Throws(wrapMatcher(matcher));
       |
       |/// Use the [throwsA] function instead.
       |@Deprecated('Will be removed in 0.13.0')
       |class Throws extends AsyncMatcher {
       |  final Matcher _matcher;
       |
      1|  const Throws([Matcher matcher]) : _matcher = matcher;
       |
       |  // Avoid async/await so we synchronously fail if we match a synchronous
       |  // function.
      1|  @override
       |  dynamic /*FutureOr<String>*/ matchAsync(item) {
      1|    if (item is! Function && item is! Future) {
       |      return 'was not a Function or Future';
       |    }
       |
      1|    if (item is Future) {
      0|      return item.then((value) => indent(prettyPrint(value), first: 'emitted '),
      0|          onError: _check);
       |    }
       |
       |    try {
      1|      var value = item();
      0|      if (value is Future) {
      0|        return value.then(
      0|            (value) => indent(prettyPrint(value),
       |                first: 'returned a Future that emitted '),
      0|            onError: _check);
       |      }
       |
      0|      return indent(prettyPrint(value), first: 'returned ');
       |    } catch (error, trace) {
      1|      return _check(error, trace);
       |    }
       |  }
       |
      0|  @override
       |  Description describe(Description description) {
      0|    if (_matcher == null) {
      0|      return description.add('throws');
       |    } else {
      0|      return description.add('throws ').addDescriptionOf(_matcher);
       |    }
       |  }
       |
       |  /// Verifies that [error] matches [_matcher] and returns a [String]
       |  /// description of the failure if it doesn't.
      1|  String _check(error, StackTrace trace) {
      1|    if (_matcher == null) return null;
       |
      1|    var matchState = {};
      2|    if (_matcher.matches(error, matchState)) return null;
       |
      0|    var result = _matcher
      0|        .describeMismatch(error, StringDescription(), matchState, false)
      0|        .toString();
       |
      0|    var buffer = StringBuffer();
      0|    buffer.writeln(indent(prettyPrint(error), first: 'threw '));
       |    if (trace != null) {
       |      buffer
      0|          .writeln(indent(formatStackTrace(trace).toString(), first: 'stack '));
       |    }
      0|    if (result.isNotEmpty) buffer.writeln(indent(result, first: 'which '));
      0|    return buffer.toString().trimRight();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/utils.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Returns a [Future] that completes after the [event loop][] has run the given
       |/// number of [times] (20 by default).
       |///
       |/// [event loop]: https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a
       |///
       |/// Awaiting this approximates waiting until all asynchronous work (other than
       |/// work that's waiting for external resources) completes.
      0|Future pumpEventQueue({int times}) {
       |  times ??= 20;
      0|  if (times == 0) return Future.value();
       |  // Use the event loop to allow the microtask queue to finish.
      0|  return Future(() => pumpEventQueue(times: times - 1));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.5/lib/src/exception.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'string_scanner.dart';
       |
       |/// An exception thrown by a [StringScanner] that failed to parse a string.
       |class StringScannerException extends SourceSpanFormatException {
      0|  String get source => super.source as String;
       |
       |  /// The URL of the source file being parsed.
       |  ///
       |  /// This may be `null`, indicating that the source URL is unknown.
      0|  Uri get sourceUrl => span.sourceUrl;
       |
      0|  StringScannerException(String message, SourceSpan span, String source)
      0|      : super(message, span, source);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.5/lib/src/line_scanner.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:charcode/ascii.dart';
       |
       |import 'string_scanner.dart';
       |
       |// Note that much of this code is duplicated in eager_span_scanner.dart.
       |
       |/// A regular expression matching newlines across platforms.
      0|final _newlineRegExp = RegExp(r"\r\n?|\n");
       |
       |/// A subclass of [StringScanner] that tracks line and column information.
       |class LineScanner extends StringScanner {
       |  /// The scanner's current (zero-based) line number.
      0|  int get line => _line;
       |  int _line = 0;
       |
       |  /// The scanner's current (zero-based) column number.
      0|  int get column => _column;
       |  int _column = 0;
       |
       |  /// The scanner's state, including line and column information.
       |  ///
       |  /// This can be used to efficiently save and restore the state of the scanner
       |  /// when backtracking. A given [LineScannerState] is only valid for the
       |  /// [LineScanner] that created it.
       |  ///
       |  /// This does not include the scanner's match information.
      0|  LineScannerState get state =>
      0|      LineScannerState._(this, position, line, column);
       |
       |  /// Whether the current position is between a CR character and an LF
       |  /// charactet.
      0|  bool get _betweenCRLF => peekChar(-1) == $cr && peekChar() == $lf;
       |
      0|  set state(LineScannerState state) {
      0|    if (!identical(state._scanner, this)) {
      0|      throw ArgumentError("The given LineScannerState was not returned by "
       |          "this LineScanner.");
       |    }
       |
      0|    super.position = state.position;
      0|    _line = state.line;
      0|    _column = state.column;
       |  }
       |
      0|  set position(int newPosition) {
      0|    var oldPosition = position;
      0|    super.position = newPosition;
       |
      0|    if (newPosition > oldPosition) {
      0|      var newlines = _newlinesIn(string.substring(oldPosition, newPosition));
      0|      _line += newlines.length;
      0|      if (newlines.isEmpty) {
      0|        _column += newPosition - oldPosition;
       |      } else {
      0|        _column = newPosition - newlines.last.end;
       |      }
       |    } else {
      0|      var newlines = _newlinesIn(string.substring(newPosition, oldPosition));
      0|      if (_betweenCRLF) newlines.removeLast();
       |
      0|      _line -= newlines.length;
      0|      if (newlines.isEmpty) {
      0|        _column -= oldPosition - newPosition;
       |      } else {
      0|        _column =
      0|            newPosition - string.lastIndexOf(_newlineRegExp, newPosition) - 1;
       |      }
       |    }
       |  }
       |
      0|  LineScanner(String string, {sourceUrl, int position})
      0|      : super(string, sourceUrl: sourceUrl, position: position);
       |
      0|  bool scanChar(int character) {
      0|    if (!super.scanChar(character)) return false;
      0|    _adjustLineAndColumn(character);
       |    return true;
       |  }
       |
      0|  int readChar() {
      0|    var character = super.readChar();
      0|    _adjustLineAndColumn(character);
       |    return character;
       |  }
       |
       |  /// Adjusts [_line] and [_column] after having consumed [character].
      0|  void _adjustLineAndColumn(int character) {
      0|    if (character == $lf || (character == $cr && peekChar() != $lf)) {
      0|      _line += 1;
      0|      _column = 0;
       |    } else {
      0|      _column += 1;
       |    }
       |  }
       |
      0|  bool scan(Pattern pattern) {
      0|    if (!super.scan(pattern)) return false;
       |
      0|    var newlines = _newlinesIn(lastMatch[0]);
      0|    _line += newlines.length;
      0|    if (newlines.isEmpty) {
      0|      _column += lastMatch[0].length;
       |    } else {
      0|      _column = lastMatch[0].length - newlines.last.end;
       |    }
       |
       |    return true;
       |  }
       |
       |  /// Returns a list of [Match]es describing all the newlines in [text], which
       |  /// is assumed to end at [position].
      0|  List<Match> _newlinesIn(String text) {
      0|    var newlines = _newlineRegExp.allMatches(text).toList();
      0|    if (_betweenCRLF) newlines.removeLast();
       |    return newlines;
       |  }
       |}
       |
       |/// A class representing the state of a [LineScanner].
       |class LineScannerState {
       |  /// The [LineScanner] that created this.
       |  final LineScanner _scanner;
       |
       |  /// The position of the scanner in this state.
       |  final int position;
       |
       |  /// The zero-based line number of the scanner in this state.
       |  final int line;
       |
       |  /// The zero-based column number of the scanner in this state.
       |  final int column;
       |
      0|  LineScannerState._(this._scanner, this.position, this.line, this.column);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.5/lib/src/span_scanner.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'eager_span_scanner.dart';
       |import 'exception.dart';
       |import 'line_scanner.dart';
       |import 'relative_span_scanner.dart';
       |import 'string_scanner.dart';
       |import 'utils.dart';
       |
       |/// A subclass of [LineScanner] that exposes matched ranges as source map
       |/// [FileSpan]s.
       |class SpanScanner extends StringScanner implements LineScanner {
       |  /// The source of the scanner.
       |  ///
       |  /// This caches line break information and is used to generate [FileSpan]s.
       |  final SourceFile _sourceFile;
       |
      0|  int get line => _sourceFile.getLine(position);
      0|  int get column => _sourceFile.getColumn(position);
       |
      0|  LineScannerState get state => _SpanScannerState(this, position);
       |
      0|  set state(LineScannerState state) {
      0|    if (state is! _SpanScannerState ||
      0|        !identical((state as _SpanScannerState)._scanner, this)) {
      0|      throw ArgumentError("The given LineScannerState was not returned by "
       |          "this LineScanner.");
       |    }
       |
      0|    position = state.position;
       |  }
       |
       |  /// The [FileSpan] for [lastMatch].
       |  ///
       |  /// This is the span for the entire match. There's no way to get spans for
       |  /// subgroups since [Match] exposes no information about their positions.
      0|  FileSpan get lastSpan {
      0|    if (lastMatch == null) _lastSpan = null;
      0|    return _lastSpan;
       |  }
       |
       |  FileSpan _lastSpan;
       |
       |  /// The current location of the scanner.
      0|  FileLocation get location => _sourceFile.location(position);
       |
       |  /// Returns an empty span at the current location.
      0|  FileSpan get emptySpan => location.pointSpan();
       |
       |  /// Creates a new [SpanScanner] that starts scanning from [position].
       |  ///
       |  /// [sourceUrl] is used as [SourceLocation.sourceUrl] for the returned
       |  /// [FileSpan]s as well as for error reporting. It can be a [String], a
       |  /// [Uri], or `null`.
      0|  SpanScanner(String string, {sourceUrl, int position})
      0|      : _sourceFile = SourceFile.fromString(string, url: sourceUrl),
      0|        super(string, sourceUrl: sourceUrl, position: position);
       |
       |  /// Creates a new [SpanScanner] that eagerly computes line and column numbers.
       |  ///
       |  /// In general [new SpanScanner] will be more efficient, since it avoids extra
       |  /// computation on every scan. However, eager scanning can be useful for
       |  /// situations where the normal course of parsing frequently involves
       |  /// accessing the current line and column numbers.
       |  ///
       |  /// Note that *only* the `line` and `column` fields on the `SpanScanner`
       |  /// itself and its `LineScannerState` are eagerly computed. To limit their
       |  /// memory footprint, returned spans and locations will still lazily compute
       |  /// their line and column numbers.
       |  factory SpanScanner.eager(String string, {sourceUrl, int position}) =
       |      EagerSpanScanner;
       |
       |  /// Creates a new [SpanScanner] that scans within [span].
       |  ///
       |  /// This scans through [span]`.text, but emits new spans from [span]`.file` in
       |  /// their appropriate relative positions. The [string] field contains only
       |  /// [span]`.text`, and [position], [line], and [column] are all relative to the
       |  /// span.
       |  factory SpanScanner.within(FileSpan span) = RelativeSpanScanner;
       |
       |  /// Creates a [FileSpan] representing the source range between [startState]
       |  /// and the current position.
      0|  FileSpan spanFrom(LineScannerState startState, [LineScannerState endState]) {
      0|    var endPosition = endState == null ? position : endState.position;
      0|    return _sourceFile.span(startState.position, endPosition);
       |  }
       |
      0|  bool matches(Pattern pattern) {
      0|    if (!super.matches(pattern)) {
      0|      _lastSpan = null;
       |      return false;
       |    }
       |
      0|    _lastSpan = _sourceFile.span(position, lastMatch.end);
       |    return true;
       |  }
       |
      0|  void error(String message, {Match match, int position, int length}) {
      0|    validateErrorArgs(string, match, position, length);
       |
      0|    if (match == null && position == null && length == null) match = lastMatch;
      0|    position ??= match == null ? this.position : match.start;
      0|    length ??= match == null ? 0 : match.end - match.start;
       |
      0|    var span = _sourceFile.span(position, position + length);
      0|    throw StringScannerException(message, span, string);
       |  }
       |}
       |
       |/// A class representing the state of a [SpanScanner].
       |class _SpanScannerState implements LineScannerState {
       |  /// The [SpanScanner] that created this.
       |  final SpanScanner _scanner;
       |
       |  final int position;
      0|  int get line => _scanner._sourceFile.getLine(position);
      0|  int get column => _scanner._sourceFile.getColumn(position);
       |
      0|  _SpanScannerState(this._scanner, this.position);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.5/lib/src/string_scanner.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:charcode/charcode.dart';
       |import 'package:meta/meta.dart';
       |import 'package:source_span/source_span.dart';
       |
       |import 'exception.dart';
       |import 'utils.dart';
       |
       |/// A class that scans through a string using [Pattern]s.
       |class StringScanner {
       |  /// The URL of the source of the string being scanned.
       |  ///
       |  /// This is used for error reporting. It may be `null`, indicating that the
       |  /// source URL is unknown or unavailable.
       |  final Uri sourceUrl;
       |
       |  /// The string being scanned through.
       |  final String string;
       |
       |  /// The current position of the scanner in the string, in characters.
      0|  int get position => _position;
      0|  set position(int position) {
      0|    if (position < 0 || position > string.length) {
      0|      throw ArgumentError("Invalid position $position");
       |    }
       |
      0|    _position = position;
      0|    _lastMatch = null;
       |  }
       |
       |  int _position = 0;
       |
       |  /// The data about the previous match made by the scanner.
       |  ///
       |  /// If the last match failed, this will be `null`.
      0|  Match get lastMatch {
       |    // Lazily unset [_lastMatch] so that we avoid extra assignments in
       |    // character-by-character methods that are used in core loops.
      0|    if (_position != _lastMatchPosition) _lastMatch = null;
      0|    return _lastMatch;
       |  }
       |
       |  Match _lastMatch;
       |  int _lastMatchPosition;
       |
       |  /// The portion of the string that hasn't yet been scanned.
      0|  String get rest => string.substring(position);
       |
       |  /// Whether the scanner has completely consumed [string].
      0|  bool get isDone => position == string.length;
       |
       |  /// Creates a new [StringScanner] that starts scanning from [position].
       |  ///
       |  /// [position] defaults to 0, the beginning of the string. [sourceUrl] is the
       |  /// URL of the source of the string being scanned, if available. It can be
       |  /// a [String], a [Uri], or `null`.
      0|  StringScanner(this.string, {sourceUrl, int position})
       |      : sourceUrl =
      0|            sourceUrl is String ? Uri.parse(sourceUrl) : sourceUrl as Uri {
      0|    if (position != null) this.position = position;
       |  }
       |
       |  /// Consumes a single character and returns its character code.
       |  ///
       |  /// This throws a [FormatException] if the string has been fully consumed. It
       |  /// doesn't affect [lastMatch].
      0|  int readChar() {
      0|    if (isDone) _fail("more input");
      0|    return string.codeUnitAt(_position++);
       |  }
       |
       |  /// Returns the character code of the character [offset] away from [position].
       |  ///
       |  /// [offset] defaults to zero, and may be negative to inspect already-consumed
       |  /// characters.
       |  ///
       |  /// This returns `null` if [offset] points outside the string. It doesn't
       |  /// affect [lastMatch].
      0|  int peekChar([int offset]) {
       |    offset ??= 0;
      0|    var index = position + offset;
      0|    if (index < 0 || index >= string.length) return null;
      0|    return string.codeUnitAt(index);
       |  }
       |
       |  /// If the next character in the string is [character], consumes it.
       |  ///
       |  /// Returns whether or not [character] was consumed.
      0|  bool scanChar(int character) {
      0|    if (isDone) return false;
      0|    if (string.codeUnitAt(_position) != character) return false;
      0|    _position++;
       |    return true;
       |  }
       |
       |  /// If the next character in the string is [character], consumes it.
       |  ///
       |  /// If [character] could not be consumed, throws a [FormatException]
       |  /// describing the position of the failure. [name] is used in this error as
       |  /// the expected name of the character being matched; if it's `null`, the
       |  /// character itself is used instead.
      0|  void expectChar(int character, {String name}) {
      0|    if (scanChar(character)) return;
       |
       |    if (name == null) {
      0|      if (character == $backslash) {
       |        name = r'"\"';
      0|      } else if (character == $double_quote) {
       |        name = r'"\""';
       |      } else {
      0|        name = '"${String.fromCharCode(character)}"';
       |      }
       |    }
       |
      0|    _fail(name);
       |  }
       |
       |  /// If [pattern] matches at the current position of the string, scans forward
       |  /// until the end of the match.
       |  ///
       |  /// Returns whether or not [pattern] matched.
      0|  bool scan(Pattern pattern) {
      0|    var success = matches(pattern);
       |    if (success) {
      0|      _position = _lastMatch.end;
      0|      _lastMatchPosition = _position;
       |    }
       |    return success;
       |  }
       |
       |  /// If [pattern] matches at the current position of the string, scans forward
       |  /// until the end of the match.
       |  ///
       |  /// If [pattern] did not match, throws a [FormatException] describing the
       |  /// position of the failure. [name] is used in this error as the expected name
       |  /// of the pattern being matched; if it's `null`, the pattern itself is used
       |  /// instead.
      0|  void expect(Pattern pattern, {String name}) {
      0|    if (scan(pattern)) return;
       |
       |    if (name == null) {
      0|      if (pattern is RegExp) {
      0|        var source = pattern.pattern;
      0|        name = "/$source/";
       |      } else {
       |        name =
      0|            pattern.toString().replaceAll("\\", "\\\\").replaceAll('"', '\\"');
      0|        name = '"$name"';
       |      }
       |    }
      0|    _fail(name);
       |  }
       |
       |  /// If the string has not been fully consumed, this throws a
       |  /// [FormatException].
      0|  void expectDone() {
      0|    if (isDone) return;
      0|    _fail("no more input");
       |  }
       |
       |  /// Returns whether or not [pattern] matches at the current position of the
       |  /// string.
       |  ///
       |  /// This doesn't move the scan pointer forward.
      0|  bool matches(Pattern pattern) {
      0|    _lastMatch = pattern.matchAsPrefix(string, position);
      0|    _lastMatchPosition = _position;
      0|    return _lastMatch != null;
       |  }
       |
       |  /// Returns the substring of [string] between [start] and [end].
       |  ///
       |  /// Unlike [String.substring], [end] defaults to [position] rather than the
       |  /// end of the string.
      0|  String substring(int start, [int end]) {
      0|    end ??= position;
      0|    return string.substring(start, end);
       |  }
       |
       |  /// Throws a [FormatException] with [message] as well as a detailed
       |  /// description of the location of the error in the string.
       |  ///
       |  /// [match] is the match information for the span of the string with which the
       |  /// error is associated. This should be a match returned by this scanner's
       |  /// [lastMatch] property. By default, the error is associated with the last
       |  /// match.
       |  ///
       |  /// If [position] and/or [length] are passed, they are used as the error span
       |  /// instead. If only [length] is passed, [position] defaults to the current
       |  /// position; if only [position] is passed, [length] defaults to 0.
       |  ///
       |  /// It's an error to pass [match] at the same time as [position] or [length].
      0|  @alwaysThrows
       |  void error(String message, {Match match, int position, int length}) {
      0|    validateErrorArgs(string, match, position, length);
       |
      0|    if (match == null && position == null && length == null) match = lastMatch;
      0|    position ??= match == null ? this.position : match.start;
      0|    length ??= match == null ? 0 : match.end - match.start;
       |
      0|    var sourceFile = SourceFile.fromString(string, url: sourceUrl);
      0|    var span = sourceFile.span(position, position + length);
      0|    throw StringScannerException(message, span, string);
       |  }
       |
       |  // TODO(nweiz): Make this handle long lines more gracefully.
       |  /// Throws a [FormatException] describing that [name] is expected at the
       |  /// current position in the string.
      0|  void _fail(String name) {
      0|    error("expected $name.", position: position, length: 0);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.5/lib/src/utils.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'string_scanner.dart';
       |
       |/// Validates the arguments passed to [StringScanner.error].
      0|void validateErrorArgs(String string, Match match, int position, int length) {
       |  if (match != null && (position != null || length != null)) {
      0|    throw ArgumentError("Can't pass both match and position/length.");
       |  }
       |
       |  if (position != null) {
      0|    if (position < 0) {
      0|      throw RangeError("position must be greater than or equal to 0.");
      0|    } else if (position > string.length) {
      0|      throw RangeError("position must be less than or equal to the "
       |          "string length.");
       |    }
       |  }
       |
      0|  if (length != null && length < 0) {
      0|    throw RangeError("length must be greater than or equal to 0.");
       |  }
       |
      0|  if (position != null && length != null && position + length > string.length) {
      0|    throw RangeError("position plus length must not go beyond the end of "
       |        "the string.");
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/span_exception.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'span.dart';
       |
       |/// A class for exceptions that have source span information attached.
       |class SourceSpanException implements Exception {
       |  // This is a getter so that subclasses can override it.
       |  /// A message describing the exception.
      0|  String get message => _message;
       |  final String _message;
       |
       |  // This is a getter so that subclasses can override it.
       |  /// The span associated with this exception.
       |  ///
       |  /// This may be `null` if the source location can't be determined.
      0|  SourceSpan get span => _span;
       |  final SourceSpan _span;
       |
      0|  SourceSpanException(this._message, this._span);
       |
       |  /// Returns a string representation of `this`.
       |  ///
       |  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
       |  /// it indicates an ANSI terminal color escape that should be used to
       |  /// highlight the span's text. If it's `true`, it indicates that the text
       |  /// should be highlighted using the default color. If it's `false` or `null`,
       |  /// it indicates that the text shouldn't be highlighted.
      0|  @override
       |  String toString({color}) {
      0|    if (span == null) return message;
      0|    return 'Error on ${span.message(message, color: color)}';
       |  }
       |}
       |
       |/// A [SourceSpanException] that's also a [FormatException].
       |class SourceSpanFormatException extends SourceSpanException
       |    implements FormatException {
       |  @override
       |  final dynamic source;
       |
      0|  @override
      0|  int get offset => span?.start?.offset;
       |
      0|  SourceSpanFormatException(String message, SourceSpan span, [this.source])
      0|      : super(message, span);
       |}
       |
       |/// A [SourceSpanException] that also highlights some secondary spans to provide
       |/// the user with extra context.
       |///
       |/// Each span has a label ([primaryLabel] for the primary, and the values of the
       |/// [secondarySpans] map for the secondary spans) that's used to indicate to the
       |/// user what that particular span represents.
       |class MultiSourceSpanException extends SourceSpanException {
       |  /// A label to attach to [span] that provides additional information and helps
       |  /// distinguish it from [secondarySpans].
       |  final String primaryLabel;
       |
       |  /// A map whose keys are secondary spans that should be highlighted.
       |  ///
       |  /// Each span's value is a label to attach to that span that provides
       |  /// additional information and helps distinguish it from [secondarySpans].
       |  final Map<SourceSpan, String> secondarySpans;
       |
      0|  MultiSourceSpanException(String message, SourceSpan span, this.primaryLabel,
       |      Map<SourceSpan, String> secondarySpans)
      0|      : secondarySpans = Map.unmodifiable(secondarySpans),
      0|        super(message, span);
       |
       |  /// Returns a string representation of `this`.
       |  ///
       |  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
       |  /// it indicates an ANSI terminal color escape that should be used to
       |  /// highlight the primary span's text. If it's `true`, it indicates that the
       |  /// text should be highlighted using the default color. If it's `false` or
       |  /// `null`, it indicates that the text shouldn't be highlighted.
       |  ///
       |  /// If [color] is `true` or a string, [secondaryColor] is used to highlight
       |  /// [secondarySpans].
      0|  @override
       |  String toString({color, String secondaryColor}) {
      0|    if (span == null) return message;
       |
       |    var useColor = false;
       |    String primaryColor;
      0|    if (color is String) {
       |      useColor = true;
       |      primaryColor = color;
      0|    } else if (color == true) {
       |      useColor = true;
       |    }
       |
      0|    final formatted = span.messageMultiple(
      0|        message, primaryLabel, secondarySpans,
       |        color: useColor,
       |        primaryColor: primaryColor,
       |        secondaryColor: secondaryColor);
      0|    return 'Error on $formatted';
       |  }
       |}
       |
       |/// A [MultiSourceSpanException] that's also a [FormatException].
       |class MultiSourceSpanFormatException extends MultiSourceSpanException
       |    implements FormatException {
       |  @override
       |  final dynamic source;
       |
      0|  @override
      0|  int get offset => span?.start?.offset;
       |
      0|  MultiSourceSpanFormatException(String message, SourceSpan span,
       |      String primaryLabel, Map<SourceSpan, String> secondarySpans,
       |      [this.source])
      0|      : super(message, span, primaryLabel, secondarySpans);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/file.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |import 'dart:typed_data';
       |
       |import 'location.dart';
       |import 'location_mixin.dart';
       |import 'span.dart';
       |import 'span_mixin.dart';
       |import 'span_with_context.dart';
       |
       |// Constants to determine end-of-lines.
       |const int _lf = 10;
       |const int _cr = 13;
       |
       |/// A class representing a source file.
       |///
       |/// This doesn't necessarily have to correspond to a file on disk, just a chunk
       |/// of text usually with a URL associated with it.
       |class SourceFile {
       |  /// The URL where the source file is located.
       |  ///
       |  /// This may be null, indicating that the URL is unknown or unavailable.
       |  final Uri url;
       |
       |  /// An array of offsets for each line beginning in the file.
       |  ///
       |  /// Each offset refers to the first character *after* the newline. If the
       |  /// source file has a trailing newline, the final offset won't actually be in
       |  /// the file.
       |  final _lineStarts = <int>[0];
       |
       |  /// The code points of the characters in the file.
       |  final Uint32List _decodedChars;
       |
       |  /// The length of the file in characters.
      0|  int get length => _decodedChars.length;
       |
       |  /// The number of lines in the file.
      0|  int get lines => _lineStarts.length;
       |
       |  /// The line that the offset fell on the last time [getLine] was called.
       |  ///
       |  /// In many cases, sequential calls to getLine() are for nearby, usually
       |  /// increasing offsets. In that case, we can find the line for an offset
       |  /// quickly by first checking to see if the offset is on the same line as the
       |  /// previous result.
       |  int _cachedLine;
       |
       |  /// This constructor is deprecated.
       |  ///
       |  /// Use [new SourceFile.fromString] instead.
      0|  @Deprecated('Will be removed in 2.0.0')
      0|  SourceFile(String text, {url}) : this.decoded(text.runes, url: url);
       |
       |  /// Creates a new source file from [text].
       |  ///
       |  /// [url] may be either a [String], a [Uri], or `null`.
      0|  SourceFile.fromString(String text, {url})
      0|      : this.decoded(text.codeUnits, url: url);
       |
       |  /// Creates a new source file from a list of decoded code units.
       |  ///
       |  /// [url] may be either a [String], a [Uri], or `null`.
       |  ///
       |  /// Currently, if [decodedChars] contains characters larger than `0xFFFF`,
       |  /// they'll be treated as single characters rather than being split into
       |  /// surrogate pairs. **This behavior is deprecated**. For
       |  /// forwards-compatibility, callers should only pass in characters less than
       |  /// or equal to `0xFFFF`.
      0|  SourceFile.decoded(Iterable<int> decodedChars, {url})
      0|      : url = url is String ? Uri.parse(url) : url as Uri,
      0|        _decodedChars = Uint32List.fromList(decodedChars.toList()) {
      0|    for (var i = 0; i < _decodedChars.length; i++) {
      0|      var c = _decodedChars[i];
      0|      if (c == _cr) {
       |        // Return not followed by newline is treated as a newline
      0|        final j = i + 1;
      0|        if (j >= _decodedChars.length || _decodedChars[j] != _lf) c = _lf;
       |      }
      0|      if (c == _lf) _lineStarts.add(i + 1);
       |    }
       |  }
       |
       |  /// Returns a span from [start] to [end] (exclusive).
       |  ///
       |  /// If [end] isn't passed, it defaults to the end of the file.
      0|  FileSpan span(int start, [int end]) {
      0|    end ??= length;
      0|    return _FileSpan(this, start, end);
       |  }
       |
       |  /// Returns a location at [offset].
      0|  FileLocation location(int offset) => FileLocation._(this, offset);
       |
       |  /// Gets the 0-based line corresponding to [offset].
      0|  int getLine(int offset) {
      0|    if (offset < 0) {
      0|      throw RangeError('Offset may not be negative, was $offset.');
      0|    } else if (offset > length) {
      0|      throw RangeError('Offset $offset must not be greater than the number '
      0|          'of characters in the file, $length.');
       |    }
       |
      0|    if (offset < _lineStarts.first) return -1;
      0|    if (offset >= _lineStarts.last) return _lineStarts.length - 1;
       |
      0|    if (_isNearCachedLine(offset)) return _cachedLine;
       |
      0|    _cachedLine = _binarySearch(offset) - 1;
      0|    return _cachedLine;
       |  }
       |
       |  /// Returns `true` if [offset] is near [_cachedLine].
       |  ///
       |  /// Checks on [_cachedLine] and the next line. If it's on the next line, it
       |  /// updates [_cachedLine] to point to that.
      0|  bool _isNearCachedLine(int offset) {
      0|    if (_cachedLine == null) return false;
       |
       |    // See if it's before the cached line.
      0|    if (offset < _lineStarts[_cachedLine]) return false;
       |
       |    // See if it's on the cached line.
      0|    if (_cachedLine >= _lineStarts.length - 1 ||
      0|        offset < _lineStarts[_cachedLine + 1]) {
       |      return true;
       |    }
       |
       |    // See if it's on the next line.
      0|    if (_cachedLine >= _lineStarts.length - 2 ||
      0|        offset < _lineStarts[_cachedLine + 2]) {
      0|      _cachedLine++;
       |      return true;
       |    }
       |
       |    return false;
       |  }
       |
       |  /// Binary search through [_lineStarts] to find the line containing [offset].
       |  ///
       |  /// Returns the index of the line in [_lineStarts].
      0|  int _binarySearch(int offset) {
       |    var min = 0;
      0|    var max = _lineStarts.length - 1;
      0|    while (min < max) {
      0|      final half = min + ((max - min) ~/ 2);
      0|      if (_lineStarts[half] > offset) {
       |        max = half;
       |      } else {
      0|        min = half + 1;
       |      }
       |    }
       |
       |    return max;
       |  }
       |
       |  /// Gets the 0-based column corresponding to [offset].
       |  ///
       |  /// If [line] is passed, it's assumed to be the line containing [offset] and
       |  /// is used to more efficiently compute the column.
      0|  int getColumn(int offset, {int line}) {
      0|    if (offset < 0) {
      0|      throw RangeError('Offset may not be negative, was $offset.');
      0|    } else if (offset > length) {
      0|      throw RangeError('Offset $offset must be not be greater than the '
      0|          'number of characters in the file, $length.');
       |    }
       |
       |    if (line == null) {
      0|      line = getLine(offset);
      0|    } else if (line < 0) {
      0|      throw RangeError('Line may not be negative, was $line.');
      0|    } else if (line >= lines) {
      0|      throw RangeError('Line $line must be less than the number of '
      0|          'lines in the file, $lines.');
       |    }
       |
      0|    final lineStart = _lineStarts[line];
      0|    if (lineStart > offset) {
      0|      throw RangeError('Line $line comes after offset $offset.');
       |    }
       |
      0|    return offset - lineStart;
       |  }
       |
       |  /// Gets the offset for a [line] and [column].
       |  ///
       |  /// [column] defaults to 0.
      0|  int getOffset(int line, [int column]) {
       |    column ??= 0;
       |
      0|    if (line < 0) {
      0|      throw RangeError('Line may not be negative, was $line.');
      0|    } else if (line >= lines) {
      0|      throw RangeError('Line $line must be less than the number of '
      0|          'lines in the file, $lines.');
      0|    } else if (column < 0) {
      0|      throw RangeError('Column may not be negative, was $column.');
       |    }
       |
      0|    final result = _lineStarts[line] + column;
      0|    if (result > length ||
      0|        (line + 1 < lines && result >= _lineStarts[line + 1])) {
      0|      throw RangeError("Line $line doesn't have $column columns.");
       |    }
       |
       |    return result;
       |  }
       |
       |  /// Returns the text of the file from [start] to [end] (exclusive).
       |  ///
       |  /// If [end] isn't passed, it defaults to the end of the file.
      0|  String getText(int start, [int end]) =>
      0|      String.fromCharCodes(_decodedChars.sublist(start, end));
       |}
       |
       |/// A [SourceLocation] within a [SourceFile].
       |///
       |/// Unlike the base [SourceLocation], [FileLocation] lazily computes its line
       |/// and column values based on its offset and the contents of [file].
       |///
       |/// A [FileLocation] can be created using [SourceFile.location].
       |class FileLocation extends SourceLocationMixin implements SourceLocation {
       |  /// The [file] that `this` belongs to.
       |  final SourceFile file;
       |
       |  @override
       |  final int offset;
       |
      0|  @override
      0|  Uri get sourceUrl => file.url;
       |
      0|  @override
      0|  int get line => file.getLine(offset);
       |
      0|  @override
      0|  int get column => file.getColumn(offset);
       |
      0|  FileLocation._(this.file, this.offset) {
      0|    if (offset < 0) {
      0|      throw RangeError('Offset may not be negative, was $offset.');
      0|    } else if (offset > file.length) {
      0|      throw RangeError('Offset $offset must not be greater than the number '
      0|          'of characters in the file, ${file.length}.');
       |    }
       |  }
       |
      0|  @override
      0|  FileSpan pointSpan() => _FileSpan(file, offset, offset);
       |}
       |
       |/// A [SourceSpan] within a [SourceFile].
       |///
       |/// Unlike the base [SourceSpan], [FileSpan] lazily computes its line and column
       |/// values based on its offset and the contents of [file]. [SourceSpan.message]
       |/// is also able to provide more context then [SourceSpan.message], and
       |/// [SourceSpan.union] will return a [FileSpan] if possible.
       |///
       |/// A [FileSpan] can be created using [SourceFile.span].
       |abstract class FileSpan implements SourceSpanWithContext {
       |  /// The [file] that `this` belongs to.
       |  SourceFile get file;
       |
       |  @override
       |  FileLocation get start;
       |
       |  @override
       |  FileLocation get end;
       |
       |  /// Returns a new span that covers both `this` and [other].
       |  ///
       |  /// Unlike [union], [other] may be disjoint from `this`. If it is, the text
       |  /// between the two will be covered by the returned span.
       |  FileSpan expand(FileSpan other);
       |}
       |
       |/// The implementation of [FileSpan].
       |///
       |/// This is split into a separate class so that `is _FileSpan` checks can be run
       |/// to make certain operations more efficient. If we used `is FileSpan`, that
       |/// would break if external classes implemented the interface.
       |class _FileSpan extends SourceSpanMixin implements FileSpan {
       |  @override
       |  final SourceFile file;
       |
       |  /// The offset of the beginning of the span.
       |  ///
       |  /// [start] is lazily generated from this to avoid allocating unnecessary
       |  /// objects.
       |  final int _start;
       |
       |  /// The offset of the end of the span.
       |  ///
       |  /// [end] is lazily generated from this to avoid allocating unnecessary
       |  /// objects.
       |  final int _end;
       |
      0|  @override
      0|  Uri get sourceUrl => file.url;
       |
      0|  @override
      0|  int get length => _end - _start;
       |
      0|  @override
      0|  FileLocation get start => FileLocation._(file, _start);
       |
      0|  @override
      0|  FileLocation get end => FileLocation._(file, _end);
       |
      0|  @override
      0|  String get text => file.getText(_start, _end);
       |
      0|  @override
       |  String get context {
      0|    final endLine = file.getLine(_end);
      0|    final endColumn = file.getColumn(_end);
       |
       |    int endOffset;
      0|    if (endColumn == 0 && endLine != 0) {
       |      // If [end] is at the very beginning of the line, the span covers the
       |      // previous newline, so we only want to include the previous line in the
       |      // context...
       |
      0|      if (length == 0) {
       |        // ...unless this is a point span, in which case we want to include the
       |        // next line (or the empty string if this is the end of the file).
      0|        return endLine == file.lines - 1
       |            ? ''
      0|            : file.getText(
      0|                file.getOffset(endLine), file.getOffset(endLine + 1));
       |      }
       |
      0|      endOffset = _end;
      0|    } else if (endLine == file.lines - 1) {
       |      // If the span covers the last line of the file, the context should go all
       |      // the way to the end of the file.
      0|      endOffset = file.length;
       |    } else {
       |      // Otherwise, the context should cover the full line on which [end]
       |      // appears.
      0|      endOffset = file.getOffset(endLine + 1);
       |    }
       |
      0|    return file.getText(file.getOffset(file.getLine(_start)), endOffset);
       |  }
       |
      0|  _FileSpan(this.file, this._start, this._end) {
      0|    if (_end < _start) {
      0|      throw ArgumentError('End $_end must come after start $_start.');
      0|    } else if (_end > file.length) {
      0|      throw RangeError('End $_end must not be greater than the number '
      0|          'of characters in the file, ${file.length}.');
      0|    } else if (_start < 0) {
      0|      throw RangeError('Start may not be negative, was $_start.');
       |    }
       |  }
       |
      0|  @override
       |  int compareTo(SourceSpan other) {
      0|    if (other is! _FileSpan) return super.compareTo(other);
       |
       |    final otherFile = other as _FileSpan;
      0|    final result = _start.compareTo(otherFile._start);
      0|    return result == 0 ? _end.compareTo(otherFile._end) : result;
       |  }
       |
      0|  @override
       |  SourceSpan union(SourceSpan other) {
      0|    if (other is! FileSpan) return super.union(other);
       |
      0|    final span = expand(other as _FileSpan);
       |
      0|    if (other is _FileSpan) {
      0|      if (_start > other._end || other._start > _end) {
      0|        throw ArgumentError('Spans $this and $other are disjoint.');
       |      }
       |    } else {
      0|      if (_start > other.end.offset || other.start.offset > _end) {
      0|        throw ArgumentError('Spans $this and $other are disjoint.');
       |      }
       |    }
       |
       |    return span;
       |  }
       |
      0|  @override
       |  bool operator ==(other) {
      0|    if (other is! FileSpan) return super == other;
      0|    if (other is! _FileSpan) {
      0|      return super == other && sourceUrl == other.sourceUrl;
       |    }
       |
      0|    return _start == other._start &&
      0|        _end == other._end &&
      0|        sourceUrl == other.sourceUrl;
       |  }
       |
       |  // Eliminates dart2js warning about overriding `==`, but not `hashCode`
      0|  @override
      0|  int get hashCode => super.hashCode;
       |
       |  /// Returns a new span that covers both `this` and [other].
       |  ///
       |  /// Unlike [union], [other] may be disjoint from `this`. If it is, the text
       |  /// between the two will be covered by the returned span.
      0|  @override
       |  FileSpan expand(FileSpan other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw ArgumentError('Source URLs \"$sourceUrl\" and '
      0|          " \"${other.sourceUrl}\" don't match.");
       |    }
       |
      0|    if (other is _FileSpan) {
      1|      final start = math.min(_start, other._start);
      1|      final end = math.max(_end, other._end);
      0|      return _FileSpan(file, start, end);
       |    } else {
      1|      final start = math.min(_start, other.start.offset);
      1|      final end = math.max(_end, other.end.offset);
      0|      return _FileSpan(file, start, end);
       |    }
       |  }
       |
       |  /// See `SourceSpanExtension.subspan`.
      0|  FileSpan subspan(int start, [int end]) {
      0|    RangeError.checkValidRange(start, end, length);
      0|    if (start == 0 && (end == null || end == length)) return this;
      0|    return file.span(_start + start, end == null ? _end : _start + end);
       |  }
       |}
       |
       |// TODO(#52): Move these to instance methods in the next breaking release.
       |/// Extension methods on the [FileSpan] API.
       |extension FileSpanExtension on FileSpan {
       |  /// See `SourceSpanExtension.subspan`.
      0|  FileSpan subspan(int start, [int end]) {
      0|    RangeError.checkValidRange(start, end, length);
      0|    if (start == 0 && (end == null || end == length)) return this;
       |
      0|    final startOffset = this.start.offset;
      0|    return file.span(
      0|        startOffset + start, end == null ? this.end.offset : startOffset + end);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/location.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'span.dart';
       |
       |// TODO(nweiz): Use SourceLocationMixin once we decide to cut a release with
       |// breaking changes. See SourceLocationMixin for details.
       |
       |/// A class that describes a single location within a source file.
       |///
       |/// This class should not be extended. Instead, [SourceLocationBase] should be
       |/// extended instead.
       |class SourceLocation implements Comparable<SourceLocation> {
       |  /// URL of the source containing this location.
       |  ///
       |  /// This may be null, indicating that the source URL is unknown or
       |  /// unavailable.
       |  final Uri sourceUrl;
       |
       |  /// The 0-based offset of this location in the source.
       |  final int offset;
       |
       |  /// The 0-based line of this location in the source.
       |  final int line;
       |
       |  /// The 0-based column of this location in the source
       |  final int column;
       |
       |  /// Returns a representation of this location in the `source:line:column`
       |  /// format used by text editors.
       |  ///
       |  /// This prints 1-based lines and columns.
      0|  String get toolString {
      0|    final source = sourceUrl ?? 'unknown source';
      0|    return '$source:${line + 1}:${column + 1}';
       |  }
       |
       |  /// Creates a new location indicating [offset] within [sourceUrl].
       |  ///
       |  /// [line] and [column] default to assuming the source is a single line. This
       |  /// means that [line] defaults to 0 and [column] defaults to [offset].
       |  ///
       |  /// [sourceUrl] may be either a [String], a [Uri], or `null`.
      0|  SourceLocation(this.offset, {sourceUrl, int line, int column})
       |      : sourceUrl =
      0|            sourceUrl is String ? Uri.parse(sourceUrl) : sourceUrl as Uri,
       |        line = line ?? 0,
       |        column = column ?? offset {
      0|    if (offset < 0) {
      0|      throw RangeError('Offset may not be negative, was $offset.');
      0|    } else if (line != null && line < 0) {
      0|      throw RangeError('Line may not be negative, was $line.');
      0|    } else if (column != null && column < 0) {
      0|      throw RangeError('Column may not be negative, was $column.');
       |    }
       |  }
       |
       |  /// Returns the distance in characters between `this` and [other].
       |  ///
       |  /// This always returns a non-negative value.
      0|  int distance(SourceLocation other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw ArgumentError('Source URLs \"$sourceUrl\" and '
      0|          "\"${other.sourceUrl}\" don't match.");
       |    }
      0|    return (offset - other.offset).abs();
       |  }
       |
       |  /// Returns a span that covers only a single point: this location.
      0|  SourceSpan pointSpan() => SourceSpan(this, this, '');
       |
       |  /// Compares two locations.
       |  ///
       |  /// [other] must have the same source URL as `this`.
      0|  @override
       |  int compareTo(SourceLocation other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw ArgumentError('Source URLs \"$sourceUrl\" and '
      0|          "\"${other.sourceUrl}\" don't match.");
       |    }
      0|    return offset - other.offset;
       |  }
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is SourceLocation &&
      0|      sourceUrl == other.sourceUrl &&
      0|      offset == other.offset;
       |
      0|  @override
      0|  int get hashCode => sourceUrl.hashCode + offset;
       |
      0|  @override
      0|  String toString() => '<$runtimeType: $offset $toolString>';
       |}
       |
       |/// A base class for source locations with [offset], [line], and [column] known
       |/// at construction time.
       |class SourceLocationBase extends SourceLocation {
      0|  SourceLocationBase(int offset, {sourceUrl, int line, int column})
      0|      : super(offset, sourceUrl: sourceUrl, line: line, column: column);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/location_mixin.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'location.dart';
       |import 'span.dart';
       |
       |// Note: this class duplicates a lot of functionality of [SourceLocation]. This
       |// is because in order for SourceLocation to use SourceLocationMixin,
       |// SourceLocationMixin couldn't implement SourceLocation. In SourceSpan we
       |// handle this by making the class itself non-extensible, but that would be a
       |// breaking change for SourceLocation. So until we want to endure the pain of
       |// cutting a release with breaking changes, we duplicate the code here.
       |
       |/// A mixin for easily implementing [SourceLocation].
       |abstract class SourceLocationMixin implements SourceLocation {
      0|  @override
       |  String get toolString {
      0|    final source = sourceUrl ?? 'unknown source';
      0|    return '$source:${line + 1}:${column + 1}';
       |  }
       |
      0|  @override
       |  int distance(SourceLocation other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw ArgumentError('Source URLs \"$sourceUrl\" and '
      0|          "\"${other.sourceUrl}\" don't match.");
       |    }
      0|    return (offset - other.offset).abs();
       |  }
       |
      0|  @override
      0|  SourceSpan pointSpan() => SourceSpan(this, this, '');
       |
      0|  @override
       |  int compareTo(SourceLocation other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw ArgumentError('Source URLs \"$sourceUrl\" and '
      0|          "\"${other.sourceUrl}\" don't match.");
       |    }
      0|    return offset - other.offset;
       |  }
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is SourceLocation &&
      0|      sourceUrl == other.sourceUrl &&
      0|      offset == other.offset;
       |
      0|  @override
      0|  int get hashCode => sourceUrl.hashCode + offset;
       |
      0|  @override
      0|  String toString() => '<$runtimeType: $offset $toolString>';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/span.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:charcode/charcode.dart';
       |import 'package:path/path.dart' as p;
       |import 'package:term_glyph/term_glyph.dart' as glyph;
       |
       |import 'file.dart';
       |import 'highlighter.dart';
       |import 'location.dart';
       |import 'span_mixin.dart';
       |import 'span_with_context.dart';
       |
       |/// A class that describes a segment of source text.
       |abstract class SourceSpan implements Comparable<SourceSpan> {
       |  /// The start location of this span.
       |  SourceLocation get start;
       |
       |  /// The end location of this span, exclusive.
       |  SourceLocation get end;
       |
       |  /// The source text for this span.
       |  String get text;
       |
       |  /// The URL of the source (typically a file) of this span.
       |  ///
       |  /// This may be null, indicating that the source URL is unknown or
       |  /// unavailable.
       |  Uri get sourceUrl;
       |
       |  /// The length of this span, in characters.
       |  int get length;
       |
       |  /// Creates a new span from [start] to [end] (exclusive) containing [text].
       |  ///
       |  /// [start] and [end] must have the same source URL and [start] must come
       |  /// before [end]. [text] must have a number of characters equal to the
       |  /// distance between [start] and [end].
      0|  factory SourceSpan(SourceLocation start, SourceLocation end, String text) =>
      0|      SourceSpanBase(start, end, text);
       |
       |  /// Creates a new span that's the union of `this` and [other].
       |  ///
       |  /// The two spans must have the same source URL and may not be disjoint.
       |  /// [text] is computed by combining `this.text` and `other.text`.
       |  SourceSpan union(SourceSpan other);
       |
       |  /// Compares two spans.
       |  ///
       |  /// [other] must have the same source URL as `this`. This orders spans by
       |  /// [start] then [length].
       |  @override
       |  int compareTo(SourceSpan other);
       |
       |  /// Formats [message] in a human-friendly way associated with this span.
       |  ///
       |  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
       |  /// it indicates an [ANSI terminal color escape][] that should
       |  /// be used to highlight the span's text (for example, `"\u001b[31m"` will
       |  /// color red). If it's `true`, it indicates that the text should be
       |  /// highlighted using the default color. If it's `false` or `null`, it
       |  /// indicates that the text shouldn't be highlighted.
       |  ///
       |  /// This uses the full range of Unicode characters to highlight the source
       |  /// span if [glyph.ascii] is `false` (the default), but only uses ASCII
       |  /// characters if it's `true`.
       |  ///
       |  /// [ANSI terminal color escape]: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
       |  String message(String message, {color});
       |
       |  /// Prints the text associated with this span in a user-friendly way.
       |  ///
       |  /// This is identical to [message], except that it doesn't print the file
       |  /// name, line number, column number, or message. If [length] is 0 and this
       |  /// isn't a [SourceSpanWithContext], returns an empty string.
       |  ///
       |  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
       |  /// it indicates an [ANSI terminal color escape][] that should
       |  /// be used to highlight the span's text (for example, `"\u001b[31m"` will
       |  /// color red). If it's `true`, it indicates that the text should be
       |  /// highlighted using the default color. If it's `false` or `null`, it
       |  /// indicates that the text shouldn't be highlighted.
       |  ///
       |  /// This uses the full range of Unicode characters to highlight the source
       |  /// span if [glyph.ascii] is `false` (the default), but only uses ASCII
       |  /// characters if it's `true`.
       |  ///
       |  /// [ANSI terminal color escape]: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
       |  String highlight({color});
       |}
       |
       |/// A base class for source spans with [start], [end], and [text] known at
       |/// construction time.
       |class SourceSpanBase extends SourceSpanMixin {
       |  @override
       |  final SourceLocation start;
       |  @override
       |  final SourceLocation end;
       |  @override
       |  final String text;
       |
      0|  SourceSpanBase(this.start, this.end, this.text) {
      0|    if (end.sourceUrl != start.sourceUrl) {
      0|      throw ArgumentError('Source URLs \"${start.sourceUrl}\" and '
      0|          " \"${end.sourceUrl}\" don't match.");
      0|    } else if (end.offset < start.offset) {
      0|      throw ArgumentError('End $end must come after start $start.');
      0|    } else if (text.length != start.distance(end)) {
      0|      throw ArgumentError('Text "$text" must be ${start.distance(end)} '
       |          'characters long.');
       |    }
       |  }
       |}
       |
       |// TODO(#52): Move these to instance methods in the next breaking release.
       |/// Extension methods on the base [SourceSpan] API.
       |extension SourceSpanExtension on SourceSpan {
       |  /// Like [SourceSpan.message], but also highlights [secondarySpans] to provide
       |  /// the user with additional context.
       |  ///
       |  /// Each span takes a label ([label] for this span, and the values of the
       |  /// [secondarySpans] map for the secondary spans) that's used to indicate to
       |  /// the user what that particular span represents.
       |  ///
       |  /// If [color] is `true`, [ANSI terminal color escapes][] are used to color
       |  /// the resulting string. By default this span is colored red and the
       |  /// secondary spans are colored blue, but that can be customized by passing
       |  /// ANSI escape strings to [primaryColor] or [secondaryColor].
       |  ///
       |  /// [ANSI terminal color escapes]: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
       |  ///
       |  /// Each span in [secondarySpans] must refer to the same document as this
       |  /// span. Throws an [ArgumentError] if any secondary span has a different
       |  /// source URL than this span.
       |  ///
       |  /// Note that while this will work with plain [SourceSpan]s, it will produce
       |  /// much more useful output with [SourceSpanWithContext]s (including
       |  /// [FileSpan]s).
      0|  String messageMultiple(
       |      String message, String label, Map<SourceSpan, String> secondarySpans,
       |      {bool color = false, String primaryColor, String secondaryColor}) {
      0|    final buffer = StringBuffer()
      0|      ..write('line ${start.line + 1}, column ${start.column + 1}');
      0|    if (sourceUrl != null) buffer.write(' of ${p.prettyUri(sourceUrl)}');
       |    buffer
      0|      ..writeln(': $message')
      0|      ..write(highlightMultiple(label, secondarySpans,
       |          color: color,
       |          primaryColor: primaryColor,
       |          secondaryColor: secondaryColor));
      0|    return buffer.toString();
       |  }
       |
       |  /// Like [SourceSpan.highlight], but also highlights [secondarySpans] to
       |  /// provide the user with additional context.
       |  ///
       |  /// Each span takes a label ([label] for this span, and the values of the
       |  /// [secondarySpans] map for the secondary spans) that's used to indicate to
       |  /// the user what that particular span represents.
       |  ///
       |  /// If [color] is `true`, [ANSI terminal color escapes][] are used to color
       |  /// the resulting string. By default this span is colored red and the
       |  /// secondary spans are colored blue, but that can be customized by passing
       |  /// ANSI escape strings to [primaryColor] or [secondaryColor].
       |  ///
       |  /// [ANSI terminal color escapes]: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
       |  ///
       |  /// Each span in [secondarySpans] must refer to the same document as this
       |  /// span. Throws an [ArgumentError] if any secondary span has a different
       |  /// source URL than this span.
       |  ///
       |  /// Note that while this will work with plain [SourceSpan]s, it will produce
       |  /// much more useful output with [SourceSpanWithContext]s (including
       |  /// [FileSpan]s).
      0|  String highlightMultiple(String label, Map<SourceSpan, String> secondarySpans,
       |          {bool color = false, String primaryColor, String secondaryColor}) =>
      0|      Highlighter.multiple(this, label, secondarySpans,
       |              color: color,
       |              primaryColor: primaryColor,
       |              secondaryColor: secondaryColor)
      0|          .highlight();
       |
       |  /// Returns a span from [start] code units (inclusive) to [end] code units
       |  /// (exclusive) after the beginning of this span.
      0|  SourceSpan subspan(int start, [int end]) {
      0|    RangeError.checkValidRange(start, end, length);
      0|    if (start == 0 && (end == null || end == length)) return this;
       |
      0|    final text = this.text;
      0|    final startLocation = this.start;
      0|    var line = startLocation.line;
      0|    var column = startLocation.column;
       |
       |    // Adjust [line] and [column] as necessary if the character at [i] in [text]
       |    // is a newline.
      0|    void consumeCodePoint(int i) {
      0|      final codeUnit = text.codeUnitAt(i);
      0|      if (codeUnit == $lf ||
       |          // A carriage return counts as a newline, but only if it's not
       |          // followed by a line feed.
      0|          (codeUnit == $cr &&
      0|              (i + 1 == text.length || text.codeUnitAt(i + 1) != $lf))) {
      0|        line += 1;
       |        column = 0;
       |      } else {
      0|        column += 1;
       |      }
       |    }
       |
      0|    for (var i = 0; i < start; i++) {
      0|      consumeCodePoint(i);
       |    }
       |
      0|    final newStartLocation = SourceLocation(startLocation.offset + start,
      0|        sourceUrl: sourceUrl, line: line, column: column);
       |
       |    SourceLocation newEndLocation;
      0|    if (end == null || end == length) {
      0|      newEndLocation = this.end;
      0|    } else if (end == start) {
       |      newEndLocation = newStartLocation;
      0|    } else if (end != null && end != length) {
      0|      for (var i = start; i < end; i++) {
      0|        consumeCodePoint(i);
       |      }
      0|      newEndLocation = SourceLocation(startLocation.offset + end,
      0|          sourceUrl: sourceUrl, line: line, column: column);
       |    }
       |
      0|    return SourceSpan(
      0|        newStartLocation, newEndLocation, text.substring(start, end));
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/span_mixin.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:path/path.dart' as p;
       |
       |import 'highlighter.dart';
       |import 'span.dart';
       |import 'span_with_context.dart';
       |import 'utils.dart';
       |
       |/// A mixin for easily implementing [SourceSpan].
       |///
       |/// This implements the [SourceSpan] methods in terms of [start], [end], and
       |/// [text]. This assumes that [start] and [end] have the same source URL, that
       |/// [start] comes before [end], and that [text] has a number of characters equal
       |/// to the distance between [start] and [end].
       |abstract class SourceSpanMixin implements SourceSpan {
      0|  @override
      0|  Uri get sourceUrl => start.sourceUrl;
       |
      0|  @override
      0|  int get length => end.offset - start.offset;
       |
      0|  @override
       |  int compareTo(SourceSpan other) {
      0|    final result = start.compareTo(other.start);
      0|    return result == 0 ? end.compareTo(other.end) : result;
       |  }
       |
      0|  @override
       |  SourceSpan union(SourceSpan other) {
      0|    if (sourceUrl != other.sourceUrl) {
      0|      throw ArgumentError('Source URLs \"$sourceUrl\" and '
      0|          " \"${other.sourceUrl}\" don't match.");
       |    }
       |
      0|    final start = min(this.start, other.start);
      0|    final end = max(this.end, other.end);
      0|    final beginSpan = start == this.start ? this : other;
      0|    final endSpan = end == this.end ? this : other;
       |
      0|    if (beginSpan.end.compareTo(endSpan.start) < 0) {
      0|      throw ArgumentError('Spans $this and $other are disjoint.');
       |    }
       |
      0|    final text = beginSpan.text +
      0|        endSpan.text.substring(beginSpan.end.distance(endSpan.start));
      0|    return SourceSpan(start, end, text);
       |  }
       |
      0|  @override
       |  String message(String message, {color}) {
      0|    final buffer = StringBuffer()
      0|      ..write('line ${start.line + 1}, column ${start.column + 1}');
      0|    if (sourceUrl != null) buffer.write(' of ${p.prettyUri(sourceUrl)}');
      0|    buffer.write(': $message');
       |
      0|    final highlight = this.highlight(color: color);
      0|    if (highlight.isNotEmpty) {
       |      buffer
      0|        ..writeln()
      0|        ..write(highlight);
       |    }
       |
      0|    return buffer.toString();
       |  }
       |
      0|  @override
       |  String highlight({color}) {
      0|    if (this is! SourceSpanWithContext && length == 0) return '';
      0|    return Highlighter(this, color: color).highlight();
       |  }
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is SourceSpan && start == other.start && end == other.end;
       |
      0|  @override
      0|  int get hashCode => start.hashCode + (31 * end.hashCode);
       |
      0|  @override
      0|  String toString() => '<$runtimeType: from $start to $end "$text">';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/span_with_context.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'location.dart';
       |import 'span.dart';
       |import 'utils.dart';
       |
       |/// A class that describes a segment of source text with additional context.
       |class SourceSpanWithContext extends SourceSpanBase {
       |  // This is a getter so that subclasses can override it.
       |  /// Text around the span, which includes the line containing this span.
      0|  String get context => _context;
       |  final String _context;
       |
       |  /// Creates a new span from [start] to [end] (exclusive) containing [text], in
       |  /// the given [context].
       |  ///
       |  /// [start] and [end] must have the same source URL and [start] must come
       |  /// before [end]. [text] must have a number of characters equal to the
       |  /// distance between [start] and [end]. [context] must contain [text], and
       |  /// [text] should start at `start.column` from the beginning of a line in
       |  /// [context].
      0|  SourceSpanWithContext(
       |      SourceLocation start, SourceLocation end, String text, this._context)
      0|      : super(start, end, text) {
      0|    if (!context.contains(text)) {
      0|      throw ArgumentError('The context line "$context" must contain "$text".');
       |    }
       |
      0|    if (findLineStart(context, text, start.column) == null) {
      0|      throw ArgumentError('The span text "$text" must start at '
      0|          'column ${start.column + 1} in a line within "$context".');
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/utils.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'span.dart';
       |
       |/// Returns the minimum of [obj1] and [obj2] according to
       |/// [Comparable.compareTo].
      0|T min<T extends Comparable>(T obj1, T obj2) =>
      0|    obj1.compareTo(obj2) > 0 ? obj2 : obj1;
       |
       |/// Returns the maximum of [obj1] and [obj2] according to
       |/// [Comparable.compareTo].
      0|T max<T extends Comparable>(T obj1, T obj2) =>
      0|    obj1.compareTo(obj2) > 0 ? obj1 : obj2;
       |
       |/// Returns whether all elements of [iter] are the same value, according to
       |/// `==`.
       |///
       |/// Assumes [iter] doesn't contain any `null` values.
      0|bool isAllTheSame(Iterable<Object> iter) {
       |  Object lastValue;
      0|  for (var value in iter) {
       |    if (lastValue == null) {
       |      lastValue = value;
      0|    } else if (value != lastValue) {
       |      return false;
       |    }
       |  }
       |  return true;
       |}
       |
       |/// Returns whether [span] covers multiple lines.
      0|bool isMultiline(SourceSpan span) => span.start.line != span.end.line;
       |
       |/// Sets the first `null` element of [list] to [element].
      0|void replaceFirstNull<E>(List<E> list, E element) {
      0|  final index = list.indexOf(null);
      0|  if (index < 0) throw ArgumentError('$list contains no null elements.');
      0|  list[index] = element;
       |}
       |
       |/// Sets the element of [list] that currently contains [element] to `null`.
      0|void replaceWithNull<E>(List<E> list, E element) {
      0|  final index = list.indexOf(element);
      0|  if (index < 0) {
      0|    throw ArgumentError('$list contains no elements matching $element.');
       |  }
       |
      0|  list[index] = null;
       |}
       |
       |/// Returns the number of instances of [codeUnit] in [string].
      0|int countCodeUnits(String string, int codeUnit) {
       |  var count = 0;
      0|  for (var codeUnitToCheck in string.codeUnits) {
      0|    if (codeUnitToCheck == codeUnit) count++;
       |  }
       |  return count;
       |}
       |
       |/// Finds a line in [context] containing [text] at the specified [column].
       |///
       |/// Returns the index in [context] where that line begins, or null if none
       |/// exists.
      0|int findLineStart(String context, String text, int column) {
       |  // If the text is empty, we just want to find the first line that has at least
       |  // [column] characters.
      0|  if (text.isEmpty) {
       |    var beginningOfLine = 0;
       |    while (true) {
      0|      final index = context.indexOf('\n', beginningOfLine);
      0|      if (index == -1) {
      0|        return context.length - beginningOfLine >= column
       |            ? beginningOfLine
       |            : null;
       |      }
       |
      0|      if (index - beginningOfLine >= column) return beginningOfLine;
      0|      beginningOfLine = index + 1;
       |    }
       |  }
       |
      0|  var index = context.indexOf(text);
      0|  while (index != -1) {
       |    // Start looking before [index] in case [text] starts with a newline.
      0|    final lineStart = index == 0 ? 0 : context.lastIndexOf('\n', index - 1) + 1;
      0|    final textColumn = index - lineStart;
      0|    if (column == textColumn) return lineStart;
      0|    index = context.indexOf(text, index + 1);
       |  }
       |  // ignore: avoid_returning_null
       |  return null;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/term_glyph-1.1.0/lib/term_glyph.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |export 'src/generated/glyph_set.dart';
       |export 'src/generated/top_level.dart';
       |
       |import 'src/generated/ascii_glyph_set.dart';
       |import 'src/generated/glyph_set.dart';
       |import 'src/generated/unicode_glyph_set.dart';
       |
       |/// A [GlyphSet] that always returns ASCII glyphs.
       |const GlyphSet asciiGlyphs = const AsciiGlyphSet();
       |
       |/// A [GlyphSet] that always returns Unicode glyphs.
       |const GlyphSet unicodeGlyphs = const UnicodeGlyphSet();
       |
       |/// Returns [asciiGlyphs] if [ascii] is `true` or [unicodeGlyphs] otherwise.
       |///
       |/// Returns [unicodeGlyphs] by default.
      0|GlyphSet get glyphs => _glyphs;
      0|GlyphSet _glyphs = unicodeGlyphs;
       |
       |/// Whether the glyph getters return plain ASCII, as opposed to Unicode
       |/// characters or sequences.
       |///
       |/// Defaults to `false`.
      0|bool get ascii => glyphs == asciiGlyphs;
       |
      0|set ascii(bool value) {
       |  _glyphs = value ? asciiGlyphs : unicodeGlyphs;
       |}
       |
       |/// Returns [glyph] if Unicode glyph are allowed, and [alternative] if they
       |/// aren't.
      0|String glyphOrAscii(String glyph, String alternative) =>
      0|    glyphs.glyphOrAscii(glyph, alternative);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/source_span-1.7.0/lib/src/highlighter.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |
       |import 'package:charcode/charcode.dart';
       |import 'package:collection/collection.dart';
       |import 'package:meta/meta.dart';
       |import 'package:path/path.dart' as p;
       |import 'package:term_glyph/term_glyph.dart' as glyph;
       |
       |import 'colors.dart' as colors;
       |import 'location.dart';
       |import 'span.dart';
       |import 'span_with_context.dart';
       |import 'utils.dart';
       |
       |/// A class for writing a chunk of text with a particular span highlighted.
       |class Highlighter {
       |  /// The lines to display, including context around the highlighted spans.
       |  final List<_Line> _lines;
       |
       |  /// The color to highlight the primary [_Highlight] within its context, or
       |  /// `null` if it should not be colored.
       |  final String _primaryColor;
       |
       |  /// The color to highlight the secondary [_Highlight]s within their context,
       |  /// or `null` if they should not be colored.
       |  final String _secondaryColor;
       |
       |  /// The number of characters before the bar in the sidebar.
       |  final int _paddingBeforeSidebar;
       |
       |  /// The maximum number of multiline spans that cover any part of a single
       |  /// line in [_lines].
       |  final int _maxMultilineSpans;
       |
       |  /// Whether [_lines] includes lines from multiple different files.
       |  final bool _multipleFiles;
       |
       |  /// The buffer to which to write the result.
       |  final _buffer = StringBuffer();
       |
       |  /// The number of spaces to render for hard tabs that appear in `_span.text`.
       |  ///
       |  /// We don't want to render raw tabs, because they'll mess up our character
       |  /// alignment.
       |  static const _spacesPerTab = 4;
       |
       |  /// Creates a [Highlighter] that will return a string highlighting [span]
       |  /// within the text of its file when [highlight] is called.
       |  ///
       |  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
       |  /// it indicates an [ANSI terminal color escape][] that should be used to
       |  /// highlight [span]'s text (for example, `"\u001b[31m"` will color red). If
       |  /// it's `true`, it indicates that the text should be highlighted using the
       |  /// default color. If it's `false` or `null`, it indicates that no color
       |  /// should be used.
       |  ///
       |  /// [ANSI terminal color escape]: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
      0|  Highlighter(SourceSpan span, {color})
      0|      : this._(_collateLines([_Highlight(span, primary: true)]), () {
      0|          if (color == true) return colors.red;
      0|          if (color == false) return null;
       |          return color as String;
      0|        }(), null);
       |
       |  /// Creates a [Highlighter] that will return a string highlighting
       |  /// [primarySpan] as well as all the spans in [secondarySpans] within the text
       |  /// of their file when [highlight] is called.
       |  ///
       |  /// Each span has an associated label that will be written alongside it. For
       |  /// [primarySpan] this message is [primaryLabel], and for [secondarySpans] the
       |  /// labels are the map values.
       |  ///
       |  /// If [color] is `true`, this will use [ANSI terminal color escapes][] to
       |  /// highlight the text. The [primarySpan] will be highlighted with
       |  /// [primaryColor] (which defaults to red), and the [secondarySpans] will be
       |  /// highlighted with [secondaryColor] (which defaults to blue). These
       |  /// arguments are ignored if [color] is `false`.
       |  ///
       |  /// [ANSI terminal color escape]: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
      0|  Highlighter.multiple(SourceSpan primarySpan, String primaryLabel,
       |      Map<SourceSpan, String> secondarySpans,
       |      {bool color = false, String primaryColor, String secondaryColor})
      0|      : this._(
      0|            _collateLines([
      0|              _Highlight(primarySpan, label: primaryLabel, primary: true),
      0|              for (var entry in secondarySpans.entries)
      0|                _Highlight(entry.key, label: entry.value)
       |            ]),
       |            color ? (primaryColor ?? colors.red) : null,
       |            color ? (secondaryColor ?? colors.blue) : null);
       |
      0|  Highlighter._(this._lines, this._primaryColor, this._secondaryColor)
      0|      : _paddingBeforeSidebar = 1 +
      1|            math.max<int>(
       |                // In a purely mathematical world, floor(log10(n)) would give the
       |                // number of digits in n, but floating point errors render that
       |                // unreliable in practice.
      0|                (_lines.last.number + 1).toString().length,
       |                // If [_lines] aren't contiguous, we'll write "..." in place of a
       |                // line number.
      0|                _contiguous(_lines) ? 0 : 3),
       |        _maxMultilineSpans = _lines
      0|            .map((line) => line.highlights
      0|                .where((highlight) => isMultiline(highlight.span))
      0|                .length)
      0|            .reduce(math.max),
      0|        _multipleFiles = !isAllTheSame(_lines.map((line) => line.url));
       |
       |  /// Returns whether [lines] contains any adjacent lines from the same source
       |  /// file that aren't adjacent in the original file.
      0|  static bool _contiguous(List<_Line> lines) {
      0|    for (var i = 0; i < lines.length - 1; i++) {
      0|      final thisLine = lines[i];
      0|      final nextLine = lines[i + 1];
      0|      if (thisLine.number + 1 != nextLine.number &&
      0|          thisLine.url == nextLine.url) {
       |        return false;
       |      }
       |    }
       |    return true;
       |  }
       |
       |  /// Collect all the source lines from the contexts of all spans in
       |  /// [highlights], and associates them with the highlights that cover them.
      0|  static List<_Line> _collateLines(List<_Highlight> highlights) {
       |    final highlightsByUrl =
      0|        groupBy(highlights, (highlight) => highlight.span.sourceUrl);
      0|    for (var list in highlightsByUrl.values) {
      0|      list.sort((highlight1, highlight2) =>
      0|          highlight1.span.compareTo(highlight2.span));
       |    }
       |
      0|    return highlightsByUrl.values.expand((highlightsForFile) {
       |      // First, create a list of all the lines in the current file that we have
       |      // context for along with their line numbers.
      0|      final lines = <_Line>[];
      0|      for (var highlight in highlightsForFile) {
      0|        final context = highlight.span.context;
       |        // If [highlight.span.context] contains lines prior to the one
       |        // [highlight.span.text] appears on, write those first.
      0|        final lineStart = findLineStart(
      0|            context, highlight.span.text, highlight.span.start.column);
       |        assert(lineStart != null); // enforced by [_normalizeContext]
       |
       |        final linesBeforeSpan =
      0|            '\n'.allMatches(context.substring(0, lineStart)).length;
       |
      0|        final url = highlight.span.sourceUrl;
      0|        var lineNumber = highlight.span.start.line - linesBeforeSpan;
      0|        for (var line in context.split('\n')) {
       |          // Only add a line if it hasn't already been added for a previous span.
      0|          if (lines.isEmpty || lineNumber > lines.last.number) {
      0|            lines.add(_Line(line, lineNumber, url));
       |          }
      0|          lineNumber++;
       |        }
       |      }
       |
       |      // Next, associate each line with each highlights that covers it.
      0|      final activeHighlights = <_Highlight>[];
       |      var highlightIndex = 0;
      0|      for (var line in lines) {
      0|        activeHighlights.removeWhere((highlight) =>
      0|            highlight.span.sourceUrl != line.url ||
      0|            highlight.span.end.line < line.number);
       |
      0|        final oldHighlightLength = activeHighlights.length;
      0|        for (var highlight in highlightsForFile.skip(highlightIndex)) {
      0|          if (highlight.span.start.line > line.number) break;
      0|          if (highlight.span.sourceUrl != line.url) break;
      0|          activeHighlights.add(highlight);
       |        }
      0|        highlightIndex += activeHighlights.length - oldHighlightLength;
       |
      0|        line.highlights.addAll(activeHighlights);
       |      }
       |
       |      return lines;
      0|    }).toList();
       |  }
       |
       |  /// Returns the highlighted span text.
       |  ///
       |  /// This method should only be called once.
      0|  String highlight() {
      0|    _writeFileStart(_lines.first.url);
       |
       |    // Each index of this list represents a column after the sidebar that could
       |    // contain a line indicating an active highlight. If it's `null`, that
       |    // column is empty; if it contains a highlight, it should be drawn for that column.
      0|    final highlightsByColumn = List<_Highlight>(_maxMultilineSpans);
       |
      0|    for (var i = 0; i < _lines.length; i++) {
      0|      final line = _lines[i];
      0|      if (i > 0) {
      0|        final lastLine = _lines[i - 1];
      0|        if (lastLine.url != line.url) {
      0|          _writeSidebar(end: glyph.upEnd);
      0|          _buffer.writeln();
      0|          _writeFileStart(line.url);
      0|        } else if (lastLine.number + 1 != line.number) {
      0|          _writeSidebar(text: '...');
      0|          _buffer.writeln();
       |        }
       |      }
       |
       |      // If a highlight covers the entire first line other than initial
       |      // whitespace, don't bother pointing out exactly where it begins. Iterate
       |      // in reverse so that longer highlights (which are sorted after shorter
       |      // highlights) appear further out, leading to fewer crossed lines.
      0|      for (var highlight in line.highlights.reversed) {
      0|        if (isMultiline(highlight.span) &&
      0|            highlight.span.start.line == line.number &&
      0|            _isOnlyWhitespace(
      0|                line.text.substring(0, highlight.span.start.column))) {
      0|          replaceFirstNull(highlightsByColumn, highlight);
       |        }
       |      }
       |
      0|      _writeSidebar(line: line.number);
      0|      _buffer.write(' ');
      0|      _writeMultilineHighlights(line, highlightsByColumn);
      0|      if (highlightsByColumn.isNotEmpty) _buffer.write(' ');
       |
      0|      final primary = line.highlights
      0|          .firstWhere((highlight) => highlight.isPrimary, orElse: () => null);
       |      if (primary != null) {
      0|        _writeHighlightedText(
      0|            line.text,
      0|            primary.span.start.line == line.number
      0|                ? primary.span.start.column
       |                : 0,
      0|            primary.span.end.line == line.number
      0|                ? primary.span.end.column
      0|                : line.text.length,
      0|            color: _primaryColor);
       |      } else {
      0|        _writeText(line.text);
       |      }
      0|      _buffer.writeln();
       |
       |      // Always write the primary span's indicator first so that it's right next
       |      // to the highlighted text.
      0|      if (primary != null) _writeIndicator(line, primary, highlightsByColumn);
      0|      for (var highlight in line.highlights) {
      0|        if (highlight.isPrimary) continue;
      0|        _writeIndicator(line, highlight, highlightsByColumn);
       |      }
       |    }
       |
      0|    _writeSidebar(end: glyph.upEnd);
      0|    return _buffer.toString();
       |  }
       |
       |  /// Writes the beginning of the file highlight for the file with the given
       |  /// [url].
      0|  void _writeFileStart(Uri url) {
      0|    if (!_multipleFiles || url == null) {
      0|      _writeSidebar(end: glyph.downEnd);
       |    } else {
      0|      _writeSidebar(end: glyph.topLeftCorner);
      0|      _colorize(() => _buffer.write('${glyph.horizontalLine * 2}>'),
       |          color: colors.blue);
      0|      _buffer.write(' ${p.prettyUri(url)}');
       |    }
      0|    _buffer.writeln();
       |  }
       |
       |  /// Writes the post-sidebar highlight bars for [line] according to
       |  /// [highlightsByColumn].
       |  ///
       |  /// If [current] is passed, it's the highlight for which an indicator is being
       |  /// written. If it appears in [highlightsByColumn], a horizontal line is
       |  /// written from its column to the rightmost column.
      0|  void _writeMultilineHighlights(
       |      _Line line, List<_Highlight> highlightsByColumn,
       |      {_Highlight current}) {
       |    // Whether we've written a sidebar indicator for opening a new span on this
       |    // line, and which color should be used for that indicator's rightward line.
       |    var openedOnThisLine = false;
       |    String openedOnThisLineColor;
       |
       |    final currentColor = current == null
       |        ? null
      0|        : current.isPrimary ? _primaryColor : _secondaryColor;
       |    var foundCurrent = false;
      0|    for (var highlight in highlightsByColumn) {
      0|      final startLine = highlight?.span?.start?.line;
      0|      final endLine = highlight?.span?.end?.line;
      0|      if (current != null && highlight == current) {
       |        foundCurrent = true;
       |        assert(startLine == line.number || endLine == line.number);
      0|        _colorize(() {
      0|          _buffer.write(startLine == line.number
      0|              ? glyph.topLeftCorner
      0|              : glyph.bottomLeftCorner);
       |        }, color: currentColor);
       |      } else if (foundCurrent) {
      0|        _colorize(() {
      0|          _buffer.write(highlight == null ? glyph.horizontalLine : glyph.cross);
       |        }, color: currentColor);
       |      } else if (highlight == null) {
       |        if (openedOnThisLine) {
      0|          _colorize(() => _buffer.write(glyph.horizontalLine),
       |              color: openedOnThisLineColor);
       |        } else {
      0|          _buffer.write(' ');
       |        }
       |      } else {
      0|        _colorize(() {
      0|          final vertical = openedOnThisLine ? glyph.cross : glyph.verticalLine;
       |          if (current != null) {
      0|            _buffer.write(vertical);
      0|          } else if (startLine == line.number) {
      0|            _colorize(() {
      0|              _buffer
      0|                  .write(glyph.glyphOrAscii(openedOnThisLine ? '' : '', '/'));
       |            }, color: openedOnThisLineColor);
       |            openedOnThisLine = true;
       |            openedOnThisLineColor ??=
      0|                highlight.isPrimary ? _primaryColor : _secondaryColor;
      0|          } else if (endLine == line.number &&
      0|              highlight.span.end.column == line.text.length) {
      0|            _buffer.write(highlight.label == null
      0|                ? glyph.glyphOrAscii('', '\\')
       |                : vertical);
       |          } else {
      0|            _colorize(() {
      0|              _buffer.write(vertical);
       |            }, color: openedOnThisLineColor);
       |          }
      0|        }, color: highlight.isPrimary ? _primaryColor : _secondaryColor);
       |      }
       |    }
       |  }
       |
       |  // Writes [text], with text between [startColumn] and [endColumn] colorized in
       |  // the same way as [_colorize].
      0|  void _writeHighlightedText(String text, int startColumn, int endColumn,
       |      {@required String color}) {
      0|    _writeText(text.substring(0, startColumn));
      0|    _colorize(() => _writeText(text.substring(startColumn, endColumn)),
       |        color: color);
      0|    _writeText(text.substring(endColumn, text.length));
       |  }
       |
       |  /// Writes an indicator for where [highlight] starts, ends, or both below
       |  /// [line].
       |  ///
       |  /// This may either add or remove [highlight] from [highlightsByColumn].
      0|  void _writeIndicator(
       |      _Line line, _Highlight highlight, List<_Highlight> highlightsByColumn) {
      0|    final color = highlight.isPrimary ? _primaryColor : _secondaryColor;
      0|    if (!isMultiline(highlight.span)) {
      0|      _writeSidebar();
      0|      _buffer.write(' ');
      0|      _writeMultilineHighlights(line, highlightsByColumn, current: highlight);
      0|      if (highlightsByColumn.isNotEmpty) _buffer.write(' ');
       |
      0|      _colorize(() {
      0|        _writeUnderline(line, highlight.span,
      0|            highlight.isPrimary ? '^' : glyph.horizontalLineBold);
      0|        _writeLabel(highlight.label);
       |      }, color: color);
      0|      _buffer.writeln();
      0|    } else if (highlight.span.start.line == line.number) {
      0|      if (highlightsByColumn.contains(highlight)) return;
      0|      replaceFirstNull(highlightsByColumn, highlight);
       |
      0|      _writeSidebar();
      0|      _buffer.write(' ');
      0|      _writeMultilineHighlights(line, highlightsByColumn, current: highlight);
      0|      _colorize(() => _writeArrow(line, highlight.span.start.column),
       |          color: color);
      0|      _buffer.writeln();
      0|    } else if (highlight.span.end.line == line.number) {
      0|      final coversWholeLine = highlight.span.end.column == line.text.length;
      0|      if (coversWholeLine && highlight.label == null) {
      0|        replaceWithNull(highlightsByColumn, highlight);
       |        return;
       |      }
       |
      0|      _writeSidebar();
      0|      _buffer.write(' ');
      0|      _writeMultilineHighlights(line, highlightsByColumn, current: highlight);
       |
      0|      _colorize(() {
       |        if (coversWholeLine) {
      0|          _buffer.write(glyph.horizontalLine * 3);
       |        } else {
      1|          _writeArrow(line, math.max(highlight.span.end.column - 1, 0),
       |              beginning: false);
       |        }
      0|        _writeLabel(highlight.label);
       |      }, color: color);
      0|      _buffer.writeln();
      0|      replaceWithNull(highlightsByColumn, highlight);
       |    }
       |  }
       |
       |  /// Underlines the portion of [line] covered by [span] with repeated instances
       |  /// of [character].
      0|  void _writeUnderline(_Line line, SourceSpan span, String character) {
       |    assert(!isMultiline(span));
       |    assert(line.text.contains(span.text));
       |
      0|    var startColumn = span.start.column;
      0|    var endColumn = span.end.column;
       |
       |    // Adjust the start and end columns to account for any tabs that were
       |    // converted to spaces.
      0|    final tabsBefore = _countTabs(line.text.substring(0, startColumn));
      0|    final tabsInside = _countTabs(line.text.substring(startColumn, endColumn));
      0|    startColumn += tabsBefore * (_spacesPerTab - 1);
      0|    endColumn += (tabsBefore + tabsInside) * (_spacesPerTab - 1);
       |
      0|    _buffer
      0|      ..write(' ' * startColumn)
      1|      ..write(character * math.max(endColumn - startColumn, 1));
       |  }
       |
       |  /// Write an arrow pointing to column [column] in [line].
       |  ///
       |  /// If the arrow points to a tab character, this will point to the beginning
       |  /// of the tab if [beginning] is `true` and the end if it's `false`.
      0|  void _writeArrow(_Line line, int column, {bool beginning = true}) {
       |    final tabs =
      0|        _countTabs(line.text.substring(0, column + (beginning ? 0 : 1)));
      0|    _buffer
      0|      ..write(glyph.horizontalLine * (1 + column + tabs * (_spacesPerTab - 1)))
      0|      ..write('^');
       |  }
       |
       |  /// Writes a space followed by [label] if [label] isn't `null`.
      0|  void _writeLabel(String label) {
      0|    if (label != null) _buffer.write(' $label');
       |  }
       |
       |  /// Writes a snippet from the source text, converting hard tab characters into
       |  /// plain indentation.
      0|  void _writeText(String text) {
      0|    for (var char in text.codeUnits) {
      0|      if (char == $tab) {
      0|        _buffer.write(' ' * _spacesPerTab);
       |      } else {
      0|        _buffer.writeCharCode(char);
       |      }
       |    }
       |  }
       |
       |  // Writes a sidebar to [buffer] that includes [line] as the line number if
       |  // given and writes [end] at the end (defaults to [glyphs.verticalLine]).
       |  //
       |  // If [text] is given, it's used in place of the line number. It can't be
       |  // passed at the same time as [line].
      0|  void _writeSidebar({int line, String text, String end}) {
       |    assert(line == null || text == null);
       |
       |    // Add 1 to line to convert from computer-friendly 0-indexed line numbers to
       |    // human-friendly 1-indexed line numbers.
      0|    if (line != null) text = (line + 1).toString();
      0|    _colorize(() {
      0|      _buffer
      0|        ..write((text ?? '').padRight(_paddingBeforeSidebar))
      0|        ..write(end ?? glyph.verticalLine);
       |    }, color: colors.blue);
       |  }
       |
       |  /// Returns the number of hard tabs in [text].
      0|  int _countTabs(String text) {
       |    var count = 0;
      0|    for (var char in text.codeUnits) {
      0|      if (char == $tab) count++;
       |    }
       |    return count;
       |  }
       |
       |  /// Returns whether [text] contains only space or tab characters.
      0|  bool _isOnlyWhitespace(String text) {
      0|    for (var char in text.codeUnits) {
      0|      if (char != $space && char != $tab) return false;
       |    }
       |    return true;
       |  }
       |
       |  /// Colors all text written to [_buffer] during [callback], if colorization is
       |  /// enabled and [color] is not `null`.
      0|  void _colorize(void Function() callback, {@required String color}) {
      0|    if (_primaryColor != null && color != null) _buffer.write(color);
      0|    callback();
      0|    if (_primaryColor != null && color != null) _buffer.write(colors.none);
       |  }
       |}
       |
       |/// Information about how to highlight a single section of a source file.
       |class _Highlight {
       |  /// The section of the source file to highlight.
       |  ///
       |  /// This is normalized to make it easier for [Highlighter] to work with.
       |  final SourceSpanWithContext span;
       |
       |  /// Whether this is the primary span in the highlight.
       |  ///
       |  /// The primary span is highlighted with a different character and colored
       |  /// differently than non-primary spans.
       |  final bool isPrimary;
       |
       |  /// The label to include inline when highlighting [span].
       |  ///
       |  /// This helps distinguish clarify what each highlight means when multiple are
       |  /// used in the same message.
       |  final String label;
       |
      0|  _Highlight(SourceSpan span, {this.label, bool primary = false})
      0|      : span = (() {
      0|          var newSpan = _normalizeContext(span);
      0|          newSpan = _normalizeNewlines(newSpan);
      0|          newSpan = _normalizeTrailingNewline(newSpan);
      0|          return _normalizeEndOfLine(newSpan);
      0|        })(),
       |        isPrimary = primary;
       |
       |  /// Normalizes [span] to ensure that it's a [SourceSpanWithContext] whose
       |  /// context actually contains its text at the expected column.
       |  ///
       |  /// If it's not already a [SourceSpanWithContext], adjust the start and end
       |  /// locations' line and column fields so that the highlighter can assume they
       |  /// match up with the context.
      0|  static SourceSpanWithContext _normalizeContext(SourceSpan span) =>
      0|      span is SourceSpanWithContext &&
      0|              findLineStart(span.context, span.text, span.start.column) != null
       |          ? span
      0|          : SourceSpanWithContext(
      0|              SourceLocation(span.start.offset,
      0|                  sourceUrl: span.sourceUrl, line: 0, column: 0),
      0|              SourceLocation(span.end.offset,
      0|                  sourceUrl: span.sourceUrl,
      0|                  line: countCodeUnits(span.text, $lf),
      0|                  column: _lastLineLength(span.text)),
      0|              span.text,
      0|              span.text);
       |
       |  /// Normalizes [span] to replace Windows-style newlines with Unix-style
       |  /// newlines.
      0|  static SourceSpanWithContext _normalizeNewlines(SourceSpanWithContext span) {
      0|    final text = span.text;
      0|    if (!text.contains('\r\n')) return span;
       |
      0|    var endOffset = span.end.offset;
      0|    for (var i = 0; i < text.length - 1; i++) {
      0|      if (text.codeUnitAt(i) == $cr && text.codeUnitAt(i + 1) == $lf) {
      0|        endOffset--;
       |      }
       |    }
       |
      0|    return SourceSpanWithContext(
      0|        span.start,
      0|        SourceLocation(endOffset,
      0|            sourceUrl: span.sourceUrl,
      0|            line: span.end.line,
      0|            column: span.end.column),
      0|        text.replaceAll('\r\n', '\n'),
      0|        span.context.replaceAll('\r\n', '\n'));
       |  }
       |
       |  /// Normalizes [span] to remove a trailing newline from `span.context`.
       |  ///
       |  /// If necessary, also adjust `span.end` so that it doesn't point past where
       |  /// the trailing newline used to be.
      0|  static SourceSpanWithContext _normalizeTrailingNewline(
       |      SourceSpanWithContext span) {
      0|    if (!span.context.endsWith('\n')) return span;
       |
       |    // If there's a full blank line on the end of [span.context], it's probably
       |    // significant, so we shouldn't trim it.
      0|    if (span.text.endsWith('\n\n')) return span;
       |
      0|    final context = span.context.substring(0, span.context.length - 1);
      0|    var text = span.text;
      0|    var start = span.start;
      0|    var end = span.end;
      0|    if (span.text.endsWith('\n') && _isTextAtEndOfContext(span)) {
      0|      text = span.text.substring(0, span.text.length - 1);
      0|      if (text.isEmpty) {
       |        end = start;
       |      } else {
      0|        end = SourceLocation(span.end.offset - 1,
      0|            sourceUrl: span.sourceUrl,
      0|            line: span.end.line - 1,
      0|            column: _lastLineLength(context));
      0|        start = span.start.offset == span.end.offset ? end : span.start;
       |      }
       |    }
      0|    return SourceSpanWithContext(start, end, text, context);
       |  }
       |
       |  /// Normalizes [span] so that the end location is at the end of a line rather
       |  /// than at the beginning of the next line.
      0|  static SourceSpanWithContext _normalizeEndOfLine(SourceSpanWithContext span) {
      0|    if (span.end.column != 0) return span;
      0|    if (span.end.line == span.start.line) return span;
       |
      0|    final text = span.text.substring(0, span.text.length - 1);
       |
      0|    return SourceSpanWithContext(
      0|        span.start,
      0|        SourceLocation(span.end.offset - 1,
      0|            sourceUrl: span.sourceUrl,
      0|            line: span.end.line - 1,
      0|            column: text.length - text.lastIndexOf('\n') - 1),
       |        text,
       |        // If the context also ends with a newline, it's possible that we don't
       |        // have the full context for that line, so we shouldn't print it at all.
      0|        span.context.endsWith('\n')
      0|            ? span.context.substring(0, span.context.length - 1)
      0|            : span.context);
       |  }
       |
       |  /// Returns the length of the last line in [text], whether or not it ends in a
       |  /// newline.
      0|  static int _lastLineLength(String text) {
      0|    if (text.isEmpty) {
       |      return 0;
      0|    } else if (text.codeUnitAt(text.length - 1) == $lf) {
      0|      return text.length == 1
       |          ? 0
      0|          : text.length - text.lastIndexOf('\n', text.length - 2) - 1;
       |    } else {
      0|      return text.length - text.lastIndexOf('\n') - 1;
       |    }
       |  }
       |
       |  /// Returns whether [span]'s text runs all the way to the end of its context.
      0|  static bool _isTextAtEndOfContext(SourceSpanWithContext span) =>
      0|      findLineStart(span.context, span.text, span.start.column) +
      0|          span.start.column +
      0|          span.length ==
      0|      span.context.length;
       |
      0|  @override
       |  String toString() {
      0|    final buffer = StringBuffer();
      0|    if (isPrimary) buffer.write('primary ');
      0|    buffer.write('${span.start.line}:${span.start.column}-'
      0|        '${span.end.line}:${span.end.column}');
      0|    if (label != null) buffer.write(' ($label)');
      0|    return buffer.toString();
       |  }
       |}
       |
       |/// A single line of the source file being highlighted.
       |class _Line {
       |  /// The text of the line, not including the trailing newline.
       |  final String text;
       |
       |  /// The 0-based line number in the source file.
       |  final int number;
       |
       |  /// The URL of the source file in which this line appears.
       |  final Uri url;
       |
       |  /// All highlights that cover any portion of this line, in source span order.
       |  ///
       |  /// This is populated after the initial line is created.
       |  final highlights = <_Highlight>[];
       |
      0|  _Line(this.text, this.number, this.url);
       |
      0|  @override
      0|  String toString() => '$number: "$text" (${highlights.join(', ')})';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/term_glyph-1.1.0/lib/src/generated/top_level.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// Don't modify this file by hand! It's generated by tool/generate.dart.
       |
       |import '../../term_glyph.dart' as glyph;
       |
       |/// A bullet point.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "*" instead.
      0|String get bullet => glyph.glyphs.bullet;
       |
       |/// A left-pointing arrow.
       |///
       |/// Note that the Unicode arrow glyphs may overlap with adjacent characters in some
       |/// terminal fonts, and should generally be surrounding by spaces.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "<" instead.
      0|String get leftArrow => glyph.glyphs.leftArrow;
       |
       |/// A right-pointing arrow.
       |///
       |/// Note that the Unicode arrow glyphs may overlap with adjacent characters in some
       |/// terminal fonts, and should generally be surrounding by spaces.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// ">" instead.
      0|String get rightArrow => glyph.glyphs.rightArrow;
       |
       |/// An upwards-pointing arrow.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "^" instead.
      0|String get upArrow => glyph.glyphs.upArrow;
       |
       |/// A downwards-pointing arrow.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "v" instead.
      0|String get downArrow => glyph.glyphs.downArrow;
       |
       |/// A two-character left-pointing arrow.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "<=" instead.
      0|String get longLeftArrow => glyph.glyphs.longLeftArrow;
       |
       |/// A two-character right-pointing arrow.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "=>" instead.
      0|String get longRightArrow => glyph.glyphs.longRightArrow;
       |
       |/// A horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get horizontalLine => glyph.glyphs.horizontalLine;
       |
       |/// A vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLine => glyph.glyphs.verticalLine;
       |
       |/// The upper left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "," instead.
      0|String get topLeftCorner => glyph.glyphs.topLeftCorner;
       |
       |/// The upper right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "," instead.
      0|String get topRightCorner => glyph.glyphs.topRightCorner;
       |
       |/// The lower left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "'" instead.
      0|String get bottomLeftCorner => glyph.glyphs.bottomLeftCorner;
       |
       |/// The lower right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "'" instead.
      0|String get bottomRightCorner => glyph.glyphs.bottomRightCorner;
       |
       |/// An intersection of vertical and horizontal box lines.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get cross => glyph.glyphs.cross;
       |
       |/// A horizontal box line with a vertical line going up from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeUp => glyph.glyphs.teeUp;
       |
       |/// A horizontal box line with a vertical line going down from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeDown => glyph.glyphs.teeDown;
       |
       |/// A vertical box line with a horizontal line going left from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeLeft => glyph.glyphs.teeLeft;
       |
       |/// A vertical box line with a horizontal line going right from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeRight => glyph.glyphs.teeRight;
       |
       |/// The top half of a vertical box line.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "'" instead.
      0|String get upEnd => glyph.glyphs.upEnd;
       |
       |/// The bottom half of a vertical box line.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "," instead.
      0|String get downEnd => glyph.glyphs.downEnd;
       |
       |/// The left half of a horizontal box line.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get leftEnd => glyph.glyphs.leftEnd;
       |
       |/// The right half of a horizontal box line.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get rightEnd => glyph.glyphs.rightEnd;
       |
       |/// A bold horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "=" instead.
      0|String get horizontalLineBold => glyph.glyphs.horizontalLineBold;
       |
       |/// A bold vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLineBold => glyph.glyphs.verticalLineBold;
       |
       |/// The bold upper left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "," instead.
      0|String get topLeftCornerBold => glyph.glyphs.topLeftCornerBold;
       |
       |/// The bold upper right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "," instead.
      0|String get topRightCornerBold => glyph.glyphs.topRightCornerBold;
       |
       |/// The bold lower left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "'" instead.
      0|String get bottomLeftCornerBold => glyph.glyphs.bottomLeftCornerBold;
       |
       |/// The bold lower right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "'" instead.
      0|String get bottomRightCornerBold => glyph.glyphs.bottomRightCornerBold;
       |
       |/// An intersection of bold vertical and horizontal box lines.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get crossBold => glyph.glyphs.crossBold;
       |
       |/// A bold horizontal box line with a vertical line going up from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeUpBold => glyph.glyphs.teeUpBold;
       |
       |/// A bold horizontal box line with a vertical line going down from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeDownBold => glyph.glyphs.teeDownBold;
       |
       |/// A bold vertical box line with a horizontal line going left from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeLeftBold => glyph.glyphs.teeLeftBold;
       |
       |/// A bold vertical box line with a horizontal line going right from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeRightBold => glyph.glyphs.teeRightBold;
       |
       |/// The top half of a bold vertical box line.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "'" instead.
      0|String get upEndBold => glyph.glyphs.upEndBold;
       |
       |/// The bottom half of a bold vertical box line.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "," instead.
      0|String get downEndBold => glyph.glyphs.downEndBold;
       |
       |/// The left half of a bold horizontal box line.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get leftEndBold => glyph.glyphs.leftEndBold;
       |
       |/// The right half of a bold horizontal box line.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get rightEndBold => glyph.glyphs.rightEndBold;
       |
       |/// A double horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "=" instead.
      0|String get horizontalLineDouble => glyph.glyphs.horizontalLineDouble;
       |
       |/// A double vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLineDouble => glyph.glyphs.verticalLineDouble;
       |
       |/// The double upper left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "," instead.
      0|String get topLeftCornerDouble => glyph.glyphs.topLeftCornerDouble;
       |
       |/// The double upper right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "," instead.
      0|String get topRightCornerDouble => glyph.glyphs.topRightCornerDouble;
       |
       |/// The double lower left-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// """ instead.
      0|String get bottomLeftCornerDouble => glyph.glyphs.bottomLeftCornerDouble;
       |
       |/// The double lower right-hand corner of a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// """ instead.
      0|String get bottomRightCornerDouble => glyph.glyphs.bottomRightCornerDouble;
       |
       |/// An intersection of double vertical and horizontal box lines.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get crossDouble => glyph.glyphs.crossDouble;
       |
       |/// A double horizontal box line with a vertical line going up from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeUpDouble => glyph.glyphs.teeUpDouble;
       |
       |/// A double horizontal box line with a vertical line going down from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeDownDouble => glyph.glyphs.teeDownDouble;
       |
       |/// A double vertical box line with a horizontal line going left from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeLeftDouble => glyph.glyphs.teeLeftDouble;
       |
       |/// A double vertical box line with a horizontal line going right from the middle.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "+" instead.
      0|String get teeRightDouble => glyph.glyphs.teeRightDouble;
       |
       |/// A dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get horizontalLineDoubleDash => glyph.glyphs.horizontalLineDoubleDash;
       |
       |/// A bold dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get horizontalLineDoubleDashBold =>
      0|    glyph.glyphs.horizontalLineDoubleDashBold;
       |
       |/// A dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLineDoubleDash => glyph.glyphs.verticalLineDoubleDash;
       |
       |/// A bold dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLineDoubleDashBold =>
      0|    glyph.glyphs.verticalLineDoubleDashBold;
       |
       |/// A dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get horizontalLineTripleDash => glyph.glyphs.horizontalLineTripleDash;
       |
       |/// A bold dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get horizontalLineTripleDashBold =>
      0|    glyph.glyphs.horizontalLineTripleDashBold;
       |
       |/// A dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLineTripleDash => glyph.glyphs.verticalLineTripleDash;
       |
       |/// A bold dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLineTripleDashBold =>
      0|    glyph.glyphs.verticalLineTripleDashBold;
       |
       |/// A dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get horizontalLineQuadrupleDash =>
      0|    glyph.glyphs.horizontalLineQuadrupleDash;
       |
       |/// A bold dashed horizontal line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "-" instead.
      0|String get horizontalLineQuadrupleDashBold =>
      0|    glyph.glyphs.horizontalLineQuadrupleDashBold;
       |
       |/// A dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLineQuadrupleDash => glyph.glyphs.verticalLineQuadrupleDash;
       |
       |/// A bold dashed vertical line that can be used to draw a box.
       |///
       |/// If [ascii] is `false`, this is "". If it's `true`, this is
       |/// "|" instead.
      0|String get verticalLineQuadrupleDashBold =>
      0|    glyph.glyphs.verticalLineQuadrupleDashBold;
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/term_glyph-1.1.0/lib/src/generated/ascii_glyph_set.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// Don't modify this file by hand! It's generated by tool/generate.dart.
       |
       |import 'glyph_set.dart';
       |
       |/// A [GlyphSet] that includes only ASCII glyphs.
       |class AsciiGlyphSet implements GlyphSet {
      0|  const AsciiGlyphSet();
       |
       |  /// Returns [glyph] if [this] supports Unicode glyphs and [alternative]
       |  /// otherwise.
      0|  String glyphOrAscii(String glyph, String alternative) => alternative;
       |
       |  /// A bullet point.
       |  ///
       |  /// Always "*" for [this].
      0|  String get bullet => "*";
       |
       |  /// A left-pointing arrow.
       |  ///
       |  /// Note that the Unicode arrow glyphs may overlap with adjacent characters in some
       |  /// terminal fonts, and should generally be surrounding by spaces.
       |  ///
       |  /// Always "<" for [this].
      0|  String get leftArrow => "<";
       |
       |  /// A right-pointing arrow.
       |  ///
       |  /// Note that the Unicode arrow glyphs may overlap with adjacent characters in some
       |  /// terminal fonts, and should generally be surrounding by spaces.
       |  ///
       |  /// Always ">" for [this].
      0|  String get rightArrow => ">";
       |
       |  /// An upwards-pointing arrow.
       |  ///
       |  /// Always "^" for [this].
      0|  String get upArrow => "^";
       |
       |  /// A downwards-pointing arrow.
       |  ///
       |  /// Always "v" for [this].
      0|  String get downArrow => "v";
       |
       |  /// A two-character left-pointing arrow.
       |  ///
       |  /// Always "<=" for [this].
      0|  String get longLeftArrow => "<=";
       |
       |  /// A two-character right-pointing arrow.
       |  ///
       |  /// Always "=>" for [this].
      0|  String get longRightArrow => "=>";
       |
       |  /// A horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "-" for [this].
      0|  String get horizontalLine => "-";
       |
       |  /// A vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLine => "|";
       |
       |  /// The upper left-hand corner of a box.
       |  ///
       |  /// Always "," for [this].
      0|  String get topLeftCorner => ",";
       |
       |  /// The upper right-hand corner of a box.
       |  ///
       |  /// Always "," for [this].
      0|  String get topRightCorner => ",";
       |
       |  /// The lower left-hand corner of a box.
       |  ///
       |  /// Always "'" for [this].
      0|  String get bottomLeftCorner => "'";
       |
       |  /// The lower right-hand corner of a box.
       |  ///
       |  /// Always "'" for [this].
      0|  String get bottomRightCorner => "'";
       |
       |  /// An intersection of vertical and horizontal box lines.
       |  ///
       |  /// Always "+" for [this].
      0|  String get cross => "+";
       |
       |  /// A horizontal box line with a vertical line going up from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeUp => "+";
       |
       |  /// A horizontal box line with a vertical line going down from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeDown => "+";
       |
       |  /// A vertical box line with a horizontal line going left from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeLeft => "+";
       |
       |  /// A vertical box line with a horizontal line going right from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeRight => "+";
       |
       |  /// The top half of a vertical box line.
       |  ///
       |  /// Always "'" for [this].
      0|  String get upEnd => "'";
       |
       |  /// The bottom half of a vertical box line.
       |  ///
       |  /// Always "," for [this].
      0|  String get downEnd => ",";
       |
       |  /// The left half of a horizontal box line.
       |  ///
       |  /// Always "-" for [this].
      0|  String get leftEnd => "-";
       |
       |  /// The right half of a horizontal box line.
       |  ///
       |  /// Always "-" for [this].
      0|  String get rightEnd => "-";
       |
       |  /// A bold horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "=" for [this].
      0|  String get horizontalLineBold => "=";
       |
       |  /// A bold vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLineBold => "|";
       |
       |  /// The bold upper left-hand corner of a box.
       |  ///
       |  /// Always "," for [this].
      0|  String get topLeftCornerBold => ",";
       |
       |  /// The bold upper right-hand corner of a box.
       |  ///
       |  /// Always "," for [this].
      0|  String get topRightCornerBold => ",";
       |
       |  /// The bold lower left-hand corner of a box.
       |  ///
       |  /// Always "'" for [this].
      0|  String get bottomLeftCornerBold => "'";
       |
       |  /// The bold lower right-hand corner of a box.
       |  ///
       |  /// Always "'" for [this].
      0|  String get bottomRightCornerBold => "'";
       |
       |  /// An intersection of bold vertical and horizontal box lines.
       |  ///
       |  /// Always "+" for [this].
      0|  String get crossBold => "+";
       |
       |  /// A bold horizontal box line with a vertical line going up from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeUpBold => "+";
       |
       |  /// A bold horizontal box line with a vertical line going down from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeDownBold => "+";
       |
       |  /// A bold vertical box line with a horizontal line going left from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeLeftBold => "+";
       |
       |  /// A bold vertical box line with a horizontal line going right from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeRightBold => "+";
       |
       |  /// The top half of a bold vertical box line.
       |  ///
       |  /// Always "'" for [this].
      0|  String get upEndBold => "'";
       |
       |  /// The bottom half of a bold vertical box line.
       |  ///
       |  /// Always "," for [this].
      0|  String get downEndBold => ",";
       |
       |  /// The left half of a bold horizontal box line.
       |  ///
       |  /// Always "-" for [this].
      0|  String get leftEndBold => "-";
       |
       |  /// The right half of a bold horizontal box line.
       |  ///
       |  /// Always "-" for [this].
      0|  String get rightEndBold => "-";
       |
       |  /// A double horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "=" for [this].
      0|  String get horizontalLineDouble => "=";
       |
       |  /// A double vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLineDouble => "|";
       |
       |  /// The double upper left-hand corner of a box.
       |  ///
       |  /// Always "," for [this].
      0|  String get topLeftCornerDouble => ",";
       |
       |  /// The double upper right-hand corner of a box.
       |  ///
       |  /// Always "," for [this].
      0|  String get topRightCornerDouble => ",";
       |
       |  /// The double lower left-hand corner of a box.
       |  ///
       |  /// Always '"' for [this].
      0|  String get bottomLeftCornerDouble => '"';
       |
       |  /// The double lower right-hand corner of a box.
       |  ///
       |  /// Always '"' for [this].
      0|  String get bottomRightCornerDouble => '"';
       |
       |  /// An intersection of double vertical and horizontal box lines.
       |  ///
       |  /// Always "+" for [this].
      0|  String get crossDouble => "+";
       |
       |  /// A double horizontal box line with a vertical line going up from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeUpDouble => "+";
       |
       |  /// A double horizontal box line with a vertical line going down from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeDownDouble => "+";
       |
       |  /// A double vertical box line with a horizontal line going left from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeLeftDouble => "+";
       |
       |  /// A double vertical box line with a horizontal line going right from the middle.
       |  ///
       |  /// Always "+" for [this].
      0|  String get teeRightDouble => "+";
       |
       |  /// A dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "-" for [this].
      0|  String get horizontalLineDoubleDash => "-";
       |
       |  /// A bold dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "-" for [this].
      0|  String get horizontalLineDoubleDashBold => "-";
       |
       |  /// A dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLineDoubleDash => "|";
       |
       |  /// A bold dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLineDoubleDashBold => "|";
       |
       |  /// A dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "-" for [this].
      0|  String get horizontalLineTripleDash => "-";
       |
       |  /// A bold dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "-" for [this].
      0|  String get horizontalLineTripleDashBold => "-";
       |
       |  /// A dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLineTripleDash => "|";
       |
       |  /// A bold dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLineTripleDashBold => "|";
       |
       |  /// A dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "-" for [this].
      0|  String get horizontalLineQuadrupleDash => "-";
       |
       |  /// A bold dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "-" for [this].
      0|  String get horizontalLineQuadrupleDashBold => "-";
       |
       |  /// A dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLineQuadrupleDash => "|";
       |
       |  /// A bold dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "|" for [this].
      0|  String get verticalLineQuadrupleDashBold => "|";
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/term_glyph-1.1.0/lib/src/generated/unicode_glyph_set.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// Don't modify this file by hand! It's generated by tool/generate.dart.
       |
       |import 'glyph_set.dart';
       |
       |/// A [GlyphSet] that includes only Unicode glyphs.
       |class UnicodeGlyphSet implements GlyphSet {
      0|  const UnicodeGlyphSet();
       |
       |  /// Returns [glyph] if [this] supports Unicode glyphs and [alternative]
       |  /// otherwise.
      0|  String glyphOrAscii(String glyph, String alternative) => glyph;
       |
       |  /// A bullet point.
       |  ///
       |  /// Always "" for [this].
      0|  String get bullet => "";
       |
       |  /// A left-pointing arrow.
       |  ///
       |  /// Note that the Unicode arrow glyphs may overlap with adjacent characters in some
       |  /// terminal fonts, and should generally be surrounding by spaces.
       |  ///
       |  /// Always "" for [this].
      0|  String get leftArrow => "";
       |
       |  /// A right-pointing arrow.
       |  ///
       |  /// Note that the Unicode arrow glyphs may overlap with adjacent characters in some
       |  /// terminal fonts, and should generally be surrounding by spaces.
       |  ///
       |  /// Always "" for [this].
      0|  String get rightArrow => "";
       |
       |  /// An upwards-pointing arrow.
       |  ///
       |  /// Always "" for [this].
      0|  String get upArrow => "";
       |
       |  /// A downwards-pointing arrow.
       |  ///
       |  /// Always "" for [this].
      0|  String get downArrow => "";
       |
       |  /// A two-character left-pointing arrow.
       |  ///
       |  /// Always "" for [this].
      0|  String get longLeftArrow => "";
       |
       |  /// A two-character right-pointing arrow.
       |  ///
       |  /// Always "" for [this].
      0|  String get longRightArrow => "";
       |
       |  /// A horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLine => "";
       |
       |  /// A vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLine => "";
       |
       |  /// The upper left-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get topLeftCorner => "";
       |
       |  /// The upper right-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get topRightCorner => "";
       |
       |  /// The lower left-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get bottomLeftCorner => "";
       |
       |  /// The lower right-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get bottomRightCorner => "";
       |
       |  /// An intersection of vertical and horizontal box lines.
       |  ///
       |  /// Always "" for [this].
      0|  String get cross => "";
       |
       |  /// A horizontal box line with a vertical line going up from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeUp => "";
       |
       |  /// A horizontal box line with a vertical line going down from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeDown => "";
       |
       |  /// A vertical box line with a horizontal line going left from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeLeft => "";
       |
       |  /// A vertical box line with a horizontal line going right from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeRight => "";
       |
       |  /// The top half of a vertical box line.
       |  ///
       |  /// Always "" for [this].
      0|  String get upEnd => "";
       |
       |  /// The bottom half of a vertical box line.
       |  ///
       |  /// Always "" for [this].
      0|  String get downEnd => "";
       |
       |  /// The left half of a horizontal box line.
       |  ///
       |  /// Always "" for [this].
      0|  String get leftEnd => "";
       |
       |  /// The right half of a horizontal box line.
       |  ///
       |  /// Always "" for [this].
      0|  String get rightEnd => "";
       |
       |  /// A bold horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLineBold => "";
       |
       |  /// A bold vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLineBold => "";
       |
       |  /// The bold upper left-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get topLeftCornerBold => "";
       |
       |  /// The bold upper right-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get topRightCornerBold => "";
       |
       |  /// The bold lower left-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get bottomLeftCornerBold => "";
       |
       |  /// The bold lower right-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get bottomRightCornerBold => "";
       |
       |  /// An intersection of bold vertical and horizontal box lines.
       |  ///
       |  /// Always "" for [this].
      0|  String get crossBold => "";
       |
       |  /// A bold horizontal box line with a vertical line going up from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeUpBold => "";
       |
       |  /// A bold horizontal box line with a vertical line going down from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeDownBold => "";
       |
       |  /// A bold vertical box line with a horizontal line going left from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeLeftBold => "";
       |
       |  /// A bold vertical box line with a horizontal line going right from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeRightBold => "";
       |
       |  /// The top half of a bold vertical box line.
       |  ///
       |  /// Always "" for [this].
      0|  String get upEndBold => "";
       |
       |  /// The bottom half of a bold vertical box line.
       |  ///
       |  /// Always "" for [this].
      0|  String get downEndBold => "";
       |
       |  /// The left half of a bold horizontal box line.
       |  ///
       |  /// Always "" for [this].
      0|  String get leftEndBold => "";
       |
       |  /// The right half of a bold horizontal box line.
       |  ///
       |  /// Always "" for [this].
      0|  String get rightEndBold => "";
       |
       |  /// A double horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLineDouble => "";
       |
       |  /// A double vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLineDouble => "";
       |
       |  /// The double upper left-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get topLeftCornerDouble => "";
       |
       |  /// The double upper right-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get topRightCornerDouble => "";
       |
       |  /// The double lower left-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get bottomLeftCornerDouble => "";
       |
       |  /// The double lower right-hand corner of a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get bottomRightCornerDouble => "";
       |
       |  /// An intersection of double vertical and horizontal box lines.
       |  ///
       |  /// Always "" for [this].
      0|  String get crossDouble => "";
       |
       |  /// A double horizontal box line with a vertical line going up from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeUpDouble => "";
       |
       |  /// A double horizontal box line with a vertical line going down from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeDownDouble => "";
       |
       |  /// A double vertical box line with a horizontal line going left from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeLeftDouble => "";
       |
       |  /// A double vertical box line with a horizontal line going right from the middle.
       |  ///
       |  /// Always "" for [this].
      0|  String get teeRightDouble => "";
       |
       |  /// A dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLineDoubleDash => "";
       |
       |  /// A bold dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLineDoubleDashBold => "";
       |
       |  /// A dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLineDoubleDash => "";
       |
       |  /// A bold dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLineDoubleDashBold => "";
       |
       |  /// A dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLineTripleDash => "";
       |
       |  /// A bold dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLineTripleDashBold => "";
       |
       |  /// A dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLineTripleDash => "";
       |
       |  /// A bold dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLineTripleDashBold => "";
       |
       |  /// A dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLineQuadrupleDash => "";
       |
       |  /// A bold dashed horizontal line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get horizontalLineQuadrupleDashBold => "";
       |
       |  /// A dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLineQuadrupleDash => "";
       |
       |  /// A bold dashed vertical line that can be used to draw a box.
       |  ///
       |  /// Always "" for [this].
      0|  String get verticalLineQuadrupleDashBold => "";
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/context.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |
       |import '../path.dart' as p;
       |import 'characters.dart' as chars;
       |import 'internal_style.dart';
       |import 'parsed_path.dart';
       |import 'path_exception.dart';
       |import 'style.dart';
       |
      2|Context createInternal() => Context._internal();
       |
       |/// An instantiable class for manipulating paths. Unlike the top-level
       |/// functions, this lets you explicitly select what platform the paths will use.
       |class Context {
       |  /// Creates a new path context for the given style and current directory.
       |  ///
       |  /// If [style] is omitted, it uses the host operating system's path style. If
       |  /// only [current] is omitted, it defaults ".". If *both* [style] and
       |  /// [current] are omitted, [current] defaults to the real current working
       |  /// directory.
       |  ///
       |  /// On the browser, [style] defaults to [Style.url] and [current] defaults to
       |  /// the current URL.
      0|  factory Context({Style style, String current}) {
       |    if (current == null) {
       |      if (style == null) {
      0|        current = p.current;
       |      } else {
       |        current = '.';
       |      }
       |    }
       |
       |    if (style == null) {
      0|      style = Style.platform;
      0|    } else if (style is! InternalStyle) {
      0|      throw ArgumentError('Only styles defined by the path package are '
       |          'allowed.');
       |    }
       |
      0|    return Context._(style as InternalStyle, current);
       |  }
       |
       |  /// Create a [Context] to be used internally within path.
      1|  Context._internal()
      1|      : style = Style.platform as InternalStyle,
       |        _current = null;
       |
      0|  Context._(this.style, this._current);
       |
       |  /// The style of path that this context works with.
       |  final InternalStyle style;
       |
       |  /// The current directory given when Context was created. If null, current
       |  /// directory is evaluated from 'p.current'.
       |  final String _current;
       |
       |  /// The current directory that relative paths are relative to.
      3|  String get current => _current ?? p.current;
       |
       |  /// Gets the path separator for the context's [style]. On Mac and Linux,
       |  /// this is `/`. On Windows, it's `\`.
      0|  String get separator => style.separator;
       |
       |  /// Creates a new path by appending the given path parts to [current].
       |  /// Equivalent to [join()] with [current] as the first argument. Example:
       |  ///
       |  ///     var context = Context(current: '/root');
       |  ///     context.absolute('path', 'to', 'foo'); // -> '/root/path/to/foo'
       |  ///
       |  /// If [current] isn't absolute, this won't return an absolute path.
      0|  String absolute(String part1,
       |      [String part2,
       |      String part3,
       |      String part4,
       |      String part5,
       |      String part6,
       |      String part7]) {
      0|    _validateArgList(
      0|        'absolute', [part1, part2, part3, part4, part5, part6, part7]);
       |
       |    // If there's a single absolute path, just return it. This is a lot faster
       |    // for the common case of `p.absolute(path)`.
      0|    if (part2 == null && isAbsolute(part1) && !isRootRelative(part1)) {
       |      return part1;
       |    }
       |
      0|    return join(current, part1, part2, part3, part4, part5, part6, part7);
       |  }
       |
       |  /// Gets the part of [path] after the last separator on the context's
       |  /// platform.
       |  ///
       |  ///     context.basename('path/to/foo.dart'); // -> 'foo.dart'
       |  ///     context.basename('path/to');          // -> 'to'
       |  ///
       |  /// Trailing separators are ignored.
       |  ///
       |  ///     context.basename('path/to/'); // -> 'to'
      0|  String basename(String path) => _parse(path).basename;
       |
       |  /// Gets the part of [path] after the last separator on the context's
       |  /// platform, and without any trailing file extension.
       |  ///
       |  ///     context.basenameWithoutExtension('path/to/foo.dart'); // -> 'foo'
       |  ///
       |  /// Trailing separators are ignored.
       |  ///
       |  ///     context.basenameWithoutExtension('path/to/foo.dart/'); // -> 'foo'
      0|  String basenameWithoutExtension(String path) =>
      0|      _parse(path).basenameWithoutExtension;
       |
       |  /// Gets the part of [path] before the last separator.
       |  ///
       |  ///     context.dirname('path/to/foo.dart'); // -> 'path/to'
       |  ///     context.dirname('path/to');          // -> 'path'
       |  ///
       |  /// Trailing separators are ignored.
       |  ///
       |  ///     context.dirname('path/to/'); // -> 'path'
      0|  String dirname(String path) {
      0|    final parsed = _parse(path);
      0|    parsed.removeTrailingSeparators();
      0|    if (parsed.parts.isEmpty) return parsed.root ?? '.';
      0|    if (parsed.parts.length == 1) return parsed.root ?? '.';
      0|    parsed.parts.removeLast();
      0|    parsed.separators.removeLast();
      0|    parsed.removeTrailingSeparators();
      0|    return parsed.toString();
       |  }
       |
       |  /// Gets the file extension of [path]: the portion of [basename] from the last
       |  /// `.` to the end (including the `.` itself).
       |  ///
       |  ///     context.extension('path/to/foo.dart'); // -> '.dart'
       |  ///     context.extension('path/to/foo'); // -> ''
       |  ///     context.extension('path.to/foo'); // -> ''
       |  ///     context.extension('path/to/foo.dart.js'); // -> '.js'
       |  ///
       |  /// If the file name starts with a `.`, then it is not considered an
       |  /// extension:
       |  ///
       |  ///     context.extension('~/.bashrc');    // -> ''
       |  ///     context.extension('~/.notes.txt'); // -> '.txt'
       |  ///
       |  /// Takes an optional parameter `level` which makes possible to return
       |  /// multiple extensions having `level` number of dots. If `level` exceeds the
       |  /// number of dots, the full extension is returned. The value of `level` must
       |  /// be greater than 0, else `RangeError` is thrown.
       |  ///
       |  ///     context.extension('foo.bar.dart.js', 2);   // -> '.dart.js
       |  ///     context.extension('foo.bar.dart.js', 3);   // -> '.bar.dart.js'
       |  ///     context.extension('foo.bar.dart.js', 10);  // -> '.bar.dart.js'
       |  ///     context.extension('path/to/foo.bar.dart.js', 2);  // -> '.dart.js'
      0|  String extension(String path, [int level = 1]) =>
      0|      _parse(path).extension(level);
       |
       |  /// Returns the root of [path] if it's absolute, or an empty string if it's
       |  /// relative.
       |  ///
       |  ///     // Unix
       |  ///     context.rootPrefix('path/to/foo'); // -> ''
       |  ///     context.rootPrefix('/path/to/foo'); // -> '/'
       |  ///
       |  ///     // Windows
       |  ///     context.rootPrefix(r'path\to\foo'); // -> ''
       |  ///     context.rootPrefix(r'C:\path\to\foo'); // -> r'C:\'
       |  ///     context.rootPrefix(r'\\server\share\a\b'); // -> r'\\server\share'
       |  ///
       |  ///     // URL
       |  ///     context.rootPrefix('path/to/foo'); // -> ''
       |  ///     context.rootPrefix('https://dart.dev/path/to/foo');
       |  ///       // -> 'https://dart.dev'
      0|  String rootPrefix(String path) => path.substring(0, style.rootLength(path));
       |
       |  /// Returns `true` if [path] is an absolute path and `false` if it is a
       |  /// relative path.
       |  ///
       |  /// On POSIX systems, absolute paths start with a `/` (forward slash). On
       |  /// Windows, an absolute path starts with `\\`, or a drive letter followed by
       |  /// `:/` or `:\`. For URLs, absolute paths either start with a protocol and
       |  /// optional hostname (e.g. `https://dart.dev`, `file://`) or with a `/`.
       |  ///
       |  /// URLs that start with `/` are known as "root-relative", since they're
       |  /// relative to the root of the current URL. Since root-relative paths are
       |  /// still absolute in every other sense, [isAbsolute] will return true for
       |  /// them. They can be detected using [isRootRelative].
      4|  bool isAbsolute(String path) => style.rootLength(path) > 0;
       |
       |  /// Returns `true` if [path] is a relative path and `false` if it is absolute.
       |  /// On POSIX systems, absolute paths start with a `/` (forward slash). On
       |  /// Windows, an absolute path starts with `\\`, or a drive letter followed by
       |  /// `:/` or `:\`.
      2|  bool isRelative(String path) => !isAbsolute(path);
       |
       |  /// Returns `true` if [path] is a root-relative path and `false` if it's not.
       |  ///
       |  /// URLs that start with `/` are known as "root-relative", since they're
       |  /// relative to the root of the current URL. Since root-relative paths are
       |  /// still absolute in every other sense, [isAbsolute] will return true for
       |  /// them. They can be detected using [isRootRelative].
       |  ///
       |  /// No POSIX and Windows paths are root-relative.
      3|  bool isRootRelative(String path) => style.isRootRelative(path);
       |
       |  /// Joins the given path parts into a single path. Example:
       |  ///
       |  ///     context.join('path', 'to', 'foo'); // -> 'path/to/foo'
       |  ///
       |  /// If any part ends in a path separator, then a redundant separator will not
       |  /// be added:
       |  ///
       |  ///     context.join('path/', 'to', 'foo'); // -> 'path/to/foo
       |  ///
       |  /// If a part is an absolute path, then anything before that will be ignored:
       |  ///
       |  ///     context.join('path', '/to', 'foo'); // -> '/to/foo'
       |  ///
      0|  String join(String part1,
       |      [String part2,
       |      String part3,
       |      String part4,
       |      String part5,
       |      String part6,
       |      String part7,
       |      String part8]) {
      0|    final parts = <String>[
       |      part1,
       |      part2,
       |      part3,
       |      part4,
       |      part5,
       |      part6,
       |      part7,
       |      part8
       |    ];
      0|    _validateArgList('join', parts);
      0|    return joinAll(parts.where((part) => part != null));
       |  }
       |
       |  /// Joins the given path parts into a single path. Example:
       |  ///
       |  ///     context.joinAll(['path', 'to', 'foo']); // -> 'path/to/foo'
       |  ///
       |  /// If any part ends in a path separator, then a redundant separator will not
       |  /// be added:
       |  ///
       |  ///     context.joinAll(['path/', 'to', 'foo']); // -> 'path/to/foo
       |  ///
       |  /// If a part is an absolute path, then anything before that will be ignored:
       |  ///
       |  ///     context.joinAll(['path', '/to', 'foo']); // -> '/to/foo'
       |  ///
       |  /// For a fixed number of parts, [join] is usually terser.
      0|  String joinAll(Iterable<String> parts) {
      0|    final buffer = StringBuffer();
       |    var needsSeparator = false;
       |    var isAbsoluteAndNotRootRelative = false;
       |
      0|    for (var part in parts.where((part) => part != '')) {
      0|      if (isRootRelative(part) && isAbsoluteAndNotRootRelative) {
       |        // If the new part is root-relative, it preserves the previous root but
       |        // replaces the path after it.
      0|        final parsed = _parse(part);
      0|        final path = buffer.toString();
      0|        parsed.root =
      0|            path.substring(0, style.rootLength(path, withDrive: true));
      0|        if (style.needsSeparator(parsed.root)) {
      0|          parsed.separators[0] = style.separator;
       |        }
      0|        buffer.clear();
      0|        buffer.write(parsed.toString());
      0|      } else if (isAbsolute(part)) {
      0|        isAbsoluteAndNotRootRelative = !isRootRelative(part);
       |        // An absolute path discards everything before it.
      0|        buffer.clear();
      0|        buffer.write(part);
       |      } else {
      0|        if (part.isNotEmpty && style.containsSeparator(part[0])) {
       |          // The part starts with a separator, so we don't need to add one.
       |        } else if (needsSeparator) {
      0|          buffer.write(separator);
       |        }
       |
      0|        buffer.write(part);
       |      }
       |
       |      // Unless this part ends with a separator, we'll need to add one before
       |      // the next part.
      0|      needsSeparator = style.needsSeparator(part);
       |    }
       |
      0|    return buffer.toString();
       |  }
       |
       |  /// Splits [path] into its components using the current platform's
       |  /// [separator]. Example:
       |  ///
       |  ///     context.split('path/to/foo'); // -> ['path', 'to', 'foo']
       |  ///
       |  /// The path will *not* be normalized before splitting.
       |  ///
       |  ///     context.split('path/../foo'); // -> ['path', '..', 'foo']
       |  ///
       |  /// If [path] is absolute, the root directory will be the first element in the
       |  /// array. Example:
       |  ///
       |  ///     // Unix
       |  ///     context.split('/path/to/foo'); // -> ['/', 'path', 'to', 'foo']
       |  ///
       |  ///     // Windows
       |  ///     context.split(r'C:\path\to\foo'); // -> [r'C:\', 'path', 'to', 'foo']
       |  ///     context.split(r'\\server\share\path\to\foo');
       |  ///       // -> [r'\\server\share', 'foo', 'bar', 'baz']
       |  ///
       |  ///     // Browser
       |  ///     context.split('https://dart.dev/path/to/foo');
       |  ///       // -> ['https://dart.dev', 'path', 'to', 'foo']
      1|  List<String> split(String path) {
      1|    final parsed = _parse(path);
       |    // Filter out empty parts that exist due to multiple separators in a row.
      6|    parsed.parts = parsed.parts.where((part) => part.isNotEmpty).toList();
      4|    if (parsed.root != null) parsed.parts.insert(0, parsed.root);
      1|    return parsed.parts;
       |  }
       |
       |  /// Canonicalizes [path].
       |  ///
       |  /// This is guaranteed to return the same path for two different input paths
       |  /// if and only if both input paths point to the same location. Unlike
       |  /// [normalize], it returns absolute paths when possible and canonicalizes
       |  /// ASCII case on Windows.
       |  ///
       |  /// Note that this does not resolve symlinks.
       |  ///
       |  /// If you want a map that uses path keys, it's probably more efficient to
       |  /// pass [equals] and [hash] to [new HashMap] than it is to canonicalize every
       |  /// key.
      0|  String canonicalize(String path) {
      0|    path = absolute(path);
      0|    if (style != Style.windows && !_needsNormalization(path)) return path;
       |
      0|    final parsed = _parse(path);
      0|    parsed.normalize(canonicalize: true);
      0|    return parsed.toString();
       |  }
       |
       |  /// Normalizes [path], simplifying it by handling `..`, and `.`, and
       |  /// removing redundant path separators whenever possible.
       |  ///
       |  /// Note that this is *not* guaranteed to return the same result for two
       |  /// equivalent input paths. For that, see [canonicalize]. Or, if you're using
       |  /// paths as map keys, pass [equals] and [hash] to [new HashMap].
       |  ///
       |  ///     context.normalize('path/./to/..//file.text'); // -> 'path/file.txt'
      1|  String normalize(String path) {
      1|    if (!_needsNormalization(path)) return path;
       |
      1|    final parsed = _parse(path);
      1|    parsed.normalize();
      1|    return parsed.toString();
       |  }
       |
       |  /// Returns whether [path] needs to be normalized.
      1|  bool _needsNormalization(String path) {
       |    var start = 0;
      1|    final codeUnits = path.codeUnits;
       |    int previousPrevious;
       |    int previous;
       |
       |    // Skip past the root before we start looking for snippets that need
       |    // normalization. We want to normalize "//", but not when it's part of
       |    // "http://".
      2|    final root = style.rootLength(path);
      1|    if (root != 0) {
       |      start = root;
       |      previous = chars.slash;
       |
       |      // On Windows, the root still needs to be normalized if it contains a
       |      // forward slash.
      3|      if (style == Style.windows) {
      0|        for (var i = 0; i < root; i++) {
      0|          if (codeUnits[i] == chars.slash) return true;
       |        }
       |      }
       |    }
       |
      3|    for (var i = start; i < codeUnits.length; i++) {
      1|      final codeUnit = codeUnits[i];
      2|      if (style.isSeparator(codeUnit)) {
       |        // Forward slashes in Windows paths are normalized to backslashes.
      3|        if (style == Style.windows && codeUnit == chars.slash) return true;
       |
       |        // Multiple separators are normalized to single separators.
      2|        if (previous != null && style.isSeparator(previous)) return true;
       |
       |        // Single dots and double dots are normalized to directory traversals.
       |        //
       |        // This can return false positives for ".../", but that's unlikely
       |        // enough that it's probably not going to cause performance issues.
      1|        if (previous == chars.period &&
       |            (previousPrevious == null ||
      0|                previousPrevious == chars.period ||
      0|                style.isSeparator(previousPrevious))) {
       |          return true;
       |        }
       |      }
       |
       |      previousPrevious = previous;
       |      previous = codeUnit;
       |    }
       |
       |    // Empty paths are normalized to ".".
       |    if (previous == null) return true;
       |
       |    // Trailing separators are removed.
      2|    if (style.isSeparator(previous)) return true;
       |
       |    // Single dots and double dots are normalized to directory traversals.
      0|    if (previous == chars.period &&
       |        (previousPrevious == null ||
      0|            style.isSeparator(previousPrevious) ||
      0|            previousPrevious == chars.period)) {
       |      return true;
       |    }
       |
       |    return false;
       |  }
       |
       |  /// Attempts to convert [path] to an equivalent relative path relative to
       |  /// [current].
       |  ///
       |  ///     var context = Context(current: '/root/path');
       |  ///     context.relative('/root/path/a/b.dart'); // -> 'a/b.dart'
       |  ///     context.relative('/root/other.dart'); // -> '../other.dart'
       |  ///
       |  /// If the [from] argument is passed, [path] is made relative to that instead.
       |  ///
       |  ///     context.relative('/root/path/a/b.dart',
       |  ///         from: '/root/path'); // -> 'a/b.dart'
       |  ///     context.relative('/root/other.dart',
       |  ///         from: '/root/path'); // -> '../other.dart'
       |  ///
       |  /// If [path] and/or [from] are relative paths, they are assumed to be
       |  /// relative to [current].
       |  ///
       |  /// Since there is no relative path from one drive letter to another on
       |  /// Windows, this will return an absolute path in that case.
       |  ///
       |  ///     context.relative(r'D:\other', from: r'C:\other'); // -> 'D:\other'
       |  ///
       |  /// This will also return an absolute path if an absolute [path] is passed to
       |  /// a context with a relative path for [current].
       |  ///
       |  ///     var context = Context(r'some/relative/path');
       |  ///     context.relative(r'/absolute/path'); // -> '/absolute/path'
       |  ///
       |  /// If [current] is relative, it may be impossible to determine a path from
       |  /// [from] to [path]. For example, if [current] and [path] are "." and [from]
       |  /// is "/", no path can be determined. In this case, a [PathException] will be
       |  /// thrown.
      1|  String relative(String path, {String from}) {
       |    // Avoid expensive computation if the path is already relative.
      1|    if (from == null && isRelative(path)) return normalize(path);
       |
      1|    from = from == null ? current : absolute(from);
       |
       |    // We can't determine the path from a relative path to an absolute path.
      1|    if (isRelative(from) && isAbsolute(path)) {
      0|      return normalize(path);
       |    }
       |
       |    // If the given path is relative, resolve it relative to the context's
       |    // current directory.
      2|    if (isRelative(path) || isRootRelative(path)) {
      0|      path = absolute(path);
       |    }
       |
       |    // If the path is still relative and `from` is absolute, we're unable to
       |    // find a path from `from` to `path`.
      1|    if (isRelative(path) && isAbsolute(from)) {
      0|      throw PathException('Unable to find a path to "$path" from "$from".');
       |    }
       |
      2|    final fromParsed = _parse(from)..normalize();
      2|    final pathParsed = _parse(path)..normalize();
       |
      5|    if (fromParsed.parts.isNotEmpty && fromParsed.parts[0] == '.') {
      0|      return pathParsed.toString();
       |    }
       |
       |    // If the root prefixes don't match (for example, different drive letters
       |    // on Windows), then there is no relative path, so just return the absolute
       |    // one. In Windows, drive letters are case-insenstive and we allow
       |    // calculation of relative paths, even if a path has not been normalized.
      3|    if (fromParsed.root != pathParsed.root &&
      0|        ((fromParsed.root == null || pathParsed.root == null) ||
      0|            !style.pathsEqual(fromParsed.root, pathParsed.root))) {
      0|      return pathParsed.toString();
       |    }
       |
       |    // Strip off their common prefix.
      2|    while (fromParsed.parts.isNotEmpty &&
      2|        pathParsed.parts.isNotEmpty &&
      6|        style.pathsEqual(fromParsed.parts[0], pathParsed.parts[0])) {
      2|      fromParsed.parts.removeAt(0);
      2|      fromParsed.separators.removeAt(1);
      2|      pathParsed.parts.removeAt(0);
      2|      pathParsed.separators.removeAt(1);
       |    }
       |
       |    // If there are any directories left in the from path, we need to walk up
       |    // out of them. If a directory left in the from path is '..', it cannot
       |    // be cancelled by adding a '..'.
      2|    if (fromParsed.parts.isNotEmpty && fromParsed.parts[0] == '..') {
      0|      throw PathException('Unable to find a path to "$path" from "$from".');
       |    }
      5|    pathParsed.parts.insertAll(0, List.filled(fromParsed.parts.length, '..'));
      2|    pathParsed.separators[0] = '';
      1|    pathParsed.separators
      6|        .insertAll(1, List.filled(fromParsed.parts.length, style.separator));
       |
       |    // Corner case: the paths completely collapsed.
      2|    if (pathParsed.parts.isEmpty) return '.';
       |
       |    // Corner case: path was '.' and some '..' directories were added in front.
       |    // Don't add a final '/.' in that case.
      0|    if (pathParsed.parts.length > 1 && pathParsed.parts.last == '.') {
      0|      pathParsed.parts.removeLast();
      0|      pathParsed.separators
      0|        ..removeLast()
      0|        ..removeLast()
      0|        ..add('');
       |    }
       |
       |    // Make it relative.
      0|    pathParsed.root = '';
      0|    pathParsed.removeTrailingSeparators();
       |
      0|    return pathParsed.toString();
       |  }
       |
       |  /// Returns `true` if [child] is a path beneath `parent`, and `false`
       |  /// otherwise.
       |  ///
       |  ///     path.isWithin('/root/path', '/root/path/a'); // -> true
       |  ///     path.isWithin('/root/path', '/root/other'); // -> false
       |  ///     path.isWithin('/root/path', '/root/path'); // -> false
      0|  bool isWithin(String parent, String child) =>
      0|      _isWithinOrEquals(parent, child) == _PathRelation.within;
       |
       |  /// Returns `true` if [path1] points to the same location as [path2], and
       |  /// `false` otherwise.
       |  ///
       |  /// The [hash] function returns a hash code that matches these equality
       |  /// semantics.
      0|  bool equals(String path1, String path2) =>
      0|      _isWithinOrEquals(path1, path2) == _PathRelation.equal;
       |
       |  /// Compares two paths and returns an enum value indicating their relationship
       |  /// to one another.
       |  ///
       |  /// This never returns [_PathRelation.inconclusive].
      0|  _PathRelation _isWithinOrEquals(String parent, String child) {
       |    // Make both paths the same level of relative. We're only able to do the
       |    // quick comparison if both paths are in the same format, and making a path
       |    // absolute is faster than making it relative.
      0|    final parentIsAbsolute = isAbsolute(parent);
      0|    final childIsAbsolute = isAbsolute(child);
       |    if (parentIsAbsolute && !childIsAbsolute) {
      0|      child = absolute(child);
      0|      if (style.isRootRelative(parent)) parent = absolute(parent);
       |    } else if (childIsAbsolute && !parentIsAbsolute) {
      0|      parent = absolute(parent);
      0|      if (style.isRootRelative(child)) child = absolute(child);
       |    } else if (childIsAbsolute && parentIsAbsolute) {
      0|      final childIsRootRelative = style.isRootRelative(child);
      0|      final parentIsRootRelative = style.isRootRelative(parent);
       |
       |      if (childIsRootRelative && !parentIsRootRelative) {
      0|        child = absolute(child);
       |      } else if (parentIsRootRelative && !childIsRootRelative) {
      0|        parent = absolute(parent);
       |      }
       |    }
       |
      0|    final result = _isWithinOrEqualsFast(parent, child);
      0|    if (result != _PathRelation.inconclusive) return result;
       |
       |    String relative;
       |    try {
      0|      relative = this.relative(child, from: parent);
      0|    } on PathException catch (_) {
       |      // If no relative path from [parent] to [child] is found, [child]
       |      // definitely isn't a child of [parent].
       |      return _PathRelation.different;
       |    }
       |
      0|    if (!isRelative(relative)) return _PathRelation.different;
      0|    if (relative == '.') return _PathRelation.equal;
      0|    if (relative == '..') return _PathRelation.different;
      0|    return (relative.length >= 3 &&
      0|            relative.startsWith('..') &&
      0|            style.isSeparator(relative.codeUnitAt(2)))
       |        ? _PathRelation.different
       |        : _PathRelation.within;
       |  }
       |
       |  /// An optimized implementation of [_isWithinOrEquals] that doesn't handle a
       |  /// few complex cases.
      0|  _PathRelation _isWithinOrEqualsFast(String parent, String child) {
       |    // Normally we just bail when we see "." path components, but we can handle
       |    // a single dot easily enough.
      0|    if (parent == '.') parent = '';
       |
      0|    final parentRootLength = style.rootLength(parent);
      0|    final childRootLength = style.rootLength(child);
       |
       |    // If the roots aren't the same length, we know both paths are absolute or
       |    // both are root-relative, and thus that the roots are meaningfully
       |    // different.
       |    //
       |    //     isWithin("C:/bar", "//foo/bar/baz") //=> false
       |    //     isWithin("http://example.com/", "http://google.com/bar") //=> false
      0|    if (parentRootLength != childRootLength) return _PathRelation.different;
       |
       |    // Make sure that the roots are textually the same as well.
       |    //
       |    //     isWithin("C:/bar", "D:/bar/baz") //=> false
       |    //     isWithin("http://example.com/", "http://example.org/bar") //=> false
      0|    for (var i = 0; i < parentRootLength; i++) {
      0|      final parentCodeUnit = parent.codeUnitAt(i);
      0|      final childCodeUnit = child.codeUnitAt(i);
      0|      if (!style.codeUnitsEqual(parentCodeUnit, childCodeUnit)) {
       |        return _PathRelation.different;
       |      }
       |    }
       |
       |    // Start by considering the last code unit as a separator, since
       |    // semantically we're starting at a new path component even if we're
       |    // comparing relative paths.
       |    var lastCodeUnit = chars.slash;
       |
       |    /// The index of the last separator in [parent].
       |    int lastParentSeparator;
       |
       |    // Iterate through both paths as long as they're semantically identical.
       |    var parentIndex = parentRootLength;
       |    var childIndex = childRootLength;
      0|    while (parentIndex < parent.length && childIndex < child.length) {
      0|      var parentCodeUnit = parent.codeUnitAt(parentIndex);
      0|      var childCodeUnit = child.codeUnitAt(childIndex);
      0|      if (style.codeUnitsEqual(parentCodeUnit, childCodeUnit)) {
      0|        if (style.isSeparator(parentCodeUnit)) {
       |          lastParentSeparator = parentIndex;
       |        }
       |
       |        lastCodeUnit = parentCodeUnit;
      0|        parentIndex++;
      0|        childIndex++;
       |        continue;
       |      }
       |
       |      // Ignore multiple separators in a row.
      0|      if (style.isSeparator(parentCodeUnit) &&
      0|          style.isSeparator(lastCodeUnit)) {
       |        lastParentSeparator = parentIndex;
      0|        parentIndex++;
       |        continue;
      0|      } else if (style.isSeparator(childCodeUnit) &&
      0|          style.isSeparator(lastCodeUnit)) {
      0|        childIndex++;
       |        continue;
       |      }
       |
       |      // If a dot comes after a separator, it may be a directory traversal
       |      // operator. To check that, we need to know if it's followed by either
       |      // "/" or "./". Otherwise, it's just a normal non-matching character.
       |      //
       |      //     isWithin("foo/./bar", "foo/bar/baz") //=> true
       |      //     isWithin("foo/bar/../baz", "foo/bar/.foo") //=> false
      0|      if (parentCodeUnit == chars.period && style.isSeparator(lastCodeUnit)) {
      0|        parentIndex++;
       |
       |        // We've hit "/." at the end of the parent path, which we can ignore,
       |        // since the paths were equivalent up to this point.
      0|        if (parentIndex == parent.length) break;
      0|        parentCodeUnit = parent.codeUnitAt(parentIndex);
       |
       |        // We've hit "/./", which we can ignore.
      0|        if (style.isSeparator(parentCodeUnit)) {
       |          lastParentSeparator = parentIndex;
      0|          parentIndex++;
       |          continue;
       |        }
       |
       |        // We've hit "/..", which may be a directory traversal operator that
       |        // we can't handle on the fast track.
      0|        if (parentCodeUnit == chars.period) {
      0|          parentIndex++;
      0|          if (parentIndex == parent.length ||
      0|              style.isSeparator(parent.codeUnitAt(parentIndex))) {
       |            return _PathRelation.inconclusive;
       |          }
       |        }
       |
       |        // If this isn't a directory traversal, fall through so we hit the
       |        // normal handling for mismatched paths.
       |      }
       |
       |      // This is the same logic as above, but for the child path instead of the
       |      // parent.
      0|      if (childCodeUnit == chars.period && style.isSeparator(lastCodeUnit)) {
      0|        childIndex++;
      0|        if (childIndex == child.length) break;
      0|        childCodeUnit = child.codeUnitAt(childIndex);
       |
      0|        if (style.isSeparator(childCodeUnit)) {
      0|          childIndex++;
       |          continue;
       |        }
       |
      0|        if (childCodeUnit == chars.period) {
      0|          childIndex++;
      0|          if (childIndex == child.length ||
      0|              style.isSeparator(child.codeUnitAt(childIndex))) {
       |            return _PathRelation.inconclusive;
       |          }
       |        }
       |      }
       |
       |      // If we're here, we've hit two non-matching, non-significant characters.
       |      // As long as the remainders of the two paths don't have any unresolved
       |      // ".." components, we can be confident that [child] is not within
       |      // [parent].
      0|      final childDirection = _pathDirection(child, childIndex);
      0|      if (childDirection != _PathDirection.belowRoot) {
       |        return _PathRelation.inconclusive;
       |      }
       |
      0|      final parentDirection = _pathDirection(parent, parentIndex);
      0|      if (parentDirection != _PathDirection.belowRoot) {
       |        return _PathRelation.inconclusive;
       |      }
       |
       |      return _PathRelation.different;
       |    }
       |
       |    // If the child is shorter than the parent, it's probably not within the
       |    // parent. The only exception is if the parent has some weird ".." stuff
       |    // going on, in which case we do the slow check.
       |    //
       |    //     isWithin("foo/bar/baz", "foo/bar") //=> false
       |    //     isWithin("foo/bar/baz/../..", "foo/bar") //=> true
      0|    if (childIndex == child.length) {
      0|      if (parentIndex == parent.length ||
      0|          style.isSeparator(parent.codeUnitAt(parentIndex))) {
       |        lastParentSeparator = parentIndex;
       |      } else {
      1|        lastParentSeparator ??= math.max(0, parentRootLength - 1);
       |      }
       |
       |      final direction =
      0|          _pathDirection(parent, lastParentSeparator ?? parentRootLength - 1);
      0|      if (direction == _PathDirection.atRoot) return _PathRelation.equal;
      0|      return direction == _PathDirection.aboveRoot
       |          ? _PathRelation.inconclusive
       |          : _PathRelation.different;
       |    }
       |
       |    // We've reached the end of the parent path, which means it's time to make a
       |    // decision. Before we do, though, we'll check the rest of the child to see
       |    // what that tells us.
      0|    final direction = _pathDirection(child, childIndex);
       |
       |    // If there are no more components in the child, then it's the same as
       |    // the parent.
       |    //
       |    //     isWithin("foo/bar", "foo/bar") //=> false
       |    //     isWithin("foo/bar", "foo/bar//") //=> false
       |    //     equals("foo/bar", "foo/bar") //=> true
       |    //     equals("foo/bar", "foo/bar//") //=> true
      0|    if (direction == _PathDirection.atRoot) return _PathRelation.equal;
       |
       |    // If there are unresolved ".." components in the child, no decision we make
       |    // will be valid. We'll abort and do the slow check instead.
       |    //
       |    //     isWithin("foo/bar", "foo/bar/..") //=> false
       |    //     isWithin("foo/bar", "foo/bar/baz/bang/../../..") //=> false
       |    //     isWithin("foo/bar", "foo/bar/baz/bang/../../../bar/baz") //=> true
      0|    if (direction == _PathDirection.aboveRoot) {
       |      return _PathRelation.inconclusive;
       |    }
       |
       |    // The child is within the parent if and only if we're on a separator
       |    // boundary.
       |    //
       |    //     isWithin("foo/bar", "foo/bar/baz") //=> true
       |    //     isWithin("foo/bar/", "foo/bar/baz") //=> true
       |    //     isWithin("foo/bar", "foo/barbaz") //=> false
      0|    return (style.isSeparator(child.codeUnitAt(childIndex)) ||
      0|            style.isSeparator(lastCodeUnit))
       |        ? _PathRelation.within
       |        : _PathRelation.different;
       |  }
       |
       |  // Returns a [_PathDirection] describing the path represented by [codeUnits]
       |  // starting at [index].
       |  //
       |  // This ignores leading separators.
       |  //
       |  //     pathDirection("foo") //=> below root
       |  //     pathDirection("foo/bar/../baz") //=> below root
       |  //     pathDirection("//foo/bar/baz") //=> below root
       |  //     pathDirection("/") //=> at root
       |  //     pathDirection("foo/..") //=> at root
       |  //     pathDirection("foo/../baz") //=> reaches root
       |  //     pathDirection("foo/../..") //=> above root
       |  //     pathDirection("foo/../../foo/bar/baz") //=> above root
      0|  _PathDirection _pathDirection(String path, int index) {
       |    var depth = 0;
       |    var reachedRoot = false;
       |    var i = index;
      0|    while (i < path.length) {
       |      // Ignore initial separators or doubled separators.
      0|      while (i < path.length && style.isSeparator(path.codeUnitAt(i))) {
      0|        i++;
       |      }
       |
       |      // If we're at the end, stop.
      0|      if (i == path.length) break;
       |
       |      // Move through the path component to the next separator.
       |      final start = i;
      0|      while (i < path.length && !style.isSeparator(path.codeUnitAt(i))) {
      0|        i++;
       |      }
       |
       |      // See if the path component is ".", "..", or a name.
      0|      if (i - start == 1 && path.codeUnitAt(start) == chars.period) {
       |        // Don't change the depth.
      0|      } else if (i - start == 2 &&
      0|          path.codeUnitAt(start) == chars.period &&
      0|          path.codeUnitAt(start + 1) == chars.period) {
       |        // ".." backs out a directory.
      0|        depth--;
       |
       |        // If we work back beyond the root, stop.
      0|        if (depth < 0) break;
       |
       |        // Record that we reached the root so we don't return
       |        // [_PathDirection.belowRoot].
      0|        if (depth == 0) reachedRoot = true;
       |      } else {
       |        // Step inside a directory.
      0|        depth++;
       |      }
       |
       |      // If we're at the end, stop.
      0|      if (i == path.length) break;
       |
       |      // Move past the separator.
      0|      i++;
       |    }
       |
      0|    if (depth < 0) return _PathDirection.aboveRoot;
      0|    if (depth == 0) return _PathDirection.atRoot;
       |    if (reachedRoot) return _PathDirection.reachesRoot;
       |    return _PathDirection.belowRoot;
       |  }
       |
       |  /// Returns a hash code for [path] that matches the semantics of [equals].
       |  ///
       |  /// Note that the same path may have different hash codes in different
       |  /// [Context]s.
      0|  int hash(String path) {
       |    // Make [path] absolute to ensure that equivalent relative and absolute
       |    // paths have the same hash code.
      0|    path = absolute(path);
       |
      0|    final result = _hashFast(path);
       |    if (result != null) return result;
       |
      0|    final parsed = _parse(path);
      0|    parsed.normalize();
      0|    return _hashFast(parsed.toString());
       |  }
       |
       |  /// An optimized implementation of [hash] that doesn't handle internal `..`
       |  /// components.
       |  ///
       |  /// This will handle `..` components that appear at the beginning of the path.
      0|  int _hashFast(String path) {
       |    var hash = 4603;
       |    var beginning = true;
       |    var wasSeparator = true;
      0|    for (var i = 0; i < path.length; i++) {
      0|      final codeUnit = style.canonicalizeCodeUnit(path.codeUnitAt(i));
       |
       |      // Take advantage of the fact that collisions are allowed to ignore
       |      // separators entirely. This lets us avoid worrying about cases like
       |      // multiple trailing slashes.
      0|      if (style.isSeparator(codeUnit)) {
       |        wasSeparator = true;
       |        continue;
       |      }
       |
      0|      if (codeUnit == chars.period && wasSeparator) {
       |        // If a dot comes after a separator, it may be a directory traversal
       |        // operator. To check that, we need to know if it's followed by either
       |        // "/" or "./". Otherwise, it's just a normal character.
       |        //
       |        //     hash("foo/./bar") == hash("foo/bar")
       |
       |        // We've hit "/." at the end of the path, which we can ignore.
      0|        if (i + 1 == path.length) break;
       |
      0|        final next = path.codeUnitAt(i + 1);
       |
       |        // We can just ignore "/./", since they don't affect the semantics of
       |        // the path.
      0|        if (style.isSeparator(next)) continue;
       |
       |        // If the path ends with "/.." or contains "/../", we need to
       |        // canonicalize it before we can hash it. We make an exception for ".."s
       |        // at the beginning of the path, since those may appear even in a
       |        // canonicalized path.
       |        if (!beginning &&
      0|            next == chars.period &&
      0|            (i + 2 == path.length ||
      0|                style.isSeparator(path.codeUnitAt(i + 2)))) {
       |          return null;
       |        }
       |      }
       |
       |      // Make sure [hash] stays under 32 bits even after multiplication.
      0|      hash &= 0x3FFFFFF;
      0|      hash *= 33;
      0|      hash ^= codeUnit;
       |      wasSeparator = false;
       |      beginning = false;
       |    }
       |    return hash;
       |  }
       |
       |  /// Removes a trailing extension from the last part of [path].
       |  ///
       |  ///     context.withoutExtension('path/to/foo.dart'); // -> 'path/to/foo'
      0|  String withoutExtension(String path) {
      0|    final parsed = _parse(path);
       |
      0|    for (var i = parsed.parts.length - 1; i >= 0; i--) {
      0|      if (parsed.parts[i].isNotEmpty) {
      0|        parsed.parts[i] = parsed.basenameWithoutExtension;
       |        break;
       |      }
       |    }
       |
      0|    return parsed.toString();
       |  }
       |
       |  /// Returns [path] with the trailing extension set to [extension].
       |  ///
       |  /// If [path] doesn't have a trailing extension, this just adds [extension] to
       |  /// the end.
       |  ///
       |  ///     context.setExtension('path/to/foo.dart', '.js')
       |  ///       // -> 'path/to/foo.js'
       |  ///     context.setExtension('path/to/foo.dart.js', '.map')
       |  ///       // -> 'path/to/foo.dart.map'
       |  ///     context.setExtension('path/to/foo', '.js')
       |  ///       // -> 'path/to/foo.js'
      0|  String setExtension(String path, String extension) =>
      0|      withoutExtension(path) + extension;
       |
       |  /// Returns the path represented by [uri], which may be a [String] or a [Uri].
       |  ///
       |  /// For POSIX and Windows styles, [uri] must be a `file:` URI. For the URL
       |  /// style, this will just convert [uri] to a string.
       |  ///
       |  ///     // POSIX
       |  ///     context.fromUri('file:///path/to/foo')
       |  ///       // -> '/path/to/foo'
       |  ///
       |  ///     // Windows
       |  ///     context.fromUri('file:///C:/path/to/foo')
       |  ///       // -> r'C:\path\to\foo'
       |  ///
       |  ///     // URL
       |  ///     context.fromUri('https://dart.dev/path/to/foo')
       |  ///       // -> 'https://dart.dev/path/to/foo'
       |  ///
       |  /// If [uri] is relative, a relative path will be returned.
       |  ///
       |  ///     path.fromUri('path/to/foo'); // -> 'path/to/foo'
      4|  String fromUri(uri) => style.pathFromUri(_parseUri(uri));
       |
       |  /// Returns the URI that represents [path].
       |  ///
       |  /// For POSIX and Windows styles, this will return a `file:` URI. For the URL
       |  /// style, this will just convert [path] to a [Uri].
       |  ///
       |  ///     // POSIX
       |  ///     context.toUri('/path/to/foo')
       |  ///       // -> Uri.parse('file:///path/to/foo')
       |  ///
       |  ///     // Windows
       |  ///     context.toUri(r'C:\path\to\foo')
       |  ///       // -> Uri.parse('file:///C:/path/to/foo')
       |  ///
       |  ///     // URL
       |  ///     context.toUri('https://dart.dev/path/to/foo')
       |  ///       // -> Uri.parse('https://dart.dev/path/to/foo')
      0|  Uri toUri(String path) {
      0|    if (isRelative(path)) {
      0|      return style.relativePathToUri(path);
       |    } else {
      0|      return style.absolutePathToUri(join(current, path));
       |    }
       |  }
       |
       |  /// Returns a terse, human-readable representation of [uri].
       |  ///
       |  /// [uri] can be a [String] or a [Uri]. If it can be made relative to the
       |  /// current working directory, that's done. Otherwise, it's returned as-is.
       |  /// This gracefully handles non-`file:` URIs for [Style.posix] and
       |  /// [Style.windows].
       |  ///
       |  /// The returned value is meant for human consumption, and may be either URI-
       |  /// or path-formatted.
       |  ///
       |  ///     // POSIX
       |  ///     var context = Context(current: '/root/path');
       |  ///     context.prettyUri('file:///root/path/a/b.dart'); // -> 'a/b.dart'
       |  ///     context.prettyUri('https://dart.dev/'); // -> 'https://dart.dev'
       |  ///
       |  ///     // Windows
       |  ///     var context = Context(current: r'C:\root\path');
       |  ///     context.prettyUri('file:///C:/root/path/a/b.dart'); // -> r'a\b.dart'
       |  ///     context.prettyUri('https://dart.dev/'); // -> 'https://dart.dev'
       |  ///
       |  ///     // URL
       |  ///     var context = Context(current: 'https://dart.dev/root/path');
       |  ///     context.prettyUri('https://dart.dev/root/path/a/b.dart');
       |  ///         // -> r'a/b.dart'
       |  ///     context.prettyUri('file:///root/path'); // -> 'file:///root/path'
      1|  String prettyUri(uri) {
      1|    final typedUri = _parseUri(uri);
      5|    if (typedUri.scheme == 'file' && style == Style.url) {
      0|      return typedUri.toString();
      2|    } else if (typedUri.scheme != 'file' &&
      0|        typedUri.scheme != '' &&
      0|        style != Style.url) {
      0|      return typedUri.toString();
       |    }
       |
      2|    final path = normalize(fromUri(typedUri));
      1|    final rel = relative(path);
       |
       |    // Only return a relative path if it's actually shorter than the absolute
       |    // path. This avoids ugly things like long "../" chains to get to the root
       |    // and then go back down.
      5|    return split(rel).length > split(path).length ? path : rel;
       |  }
       |
      3|  ParsedPath _parse(String path) => ParsedPath.parse(path, style);
       |}
       |
       |/// Parses argument if it's a [String] or returns it intact if it's a [Uri].
       |///
       |/// Throws an [ArgumentError] otherwise.
      1|Uri _parseUri(uri) {
      1|  if (uri is String) return Uri.parse(uri);
      1|  if (uri is Uri) return uri;
      0|  throw ArgumentError.value(uri, 'uri', 'Value must be a String or a Uri');
       |}
       |
       |/// Validates that there are no non-null arguments following a null one and
       |/// throws an appropriate [ArgumentError] on failure.
      0|void _validateArgList(String method, List<String> args) {
      0|  for (var i = 1; i < args.length; i++) {
       |    // Ignore nulls hanging off the end.
      0|    if (args[i] == null || args[i - 1] != null) continue;
       |
       |    int numArgs;
      0|    for (numArgs = args.length; numArgs >= 1; numArgs--) {
      0|      if (args[numArgs - 1] != null) break;
       |    }
       |
       |    // Show the arguments.
      0|    final message = StringBuffer();
      0|    message.write('$method(');
      0|    message.write(args
      0|        .take(numArgs)
      0|        .map((arg) => arg == null ? 'null' : '"$arg"')
      0|        .join(', '));
      0|    message.write('): part ${i - 1} was null, but part $i was not.');
      0|    throw ArgumentError(message.toString());
       |  }
       |}
       |
       |/// An enum of possible return values for [Context._pathDirection].
       |class _PathDirection {
       |  /// The path contains enough ".." components that at some point it reaches
       |  /// above its original root.
       |  ///
       |  /// Note that this applies even if the path ends beneath its original root. It
       |  /// takes precendence over any other return values that may apple.
       |  static const aboveRoot = _PathDirection('above root');
       |
       |  /// The path contains enough ".." components that it ends at its original
       |  /// root.
       |  static const atRoot = _PathDirection('at root');
       |
       |  /// The path contains enough ".." components that at some point it reaches its
       |  /// original root, but it ends beneath that root.
       |  static const reachesRoot = _PathDirection('reaches root');
       |
       |  /// The path never reaches to or above its original root.
       |  static const belowRoot = _PathDirection('below root');
       |
       |  final String name;
       |
      0|  const _PathDirection(this.name);
       |
      0|  @override
      0|  String toString() => name;
       |}
       |
       |/// An enum of possible return values for [Context._isWithinOrEquals].
       |class _PathRelation {
       |  /// The first path is a proper parent of the second.
       |  ///
       |  /// For example, `foo` is a proper parent of `foo/bar`, but not of `foo`.
       |  static const within = _PathRelation('within');
       |
       |  /// The two paths are equivalent.
       |  ///
       |  /// For example, `foo//bar` is equivalent to `foo/bar`.
       |  static const equal = _PathRelation('equal');
       |
       |  /// The first path is neither a parent of nor equal to the second.
       |  static const different = _PathRelation('different');
       |
       |  /// We couldn't quickly determine any information about the paths'
       |  /// relationship to each other.
       |  ///
       |  /// Only returned by [Context._isWithinOrEqualsFast].
       |  static const inconclusive = _PathRelation('inconclusive');
       |
       |  final String name;
       |
      0|  const _PathRelation(this.name);
       |
      0|  @override
      0|  String toString() => name;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/style.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'context.dart';
       |import 'style/posix.dart';
       |import 'style/url.dart';
       |import 'style/windows.dart';
       |
       |/// An enum type describing a "flavor" of path.
       |abstract class Style {
       |  /// POSIX-style paths use "/" (forward slash) as separators. Absolute paths
       |  /// start with "/". Used by UNIX, Linux, Mac OS X, and others.
      3|  static final Style posix = PosixStyle();
       |
       |  /// Windows paths use `\` (backslash) as separators. Absolute paths start with
       |  /// a drive letter followed by a colon (example, `C:`) or two backslashes
       |  /// (`\\`) for UNC paths.
      3|  static final Style windows = WindowsStyle();
       |
       |  /// URLs aren't filesystem paths, but they're supported to make it easier to
       |  /// manipulate URL paths in the browser.
       |  ///
       |  /// URLs use "/" (forward slash) as separators. Absolute paths either start
       |  /// with a protocol and optional hostname (e.g. `https://dart.dev`,
       |  /// `file://`) or with "/".
      3|  static final Style url = UrlStyle();
       |
       |  /// The style of the host platform.
       |  ///
       |  /// When running on the command line, this will be [windows] or [posix] based
       |  /// on the host operating system. On a browser, this will be [url].
      3|  static final Style platform = _getPlatformStyle();
       |
       |  /// Gets the type of the host platform.
      1|  static Style _getPlatformStyle() {
       |    // If we're running a Dart file in the browser from a `file:` URI,
       |    // [Uri.base] will point to a file. If we're running on the standalone,
       |    // it will point to a directory. We can use that fact to determine which
       |    // style to use.
      3|    if (Uri.base.scheme != 'file') return Style.url;
      3|    if (!Uri.base.path.endsWith('/')) return Style.url;
      3|    if (Uri(path: 'a/b').toFilePath() == 'a\\b') return Style.windows;
      1|    return Style.posix;
       |  }
       |
       |  /// The name of this path style. Will be "posix" or "windows".
       |  String get name;
       |
       |  /// A [Context] that uses this style.
      0|  Context get context => Context(style: this);
       |
       |  @Deprecated('Most Style members will be removed in path 2.0.')
       |  String get separator;
       |
       |  @Deprecated('Most Style members will be removed in path 2.0.')
       |  Pattern get separatorPattern;
       |
       |  @Deprecated('Most Style members will be removed in path 2.0.')
       |  Pattern get needsSeparatorPattern;
       |
       |  @Deprecated('Most Style members will be removed in path 2.0.')
       |  Pattern get rootPattern;
       |
       |  @Deprecated('Most Style members will be removed in path 2.0.')
       |  Pattern get relativeRootPattern;
       |
       |  @Deprecated('Most style members will be removed in path 2.0.')
       |  String getRoot(String path);
       |
       |  @Deprecated('Most style members will be removed in path 2.0.')
       |  String getRelativeRoot(String path);
       |
       |  @Deprecated('Most style members will be removed in path 2.0.')
       |  String pathFromUri(Uri uri);
       |
       |  @Deprecated('Most style members will be removed in path 2.0.')
       |  Uri relativePathToUri(String path);
       |
       |  @Deprecated('Most style members will be removed in path 2.0.')
       |  Uri absolutePathToUri(String path);
       |
      0|  @override
      0|  String toString() => name;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/path_exception.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An exception class that's thrown when a path operation is unable to be
       |/// computed accurately.
       |class PathException implements Exception {
       |  String message;
       |
      0|  PathException(this.message);
       |
      0|  @override
      0|  String toString() => 'PathException: $message';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/path_map.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import '../path.dart' as p;
       |
       |/// A map whose keys are paths, compared using [equals] and [hash].
       |class PathMap<V> extends MapView<String, V> {
       |  /// Creates an empty [PathMap] whose keys are compared using `context.equals`
       |  /// and `context.hash`.
       |  ///
       |  /// The [context] defaults to the current path context.
      0|  PathMap({p.Context context}) : super(_create(context));
       |
       |  /// Creates a [PathMap] with the same keys and values as [other] whose keys
       |  /// are compared using `context.equals` and `context.hash`.
       |  ///
       |  /// The [context] defaults to the current path context. If multiple keys in
       |  /// [other] represent the same logical path, the last key's value will be
       |  /// used.
      0|  PathMap.of(Map<String, V> other, {p.Context context})
      0|      : super(_create(context)..addAll(other));
       |
       |  /// Creates a map that uses [context] for equality and hashing.
      0|  static Map<String, V> _create<V>(p.Context context) {
      0|    context ??= p.context;
      0|    return LinkedHashMap(
      0|        equals: (path1, path2) {
       |          if (path1 == null) return path2 == null;
       |          if (path2 == null) return false;
      0|          return context.equals(path1, path2);
       |        },
      0|        hashCode: (path) => path == null ? 0 : context.hash(path),
      0|        isValidKey: (path) => path is String || path == null);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/path_set.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import '../path.dart' as p;
       |
       |/// A set containing paths, compared using [equals] and [hash].
       |class PathSet extends IterableBase<String> implements Set<String> {
       |  /// The set to which we forward implementation methods.
       |  final Set<String> _inner;
       |
       |  /// Creates an empty [PathSet] whose contents are compared using
       |  /// `context.equals` and `context.hash`.
       |  ///
       |  /// The [context] defaults to the current path context.
      0|  PathSet({p.Context context}) : _inner = _create(context);
       |
       |  /// Creates a [PathSet] with the same contents as [other] whose elements are
       |  /// compared using `context.equals` and `context.hash`.
       |  ///
       |  /// The [context] defaults to the current path context. If multiple elements
       |  /// in [other] represent the same logical path, the first value will be
       |  /// used.
      0|  PathSet.of(Iterable<String> other, {p.Context context})
      0|      : _inner = _create(context)..addAll(other);
       |
       |  /// Creates a set that uses [context] for equality and hashing.
      0|  static Set<String> _create(p.Context context) {
      0|    context ??= p.context;
      0|    return LinkedHashSet(
      0|        equals: (path1, path2) {
       |          if (path1 == null) return path2 == null;
       |          if (path2 == null) return false;
      0|          return context.equals(path1, path2);
       |        },
      0|        hashCode: (path) => path == null ? 0 : context.hash(path),
      0|        isValidKey: (path) => path is String || path == null);
       |  }
       |
       |  // Normally we'd use DelegatingSetView from the collection package to
       |  // implement these, but we want to avoid adding dependencies from path because
       |  // it's so widely used that even brief version skew can be very painful.
       |
      0|  @override
      0|  Iterator<String> get iterator => _inner.iterator;
       |
      0|  @override
      0|  int get length => _inner.length;
       |
      0|  @override
      0|  bool add(String value) => _inner.add(value);
       |
      0|  @override
      0|  void addAll(Iterable<String> elements) => _inner.addAll(elements);
       |
      0|  @override
      0|  Set<T> cast<T>() => _inner.cast<T>();
       |
      0|  @override
      0|  void clear() => _inner.clear();
       |
      0|  @override
      0|  bool contains(Object element) => _inner.contains(element);
       |
      0|  @override
      0|  bool containsAll(Iterable<Object> other) => _inner.containsAll(other);
       |
      0|  @override
      0|  Set<String> difference(Set<Object> other) => _inner.difference(other);
       |
      0|  @override
      0|  Set<String> intersection(Set<Object> other) => _inner.intersection(other);
       |
      0|  @override
      0|  String lookup(Object element) => _inner.lookup(element);
       |
      0|  @override
      0|  bool remove(Object value) => _inner.remove(value);
       |
      0|  @override
      0|  void removeAll(Iterable<Object> elements) => _inner.removeAll(elements);
       |
      0|  @override
      0|  void removeWhere(bool Function(String) test) => _inner.removeWhere(test);
       |
      0|  @override
      0|  void retainAll(Iterable<Object> elements) => _inner.retainAll(elements);
       |
      0|  @override
      0|  void retainWhere(bool Function(String) test) => _inner.retainWhere(test);
       |
      0|  @override
      0|  Set<String> union(Set<String> other) => _inner.union(other);
       |
      0|  @override
      0|  Set<String> toSet() => _inner.toSet();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/style/posix.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../characters.dart' as chars;
       |import '../internal_style.dart';
       |import '../parsed_path.dart';
       |
       |/// The style for POSIX paths.
       |class PosixStyle extends InternalStyle {
      1|  PosixStyle();
       |
       |  @override
       |  final name = 'posix';
       |  @override
       |  final separator = '/';
       |  final separators = const ['/'];
       |
       |  // Deprecated properties.
       |
       |  @override
       |  final separatorPattern = RegExp(r'/');
       |  @override
       |  final needsSeparatorPattern = RegExp(r'[^/]$');
       |  @override
       |  final rootPattern = RegExp(r'^/');
       |  @override
       |  final relativeRootPattern = null;
       |
      0|  @override
      0|  bool containsSeparator(String path) => path.contains('/');
       |
      1|  @override
      1|  bool isSeparator(int codeUnit) => codeUnit == chars.slash;
       |
      1|  @override
       |  bool needsSeparator(String path) =>
      5|      path.isNotEmpty && !isSeparator(path.codeUnitAt(path.length - 1));
       |
      1|  @override
       |  int rootLength(String path, {bool withDrive = false}) {
      3|    if (path.isNotEmpty && isSeparator(path.codeUnitAt(0))) return 1;
       |    return 0;
       |  }
       |
      1|  @override
       |  bool isRootRelative(String path) => false;
       |
      0|  @override
       |  String getRelativeRoot(String path) => null;
       |
      1|  @override
       |  String pathFromUri(Uri uri) {
      4|    if (uri.scheme == '' || uri.scheme == 'file') {
      2|      return Uri.decodeComponent(uri.path);
       |    }
      0|    throw ArgumentError("Uri $uri must have scheme 'file:'.");
       |  }
       |
      0|  @override
       |  Uri absolutePathToUri(String path) {
      0|    final parsed = ParsedPath.parse(path, this);
      0|    if (parsed.parts.isEmpty) {
       |      // If the path is a bare root (e.g. "/"), [components] will
       |      // currently be empty. We add two empty components so the URL constructor
       |      // produces "file:///", with a trailing slash.
      0|      parsed.parts.addAll(['', '']);
      0|    } else if (parsed.hasTrailingSeparator) {
       |      // If the path has a trailing slash, add a single empty component so the
       |      // URI has a trailing slash as well.
      0|      parsed.parts.add('');
       |    }
       |
      0|    return Uri(scheme: 'file', pathSegments: parsed.parts);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/style/url.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../characters.dart' as chars;
       |import '../internal_style.dart';
       |import '../utils.dart';
       |
       |/// The style for URL paths.
       |class UrlStyle extends InternalStyle {
      1|  UrlStyle();
       |
       |  @override
       |  final name = 'url';
       |  @override
       |  final separator = '/';
       |  final separators = const ['/'];
       |
       |  // Deprecated properties.
       |
       |  @override
       |  final separatorPattern = RegExp(r'/');
       |  @override
       |  final needsSeparatorPattern = RegExp(r'(^[a-zA-Z][-+.a-zA-Z\d]*://|[^/])$');
       |  @override
       |  final rootPattern = RegExp(r'[a-zA-Z][-+.a-zA-Z\d]*://[^/]*');
       |  @override
       |  final relativeRootPattern = RegExp(r'^/');
       |
      0|  @override
      0|  bool containsSeparator(String path) => path.contains('/');
       |
      0|  @override
      0|  bool isSeparator(int codeUnit) => codeUnit == chars.slash;
       |
      0|  @override
       |  bool needsSeparator(String path) {
      0|    if (path.isEmpty) return false;
       |
       |    // A URL that doesn't end in "/" always needs a separator.
      0|    if (!isSeparator(path.codeUnitAt(path.length - 1))) return true;
       |
       |    // A URI that's just "scheme://" needs an extra separator, despite ending
       |    // with "/".
      0|    return path.endsWith('://') && rootLength(path) == path.length;
       |  }
       |
      0|  @override
       |  int rootLength(String path, {bool withDrive = false}) {
      0|    if (path.isEmpty) return 0;
      0|    if (isSeparator(path.codeUnitAt(0))) return 1;
       |
      0|    for (var i = 0; i < path.length; i++) {
      0|      final codeUnit = path.codeUnitAt(i);
      0|      if (isSeparator(codeUnit)) return 0;
      0|      if (codeUnit == chars.colon) {
      0|        if (i == 0) return 0;
       |
       |        // The root part is up until the next '/', or the full path. Skip ':'
       |        // (and '//' if it exists) and search for '/' after that.
      0|        if (path.startsWith('//', i + 1)) i += 3;
      0|        final index = path.indexOf('/', i);
      0|        if (index <= 0) return path.length;
       |
       |        // file: URLs sometimes consider Windows drive letters part of the root.
       |        // See https://url.spec.whatwg.org/#file-slash-state.
      0|        if (!withDrive || path.length < index + 3) return index;
      0|        if (!path.startsWith('file://')) return index;
      0|        if (!isDriveLetter(path, index + 1)) return index;
      0|        return path.length == index + 3 ? index + 3 : index + 4;
       |      }
       |    }
       |
       |    return 0;
       |  }
       |
      0|  @override
       |  bool isRootRelative(String path) =>
      0|      path.isNotEmpty && isSeparator(path.codeUnitAt(0));
       |
      0|  @override
      0|  String getRelativeRoot(String path) => isRootRelative(path) ? '/' : null;
       |
      0|  @override
      0|  String pathFromUri(Uri uri) => uri.toString();
       |
      0|  @override
      0|  Uri relativePathToUri(String path) => Uri.parse(path);
      0|  @override
      0|  Uri absolutePathToUri(String path) => Uri.parse(path);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/style/windows.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../characters.dart' as chars;
       |import '../internal_style.dart';
       |import '../parsed_path.dart';
       |import '../utils.dart';
       |
       |// `0b100000` can be bitwise-ORed with uppercase ASCII letters to get their
       |// lowercase equivalents.
       |const _asciiCaseBit = 0x20;
       |
       |/// The style for Windows paths.
       |class WindowsStyle extends InternalStyle {
      1|  WindowsStyle();
       |
       |  @override
       |  final name = 'windows';
       |  @override
       |  final separator = '\\';
       |  final separators = const ['/', '\\'];
       |
       |  // Deprecated properties.
       |
       |  @override
       |  final separatorPattern = RegExp(r'[/\\]');
       |  @override
       |  final needsSeparatorPattern = RegExp(r'[^/\\]$');
       |  @override
       |  final rootPattern = RegExp(r'^(\\\\[^\\]+\\[^\\/]+|[a-zA-Z]:[/\\])');
       |  @override
       |  final relativeRootPattern = RegExp(r'^[/\\](?![/\\])');
       |
      0|  @override
      0|  bool containsSeparator(String path) => path.contains('/');
       |
      0|  @override
       |  bool isSeparator(int codeUnit) =>
      0|      codeUnit == chars.slash || codeUnit == chars.backslash;
       |
      0|  @override
       |  bool needsSeparator(String path) {
      0|    if (path.isEmpty) return false;
      0|    return !isSeparator(path.codeUnitAt(path.length - 1));
       |  }
       |
      0|  @override
       |  int rootLength(String path, {bool withDrive = false}) {
      0|    if (path.isEmpty) return 0;
      0|    if (path.codeUnitAt(0) == chars.slash) return 1;
      0|    if (path.codeUnitAt(0) == chars.backslash) {
      0|      if (path.length < 2 || path.codeUnitAt(1) != chars.backslash) return 1;
       |      // The path is a network share. Search for up to two '\'s, as they are
       |      // the server and share - and part of the root part.
      0|      var index = path.indexOf('\\', 2);
      0|      if (index > 0) {
      0|        index = path.indexOf('\\', index + 1);
      0|        if (index > 0) return index;
       |      }
      0|      return path.length;
       |    }
       |    // If the path is of the form 'C:/' or 'C:\', with C being any letter, it's
       |    // a root part.
      0|    if (path.length < 3) return 0;
       |    // Check for the letter.
      0|    if (!isAlphabetic(path.codeUnitAt(0))) return 0;
       |    // Check for the ':'.
      0|    if (path.codeUnitAt(1) != chars.colon) return 0;
       |    // Check for either '/' or '\'.
      0|    if (!isSeparator(path.codeUnitAt(2))) return 0;
       |    return 3;
       |  }
       |
      0|  @override
      0|  bool isRootRelative(String path) => rootLength(path) == 1;
       |
      0|  @override
       |  String getRelativeRoot(String path) {
      0|    final length = rootLength(path);
      0|    if (length == 1) return path[0];
       |    return null;
       |  }
       |
      0|  @override
       |  String pathFromUri(Uri uri) {
      0|    if (uri.scheme != '' && uri.scheme != 'file') {
      0|      throw ArgumentError("Uri $uri must have scheme 'file:'.");
       |    }
       |
      0|    var path = uri.path;
      0|    if (uri.host == '') {
       |      // Drive-letter paths look like "file:///C:/path/to/file". The
       |      // replaceFirst removes the extra initial slash. Otherwise, leave the
       |      // slash to match IE's interpretation of "/foo" as a root-relative path.
      0|      if (path.length >= 3 && path.startsWith('/') && isDriveLetter(path, 1)) {
      0|        path = path.replaceFirst('/', '');
       |      }
       |    } else {
       |      // Network paths look like "file://hostname/path/to/file".
      0|      path = '\\\\${uri.host}$path';
       |    }
      0|    return Uri.decodeComponent(path.replaceAll('/', '\\'));
       |  }
       |
      0|  @override
       |  Uri absolutePathToUri(String path) {
      0|    final parsed = ParsedPath.parse(path, this);
      0|    if (parsed.root.startsWith(r'\\')) {
       |      // Network paths become "file://server/share/path/to/file".
       |
       |      // The root is of the form "\\server\share". We want "server" to be the
       |      // URI host, and "share" to be the first element of the path.
      0|      final rootParts = parsed.root.split('\\').where((part) => part != '');
      0|      parsed.parts.insert(0, rootParts.last);
       |
      0|      if (parsed.hasTrailingSeparator) {
       |        // If the path has a trailing slash, add a single empty component so the
       |        // URI has a trailing slash as well.
      0|        parsed.parts.add('');
       |      }
       |
      0|      return Uri(
      0|          scheme: 'file', host: rootParts.first, pathSegments: parsed.parts);
       |    } else {
       |      // Drive-letter paths become "file:///C:/path/to/file".
       |
       |      // If the path is a bare root (e.g. "C:\"), [parsed.parts] will currently
       |      // be empty. We add an empty component so the URL constructor produces
       |      // "file:///C:/", with a trailing slash. We also add an empty component if
       |      // the URL otherwise has a trailing slash.
      0|      if (parsed.parts.isEmpty || parsed.hasTrailingSeparator) {
      0|        parsed.parts.add('');
       |      }
       |
       |      // Get rid of the trailing "\" in "C:\" because the URI constructor will
       |      // add a separator on its own.
      0|      parsed.parts
      0|          .insert(0, parsed.root.replaceAll('/', '').replaceAll('\\', ''));
       |
      0|      return Uri(scheme: 'file', pathSegments: parsed.parts);
       |    }
       |  }
       |
      0|  @override
       |  bool codeUnitsEqual(int codeUnit1, int codeUnit2) {
      0|    if (codeUnit1 == codeUnit2) return true;
       |
       |    /// Forward slashes and backslashes are equivalent on Windows.
      0|    if (codeUnit1 == chars.slash) return codeUnit2 == chars.backslash;
      0|    if (codeUnit1 == chars.backslash) return codeUnit2 == chars.slash;
       |
       |    // If this check fails, the code units are definitely different. If it
       |    // succeeds *and* either codeUnit is an ASCII letter, they're equivalent.
      0|    if (codeUnit1 ^ codeUnit2 != _asciiCaseBit) return false;
       |
       |    // Now we just need to verify that one of the code units is an ASCII letter.
      0|    final upperCase1 = codeUnit1 | _asciiCaseBit;
      0|    return upperCase1 >= chars.lowerA && upperCase1 <= chars.lowerZ;
       |  }
       |
      0|  @override
       |  bool pathsEqual(String path1, String path2) {
       |    if (identical(path1, path2)) return true;
      0|    if (path1.length != path2.length) return false;
      0|    for (var i = 0; i < path1.length; i++) {
      0|      if (!codeUnitsEqual(path1.codeUnitAt(i), path2.codeUnitAt(i))) {
       |        return false;
       |      }
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  int canonicalizeCodeUnit(int codeUnit) {
      0|    if (codeUnit == chars.slash) return chars.backslash;
      0|    if (codeUnit < chars.upperA) return codeUnit;
      0|    if (codeUnit > chars.upperZ) return codeUnit;
      0|    return codeUnit | _asciiCaseBit;
       |  }
       |
      0|  @override
      0|  String canonicalizePart(String part) => part.toLowerCase();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/internal_style.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'context.dart';
       |import 'style.dart';
       |
       |/// The internal interface for the [Style] type.
       |///
       |/// Users should be able to pass around instances of [Style] like an enum, but
       |/// the members that [Context] uses should be hidden from them. Those members
       |/// are defined on this class instead.
       |abstract class InternalStyle extends Style {
       |  /// The default path separator for this style.
       |  ///
       |  /// On POSIX, this is `/`. On Windows, it's `\`.
       |  @override
       |  String get separator;
       |
       |  /// Returns whether [path] contains a separator.
       |  bool containsSeparator(String path);
       |
       |  /// Returns whether [codeUnit] is the character code of a separator.
       |  bool isSeparator(int codeUnit);
       |
       |  /// Returns whether this path component needs a separator after it.
       |  ///
       |  /// Windows and POSIX styles just need separators when the previous component
       |  /// doesn't already end in a separator, but the URL always needs to place a
       |  /// separator between the root and the first component, even if the root
       |  /// already ends in a separator character. For example, to join "file://" and
       |  /// "usr", an additional "/" is needed (making "file:///usr").
       |  bool needsSeparator(String path);
       |
       |  /// Returns the number of characters of the root part.
       |  ///
       |  /// Returns 0 if the path is relative and 1 if the path is root-relative.
       |  ///
       |  /// If [withDrive] is `true`, this should include the drive letter for `file:`
       |  /// URLs. Non-URL styles may ignore the parameter.
       |  int rootLength(String path, {bool withDrive = false});
       |
       |  /// Gets the root prefix of [path] if path is absolute. If [path] is relative,
       |  /// returns `null`.
      1|  @override
       |  String getRoot(String path) {
      1|    final length = rootLength(path);
      2|    if (length > 0) return path.substring(0, length);
      1|    return isRootRelative(path) ? path[0] : null;
       |  }
       |
       |  /// Returns whether [path] is root-relative.
       |  ///
       |  /// If [path] is relative or absolute and not root-relative, returns `false`.
       |  bool isRootRelative(String path);
       |
       |  /// Returns the path represented by [uri] in this style.
       |  @override
       |  String pathFromUri(Uri uri);
       |
       |  /// Returns the URI that represents the relative path made of [parts].
      0|  @override
       |  Uri relativePathToUri(String path) {
      0|    final segments = context.split(path);
       |
       |    // Ensure that a trailing slash in the path produces a trailing slash in the
       |    // URL.
      0|    if (isSeparator(path.codeUnitAt(path.length - 1))) segments.add('');
      0|    return Uri(pathSegments: segments);
       |  }
       |
       |  /// Returns the URI that represents [path], which is assumed to be absolute.
       |  @override
       |  Uri absolutePathToUri(String path);
       |
       |  /// Returns whether [codeUnit1] and [codeUnit2] are considered equivalent for
       |  /// this style.
      0|  bool codeUnitsEqual(int codeUnit1, int codeUnit2) => codeUnit1 == codeUnit2;
       |
       |  /// Returns whether [path1] and [path2] are equivalent.
       |  ///
       |  /// This only needs to handle character-by-character comparison; it can assume
       |  /// the paths are normalized and contain no `..` components.
      2|  bool pathsEqual(String path1, String path2) => path1 == path2;
       |
      0|  int canonicalizeCodeUnit(int codeUnit) => codeUnit;
       |
      0|  String canonicalizePart(String part) => part;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/parsed_path.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'internal_style.dart';
       |import 'style.dart';
       |
       |class ParsedPath {
       |  /// The [InternalStyle] that was used to parse this path.
       |  InternalStyle style;
       |
       |  /// The absolute root portion of the path, or `null` if the path is relative.
       |  /// On POSIX systems, this will be `null` or "/". On Windows, it can be
       |  /// `null`, "//" for a UNC path, or something like "C:\" for paths with drive
       |  /// letters.
       |  String root;
       |
       |  /// Whether this path is root-relative.
       |  ///
       |  /// See [Context.isRootRelative].
       |  bool isRootRelative;
       |
       |  /// The path-separated parts of the path. All but the last will be
       |  /// directories.
       |  List<String> parts;
       |
       |  /// The path separators preceding each part.
       |  ///
       |  /// The first one will be an empty string unless the root requires a separator
       |  /// between it and the path. The last one will be an empty string unless the
       |  /// path ends with a trailing separator.
       |  List<String> separators;
       |
       |  /// The file extension of the last non-empty part, or "" if it doesn't have
       |  /// one.
      0|  String extension([int level]) => _splitExtension(level)[1];
       |
       |  /// `true` if this is an absolute path.
      2|  bool get isAbsolute => root != null;
       |
      1|  factory ParsedPath.parse(String path, InternalStyle style) {
       |    // Remove the root prefix, if any.
      1|    final root = style.getRoot(path);
      1|    final isRootRelative = style.isRootRelative(path);
      2|    if (root != null) path = path.substring(root.length);
       |
       |    // Split the parts on path separators.
      1|    final parts = <String>[];
      1|    final separators = <String>[];
       |
       |    var start = 0;
       |
      3|    if (path.isNotEmpty && style.isSeparator(path.codeUnitAt(0))) {
      0|      separators.add(path[0]);
       |      start = 1;
       |    } else {
      1|      separators.add('');
       |    }
       |
      3|    for (var i = start; i < path.length; i++) {
      2|      if (style.isSeparator(path.codeUnitAt(i))) {
      2|        parts.add(path.substring(start, i));
      2|        separators.add(path[i]);
      1|        start = i + 1;
       |      }
       |    }
       |
       |    // Add the final part, if any.
      2|    if (start < path.length) {
      2|      parts.add(path.substring(start));
      1|      separators.add('');
       |    }
       |
      1|    return ParsedPath._(style, root, isRootRelative, parts, separators);
       |  }
       |
      1|  ParsedPath._(
       |      this.style, this.root, this.isRootRelative, this.parts, this.separators);
       |
      0|  String get basename {
      0|    final copy = clone();
      0|    copy.removeTrailingSeparators();
      0|    if (copy.parts.isEmpty) return root ?? '';
      0|    return copy.parts.last;
       |  }
       |
      0|  String get basenameWithoutExtension => _splitExtension()[0];
       |
      0|  bool get hasTrailingSeparator =>
      0|      parts.isNotEmpty && (parts.last == '' || separators.last != '');
       |
      1|  void removeTrailingSeparators() {
      5|    while (parts.isNotEmpty && parts.last == '') {
      0|      parts.removeLast();
      0|      separators.removeLast();
       |    }
      7|    if (separators.isNotEmpty) separators[separators.length - 1] = '';
       |  }
       |
      1|  void normalize({bool canonicalize = false}) {
       |    // Handle '.', '..', and empty parts.
       |    var leadingDoubles = 0;
      1|    final newParts = <String>[];
      2|    for (var part in parts) {
      2|      if (part == '.' || part == '') {
       |        // Do nothing. Ignore it.
      1|      } else if (part == '..') {
       |        // Pop the last part off.
      0|        if (newParts.isNotEmpty) {
      0|          newParts.removeLast();
       |        } else {
       |          // Backed out past the beginning, so preserve the "..".
      0|          leadingDoubles++;
       |        }
       |      } else {
      1|        newParts.add(canonicalize ? style.canonicalizePart(part) : part);
       |      }
       |    }
       |
       |    // A relative path can back out from the start directory.
      1|    if (!isAbsolute) {
      0|      newParts.insertAll(0, List.filled(leadingDoubles, '..'));
       |    }
       |
       |    // If we collapsed down to nothing, do ".".
      1|    if (newParts.isEmpty && !isAbsolute) {
      0|      newParts.add('.');
       |    }
       |
       |    // Canonicalize separators.
      1|    final newSeparators = List<String>.generate(
      4|        newParts.length, (_) => style.separator,
       |        growable: true);
      1|    newSeparators.insert(
       |        0,
      5|        isAbsolute && newParts.isNotEmpty && style.needsSeparator(root)
      0|            ? style.separator
       |            : '');
       |
      1|    parts = newParts;
      1|    separators = newSeparators;
       |
       |    // Normalize the Windows root if needed.
      4|    if (root != null && style == Style.windows) {
      0|      if (canonicalize) root = root.toLowerCase();
      0|      root = root.replaceAll('/', '\\');
       |    }
      1|    removeTrailingSeparators();
       |  }
       |
      1|  @override
       |  String toString() {
      1|    final builder = StringBuffer();
      3|    if (root != null) builder.write(root);
      4|    for (var i = 0; i < parts.length; i++) {
      3|      builder.write(separators[i]);
      3|      builder.write(parts[i]);
       |    }
      3|    builder.write(separators.last);
       |
      1|    return builder.toString();
       |  }
       |
       |  /// Returns k-th last index of the `character` in the `path`.
       |  ///
       |  /// If `k` exceeds the count of `character`s in `path`, the left most index
       |  /// of the `character` is returned.
      0|  int _kthLastIndexOf(String path, String character, int k) {
       |    var count = 0, leftMostIndexedCharacter = 0;
      0|    for (var index = path.length - 1; index >= 0; --index) {
      0|      if (path[index] == character) {
       |        leftMostIndexedCharacter = index;
      0|        ++count;
      0|        if (count == k) {
       |          return index;
       |        }
       |      }
       |    }
       |    return leftMostIndexedCharacter;
       |  }
       |
       |  /// Splits the last non-empty part of the path into a `[basename, extension]`
       |  /// pair.
       |  ///
       |  /// Takes an optional parameter `level` which makes possible to return
       |  /// multiple extensions having `level` number of dots. If `level` exceeds the
       |  /// number of dots, the path is split at the first most dot. The value of
       |  /// `level` must be greater than 0, else `RangeError` is thrown.
       |  ///
       |  /// Returns a two-element list. The first is the name of the file without any
       |  /// extension. The second is the extension or "" if it has none.
      0|  List<String> _splitExtension([int level = 1]) {
      0|    if (level == null) throw ArgumentError.notNull('level');
      0|    if (level <= 0) {
      0|      throw RangeError.value(
       |          level, 'level', "level's value must be greater than 0");
       |    }
       |
      0|    final file = parts.lastWhere((p) => p != '', orElse: () => null);
       |
      0|    if (file == null) return ['', ''];
      0|    if (file == '..') return ['..', ''];
       |
      0|    final lastDot = _kthLastIndexOf(file, '.', level);
       |
       |    // If there is no dot, or it's the first character, like '.bashrc', it
       |    // doesn't count.
      0|    if (lastDot <= 0) return [file, ''];
       |
      0|    return [file.substring(0, lastDot), file.substring(lastDot)];
       |  }
       |
      0|  ParsedPath clone() => ParsedPath._(
      0|      style, root, isRootRelative, List.from(parts), List.from(separators));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/path-1.7.0/lib/src/utils.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'characters.dart' as chars;
       |
       |/// Returns whether [char] is the code for an ASCII letter (uppercase or
       |/// lowercase).
      0|bool isAlphabetic(int char) =>
      0|    (char >= chars.upperA && char <= chars.upperZ) ||
      0|    (char >= chars.lowerA && char <= chars.lowerZ);
       |
       |/// Returns whether [char] is the code for an ASCII digit.
      0|bool isNumeric(int char) => char >= chars.zero && char <= chars.nine;
       |
       |/// Returns whether [path] has a URL-formatted Windows drive letter beginning at
       |/// [index].
      0|bool isDriveLetter(String path, int index) {
      0|  if (path.length < index + 2) return false;
      0|  if (!isAlphabetic(path.codeUnitAt(index))) return false;
      0|  if (path.codeUnitAt(index + 1) != chars.colon) return false;
      0|  if (path.length == index + 2) return true;
      0|  return path.codeUnitAt(index + 2) == chars.slash;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/algorithms.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |
       |import 'utils.dart';
       |
       |/// Returns a position of the [value] in [sortedList], if it is there.
       |///
       |/// If the list isn't sorted according to the [compare] function, the result
       |/// is unpredictable.
       |///
       |/// If [compare] is omitted, this defaults to calling [Comparable.compareTo] on
       |/// the objects. If any object is not [Comparable], this throws a [TypeError]
       |/// (`CastError` on some SDK versions).
       |///
       |/// Returns -1 if [value] is not in the list by default.
      0|int binarySearch<T>(List<T> sortedList, T value, {int Function(T, T) compare}) {
      0|  compare ??= defaultCompare<T>();
       |  var min = 0;
      0|  var max = sortedList.length;
      0|  while (min < max) {
      0|    var mid = min + ((max - min) >> 1);
      0|    var element = sortedList[mid];
      0|    var comp = compare(element, value);
      0|    if (comp == 0) return mid;
      0|    if (comp < 0) {
      0|      min = mid + 1;
       |    } else {
       |      max = mid;
       |    }
       |  }
      0|  return -1;
       |}
       |
       |/// Returns the first position in [sortedList] that does not compare less than
       |/// [value].
       |///
       |/// If the list isn't sorted according to the [compare] function, the result
       |/// is unpredictable.
       |///
       |/// If [compare] is omitted, this defaults to calling [Comparable.compareTo] on
       |/// the objects. If any object is not [Comparable], this throws a [TypeError]
       |/// (`CastError` on some SDK versions).
       |///
       |/// Returns [sortedList.length] if all the items in [sortedList] compare less
       |/// than [value].
      0|int lowerBound<T>(List<T> sortedList, T value, {int Function(T, T) compare}) {
      0|  compare ??= defaultCompare<T>();
       |  var min = 0;
      0|  var max = sortedList.length;
      0|  while (min < max) {
      0|    var mid = min + ((max - min) >> 1);
      0|    var element = sortedList[mid];
      0|    var comp = compare(element, value);
      0|    if (comp < 0) {
      0|      min = mid + 1;
       |    } else {
       |      max = mid;
       |    }
       |  }
       |  return min;
       |}
       |
       |/// Shuffles a list randomly.
       |///
       |/// A sub-range of a list can be shuffled by providing [start] and [end].
      0|void shuffle(List list, [int start = 0, int end]) {
      0|  var random = math.Random();
      0|  end ??= list.length;
      0|  var length = end - start;
      0|  while (length > 1) {
      0|    var pos = random.nextInt(length);
      0|    length--;
      0|    var tmp1 = list[start + pos];
      0|    list[start + pos] = list[start + length];
      0|    list[start + length] = tmp1;
       |  }
       |}
       |
       |/// Reverses a list, or a part of a list, in-place.
      0|void reverse(List list, [int start = 0, int end]) {
      0|  end ??= list.length;
      0|  _reverse(list, start, end);
       |}
       |
       |/// Internal helper function that assumes valid arguments.
      0|void _reverse(List list, int start, int end) {
      0|  for (var i = start, j = end - 1; i < j; i++, j--) {
      0|    var tmp = list[i];
      0|    list[i] = list[j];
      0|    list[j] = tmp;
       |  }
       |}
       |
       |/// Sort a list between [start] (inclusive) and [end] (exclusive) using
       |/// insertion sort.
       |///
       |/// If [compare] is omitted, this defaults to calling [Comparable.compareTo] on
       |/// the objects. If any object is not [Comparable], this throws a [TypeError]
       |/// (`CastError` on some SDK versions).
       |///
       |/// Insertion sort is a simple sorting algorithm. For `n` elements it does on
       |/// the order of `n * log(n)` comparisons but up to `n` squared moves. The
       |/// sorting is performed in-place, without using extra memory.
       |///
       |/// For short lists the many moves have less impact than the simple algorithm,
       |/// and it is often the favored sorting algorithm for short lists.
       |///
       |/// This insertion sort is stable: Equal elements end up in the same order
       |/// as they started in.
      0|void insertionSort<T>(List<T> list,
       |    {int Function(T, T) compare, int start = 0, int end}) {
       |  // If the same method could have both positional and named optional
       |  // parameters, this should be (list, [start, end], {compare}).
      0|  compare ??= defaultCompare<T>();
      0|  end ??= list.length;
       |
      0|  for (var pos = start + 1; pos < end; pos++) {
       |    var min = start;
       |    var max = pos;
      0|    var element = list[pos];
      0|    while (min < max) {
      0|      var mid = min + ((max - min) >> 1);
      0|      var comparison = compare(element, list[mid]);
      0|      if (comparison < 0) {
       |        max = mid;
       |      } else {
      0|        min = mid + 1;
       |      }
       |    }
      0|    list.setRange(min + 1, pos + 1, list, min);
      0|    list[min] = element;
       |  }
       |}
       |
       |/// Limit below which merge sort defaults to insertion sort.
       |const int _MERGE_SORT_LIMIT = 32;
       |
       |/// Sorts a list between [start] (inclusive) and [end] (exclusive) using the
       |/// merge sort algorithm.
       |///
       |/// If [compare] is omitted, this defaults to calling [Comparable.compareTo] on
       |/// the objects. If any object is not [Comparable], this throws a [TypeError]
       |/// (`CastError` on some SDK versions).
       |///
       |/// Merge-sorting works by splitting the job into two parts, sorting each
       |/// recursively, and then merging the two sorted parts.
       |///
       |/// This takes on the order of `n * log(n)` comparisons and moves to sort
       |/// `n` elements, but requires extra space of about the same size as the list
       |/// being sorted.
       |///
       |/// This merge sort is stable: Equal elements end up in the same order
       |/// as they started in.
      0|void mergeSort<T>(List<T> list,
       |    {int start = 0, int end, int Function(T, T) compare}) {
      0|  end ??= list.length;
      0|  compare ??= defaultCompare<T>();
       |
      0|  var length = end - start;
      0|  if (length < 2) return;
      0|  if (length < _MERGE_SORT_LIMIT) {
      0|    insertionSort(list, compare: compare, start: start, end: end);
       |    return;
       |  }
       |  // Special case the first split instead of directly calling
       |  // _mergeSort, because the _mergeSort requires its target to
       |  // be different from its source, and it requires extra space
       |  // of the same size as the list to sort.
       |  // This split allows us to have only half as much extra space,
       |  // and it ends up in the original place.
      0|  var middle = start + ((end - start) >> 1);
      0|  var firstLength = middle - start;
      0|  var secondLength = end - middle;
       |  // secondLength is always the same as firstLength, or one greater.
      0|  var scratchSpace = List<T>(secondLength);
      0|  _mergeSort(list, compare, middle, end, scratchSpace, 0);
      0|  var firstTarget = end - firstLength;
      0|  _mergeSort(list, compare, start, middle, list, firstTarget);
      0|  _merge(compare, list, firstTarget, end, scratchSpace, 0, secondLength, list,
       |      start);
       |}
       |
       |/// Performs an insertion sort into a potentially different list than the
       |/// one containing the original values.
       |///
       |/// It will work in-place as well.
      0|void _movingInsertionSort<T>(List<T> list, int Function(T, T) compare,
       |    int start, int end, List<T> target, int targetOffset) {
      0|  var length = end - start;
      0|  if (length == 0) return;
      0|  target[targetOffset] = list[start];
      0|  for (var i = 1; i < length; i++) {
      0|    var element = list[start + i];
       |    var min = targetOffset;
      0|    var max = targetOffset + i;
      0|    while (min < max) {
      0|      var mid = min + ((max - min) >> 1);
      0|      if (compare(element, target[mid]) < 0) {
       |        max = mid;
       |      } else {
      0|        min = mid + 1;
       |      }
       |    }
      0|    target.setRange(min + 1, targetOffset + i + 1, target, min);
      0|    target[min] = element;
       |  }
       |}
       |
       |/// Sorts [list] from [start] to [end] into [target] at [targetOffset].
       |///
       |/// The `target` list must be able to contain the range from `start` to `end`
       |/// after `targetOffset`.
       |///
       |/// Allows target to be the same list as [list], as long as it's not
       |/// overlapping the `start..end` range.
      0|void _mergeSort<T>(List<T> list, int Function(T, T) compare, int start, int end,
       |    List<T> target, int targetOffset) {
      0|  var length = end - start;
      0|  if (length < _MERGE_SORT_LIMIT) {
      0|    _movingInsertionSort(list, compare, start, end, target, targetOffset);
       |    return;
       |  }
      0|  var middle = start + (length >> 1);
      0|  var firstLength = middle - start;
      0|  var secondLength = end - middle;
       |  // Here secondLength >= firstLength (differs by at most one).
      0|  var targetMiddle = targetOffset + firstLength;
       |  // Sort the second half into the end of the target area.
      0|  _mergeSort(list, compare, middle, end, target, targetMiddle);
       |  // Sort the first half into the end of the source area.
      0|  _mergeSort(list, compare, start, middle, list, middle);
       |  // Merge the two parts into the target area.
      0|  _merge(compare, list, middle, middle + firstLength, target, targetMiddle,
      0|      targetMiddle + secondLength, target, targetOffset);
       |}
       |
       |/// Merges two lists into a target list.
       |///
       |/// One of the input lists may be positioned at the end of the target
       |/// list.
       |///
       |/// For equal object, elements from [firstList] are always preferred.
       |/// This allows the merge to be stable if the first list contains elements
       |/// that started out earlier than the ones in [secondList]
      0|void _merge<T>(
       |    int Function(T, T) compare,
       |    List<T> firstList,
       |    int firstStart,
       |    int firstEnd,
       |    List<T> secondList,
       |    int secondStart,
       |    int secondEnd,
       |    List<T> target,
       |    int targetOffset) {
       |  // No empty lists reaches here.
       |  assert(firstStart < firstEnd);
       |  assert(secondStart < secondEnd);
       |  var cursor1 = firstStart;
       |  var cursor2 = secondStart;
      0|  var firstElement = firstList[cursor1++];
      0|  var secondElement = secondList[cursor2++];
       |  while (true) {
      0|    if (compare(firstElement, secondElement) <= 0) {
      0|      target[targetOffset++] = firstElement;
      0|      if (cursor1 == firstEnd) break; // Flushing second list after loop.
      0|      firstElement = firstList[cursor1++];
       |    } else {
      0|      target[targetOffset++] = secondElement;
      0|      if (cursor2 != secondEnd) {
      0|        secondElement = secondList[cursor2++];
       |        continue;
       |      }
       |      // Second list empties first. Flushing first list here.
      0|      target[targetOffset++] = firstElement;
      0|      target.setRange(targetOffset, targetOffset + (firstEnd - cursor1),
       |          firstList, cursor1);
       |      return;
       |    }
       |  }
       |  // First list empties first. Reached by break above.
      0|  target[targetOffset++] = secondElement;
      0|  target.setRange(
      0|      targetOffset, targetOffset + (secondEnd - cursor2), secondList, cursor2);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/canonicalized_map.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'utils.dart';
       |
       |/// A map whose keys are converted to canonical values of type `C`.
       |///
       |/// This is useful for using case-insensitive String keys, for example. It's
       |/// more efficient than a [LinkedHashMap] with a custom equality operator
       |/// because it only canonicalizes each key once, rather than doing so for each
       |/// comparison.
       |///
       |/// By default, `null` is allowed as a key. It can be forbidden via the
       |/// `isValidKey` parameter.
       |class CanonicalizedMap<C, K, V> implements Map<K, V> {
       |  final C Function(K) _canonicalize;
       |
       |  final bool Function(Object) _isValidKeyFn;
       |
       |  final _base = <C, Pair<K, V>>{};
       |
       |  /// Creates an empty canonicalized map.
       |  ///
       |  /// The [canonicalize] function should return the canonical value for the
       |  /// given key. Keys with the same canonical value are considered equivalent.
       |  ///
       |  /// The [isValidKey] function is called before calling [canonicalize] for
       |  /// methods that take arbitrary objects. It can be used to filter out keys
       |  /// that can't be canonicalized.
      0|  CanonicalizedMap(C Function(K key) canonicalize,
       |      {bool Function(Object key) isValidKey})
       |      : _canonicalize = canonicalize,
       |        _isValidKeyFn = isValidKey;
       |
       |  /// Creates a canonicalized map that is initialized with the key/value pairs
       |  /// of [other].
       |  ///
       |  /// The [canonicalize] function should return the canonical value for the
       |  /// given key. Keys with the same canonical value are considered equivalent.
       |  ///
       |  /// The [isValidKey] function is called before calling [canonicalize] for
       |  /// methods that take arbitrary objects. It can be used to filter out keys
       |  /// that can't be canonicalized.
      0|  CanonicalizedMap.from(Map<K, V> other, C Function(K key) canonicalize,
       |      {bool Function(Object key) isValidKey})
       |      : _canonicalize = canonicalize,
       |        _isValidKeyFn = isValidKey {
      0|    addAll(other);
       |  }
       |
      0|  @override
       |  V operator [](Object key) {
      0|    if (!_isValidKey(key)) return null;
      0|    var pair = _base[_canonicalize(key as K)];
      0|    return pair == null ? null : pair.last;
       |  }
       |
      0|  @override
       |  void operator []=(K key, V value) {
      0|    if (!_isValidKey(key)) return;
      0|    _base[_canonicalize(key)] = Pair(key, value);
       |  }
       |
      0|  @override
       |  void addAll(Map<K, V> other) {
      0|    other.forEach((key, value) => this[key] = value);
       |  }
       |
      0|  @override
      0|  void addEntries(Iterable<MapEntry<K, V>> entries) => _base.addEntries(
      0|      entries.map((e) => MapEntry(_canonicalize(e.key), Pair(e.key, e.value))));
       |
      0|  @override
      0|  Map<K2, V2> cast<K2, V2>() => _base.cast<K2, V2>();
       |
      0|  @override
       |  void clear() {
      0|    _base.clear();
       |  }
       |
      0|  @override
       |  bool containsKey(Object key) {
      0|    if (!_isValidKey(key)) return false;
      0|    return _base.containsKey(_canonicalize(key as K));
       |  }
       |
      0|  @override
       |  bool containsValue(Object value) =>
      0|      _base.values.any((pair) => pair.last == value);
       |
      0|  @override
       |  Iterable<MapEntry<K, V>> get entries =>
      0|      _base.entries.map((e) => MapEntry(e.value.first, e.value.last));
       |
      0|  @override
       |  void forEach(void Function(K, V) f) {
      0|    _base.forEach((key, pair) => f(pair.first, pair.last));
       |  }
       |
      0|  @override
      0|  bool get isEmpty => _base.isEmpty;
       |
      0|  @override
      0|  bool get isNotEmpty => _base.isNotEmpty;
       |
      0|  @override
      0|  Iterable<K> get keys => _base.values.map((pair) => pair.first);
       |
      0|  @override
      0|  int get length => _base.length;
       |
      0|  @override
       |  Map<K2, V2> map<K2, V2>(MapEntry<K2, V2> Function(K, V) transform) =>
      0|      _base.map((_, pair) => transform(pair.first, pair.last));
       |
      0|  @override
       |  V putIfAbsent(K key, V Function() ifAbsent) {
      0|    return _base
      0|        .putIfAbsent(_canonicalize(key), () => Pair(key, ifAbsent()))
      0|        .last;
       |  }
       |
      0|  @override
       |  V remove(Object key) {
      0|    if (!_isValidKey(key)) return null;
      0|    var pair = _base.remove(_canonicalize(key as K));
      0|    return pair == null ? null : pair.last;
       |  }
       |
      0|  @override
       |  void removeWhere(bool Function(K key, V value) test) =>
      0|      _base.removeWhere((_, pair) => test(pair.first, pair.last));
       |
      0|  @deprecated
      0|  Map<K2, V2> retype<K2, V2>() => cast<K2, V2>();
       |
      0|  @override
      0|  V update(K key, V Function(V) update, {V Function() ifAbsent}) => _base
      0|      .update(_canonicalize(key), (pair) => Pair(key, update(pair.last)),
      0|          ifAbsent: ifAbsent == null ? null : () => Pair(key, ifAbsent()))
      0|      .last;
       |
      0|  @override
      0|  void updateAll(V Function(K key, V value) update) => _base
      0|      .updateAll((_, pair) => Pair(pair.first, update(pair.first, pair.last)));
       |
      0|  @override
      0|  Iterable<V> get values => _base.values.map((pair) => pair.last);
       |
      0|  @override
       |  String toString() {
       |    // Detect toString() cycles.
      0|    if (_isToStringVisiting(this)) {
       |      return '{...}';
       |    }
       |
      0|    var result = StringBuffer();
       |    try {
      0|      _toStringVisiting.add(this);
      0|      result.write('{');
       |      var first = true;
      0|      forEach((k, v) {
       |        if (!first) {
      0|          result.write(', ');
       |        }
       |        first = false;
      0|        result.write('$k: $v');
       |      });
      0|      result.write('}');
       |    } finally {
       |      assert(identical(_toStringVisiting.last, this));
      0|      _toStringVisiting.removeLast();
       |    }
       |
      0|    return result.toString();
       |  }
       |
      0|  bool _isValidKey(Object key) =>
      0|      (key == null || key is K) &&
      0|      (_isValidKeyFn == null || _isValidKeyFn(key));
       |}
       |
       |/// A collection used to identify cyclic maps during toString() calls.
      0|final List _toStringVisiting = [];
       |
       |/// Check if we are currently visiting `o` in a toString() call.
      0|bool _isToStringVisiting(o) => _toStringVisiting.any((e) => identical(o, e));
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/combined_wrappers/combined_iterable.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |/// A view of several iterables combined sequentially into a single iterable.
       |///
       |/// All methods and accessors treat the [CombinedIterableView] as if it were a
       |/// single concatenated iterable, but the underlying implementation is based on
       |/// lazily accessing individual iterable instances. This means that if the
       |/// underlying iterables change, the [CombinedIterableView] will reflect those
       |/// changes.
       |class CombinedIterableView<T> extends IterableBase<T> {
       |  /// The iterables that this combines.
       |  final Iterable<Iterable<T>> _iterables;
       |
       |  /// Creates a combined view of [iterables].
      0|  const CombinedIterableView(this._iterables);
       |
      0|  @override
       |  Iterator<T> get iterator =>
      0|      _CombinedIterator<T>(_iterables.map((i) => i.iterator).iterator);
       |
       |  // Special cased contains/isEmpty/length since many iterables have an
       |  // efficient implementation instead of running through the entire iterator.
       |
      0|  @override
      0|  bool contains(Object element) => _iterables.any((i) => i.contains(element));
       |
      0|  @override
      0|  bool get isEmpty => _iterables.every((i) => i.isEmpty);
       |
      0|  @override
      0|  int get length => _iterables.fold(0, (length, i) => length + i.length);
       |}
       |
       |/// The iterator for [CombinedIterableView].
       |///
       |/// This moves through each iterable's iterators in sequence.
       |class _CombinedIterator<T> implements Iterator<T> {
       |  /// The iterators that this combines.
       |  ///
       |  /// Because this comes from a call to [Iterable.map], it's lazy and will
       |  /// avoid instantiating unnecessary iterators.
       |  final Iterator<Iterator<T>> _iterators;
       |
      0|  _CombinedIterator(this._iterators);
       |
      0|  @override
      0|  T get current => _iterators.current?.current;
       |
      0|  @override
       |  bool moveNext() {
      0|    var current = _iterators.current;
      0|    if (current != null && current.moveNext()) {
       |      return true;
       |    }
      0|    return _iterators.moveNext() && moveNext();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/combined_wrappers/combined_list.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |/// A view of several lists combined into a single list.
       |///
       |/// All methods and accessors treat the [CombinedListView] list as if it were a
       |/// single concatenated list, but the underlying implementation is based on
       |/// lazily accessing individual list instances. This means that if the
       |/// underlying lists change, the [CombinedListView] will reflect those changes.
       |///
       |/// The index operator (`[]`) and [length] property of a [CombinedListView] are
       |/// both `O(lists)` rather than `O(1)`. A [CombinedListView] is unmodifiable.
       |class CombinedListView<T> extends ListBase<T>
       |    implements UnmodifiableListView<T> {
      0|  static void _throw() {
      0|    throw UnsupportedError('Cannot modify an unmodifiable List');
       |  }
       |
       |  /// The lists that this combines.
       |  final List<List<T>> _lists;
       |
       |  /// Creates a combined view of [lists].
      0|  CombinedListView(this._lists);
       |
      0|  @override
       |  set length(int length) {
      0|    _throw();
       |  }
       |
      0|  @override
      0|  int get length => _lists.fold(0, (length, list) => length + list.length);
       |
      0|  @override
       |  T operator [](int index) {
       |    var initialIndex = index;
      0|    for (var i = 0; i < _lists.length; i++) {
      0|      var list = _lists[i];
      0|      if (index < list.length) {
      0|        return list[index];
       |      }
      0|      index -= list.length;
       |    }
      0|    throw RangeError.index(initialIndex, this, 'index', null, length);
       |  }
       |
      0|  @override
       |  void operator []=(int index, T value) {
      0|    _throw();
       |  }
       |
      0|  @override
       |  void clear() {
      0|    _throw();
       |  }
       |
      0|  @override
       |  bool remove(Object element) {
      0|    _throw();
       |    return null;
       |  }
       |
      0|  @override
       |  void removeWhere(bool Function(T) test) {
      0|    _throw();
       |  }
       |
      0|  @override
       |  void retainWhere(bool Function(T) test) {
      0|    _throw();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/combined_wrappers/combined_map.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'combined_iterable.dart';
       |
       |/// Returns a new map that represents maps flattened into a single map.
       |///
       |/// All methods and accessors treat the new map as-if it were a single
       |/// concatenated map, but the underlying implementation is based on lazily
       |/// accessing individual map instances. In the occasion where a key occurs in
       |/// multiple maps the first value is returned.
       |///
       |/// The resulting map has an index operator (`[]`) that is `O(maps)`, rather
       |/// than `O(1)`, and the map is unmodifiable, but underlying changes to these
       |/// maps are still accessible from the resulting map.
       |///
       |/// The `length` getter is `O(M)` where M is the total number of entries in
       |/// all maps, since it has to remove duplicate entries.
       |class CombinedMapView<K, V> extends UnmodifiableMapBase<K, V> {
       |  final Iterable<Map<K, V>> _maps;
       |
       |  /// Create a new combined view of multiple maps.
       |  ///
       |  /// The iterable is accessed lazily so it should be collection type like
       |  /// [List] or [Set] rather than a lazy iterable produced by `map()` et al.
      0|  CombinedMapView(this._maps);
       |
      0|  @override
       |  V operator [](Object key) {
      0|    for (var map in _maps) {
       |      // Avoid two hash lookups on a positive hit.
      0|      var value = map[key];
      0|      if (value != null || map.containsKey(value)) {
       |        return value;
       |      }
       |    }
       |    return null;
       |  }
       |
       |  /// The keys of [this].
       |  ///
       |  /// The returned iterable has efficient `contains` operations, assuming the
       |  /// iterables returned by the wrapped maps have efficient `contains` operations
       |  /// for their `keys` iterables.
       |  ///
       |  /// The `length` must do deduplication and thus is not optimized.
       |  ///
       |  /// The order of iteration is defined by the individual `Map` implementations,
       |  /// but must be consistent between changes to the maps.
       |  ///
       |  /// Unlike most [Map] implementations, modifying an individual map while
       |  /// iterating the keys will _sometimes_ throw. This behavior may change in
       |  /// the future.
      0|  @override
      0|  Iterable<K> get keys => _DeduplicatingIterableView(
      0|      CombinedIterableView(_maps.map((m) => m.keys)));
       |}
       |
       |/// A view of an iterable that skips any duplicate entries.
       |class _DeduplicatingIterableView<T> extends IterableBase<T> {
       |  final Iterable<T> _iterable;
       |
      0|  const _DeduplicatingIterableView(this._iterable);
       |
      0|  @override
      0|  Iterator<T> get iterator => _DeduplicatingIterator(_iterable.iterator);
       |
       |  // Special cased contains/isEmpty since many iterables have an efficient
       |  // implementation instead of running through the entire iterator.
       |  //
       |  // Note: We do not do this for `length` because we have to remove the
       |  // duplicates.
       |
      0|  @override
      0|  bool contains(Object element) => _iterable.contains(element);
       |
      0|  @override
      0|  bool get isEmpty => _iterable.isEmpty;
       |}
       |
       |/// An iterator that wraps another iterator and skips duplicate values.
       |class _DeduplicatingIterator<T> implements Iterator<T> {
       |  final Iterator<T> _iterator;
       |
       |  final _emitted = HashSet<T>();
       |
      0|  _DeduplicatingIterator(this._iterator);
       |
      0|  @override
      0|  T get current => _iterator.current;
       |
      0|  @override
       |  bool moveNext() {
      0|    while (_iterator.moveNext()) {
      0|      if (_emitted.add(current)) {
       |        return true;
       |      }
       |    }
       |    return false;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/comparators.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// Character constants.
       |const int _zero = 0x30;
       |const int _upperCaseA = 0x41;
       |const int _upperCaseZ = 0x5a;
       |const int _lowerCaseA = 0x61;
       |const int _lowerCaseZ = 0x7a;
       |const int _asciiCaseBit = 0x20;
       |
       |/// Checks if strings [a] and [b] differ only on the case of ASCII letters.
       |///
       |/// Strings are equal if they have the same length, and the characters at
       |/// each index are the same, or they are ASCII letters where one is upper-case
       |/// and the other is the lower-case version of the same letter.
       |///
       |/// The comparison does not ignore the case of non-ASCII letters, so
       |/// an upper-case ae-ligature () is different from
       |/// a lower case ae-ligature ().
       |///
       |/// Ignoring non-ASCII letters is not generally a good idea, but it makes sense
       |/// for situations where the strings are known to be ASCII. Examples could
       |/// be Dart identifiers, base-64 or hex encoded strings, GUIDs or similar
       |/// strings with a known structure.
      0|bool equalsIgnoreAsciiCase(String a, String b) {
      0|  if (a.length != b.length) return false;
      0|  for (var i = 0; i < a.length; i++) {
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    // Quick-check for whether this may be different cases of the same letter.
      0|    if (aChar ^ bChar != _asciiCaseBit) return false;
       |    // If it's possible, then check if either character is actually an ASCII
       |    // letter.
      0|    var aCharLowerCase = aChar | _asciiCaseBit;
      0|    if (_lowerCaseA <= aCharLowerCase && aCharLowerCase <= _lowerCaseZ) {
       |      continue;
       |    }
       |    return false;
       |  }
       |  return true;
       |}
       |
       |/// Hash code for a string which is compatible with [equalsIgnoreAsciiCase].
       |///
       |/// The hash code is unaffected by changing the case of ASCII letters, but
       |/// the case of non-ASCII letters do affect the result.
      0|int hashIgnoreAsciiCase(String string) {
       |  // Jenkins hash code ( http://en.wikipedia.org/wiki/Jenkins_hash_function).
       |  // adapted to smi values.
       |  // Same hash used by dart2js for strings, modified to ignore ASCII letter
       |  // case.
       |  var hash = 0;
      0|  for (var i = 0; i < string.length; i++) {
      0|    var char = string.codeUnitAt(i);
       |    // Convert lower-case ASCII letters to upper case.upper
       |    // This ensures that strings that differ only in case will have the
       |    // same hash code.
      0|    if (_lowerCaseA <= char && char <= _lowerCaseZ) char -= _asciiCaseBit;
      0|    hash = 0x1fffffff & (hash + char);
      0|    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
      0|    hash >>= 6;
       |  }
      0|  hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
      0|  hash >>= 11;
      0|  return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
       |}
       |
       |/// Compares [a] and [b] lexically, converting ASCII letters to upper case.
       |///
       |/// Comparison treats all lower-case ASCII letters as upper-case letters,
       |/// but does no case conversion for non-ASCII letters.
       |///
       |/// If two strings differ only on the case of ASCII letters, the one with the
       |/// capital letter at the first difference will compare as less than the other
       |/// string. This tie-breaking ensures that the comparison is a total ordering
       |/// on strings and is compatible with equality.
       |///
       |/// Ignoring non-ASCII letters is not generally a good idea, but it makes sense
       |/// for situations where the strings are known to be ASCII. Examples could
       |/// be Dart identifiers, base-64 or hex encoded strings, GUIDs or similar
       |/// strings with a known structure.
      0|int compareAsciiUpperCase(String a, String b) {
       |  var defaultResult = 0; // Returned if no difference found.
      0|  for (var i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    // Upper-case if letters.
       |    var aUpperCase = aChar;
       |    var bUpperCase = bChar;
      0|    if (_lowerCaseA <= aChar && aChar <= _lowerCaseZ) {
      0|      aUpperCase -= _asciiCaseBit;
       |    }
      0|    if (_lowerCaseA <= bChar && bChar <= _lowerCaseZ) {
      0|      bUpperCase -= _asciiCaseBit;
       |    }
      0|    if (aUpperCase != bUpperCase) return (aUpperCase - bUpperCase).sign;
      0|    if (defaultResult == 0) defaultResult = (aChar - bChar);
       |  }
      0|  if (b.length > a.length) return -1;
      0|  return defaultResult.sign;
       |}
       |
       |/// Compares [a] and [b] lexically, converting ASCII letters to lower case.
       |///
       |/// Comparison treats all upper-case ASCII letters as lower-case letters,
       |/// but does no case conversion for non-ASCII letters.
       |///
       |/// If two strings differ only on the case of ASCII letters, the one with the
       |/// capital letter at the first difference will compare as less than the other
       |/// string. This tie-breaking ensures that the comparison is a total ordering
       |/// on strings.
       |///
       |/// Ignoring non-ASCII letters is not generally a good idea, but it makes sense
       |/// for situations where the strings are known to be ASCII. Examples could
       |/// be Dart identifiers, base-64 or hex encoded strings, GUIDs or similar
       |/// strings with a known structure.
      0|int compareAsciiLowerCase(String a, String b) {
       |  var defaultResult = 0;
      0|  for (var i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    var aLowerCase = aChar;
       |    var bLowerCase = bChar;
       |    // Upper case if ASCII letters.
      0|    if (_upperCaseA <= bChar && bChar <= _upperCaseZ) {
      0|      bLowerCase += _asciiCaseBit;
       |    }
      0|    if (_upperCaseA <= aChar && aChar <= _upperCaseZ) {
      0|      aLowerCase += _asciiCaseBit;
       |    }
      0|    if (aLowerCase != bLowerCase) return (aLowerCase - bLowerCase).sign;
      0|    if (defaultResult == 0) defaultResult = aChar - bChar;
       |  }
      0|  if (b.length > a.length) return -1;
      0|  return defaultResult.sign;
       |}
       |
       |/// Compares strings [a] and [b] according to [natural sort ordering][].
       |///
       |/// A natural sort ordering is a lexical ordering where embedded
       |/// numerals (digit sequences) are treated as a single unit and ordered by
       |/// numerical value.
       |/// This means that `"a10b"` will be ordered after `"a7b"` in natural
       |/// ordering, where lexical ordering would put the `1` before the `7`, ignoring
       |/// that the `1` is part of a larger number.
       |///
       |/// Example:
       |/// The following strings are in the order they would be sorted by using this
       |/// comparison function:
       |///
       |///     "a", "a0", "a0b", "a1", "a01", "a9", "a10", "a100", "a100b", "aa"
       |///
       |/// [natural sort ordering]: https://en.wikipedia.org/wiki/Natural_sort_order
      0|int compareNatural(String a, String b) {
      0|  for (var i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar != bChar) {
      0|      return _compareNaturally(a, b, i, aChar, bChar);
       |    }
       |  }
      0|  if (b.length > a.length) return -1;
       |  return 0;
       |}
       |
       |/// Compares strings [a] and [b] according to lower-case
       |/// [natural sort ordering][].
       |///
       |/// ASCII letters are converted to lower case before being compared, like
       |/// for [compareAsciiLowerCase], then the result is compared like for
       |/// [compareNatural].
       |///
       |/// If two strings differ only on the case of ASCII letters, the one with the
       |/// capital letter at the first difference will compare as less than the other
       |/// string. This tie-breaking ensures that the comparison is a total ordering
       |/// on strings.
       |///
       |/// [natural sort ordering]: https://en.wikipedia.org/wiki/Natural_sort_order
      0|int compareAsciiLowerCaseNatural(String a, String b) {
       |  var defaultResult = 0; // Returned if no difference found.
      0|  for (var i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    var aLowerCase = aChar;
       |    var bLowerCase = bChar;
      0|    if (_upperCaseA <= aChar && aChar <= _upperCaseZ) {
      0|      aLowerCase += _asciiCaseBit;
       |    }
      0|    if (_upperCaseA <= bChar && bChar <= _upperCaseZ) {
      0|      bLowerCase += _asciiCaseBit;
       |    }
      0|    if (aLowerCase != bLowerCase) {
      0|      return _compareNaturally(a, b, i, aLowerCase, bLowerCase);
       |    }
      0|    if (defaultResult == 0) defaultResult = aChar - bChar;
       |  }
      0|  if (b.length > a.length) return -1;
      0|  return defaultResult.sign;
       |}
       |
       |/// Compares strings [a] and [b] according to upper-case
       |/// [natural sort ordering][].
       |///
       |/// ASCII letters are converted to upper case before being compared, like
       |/// for [compareAsciiUpperCase], then the result is compared like for
       |/// [compareNatural].
       |///
       |/// If two strings differ only on the case of ASCII letters, the one with the
       |/// capital letter at the first difference will compare as less than the other
       |/// string. This tie-breaking ensures that the comparison is a total ordering
       |/// on strings
       |///
       |/// [natural sort ordering]: https://en.wikipedia.org/wiki/Natural_sort_order
      0|int compareAsciiUpperCaseNatural(String a, String b) {
       |  var defaultResult = 0;
      0|  for (var i = 0; i < a.length; i++) {
      0|    if (i >= b.length) return 1;
      0|    var aChar = a.codeUnitAt(i);
      0|    var bChar = b.codeUnitAt(i);
      0|    if (aChar == bChar) continue;
       |    var aUpperCase = aChar;
       |    var bUpperCase = bChar;
      0|    if (_lowerCaseA <= aChar && aChar <= _lowerCaseZ) {
      0|      aUpperCase -= _asciiCaseBit;
       |    }
      0|    if (_lowerCaseA <= bChar && bChar <= _lowerCaseZ) {
      0|      bUpperCase -= _asciiCaseBit;
       |    }
      0|    if (aUpperCase != bUpperCase) {
      0|      return _compareNaturally(a, b, i, aUpperCase, bUpperCase);
       |    }
      0|    if (defaultResult == 0) defaultResult = aChar - bChar;
       |  }
      0|  if (b.length > a.length) return -1;
      0|  return defaultResult.sign;
       |}
       |
       |/// Check for numbers overlapping the current mismatched characters.
       |///
       |/// If both [aChar] and [bChar] are digits, use numerical comparison.
       |/// Check if the previous characters is a non-zero number, and if not,
       |/// skip - but count - leading zeros before comparing numbers.
       |///
       |/// If one is a digit and the other isn't, check if the previous character
       |/// is a digit, and if so, the the one with the digit is the greater number.
       |///
       |/// Otherwise just returns the difference between [aChar] and [bChar].
      0|int _compareNaturally(String a, String b, int index, int aChar, int bChar) {
       |  assert(aChar != bChar);
      0|  var aIsDigit = _isDigit(aChar);
      0|  var bIsDigit = _isDigit(bChar);
       |  if (aIsDigit) {
       |    if (bIsDigit) {
      0|      return _compareNumerically(a, b, aChar, bChar, index);
      0|    } else if (index > 0 && _isDigit(a.codeUnitAt(index - 1))) {
       |      // aChar is the continuation of a longer number.
       |      return 1;
       |    }
      0|  } else if (bIsDigit && index > 0 && _isDigit(b.codeUnitAt(index - 1))) {
       |    // bChar is the continuation of a longer number.
      0|    return -1;
       |  }
       |  // Characters are both non-digits, or not continuation of earlier number.
      0|  return (aChar - bChar).sign;
       |}
       |
       |/// Compare numbers overlapping [aChar] and [bChar] numerically.
       |///
       |/// If the numbers have the same numerical value, but one has more leading
       |/// zeros, the longer number is considered greater than the shorter one.
       |///
       |/// This ensures a total ordering on strings compatible with equality.
      0|int _compareNumerically(String a, String b, int aChar, int bChar, int index) {
       |  // Both are digits. Find the first significant different digit, then find
       |  // the length of the numbers.
      0|  if (_isNonZeroNumberSuffix(a, index)) {
       |    // Part of a longer number, differs at this index, just count the length.
      0|    var result = _compareDigitCount(a, b, index, index);
      0|    if (result != 0) return result;
       |    // If same length, the current character is the most significant differing
       |    // digit.
      0|    return (aChar - bChar).sign;
       |  }
       |  // Not part of larger (non-zero) number, so skip leading zeros before
       |  // comparing numbers.
       |  var aIndex = index;
       |  var bIndex = index;
      0|  if (aChar == _zero) {
       |    do {
      0|      aIndex++;
      0|      if (aIndex == a.length) return -1; // number in a is zero, b is not.
      0|      aChar = a.codeUnitAt(aIndex);
      0|    } while (aChar == _zero);
      0|    if (!_isDigit(aChar)) return -1;
      0|  } else if (bChar == _zero) {
       |    do {
      0|      bIndex++;
      0|      if (bIndex == b.length) return 1; // number in b is zero, a is not.
      0|      bChar = b.codeUnitAt(bIndex);
      0|    } while (bChar == _zero);
      0|    if (!_isDigit(bChar)) return 1;
       |  }
      0|  if (aChar != bChar) {
      0|    var result = _compareDigitCount(a, b, aIndex, bIndex);
      0|    if (result != 0) return result;
      0|    return (aChar - bChar).sign;
       |  }
       |  // Same leading digit, one had more leading zeros.
       |  // Compare digits until reaching a difference.
       |  while (true) {
       |    var aIsDigit = false;
       |    var bIsDigit = false;
       |    aChar = 0;
       |    bChar = 0;
      0|    if (++aIndex < a.length) {
      0|      aChar = a.codeUnitAt(aIndex);
      0|      aIsDigit = _isDigit(aChar);
       |    }
      0|    if (++bIndex < b.length) {
      0|      bChar = b.codeUnitAt(bIndex);
      0|      bIsDigit = _isDigit(bChar);
       |    }
       |    if (aIsDigit) {
       |      if (bIsDigit) {
      0|        if (aChar == bChar) continue;
       |        // First different digit found.
       |        break;
       |      }
       |      // bChar is non-digit, so a has longer number.
       |      return 1;
       |    } else if (bIsDigit) {
      0|      return -1; // b has longer number.
       |    } else {
       |      // Neither is digit, so numbers had same numerical value.
       |      // Fall back on number of leading zeros
       |      // (reflected by difference in indices).
      0|      return (aIndex - bIndex).sign;
       |    }
       |  }
       |  // At first differing digits.
      0|  var result = _compareDigitCount(a, b, aIndex, bIndex);
      0|  if (result != 0) return result;
      0|  return (aChar - bChar).sign;
       |}
       |
       |/// Checks which of [a] and [b] has the longest sequence of digits.
       |///
       |/// Starts counting from `i + 1` and `j + 1` (assumes that `a[i]` and `b[j]` are
       |/// both already known to be digits).
      0|int _compareDigitCount(String a, String b, int i, int j) {
      0|  while (++i < a.length) {
      0|    var aIsDigit = _isDigit(a.codeUnitAt(i));
      0|    if (++j == b.length) return aIsDigit ? 1 : 0;
      0|    var bIsDigit = _isDigit(b.codeUnitAt(j));
       |    if (aIsDigit) {
       |      if (bIsDigit) continue;
       |      return 1;
       |    } else if (bIsDigit) {
      0|      return -1;
       |    } else {
       |      return 0;
       |    }
       |  }
      0|  if (++j < b.length && _isDigit(b.codeUnitAt(j))) {
      0|    return -1;
       |  }
       |  return 0;
       |}
       |
      0|bool _isDigit(int charCode) => (charCode ^ _zero) <= 9;
       |
       |/// Check if the digit at [index] is continuing a non-zero number.
       |///
       |/// If there is no non-zero digits before, then leading zeros at [index]
       |/// are also ignored when comparing numerically. If there is a non-zero digit
       |/// before, then zeros at [index] are significant.
      0|bool _isNonZeroNumberSuffix(String string, int index) {
      0|  while (--index >= 0) {
      0|    var char = string.codeUnitAt(index);
      0|    if (char != _zero) return _isDigit(char);
       |  }
       |  return false;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/equality.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'comparators.dart';
       |
       |const int _HASH_MASK = 0x7fffffff;
       |
       |/// A generic equality relation on objects.
       |abstract class Equality<E> {
       |  const factory Equality() = DefaultEquality<E>;
       |
       |  /// Compare two elements for being equal.
       |  ///
       |  /// This should be a proper equality relation.
       |  bool equals(E e1, E e2);
       |
       |  /// Get a hashcode of an element.
       |  ///
       |  /// The hashcode should be compatible with [equals], so that if
       |  /// `equals(a, b)` then `hash(a) == hash(b)`.
       |  int hash(E e);
       |
       |  /// Test whether an object is a valid argument to [equals] and [hash].
       |  ///
       |  /// Some implementations may be restricted to only work on specific types
       |  /// of objects.
       |  bool isValidKey(Object o);
       |}
       |
       |/// Equality of objects based on derived values.
       |///
       |/// For example, given the class:
       |/// ```dart
       |/// abstract class Employee {
       |///   int get employmentId;
       |/// }
       |/// ```
       |///
       |/// The following [Equality] considers employees with the same IDs to be equal:
       |/// ```dart
       |/// EqualityBy((Employee e) => e.employmentId);
       |/// ```
       |///
       |/// It's also possible to pass an additional equality instance that should be
       |/// used to compare the value itself.
       |class EqualityBy<E, F> implements Equality<E> {
       |  final F Function(E) _comparisonKey;
       |
       |  final Equality<F> _inner;
       |
      0|  EqualityBy(F Function(E) comparisonKey,
       |      [Equality<F> inner = const DefaultEquality()])
       |      : _comparisonKey = comparisonKey,
       |        _inner = inner;
       |
      0|  @override
       |  bool equals(E e1, E e2) =>
      0|      _inner.equals(_comparisonKey(e1), _comparisonKey(e2));
       |
      0|  @override
      0|  int hash(E e) => _inner.hash(_comparisonKey(e));
       |
      0|  @override
       |  bool isValidKey(Object o) {
      0|    if (o is E) {
      0|      final value = _comparisonKey(o);
      0|      return value is F && _inner.isValidKey(value);
       |    }
       |    return false;
       |  }
       |}
       |
       |/// Equality of objects that compares only the natural equality of the objects.
       |///
       |/// This equality uses the objects' own [Object.==] and [Object.hashCode] for
       |/// the equality.
       |///
       |/// Note that [equals] and [hash] take `Object`s rather than `E`s. This allows
       |/// `E` to be inferred as `Null` in const contexts where `E` wouldn't be a
       |/// compile-time constant, while still allowing the class to be used at runtime.
       |class DefaultEquality<E> implements Equality<E> {
      0|  const DefaultEquality();
      0|  @override
      0|  bool equals(Object e1, Object e2) => e1 == e2;
      0|  @override
      0|  int hash(Object e) => e.hashCode;
      0|  @override
       |  bool isValidKey(Object o) => true;
       |}
       |
       |/// Equality of objects that compares only the identity of the objects.
       |class IdentityEquality<E> implements Equality<E> {
      0|  const IdentityEquality();
      0|  @override
       |  bool equals(E e1, E e2) => identical(e1, e2);
      0|  @override
      0|  int hash(E e) => identityHashCode(e);
      0|  @override
       |  bool isValidKey(Object o) => true;
       |}
       |
       |/// Equality on iterables.
       |///
       |/// Two iterables are equal if they have the same elements in the same order.
       |///
       |/// The [equals] and [hash] methods accepts `null` values,
       |/// even if the [isValidKey] returns `false` for `null`.
       |/// The [hash] of `null` is `null.hashCode`.
       |class IterableEquality<E> implements Equality<Iterable<E>> {
       |  final Equality<E> _elementEquality;
      0|  const IterableEquality(
       |      [Equality<E> elementEquality = const DefaultEquality()])
       |      : _elementEquality = elementEquality;
       |
      0|  @override
       |  bool equals(Iterable<E> elements1, Iterable<E> elements2) {
       |    if (identical(elements1, elements2)) return true;
       |    if (elements1 == null || elements2 == null) return false;
      0|    var it1 = elements1.iterator;
      0|    var it2 = elements2.iterator;
       |    while (true) {
      0|      var hasNext = it1.moveNext();
      0|      if (hasNext != it2.moveNext()) return false;
       |      if (!hasNext) return true;
      0|      if (!_elementEquality.equals(it1.current, it2.current)) return false;
       |    }
       |  }
       |
      0|  @override
       |  int hash(Iterable<E> elements) {
      0|    if (elements == null) return null.hashCode;
       |    // Jenkins's one-at-a-time hash function.
       |    var hash = 0;
      0|    for (var element in elements) {
      0|      var c = _elementEquality.hash(element);
      0|      hash = (hash + c) & _HASH_MASK;
      0|      hash = (hash + (hash << 10)) & _HASH_MASK;
      0|      hash ^= (hash >> 6);
       |    }
      0|    hash = (hash + (hash << 3)) & _HASH_MASK;
      0|    hash ^= (hash >> 11);
      0|    hash = (hash + (hash << 15)) & _HASH_MASK;
       |    return hash;
       |  }
       |
      0|  @override
      0|  bool isValidKey(Object o) => o is Iterable<E>;
       |}
       |
       |/// Equality on lists.
       |///
       |/// Two lists are equal if they have the same length and their elements
       |/// at each index are equal.
       |///
       |/// This is effectively the same as [IterableEquality] except that it
       |/// accesses elements by index instead of through iteration.
       |///
       |/// The [equals] and [hash] methods accepts `null` values,
       |/// even if the [isValidKey] returns `false` for `null`.
       |/// The [hash] of `null` is `null.hashCode`.
       |class ListEquality<E> implements Equality<List<E>> {
       |  final Equality<E> _elementEquality;
      0|  const ListEquality([Equality<E> elementEquality = const DefaultEquality()])
       |      : _elementEquality = elementEquality;
       |
      0|  @override
       |  bool equals(List<E> list1, List<E> list2) {
       |    if (identical(list1, list2)) return true;
       |    if (list1 == null || list2 == null) return false;
      0|    var length = list1.length;
      0|    if (length != list2.length) return false;
      0|    for (var i = 0; i < length; i++) {
      0|      if (!_elementEquality.equals(list1[i], list2[i])) return false;
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  int hash(List<E> list) {
      0|    if (list == null) return null.hashCode;
       |    // Jenkins's one-at-a-time hash function.
       |    // This code is almost identical to the one in IterableEquality, except
       |    // that it uses indexing instead of iterating to get the elements.
       |    var hash = 0;
      0|    for (var i = 0; i < list.length; i++) {
      0|      var c = _elementEquality.hash(list[i]);
      0|      hash = (hash + c) & _HASH_MASK;
      0|      hash = (hash + (hash << 10)) & _HASH_MASK;
      0|      hash ^= (hash >> 6);
       |    }
      0|    hash = (hash + (hash << 3)) & _HASH_MASK;
      0|    hash ^= (hash >> 11);
      0|    hash = (hash + (hash << 15)) & _HASH_MASK;
       |    return hash;
       |  }
       |
      0|  @override
      0|  bool isValidKey(Object o) => o is List<E>;
       |}
       |
       |abstract class _UnorderedEquality<E, T extends Iterable<E>>
       |    implements Equality<T> {
       |  final Equality<E> _elementEquality;
       |
      0|  const _UnorderedEquality(this._elementEquality);
       |
      0|  @override
       |  bool equals(T elements1, T elements2) {
       |    if (identical(elements1, elements2)) return true;
       |    if (elements1 == null || elements2 == null) return false;
      0|    var counts = HashMap(
      0|        equals: _elementEquality.equals,
      0|        hashCode: _elementEquality.hash,
      0|        isValidKey: _elementEquality.isValidKey);
       |    var length = 0;
      0|    for (var e in elements1) {
      0|      var count = counts[e] ?? 0;
      0|      counts[e] = count + 1;
      0|      length++;
       |    }
      0|    for (var e in elements2) {
      0|      var count = counts[e];
      0|      if (count == null || count == 0) return false;
      0|      counts[e] = count - 1;
      0|      length--;
       |    }
      0|    return length == 0;
       |  }
       |
      0|  @override
       |  int hash(T elements) {
      0|    if (elements == null) return null.hashCode;
       |    var hash = 0;
      0|    for (E element in elements) {
      0|      var c = _elementEquality.hash(element);
      0|      hash = (hash + c) & _HASH_MASK;
       |    }
      0|    hash = (hash + (hash << 3)) & _HASH_MASK;
      0|    hash ^= (hash >> 11);
      0|    hash = (hash + (hash << 15)) & _HASH_MASK;
       |    return hash;
       |  }
       |}
       |
       |/// Equality of the elements of two iterables without considering order.
       |///
       |/// Two iterables are considered equal if they have the same number of elements,
       |/// and the elements of one set can be paired with the elements
       |/// of the other iterable, so that each pair are equal.
       |class UnorderedIterableEquality<E> extends _UnorderedEquality<E, Iterable<E>> {
      0|  const UnorderedIterableEquality(
       |      [Equality<E> elementEquality = const DefaultEquality()])
      0|      : super(elementEquality);
       |
      0|  @override
      0|  bool isValidKey(Object o) => o is Iterable<E>;
       |}
       |
       |/// Equality of sets.
       |///
       |/// Two sets are considered equal if they have the same number of elements,
       |/// and the elements of one set can be paired with the elements
       |/// of the other set, so that each pair are equal.
       |///
       |/// This equality behaves the same as [UnorderedIterableEquality] except that
       |/// it expects sets instead of iterables as arguments.
       |///
       |/// The [equals] and [hash] methods accepts `null` values,
       |/// even if the [isValidKey] returns `false` for `null`.
       |/// The [hash] of `null` is `null.hashCode`.
       |class SetEquality<E> extends _UnorderedEquality<E, Set<E>> {
      0|  const SetEquality([Equality<E> elementEquality = const DefaultEquality()])
      0|      : super(elementEquality);
       |
      0|  @override
      0|  bool isValidKey(Object o) => o is Set<E>;
       |}
       |
       |/// Internal class used by [MapEquality].
       |///
       |/// The class represents a map entry as a single object,
       |/// using a combined hashCode and equality of the key and value.
       |class _MapEntry {
       |  final MapEquality equality;
       |  final key;
       |  final value;
      0|  _MapEntry(this.equality, this.key, this.value);
       |
      0|  @override
       |  int get hashCode =>
      0|      (3 * equality._keyEquality.hash(key) +
      0|          7 * equality._valueEquality.hash(value)) &
       |      _HASH_MASK;
       |
      0|  @override
       |  bool operator ==(Object other) =>
      0|      other is _MapEntry &&
      0|      equality._keyEquality.equals(key, other.key) &&
      0|      equality._valueEquality.equals(value, other.value);
       |}
       |
       |/// Equality on maps.
       |///
       |/// Two maps are equal if they have the same number of entries, and if the
       |/// entries of the two maps are pairwise equal on both key and value.
       |///
       |/// The [equals] and [hash] methods accepts `null` values,
       |/// even if the [isValidKey] returns `false` for `null`.
       |/// The [hash] of `null` is `null.hashCode`.
       |class MapEquality<K, V> implements Equality<Map<K, V>> {
       |  final Equality<K> _keyEquality;
       |  final Equality<V> _valueEquality;
      0|  const MapEquality(
       |      {Equality<K> keys = const DefaultEquality(),
       |      Equality<V> values = const DefaultEquality()})
       |      : _keyEquality = keys,
       |        _valueEquality = values;
       |
      0|  @override
       |  bool equals(Map<K, V> map1, Map<K, V> map2) {
       |    if (identical(map1, map2)) return true;
       |    if (map1 == null || map2 == null) return false;
      0|    var length = map1.length;
      0|    if (length != map2.length) return false;
      0|    Map<_MapEntry, int> equalElementCounts = HashMap();
      0|    for (var key in map1.keys) {
      0|      var entry = _MapEntry(this, key, map1[key]);
      0|      var count = equalElementCounts[entry] ?? 0;
      0|      equalElementCounts[entry] = count + 1;
       |    }
      0|    for (var key in map2.keys) {
      0|      var entry = _MapEntry(this, key, map2[key]);
      0|      var count = equalElementCounts[entry];
      0|      if (count == null || count == 0) return false;
      0|      equalElementCounts[entry] = count - 1;
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  int hash(Map<K, V> map) {
      0|    if (map == null) return null.hashCode;
       |    var hash = 0;
      0|    for (var key in map.keys) {
      0|      var keyHash = _keyEquality.hash(key);
      0|      var valueHash = _valueEquality.hash(map[key]);
      0|      hash = (hash + 3 * keyHash + 7 * valueHash) & _HASH_MASK;
       |    }
      0|    hash = (hash + (hash << 3)) & _HASH_MASK;
      0|    hash ^= (hash >> 11);
      0|    hash = (hash + (hash << 15)) & _HASH_MASK;
       |    return hash;
       |  }
       |
      0|  @override
      0|  bool isValidKey(Object o) => o is Map<K, V>;
       |}
       |
       |/// Combines several equalities into a single equality.
       |///
       |/// Tries each equality in order, using [Equality.isValidKey], and returns
       |/// the result of the first equality that applies to the argument or arguments.
       |///
       |/// For `equals`, the first equality that matches the first argument is used,
       |/// and if the second argument of `equals` is not valid for that equality,
       |/// it returns false.
       |///
       |/// Because the equalities are tried in order, they should generally work on
       |/// disjoint types. Otherwise the multi-equality may give inconsistent results
       |/// for `equals(e1, e2)` and `equals(e2, e1)`. This can happen if one equality
       |/// considers only `e1` a valid key, and not `e2`, but an equality which is
       |/// checked later, allows both.
       |class MultiEquality<E> implements Equality<E> {
       |  final Iterable<Equality<E>> _equalities;
       |
      0|  const MultiEquality(Iterable<Equality<E>> equalities)
       |      : _equalities = equalities;
       |
      0|  @override
       |  bool equals(E e1, E e2) {
      0|    for (var eq in _equalities) {
      0|      if (eq.isValidKey(e1)) return eq.isValidKey(e2) && eq.equals(e1, e2);
       |    }
       |    return false;
       |  }
       |
      0|  @override
       |  int hash(E e) {
      0|    for (var eq in _equalities) {
      0|      if (eq.isValidKey(e)) return eq.hash(e);
       |    }
       |    return 0;
       |  }
       |
      0|  @override
       |  bool isValidKey(Object o) {
      0|    for (var eq in _equalities) {
      0|      if (eq.isValidKey(o)) return true;
       |    }
       |    return false;
       |  }
       |}
       |
       |/// Deep equality on collections.
       |///
       |/// Recognizes lists, sets, iterables and maps and compares their elements using
       |/// deep equality as well.
       |///
       |/// Non-iterable/map objects are compared using a configurable base equality.
       |///
       |/// Works in one of two modes: ordered or unordered.
       |///
       |/// In ordered mode, lists and iterables are required to have equal elements
       |/// in the same order. In unordered mode, the order of elements in iterables
       |/// and lists are not important.
       |///
       |/// A list is only equal to another list, likewise for sets and maps. All other
       |/// iterables are compared as iterables only.
       |class DeepCollectionEquality implements Equality {
       |  final Equality _base;
       |  final bool _unordered;
      0|  const DeepCollectionEquality([Equality base = const DefaultEquality()])
       |      : _base = base,
       |        _unordered = false;
       |
       |  /// Creates a deep equality on collections where the order of lists and
       |  /// iterables are not considered important. That is, lists and iterables are
       |  /// treated as unordered iterables.
      0|  const DeepCollectionEquality.unordered(
       |      [Equality base = const DefaultEquality()])
       |      : _base = base,
       |        _unordered = true;
       |
      0|  @override
       |  bool equals(e1, e2) {
      0|    if (e1 is Set) {
      0|      return e2 is Set && SetEquality(this).equals(e1, e2);
       |    }
      0|    if (e1 is Map) {
      0|      return e2 is Map && MapEquality(keys: this, values: this).equals(e1, e2);
       |    }
      0|    if (!_unordered) {
      0|      if (e1 is List) {
      0|        return e2 is List && ListEquality(this).equals(e1, e2);
       |      }
      0|      if (e1 is Iterable) {
      0|        return e2 is Iterable && IterableEquality(this).equals(e1, e2);
       |      }
      0|    } else if (e1 is Iterable) {
      0|      if (e1 is List != e2 is List) return false;
      0|      return e2 is Iterable && UnorderedIterableEquality(this).equals(e1, e2);
       |    }
      0|    return _base.equals(e1, e2);
       |  }
       |
      0|  @override
       |  int hash(Object o) {
      0|    if (o is Set) return SetEquality(this).hash(o);
      0|    if (o is Map) return MapEquality(keys: this, values: this).hash(o);
      0|    if (!_unordered) {
      0|      if (o is List) return ListEquality(this).hash(o);
      0|      if (o is Iterable) return IterableEquality(this).hash(o);
      0|    } else if (o is Iterable) {
      0|      return UnorderedIterableEquality(this).hash(o);
       |    }
      0|    return _base.hash(o);
       |  }
       |
      0|  @override
      0|  bool isValidKey(Object o) => o is Iterable || o is Map || _base.isValidKey(o);
       |}
       |
       |/// String equality that's insensitive to differences in ASCII case.
       |///
       |/// Non-ASCII characters are compared as-is, with no conversion.
       |class CaseInsensitiveEquality implements Equality<String> {
      0|  const CaseInsensitiveEquality();
       |
      0|  @override
       |  bool equals(String string1, String string2) =>
      0|      equalsIgnoreAsciiCase(string1, string2);
       |
      0|  @override
      0|  int hash(String string) => hashIgnoreAsciiCase(string);
       |
      0|  @override
      0|  bool isValidKey(Object object) => object is String;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/equality_map.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'equality.dart';
       |import 'wrappers.dart';
       |
       |/// A [Map] whose key equality is determined by an [Equality] object.
       |class EqualityMap<K, V> extends DelegatingMap<K, V> {
       |  /// Creates a map with equality based on [equality].
      0|  EqualityMap(Equality<K> equality)
      0|      : super(LinkedHashMap(
      0|            equals: equality.equals,
      0|            hashCode: equality.hash,
      0|            isValidKey: equality.isValidKey));
       |
       |  /// Creates a map with equality based on [equality] that contains all
       |  /// key-value pairs of [other].
       |  ///
       |  /// If [other] has multiple keys that are equivalent according to [equality],
       |  /// the last one reached during iteration takes precedence.
      0|  EqualityMap.from(Equality<K> equality, Map<K, V> other)
      0|      : super(LinkedHashMap(
      0|            equals: equality.equals,
      0|            hashCode: equality.hash,
      0|            isValidKey: equality.isValidKey)) {
      0|    addAll(other);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/equality_set.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'equality.dart';
       |import 'wrappers.dart';
       |
       |/// A [Set] whose key equality is determined by an [Equality] object.
       |class EqualitySet<E> extends DelegatingSet<E> {
       |  /// Creates a set with equality based on [equality].
      0|  EqualitySet(Equality<E> equality)
      0|      : super(LinkedHashSet(
      0|            equals: equality.equals,
      0|            hashCode: equality.hash,
      0|            isValidKey: equality.isValidKey));
       |
       |  /// Creates a set with equality based on [equality] that contains all
       |  /// elements in [other].
       |  ///
       |  /// If [other] has multiple values that are equivalent according to
       |  /// [equality], the first one reached during iteration takes precedence.
      0|  EqualitySet.from(Equality<E> equality, Iterable<E> other)
      0|      : super(LinkedHashSet(
      0|            equals: equality.equals,
      0|            hashCode: equality.hash,
      0|            isValidKey: equality.isValidKey)) {
      0|    addAll(other);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/functions.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |import 'dart:math' as math;
       |
       |import 'utils.dart';
       |
       |/// Creates a new map from [map] with new keys and values.
       |///
       |/// The return values of [key] are used as the keys and the return values of
       |/// [value] are used as the values for the new map.
      0|@Deprecated('Use Map.map or a for loop in a Map literal.')
       |Map<K2, V2> mapMap<K1, V1, K2, V2>(Map<K1, V1> map,
       |    {K2 Function(K1, V1) key, V2 Function(K1, V1) value}) {
      0|  key ??= (mapKey, _) => mapKey as K2;
      0|  value ??= (_, mapValue) => mapValue as V2;
       |
      0|  var result = <K2, V2>{};
      0|  map.forEach((mapKey, mapValue) {
      0|    result[key(mapKey, mapValue)] = value(mapKey, mapValue);
       |  });
       |  return result;
       |}
       |
       |/// Returns a new map with all key/value pairs in both [map1] and [map2].
       |///
       |/// If there are keys that occur in both maps, the [value] function is used to
       |/// select the value that goes into the resulting map based on the two original
       |/// values. If [value] is omitted, the value from [map2] is used.
      1|Map<K, V> mergeMaps<K, V>(Map<K, V> map1, Map<K, V> map2,
       |    {V Function(V, V) value}) {
      1|  var result = Map<K, V>.from(map1);
      0|  if (value == null) return result..addAll(map2);
       |
      1|  map2.forEach((key, mapValue) {
      0|    result[key] =
      0|        result.containsKey(key) ? value(result[key], mapValue) : mapValue;
       |  });
       |  return result;
       |}
       |
       |/// Groups the elements in [values] by the value returned by [key].
       |///
       |/// Returns a map from keys computed by [key] to a list of all values for which
       |/// [key] returns that key. The values appear in the list in the same relative
       |/// order as in [values].
      0|Map<T, List<S>> groupBy<S, T>(Iterable<S> values, T Function(S) key) {
      0|  var map = <T, List<S>>{};
      0|  for (var element in values) {
      0|    (map[key(element)] ??= []).add(element);
       |  }
       |  return map;
       |}
       |
       |/// Returns the element of [values] for which [orderBy] returns the minimum
       |/// value.
       |///
       |/// The values returned by [orderBy] are compared using the [compare] function.
       |/// If [compare] is omitted, values must implement [Comparable<T>] and they are
       |/// compared using their [Comparable.compareTo].
      0|S minBy<S, T>(Iterable<S> values, T Function(S) orderBy,
       |    {int Function(T, T) compare}) {
      0|  compare ??= defaultCompare<T>();
       |
       |  S minValue;
       |  T minOrderBy;
      0|  for (var element in values) {
      0|    var elementOrderBy = orderBy(element);
      0|    if (minOrderBy == null || compare(elementOrderBy, minOrderBy) < 0) {
       |      minValue = element;
       |      minOrderBy = elementOrderBy;
       |    }
       |  }
       |  return minValue;
       |}
       |
       |/// Returns the element of [values] for which [orderBy] returns the maximum
       |/// value.
       |///
       |/// The values returned by [orderBy] are compared using the [compare] function.
       |/// If [compare] is omitted, values must implement [Comparable<T>] and they are
       |/// compared using their [Comparable.compareTo].
      0|S maxBy<S, T>(Iterable<S> values, T Function(S) orderBy,
       |    {int Function(T, T) compare}) {
      0|  compare ??= defaultCompare<T>();
       |
       |  S maxValue;
       |  T maxOrderBy;
      0|  for (var element in values) {
      0|    var elementOrderBy = orderBy(element);
      0|    if (maxOrderBy == null || compare(elementOrderBy, maxOrderBy) > 0) {
       |      maxValue = element;
       |      maxOrderBy = elementOrderBy;
       |    }
       |  }
       |  return maxValue;
       |}
       |
       |/// Returns the [transitive closure][] of [graph].
       |///
       |/// [transitive closure]: https://en.wikipedia.org/wiki/Transitive_closure
       |///
       |/// Interprets [graph] as a directed graph with a vertex for each key and edges
       |/// from each key to the values that the key maps to.
       |///
       |/// Assumes that every vertex in the graph has a key to represent it, even if
       |/// that vertex has no outgoing edges. This isn't checked, but if it's not
       |/// satisfied, the function may crash or provide unexpected output. For example,
       |/// `{"a": ["b"]}` is not valid, but `{"a": ["b"], "b": []}` is.
      0|Map<T, Set<T>> transitiveClosure<T>(Map<T, Iterable<T>> graph) {
       |  // This uses [Warshall's algorithm][], modified not to add a vertex from each
       |  // node to itself.
       |  //
       |  // [Warshall's algorithm]: https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Applications_and_generalizations.
      0|  var result = <T, Set<T>>{};
      0|  graph.forEach((vertex, edges) {
      0|    result[vertex] = Set<T>.from(edges);
       |  });
       |
       |  // Lists are faster to iterate than maps, so we create a list since we're
       |  // iterating repeatedly.
      0|  var keys = graph.keys.toList();
      0|  for (var vertex1 in keys) {
      0|    for (var vertex2 in keys) {
      0|      for (var vertex3 in keys) {
      0|        if (result[vertex2].contains(vertex1) &&
      0|            result[vertex1].contains(vertex3)) {
      0|          result[vertex2].add(vertex3);
       |        }
       |      }
       |    }
       |  }
       |
       |  return result;
       |}
       |
       |/// Returns the [strongly connected components][] of [graph], in topological
       |/// order.
       |///
       |/// [strongly connected components]: https://en.wikipedia.org/wiki/Strongly_connected_component
       |///
       |/// Interprets [graph] as a directed graph with a vertex for each key and edges
       |/// from each key to the values that the key maps to.
       |///
       |/// Assumes that every vertex in the graph has a key to represent it, even if
       |/// that vertex has no outgoing edges. This isn't checked, but if it's not
       |/// satisfied, the function may crash or provide unexpected output. For example,
       |/// `{"a": ["b"]}` is not valid, but `{"a": ["b"], "b": []}` is.
      0|List<Set<T>> stronglyConnectedComponents<T>(Map<T, Iterable<T>> graph) {
       |  // This uses [Tarjan's algorithm][].
       |  //
       |  // [Tarjan's algorithm]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
       |  var index = 0;
      0|  var stack = <T>[];
      0|  var result = <Set<T>>[];
       |
       |  // The order of these doesn't matter, so we use un-linked implementations to
       |  // avoid unnecessary overhead.
      0|  var indices = HashMap<T, int>();
      0|  var lowLinks = HashMap<T, int>();
      0|  var onStack = HashSet<T>();
       |
      0|  void strongConnect(T vertex) {
      0|    indices[vertex] = index;
      0|    lowLinks[vertex] = index;
      0|    index++;
       |
      0|    stack.add(vertex);
      0|    onStack.add(vertex);
       |
      0|    for (var successor in graph[vertex]) {
      0|      if (!indices.containsKey(successor)) {
      0|        strongConnect(successor);
      1|        lowLinks[vertex] = math.min(lowLinks[vertex], lowLinks[successor]);
      0|      } else if (onStack.contains(successor)) {
      1|        lowLinks[vertex] = math.min(lowLinks[vertex], lowLinks[successor]);
       |      }
       |    }
       |
      0|    if (lowLinks[vertex] == indices[vertex]) {
       |      var component = <T>{};
       |      T neighbor;
       |      do {
      0|        neighbor = stack.removeLast();
      0|        onStack.remove(neighbor);
      0|        component.add(neighbor);
      0|      } while (neighbor != vertex);
      0|      result.add(component);
       |    }
       |  }
       |
      0|  for (var vertex in graph.keys) {
      0|    if (!indices.containsKey(vertex)) strongConnect(vertex);
       |  }
       |
       |  // Tarjan's algorithm produces a reverse-topological sort, so we reverse it to
       |  // get a normal topological sort.
      0|  return result.reversed.toList();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/iterable_zip.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |/// Iterable that iterates over lists of values from other iterables.
       |///
       |/// When [iterator] is read, an [Iterator] is created for each [Iterable] in
       |/// the [Iterable] passed to the constructor.
       |///
       |/// As long as all these iterators have a next value, those next values are
       |/// combined into a single list, which becomes the next value of this
       |/// [Iterable]'s [Iterator]. As soon as any of the iterators run out,
       |/// the zipped iterator also stops.
       |class IterableZip<T> extends IterableBase<List<T>> {
       |  final Iterable<Iterable<T>> _iterables;
       |
      0|  IterableZip(Iterable<Iterable<T>> iterables) : _iterables = iterables;
       |
       |  /// Returns an iterator that combines values of the iterables' iterators
       |  /// as long as they all have values.
      0|  @override
       |  Iterator<List<T>> get iterator {
      0|    var iterators = _iterables.map((x) => x.iterator).toList(growable: false);
       |    // TODO(lrn): Return an empty iterator directly if iterators is empty?
      0|    return _IteratorZip<T>(iterators);
       |  }
       |}
       |
       |class _IteratorZip<T> implements Iterator<List<T>> {
       |  final List<Iterator<T>> _iterators;
       |  List<T> _current;
       |
      0|  _IteratorZip(List<Iterator<T>> iterators) : _iterators = iterators;
       |
      0|  @override
       |  bool moveNext() {
      0|    if (_iterators.isEmpty) return false;
      0|    for (var i = 0; i < _iterators.length; i++) {
      0|      if (!_iterators[i].moveNext()) {
      0|        _current = null;
       |        return false;
       |      }
       |    }
      0|    _current = List(_iterators.length);
      0|    for (var i = 0; i < _iterators.length; i++) {
      0|      _current[i] = _iterators[i].current;
       |    }
       |    return true;
       |  }
       |
      0|  @override
      0|  List<T> get current => _current;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/priority_queue.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'utils.dart';
       |
       |/// A priority queue is a priority based work-list of elements.
       |///
       |/// The queue allows adding elements, and removing them again in priority order.
       |abstract class PriorityQueue<E> {
       |  /// Creates an empty [PriorityQueue].
       |  ///
       |  /// The created [PriorityQueue] is a plain [HeapPriorityQueue].
       |  ///
       |  /// The [comparison] is a [Comparator] used to compare the priority of
       |  /// elements. An element that compares as less than another element has
       |  /// a higher priority.
       |  ///
       |  /// If [comparison] is omitted, it defaults to [Comparable.compare]. If this
       |  /// is the case, `E` must implement [Comparable], and this is checked at
       |  /// runtime for every comparison.
       |  factory PriorityQueue([int Function(E, E) comparison]) = HeapPriorityQueue<E>;
       |
       |  /// Number of elements in the queue.
       |  int get length;
       |
       |  /// Whether the queue is empty.
       |  bool get isEmpty;
       |
       |  /// Whether the queue has any elements.
       |  bool get isNotEmpty;
       |
       |  /// Checks if [object] is in the queue.
       |  ///
       |  /// Returns true if the element is found.
       |  bool contains(E object);
       |
       |  /// Adds element to the queue.
       |  ///
       |  /// The element will become the next to be removed by [removeFirst]
       |  /// when all elements with higher priority have been removed.
       |  void add(E element);
       |
       |  /// Adds all [elements] to the queue.
       |  void addAll(Iterable<E> elements);
       |
       |  /// Returns the next element that will be returned by [removeFirst].
       |  ///
       |  /// The element is not removed from the queue.
       |  ///
       |  /// The queue must not be empty when this method is called.
       |  E get first;
       |
       |  /// Removes and returns the element with the highest priority.
       |  ///
       |  /// Repeatedly calling this method, without adding element in between,
       |  /// is guaranteed to return elements in non-decreasing order as, specified by
       |  /// [comparison].
       |  ///
       |  /// The queue must not be empty when this method is called.
       |  E removeFirst();
       |
       |  /// Removes an element that compares equal to [element] in the queue.
       |  ///
       |  /// Returns true if an element is found and removed,
       |  /// and false if no equal element is found.
       |  bool remove(E element);
       |
       |  /// Removes all the elements from this queue and returns them.
       |  ///
       |  /// The returned iterable has no specified order.
       |  Iterable<E> removeAll();
       |
       |  /// Removes all the elements from this queue.
       |  void clear();
       |
       |  /// Returns a list of the elements of this queue in priority order.
       |  ///
       |  /// The queue is not modified.
       |  ///
       |  /// The order is the order that the elements would be in if they were
       |  /// removed from this queue using [removeFirst].
       |  List<E> toList();
       |
       |  /// Return a comparator based set using the comparator of this queue.
       |  ///
       |  /// The queue is not modified.
       |  ///
       |  /// The returned [Set] is currently a [SplayTreeSet],
       |  /// but this may change as other ordered sets are implemented.
       |  ///
       |  /// The set contains all the elements of this queue.
       |  /// If an element occurs more than once in the queue,
       |  /// the set will contain it only once.
       |  Set<E> toSet();
       |}
       |
       |/// Heap based priority queue.
       |///
       |/// The elements are kept in a heap structure,
       |/// where the element with the highest priority is immediately accessible,
       |/// and modifying a single element takes
       |/// logarithmic time in the number of elements on average.
       |///
       |/// * The [add] and [removeFirst] operations take amortized logarithmic time,
       |///   O(log(n)), but may occasionally take linear time when growing the capacity
       |///   of the heap.
       |/// * The [addAll] operation works as doing repeated [add] operations.
       |/// * The [first] getter takes constant time, O(1).
       |/// * The [clear] and [removeAll] methods also take constant time, O(1).
       |/// * The [contains] and [remove] operations may need to search the entire
       |///   queue for the elements, taking O(n) time.
       |/// * The [toList] operation effectively sorts the elements, taking O(n*log(n))
       |///   time.
       |/// * The [toSet] operation effectively adds each element to the new set, taking
       |///   an expected O(n*log(n)) time.
       |class HeapPriorityQueue<E> implements PriorityQueue<E> {
       |  /// Initial capacity of a queue when created, or when added to after a
       |  /// [clear].
       |  ///
       |  /// Number can be any positive value. Picking a size that gives a whole
       |  /// number of "tree levels" in the heap is only done for aesthetic reasons.
       |  static const int _INITIAL_CAPACITY = 7;
       |
       |  /// The comparison being used to compare the priority of elements.
       |  final Comparator<E> comparison;
       |
       |  /// List implementation of a heap.
       |  List<E> _queue = List<E>(_INITIAL_CAPACITY);
       |
       |  /// Number of elements in queue.
       |  ///
       |  /// The heap is implemented in the first [_length] entries of [_queue].
       |  int _length = 0;
       |
       |  /// Create a new priority queue.
       |  ///
       |  /// The [comparison] is a [Comparator] used to compare the priority of
       |  /// elements. An element that compares as less than another element has
       |  /// a higher priority.
       |  ///
       |  /// If [comparison] is omitted, it defaults to [Comparable.compare]. If this
       |  /// is the case, `E` must implement [Comparable], and this is checked at
       |  /// runtime for every comparison.
      0|  HeapPriorityQueue([int Function(E, E) comparison])
      0|      : comparison = comparison ?? defaultCompare<E>();
       |
      0|  @override
       |  void add(E element) {
      0|    _add(element);
       |  }
       |
      0|  @override
       |  void addAll(Iterable<E> elements) {
      0|    for (var element in elements) {
      0|      _add(element);
       |    }
       |  }
       |
      0|  @override
       |  void clear() {
      0|    _queue = const [];
      0|    _length = 0;
       |  }
       |
      0|  @override
       |  bool contains(E object) {
      0|    return _locate(object) >= 0;
       |  }
       |
      0|  @override
       |  E get first {
      0|    if (_length == 0) throw StateError('No such element');
      0|    return _queue[0];
       |  }
       |
      0|  @override
      0|  bool get isEmpty => _length == 0;
       |
      0|  @override
      0|  bool get isNotEmpty => _length != 0;
       |
      0|  @override
      0|  int get length => _length;
       |
      0|  @override
       |  bool remove(E element) {
      0|    var index = _locate(element);
      0|    if (index < 0) return false;
      0|    var last = _removeLast();
      0|    if (index < _length) {
      0|      var comp = comparison(last, element);
      0|      if (comp <= 0) {
      0|        _bubbleUp(last, index);
       |      } else {
      0|        _bubbleDown(last, index);
       |      }
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  Iterable<E> removeAll() {
      0|    var result = _queue;
      0|    var length = _length;
      0|    _queue = const [];
      0|    _length = 0;
      0|    return result.take(length);
       |  }
       |
      0|  @override
       |  E removeFirst() {
      0|    if (_length == 0) throw StateError('No such element');
      0|    var result = _queue[0];
      0|    var last = _removeLast();
      0|    if (_length > 0) {
      0|      _bubbleDown(last, 0);
       |    }
       |    return result;
       |  }
       |
      0|  @override
       |  List<E> toList() {
      0|    var list = <E>[]
      0|      ..length = _length
      0|      ..setRange(0, _length, _queue)
      0|      ..sort(comparison);
       |    return list;
       |  }
       |
      0|  @override
       |  Set<E> toSet() {
      0|    Set<E> set = SplayTreeSet<E>(comparison);
      0|    for (var i = 0; i < _length; i++) {
      0|      set.add(_queue[i]);
       |    }
       |    return set;
       |  }
       |
       |  /// Returns some representation of the queue.
       |  ///
       |  /// The format isn't significant, and may change in the future.
      0|  @override
       |  String toString() {
      0|    return _queue.take(_length).toString();
       |  }
       |
       |  /// Add element to the queue.
       |  ///
       |  /// Grows the capacity if the backing list is full.
      0|  void _add(E element) {
      0|    if (_length == _queue.length) _grow();
      0|    _bubbleUp(element, _length++);
       |  }
       |
       |  /// Find the index of an object in the heap.
       |  ///
       |  /// Returns -1 if the object is not found.
      0|  int _locate(E object) {
      0|    if (_length == 0) return -1;
       |    // Count positions from one instead of zero. This gives the numbers
       |    // some nice properties. For example, all right children are odd,
       |    // their left sibling is even, and the parent is found by shifting
       |    // right by one.
       |    // Valid range for position is [1.._length], inclusive.
       |    var position = 1;
       |    // Pre-order depth first search, omit child nodes if the current
       |    // node has lower priority than [object], because all nodes lower
       |    // in the heap will also have lower priority.
       |    do {
      0|      var index = position - 1;
      0|      var element = _queue[index];
      0|      var comp = comparison(element, object);
      0|      if (comp == 0) return index;
      0|      if (comp < 0) {
       |        // Element may be in subtree.
       |        // Continue with the left child, if it is there.
      0|        var leftChildPosition = position * 2;
      0|        if (leftChildPosition <= _length) {
       |          position = leftChildPosition;
       |          continue;
       |        }
       |      }
       |      // Find the next right sibling or right ancestor sibling.
       |      do {
      0|        while (position.isOdd) {
       |          // While position is a right child, go to the parent.
      0|          position >>= 1;
       |        }
       |        // Then go to the right sibling of the left-child.
      0|        position += 1;
      0|      } while (position > _length); // Happens if last element is a left child.
      0|    } while (position != 1); // At root again. Happens for right-most element.
      0|    return -1;
       |  }
       |
      0|  E _removeLast() {
      0|    var newLength = _length - 1;
      0|    var last = _queue[newLength];
      0|    _queue[newLength] = null;
      0|    _length = newLength;
       |    return last;
       |  }
       |
       |  /// Place [element] in heap at [index] or above.
       |  ///
       |  /// Put element into the empty cell at `index`.
       |  /// While the `element` has higher priority than the
       |  /// parent, swap it with the parent.
      0|  void _bubbleUp(E element, int index) {
      0|    while (index > 0) {
      0|      var parentIndex = (index - 1) ~/ 2;
      0|      var parent = _queue[parentIndex];
      0|      if (comparison(element, parent) > 0) break;
      0|      _queue[index] = parent;
       |      index = parentIndex;
       |    }
      0|    _queue[index] = element;
       |  }
       |
       |  /// Place [element] in heap at [index] or above.
       |  ///
       |  /// Put element into the empty cell at `index`.
       |  /// While the `element` has lower priority than either child,
       |  /// swap it with the highest priority child.
      0|  void _bubbleDown(E element, int index) {
      0|    var rightChildIndex = index * 2 + 2;
      0|    while (rightChildIndex < _length) {
      0|      var leftChildIndex = rightChildIndex - 1;
      0|      var leftChild = _queue[leftChildIndex];
      0|      var rightChild = _queue[rightChildIndex];
      0|      var comp = comparison(leftChild, rightChild);
       |      var minChildIndex;
       |      E minChild;
      0|      if (comp < 0) {
       |        minChild = leftChild;
       |        minChildIndex = leftChildIndex;
       |      } else {
       |        minChild = rightChild;
       |        minChildIndex = rightChildIndex;
       |      }
      0|      comp = comparison(element, minChild);
      0|      if (comp <= 0) {
      0|        _queue[index] = element;
       |        return;
       |      }
      0|      _queue[index] = minChild;
       |      index = minChildIndex;
      0|      rightChildIndex = index * 2 + 2;
       |    }
      0|    var leftChildIndex = rightChildIndex - 1;
      0|    if (leftChildIndex < _length) {
      0|      var child = _queue[leftChildIndex];
      0|      var comp = comparison(element, child);
      0|      if (comp > 0) {
      0|        _queue[index] = child;
       |        index = leftChildIndex;
       |      }
       |    }
      0|    _queue[index] = element;
       |  }
       |
       |  /// Grows the capacity of the list holding the heap.
       |  ///
       |  /// Called when the list is full.
      0|  void _grow() {
      0|    var newCapacity = _queue.length * 2 + 1;
      0|    if (newCapacity < _INITIAL_CAPACITY) newCapacity = _INITIAL_CAPACITY;
      0|    var newQueue = List<E>(newCapacity);
      0|    newQueue.setRange(0, _length, _queue);
      0|    _queue = newQueue;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/queue_list.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |/// A class that efficiently implements both [Queue] and [List].
       |// TODO(nweiz): Currently this code is copied almost verbatim from
       |// dart:collection. The only changes are to implement List and to remove methods
       |// that are redundant with ListMixin. Remove or simplify it when issue 21330 is
       |// fixed.
       |class QueueList<E> extends Object with ListMixin<E> implements Queue<E> {
       |  /// Adapts [source] to be a `QueueList<T>`.
       |  ///
       |  /// Any time the class would produce an element that is not a [T], the element
       |  /// access will throw.
       |  ///
       |  /// Any time a [T] value is attempted stored into the adapted class, the store
       |  /// will throw unless the value is also an instance of [S].
       |  ///
       |  /// If all accessed elements of [source] are actually instances of [T] and if
       |  /// all elements stored in the returned  are actually instance of [S],
       |  /// then the returned instance can be used as a `QueueList<T>`.
      0|  static QueueList<T> _castFrom<S, T>(QueueList<S> source) {
      0|    return _CastQueueList<S, T>(source);
       |  }
       |
       |  static const int _INITIAL_CAPACITY = 8;
       |  List<E> _table;
       |  int _head;
       |  int _tail;
       |
       |  /// Create an empty queue.
       |  ///
       |  /// If [initialCapacity] is given, prepare the queue for at least that many
       |  /// elements.
      1|  QueueList([int initialCapacity])
       |      : _head = 0,
       |        _tail = 0 {
      0|    if (initialCapacity == null || initialCapacity < _INITIAL_CAPACITY) {
       |      initialCapacity = _INITIAL_CAPACITY;
      0|    } else if (!_isPowerOf2(initialCapacity)) {
      0|      initialCapacity = _nextPowerOf2(initialCapacity);
       |    }
       |    assert(_isPowerOf2(initialCapacity));
      2|    _table = List<E>(initialCapacity);
       |  }
       |
       |  // An internal constructor for use by _CastQueueList.
      0|  QueueList._();
       |
       |  /// Create a queue initially containing the elements of [source].
      0|  factory QueueList.from(Iterable<E> source) {
      0|    if (source is List) {
      0|      var length = source.length;
      0|      var queue = QueueList<E>(length + 1);
       |      assert(queue._table.length > length);
       |      var sourceList = source;
      0|      queue._table.setRange(0, length, sourceList, 0);
      0|      queue._tail = length;
       |      return queue;
       |    } else {
      0|      return QueueList<E>()..addAll(source);
       |    }
       |  }
       |
       |  // Collection interface.
       |
      1|  @override
       |  void add(E element) {
      1|    _add(element);
       |  }
       |
      0|  @override
       |  void addAll(Iterable<E> iterable) {
      0|    if (iterable is List) {
       |      var list = iterable;
      0|      var addCount = list.length;
      0|      var length = this.length;
      0|      if (length + addCount >= _table.length) {
      0|        _preGrow(length + addCount);
       |        // After preGrow, all elements are at the start of the list.
      0|        _table.setRange(length, length + addCount, list, 0);
      0|        _tail += addCount;
       |      } else {
       |        // Adding addCount elements won't reach _head.
      0|        var endSpace = _table.length - _tail;
      0|        if (addCount < endSpace) {
      0|          _table.setRange(_tail, _tail + addCount, list, 0);
      0|          _tail += addCount;
       |        } else {
      0|          var preSpace = addCount - endSpace;
      0|          _table.setRange(_tail, _tail + endSpace, list, 0);
      0|          _table.setRange(0, preSpace, list, endSpace);
      0|          _tail = preSpace;
       |        }
       |      }
       |    } else {
      0|      for (var element in iterable) {
      0|        _add(element);
       |      }
       |    }
       |  }
       |
      0|  QueueList<T> cast<T>() => QueueList._castFrom<E, T>(this);
       |
      0|  @deprecated
      0|  QueueList<T> retype<T>() => cast<T>();
       |
      0|  @override
      0|  String toString() => IterableBase.iterableToFullString(this, '{', '}');
       |
       |  // Queue interface.
       |
      0|  @override
       |  void addLast(E element) {
      0|    _add(element);
       |  }
       |
      0|  @override
       |  void addFirst(E element) {
      0|    _head = (_head - 1) & (_table.length - 1);
      0|    _table[_head] = element;
      0|    if (_head == _tail) _grow();
       |  }
       |
      0|  @override
       |  E removeFirst() {
      0|    if (_head == _tail) throw StateError('No element');
      0|    var result = _table[_head];
      0|    _table[_head] = null;
      0|    _head = (_head + 1) & (_table.length - 1);
       |    return result;
       |  }
       |
      0|  @override
       |  E removeLast() {
      0|    if (_head == _tail) throw StateError('No element');
      0|    _tail = (_tail - 1) & (_table.length - 1);
      0|    var result = _table[_tail];
      0|    _table[_tail] = null;
       |    return result;
       |  }
       |
       |  // List interface.
       |
      1|  @override
      7|  int get length => (_tail - _head) & (_table.length - 1);
       |
      1|  @override
       |  set length(int value) {
      1|    if (value < 0) throw RangeError('Length $value may not be negative.');
       |
      2|    var delta = value - length;
      1|    if (delta >= 0) {
      0|      if (_table.length <= value) {
      0|        _preGrow(value);
       |      }
      0|      _tail = (_tail + delta) & (_table.length - 1);
       |      return;
       |    }
       |
      2|    var newTail = _tail + delta; // [delta] is negative.
      1|    if (newTail >= 0) {
      3|      _table.fillRange(newTail, _tail, null);
       |    } else {
      0|      newTail += _table.length;
      0|      _table.fillRange(0, _tail, null);
      0|      _table.fillRange(newTail, _table.length, null);
       |    }
      1|    _tail = newTail;
       |  }
       |
      1|  @override
       |  E operator [](int index) {
      3|    if (index < 0 || index >= length) {
      0|      throw RangeError('Index $index must be in the range [0..$length).');
       |    }
       |
      8|    return _table[(_head + index) & (_table.length - 1)];
       |  }
       |
      0|  @override
       |  void operator []=(int index, E value) {
      0|    if (index < 0 || index >= length) {
      0|      throw RangeError('Index $index must be in the range [0..$length).');
       |    }
       |
      0|    _table[(_head + index) & (_table.length - 1)] = value;
       |  }
       |
       |  // Internal helper functions.
       |
       |  /// Whether [number] is a power of two.
       |  ///
       |  /// Only works for positive numbers.
      0|  static bool _isPowerOf2(int number) => (number & (number - 1)) == 0;
       |
       |  /// Rounds [number] up to the nearest power of 2.
       |  ///
       |  /// If [number] is a power of 2 already, it is returned.
       |  ///
       |  /// Only works for positive numbers.
      0|  static int _nextPowerOf2(int number) {
       |    assert(number > 0);
      0|    number = (number << 1) - 1;
       |    for (;;) {
      0|      var nextNumber = number & (number - 1);
      0|      if (nextNumber == 0) return number;
       |      number = nextNumber;
       |    }
       |  }
       |
       |  /// Adds element at end of queue. Used by both [add] and [addAll].
      1|  void _add(E element) {
      3|    _table[_tail] = element;
      7|    _tail = (_tail + 1) & (_table.length - 1);
      3|    if (_head == _tail) _grow();
       |  }
       |
       |  /// Grow the table when full.
      0|  void _grow() {
      0|    var newTable = List<E>(_table.length * 2);
      0|    var split = _table.length - _head;
      0|    newTable.setRange(0, split, _table, _head);
      0|    newTable.setRange(split, split + _head, _table, 0);
      0|    _head = 0;
      0|    _tail = _table.length;
      0|    _table = newTable;
       |  }
       |
      0|  int _writeToList(List<E> target) {
       |    assert(target.length >= length);
      0|    if (_head <= _tail) {
      0|      var length = _tail - _head;
      0|      target.setRange(0, length, _table, _head);
       |      return length;
       |    } else {
      0|      var firstPartSize = _table.length - _head;
      0|      target.setRange(0, firstPartSize, _table, _head);
      0|      target.setRange(firstPartSize, firstPartSize + _tail, _table, 0);
      0|      return _tail + firstPartSize;
       |    }
       |  }
       |
       |  /// Grows the table even if it is not full.
      0|  void _preGrow(int newElementCount) {
       |    assert(newElementCount >= length);
       |
       |    // Add 1.5x extra room to ensure that there's room for more elements after
       |    // expansion.
      0|    newElementCount += newElementCount >> 1;
      0|    var newCapacity = _nextPowerOf2(newElementCount);
      0|    var newTable = List<E>(newCapacity);
      0|    _tail = _writeToList(newTable);
      0|    _table = newTable;
      0|    _head = 0;
       |  }
       |}
       |
       |class _CastQueueList<S, T> extends QueueList<T> {
       |  final QueueList<S> _delegate;
       |
      0|  _CastQueueList(this._delegate) : super._() {
      0|    _table = _delegate._table.cast<T>();
       |  }
       |
      0|  @override
      0|  int get _head => _delegate._head;
       |
      0|  @override
      0|  set _head(int value) => _delegate._head = value;
       |
      0|  @override
      0|  int get _tail => _delegate._tail;
       |
      0|  @override
      0|  set _tail(int value) => _delegate._tail = value;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/unmodifiable_wrappers.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'empty_unmodifiable_set.dart';
       |import 'wrappers.dart';
       |
       |export 'dart:collection' show UnmodifiableListView, UnmodifiableMapView;
       |
       |/// A fixed-length list.
       |///
       |/// A `NonGrowableListView` contains a [List] object and ensures that
       |/// its length does not change.
       |/// Methods that would change the length of the list,
       |/// such as [add] and [remove], throw an [UnsupportedError].
       |/// All other methods work directly on the underlying list.
       |///
       |/// This class _does_ allow changes to the contents of the wrapped list.
       |/// You can, for example, [sort] the list.
       |/// Permitted operations defer to the wrapped list.
       |class NonGrowableListView<E> extends DelegatingList<E>
       |    with NonGrowableListMixin<E> {
      0|  NonGrowableListView(List<E> listBase) : super(listBase);
       |}
       |
       |/// Mixin class that implements a throwing version of all list operations that
       |/// change the List's length.
       |abstract class NonGrowableListMixin<E> implements List<E> {
      0|  static T _throw<T>() {
      0|    throw UnsupportedError('Cannot change the length of a fixed-length list');
       |  }
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  set length(int newLength) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  bool add(E value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  void addAll(Iterable<E> iterable) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  void insert(int index, E element) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  void insertAll(int index, Iterable<E> iterable) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  bool remove(Object value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  E removeAt(int index) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  E removeLast() => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  void removeWhere(bool Function(E) test) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  void retainWhere(bool Function(E) test) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  void removeRange(int start, int end) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  void replaceRange(int start, int end, Iterable<E> iterable) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the length of the list are disallowed.
      0|  @override
      0|  void clear() => _throw();
       |}
       |
       |/// An unmodifiable set.
       |///
       |/// An UnmodifiableSetView contains a [Set] object and ensures
       |/// that it does not change.
       |/// Methods that would change the set,
       |/// such as [add] and [remove], throw an [UnsupportedError].
       |/// Permitted operations defer to the wrapped set.
       |class UnmodifiableSetView<E> extends DelegatingSet<E>
       |    with UnmodifiableSetMixin<E> {
      2|  UnmodifiableSetView(Set<E> setBase) : super(setBase);
       |
       |  /// An unmodifiable empty set.
       |  ///
       |  /// This is the same as `UnmodifiableSetView(Set())`, except that it
       |  /// can be used in const contexts.
       |  const factory UnmodifiableSetView.empty() = EmptyUnmodifiableSet<E>;
       |}
       |
       |/// Mixin class that implements a throwing version of all set operations that
       |/// change the Set.
       |abstract class UnmodifiableSetMixin<E> implements Set<E> {
      0|  static T _throw<T>() {
      0|    throw UnsupportedError('Cannot modify an unmodifiable Set');
       |  }
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  @override
      0|  bool add(E value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  @override
      0|  void addAll(Iterable<E> elements) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  @override
      0|  bool remove(Object value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  @override
      0|  void removeAll(Iterable elements) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  @override
      0|  void retainAll(Iterable elements) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  @override
      0|  void removeWhere(bool Function(E) test) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  @override
      0|  void retainWhere(bool Function(E) test) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the set are disallowed.
      0|  @override
      0|  void clear() => _throw();
       |}
       |
       |/// Mixin class that implements a throwing version of all map operations that
       |/// change the Map.
       |abstract class UnmodifiableMapMixin<K, V> implements Map<K, V> {
      0|  static T _throw<T>() {
      0|    throw UnsupportedError('Cannot modify an unmodifiable Map');
       |  }
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  @override
      0|  void operator []=(K key, V value) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  @override
      0|  V putIfAbsent(K key, V Function() ifAbsent) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  @override
      0|  void addAll(Map<K, V> other) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  @override
      0|  V remove(Object key) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  @override
      0|  void clear() => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  set first(_) => _throw();
       |
       |  /// Throws an [UnsupportedError];
       |  /// operations that change the map are disallowed.
      0|  set last(_) => _throw();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/union_set.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'unmodifiable_wrappers.dart';
       |
       |/// A single set that provides a view of the union over a set of sets.
       |///
       |/// Since this is just a view, it reflects all changes in the underlying sets.
       |///
       |/// If an element is in multiple sets and the outer set is ordered, the version
       |/// in the earliest inner set is preferred. Component sets are assumed to use
       |/// `==` and `hashCode` for equality.
       |class UnionSet<E> extends SetBase<E> with UnmodifiableSetMixin<E> {
       |  /// The set of sets that this provides a view of.
       |  final Set<Set<E>> _sets;
       |
       |  /// Whether the sets in [_sets] are guaranteed to be disjoint.
       |  final bool _disjoint;
       |
       |  /// Creates a new set that's a view of the union of all sets in [sets].
       |  ///
       |  /// If any sets in [sets] change, this [UnionSet] reflects that change. If a
       |  /// new set is added to [sets], this [UnionSet] reflects that as well.
       |  ///
       |  /// If [disjoint] is `true`, then all component sets must be disjoint. That
       |  /// is, that they contain no elements in common. This makes many operations
       |  /// including [length] more efficient. If the component sets turn out not to
       |  /// be disjoint, some operations may behave inconsistently.
      1|  UnionSet(this._sets, {bool disjoint = false}) : _disjoint = disjoint;
       |
       |  /// Creates a new set that's a view of the union of all sets in [sets].
       |  ///
       |  /// If any sets in [sets] change, this [UnionSet] reflects that change.
       |  /// However, unlike [new UnionSet], this creates a copy of its parameter, so
       |  /// changes in [sets] aren't reflected in this [UnionSet].
       |  ///
       |  /// If [disjoint] is `true`, then all component sets must be disjoint. That
       |  /// is, that they contain no elements in common. This makes many operations
       |  /// including [length] more efficient. If the component sets turn out not to
       |  /// be disjoint, some operations may behave inconsistently.
      1|  UnionSet.from(Iterable<Set<E>> sets, {bool disjoint = false})
      2|      : this(sets.toSet(), disjoint: disjoint);
       |
      1|  @override
      1|  int get length => _disjoint
      5|      ? _sets.fold(0, (length, set) => length + set.length)
      0|      : _iterable.length;
       |
      1|  @override
      2|  Iterator<E> get iterator => _iterable.iterator;
       |
       |  /// An iterable over the contents of all [_sets].
       |  ///
       |  /// If this is not a [_disjoint] union an extra set is used to deduplicate
       |  /// values.
      1|  Iterable<E> get _iterable {
      3|    var allElements = _sets.expand((set) => set);
      1|    return _disjoint ? allElements : allElements.where(<E>{}.add);
       |  }
       |
      0|  @override
      0|  bool contains(Object element) => _sets.any((set) => set.contains(element));
       |
      0|  @override
       |  E lookup(Object element) {
       |    if (element == null) return null;
       |
      0|    return _sets
      0|        .map((set) => set.lookup(element))
      0|        .firstWhere((result) => result != null, orElse: () => null);
       |  }
       |
      0|  @override
       |  Set<E> toSet() {
       |    var result = <E>{};
      0|    for (var set in _sets) {
      0|      result.addAll(set);
       |    }
       |    return result;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/union_set_controller.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'union_set.dart';
       |
       |/// A controller that exposes a view of the union of a collection of sets.
       |///
       |/// This is a convenience class for creating a [UnionSet] whose contents change
       |/// over the lifetime of a class. For example:
       |///
       |/// ```dart
       |/// class Engine {
       |///   Set<Test> get activeTests => _activeTestsGroup.set;
       |///   final _activeTestsGroup = UnionSetController<Test>();
       |///
       |///   void addSuite(Suite suite) {
       |///     _activeTestsGroup.add(suite.tests);
       |///     _runSuite(suite);
       |///     _activeTestsGroup.remove(suite.tests);
       |///   }
       |/// }
       |/// ```
       |class UnionSetController<E> {
       |  /// The [UnionSet] that provides a view of the union of sets in [this].
      2|  UnionSet<E> get set => _set;
       |  UnionSet<E> _set;
       |
       |  /// The sets whose union is exposed through [set].
       |  final _sets = <Set<E>>{};
       |
       |  /// Creates a set of sets that provides a view of the union of those sets.
       |  ///
       |  /// If [disjoint] is `true`, this assumes that all component sets are
       |  /// disjointthat is, that they contain no elements in common. This makes
       |  /// many operations including [length] more efficient.
      1|  UnionSetController({bool disjoint = false}) {
      3|    _set = UnionSet<E>(_sets, disjoint: disjoint);
       |  }
       |
       |  /// Adds the contents of [component] to [set].
       |  ///
       |  /// If the contents of [component] change over time, [set] will change
       |  /// accordingly.
      1|  void add(Set<E> component) {
      2|    _sets.add(component);
       |  }
       |
       |  /// Removes the contents of [component] to [set].
       |  ///
       |  /// If another set in [this] has overlapping elements with [component], those
       |  /// elements will remain in [set].
      0|  bool remove(Set<E> component) => _sets.remove(component);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/wrappers.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |import 'dart:math' as math;
       |
       |import 'unmodifiable_wrappers.dart';
       |
       |/// A base class for delegating iterables.
       |///
       |/// Subclasses can provide a [_base] that should be delegated to. Unlike
       |/// [DelegatingIterable], this allows the base to be created on demand.
       |abstract class _DelegatingIterableBase<E> implements Iterable<E> {
       |  Iterable<E> get _base;
       |
      1|  const _DelegatingIterableBase();
       |
      0|  @override
      0|  bool any(bool Function(E) test) => _base.any(test);
       |
      0|  @override
      0|  Iterable<T> cast<T>() => _base.cast<T>();
       |
      0|  @override
      0|  bool contains(Object element) => _base.contains(element);
       |
      0|  @override
      0|  E elementAt(int index) => _base.elementAt(index);
       |
      0|  @override
      0|  bool every(bool Function(E) test) => _base.every(test);
       |
      0|  @override
      0|  Iterable<T> expand<T>(Iterable<T> Function(E) f) => _base.expand(f);
       |
      0|  @override
      0|  E get first => _base.first;
       |
      0|  @override
       |  E firstWhere(bool Function(E) test, {E Function() orElse}) =>
      0|      _base.firstWhere(test, orElse: orElse);
       |
      0|  @override
       |  T fold<T>(T initialValue, T Function(T previousValue, E element) combine) =>
      0|      _base.fold(initialValue, combine);
       |
      0|  @override
      0|  Iterable<E> followedBy(Iterable<E> other) => _base.followedBy(other);
       |
      0|  @override
      0|  void forEach(void Function(E) f) => _base.forEach(f);
       |
      0|  @override
      0|  bool get isEmpty => _base.isEmpty;
       |
      0|  @override
      0|  bool get isNotEmpty => _base.isNotEmpty;
       |
      1|  @override
      2|  Iterator<E> get iterator => _base.iterator;
       |
      0|  @override
      0|  String join([String separator = '']) => _base.join(separator);
       |
      0|  @override
      0|  E get last => _base.last;
       |
      0|  @override
       |  E lastWhere(bool Function(E) test, {E Function() orElse}) =>
      0|      _base.lastWhere(test, orElse: orElse);
       |
      1|  @override
      2|  int get length => _base.length;
       |
      0|  @override
      0|  Iterable<T> map<T>(T Function(E) f) => _base.map(f);
       |
      0|  @override
      0|  E reduce(E Function(E value, E element) combine) => _base.reduce(combine);
       |
      0|  @deprecated
      0|  Iterable<T> retype<T>() => cast<T>();
       |
      0|  @override
      0|  E get single => _base.single;
       |
      0|  @override
       |  E singleWhere(bool Function(E) test, {E Function() orElse}) {
      0|    return _base.singleWhere(test, orElse: orElse);
       |  }
       |
      0|  @override
      0|  Iterable<E> skip(int n) => _base.skip(n);
       |
      0|  @override
      0|  Iterable<E> skipWhile(bool Function(E) test) => _base.skipWhile(test);
       |
      0|  @override
      0|  Iterable<E> take(int n) => _base.take(n);
       |
      0|  @override
      0|  Iterable<E> takeWhile(bool Function(E) test) => _base.takeWhile(test);
       |
      0|  @override
      0|  List<E> toList({bool growable = true}) => _base.toList(growable: growable);
       |
      0|  @override
      0|  Set<E> toSet() => _base.toSet();
       |
      1|  @override
      2|  Iterable<E> where(bool Function(E) test) => _base.where(test);
       |
      0|  @override
      0|  Iterable<T> whereType<T>() => _base.whereType<T>();
       |
      0|  @override
      0|  String toString() => _base.toString();
       |}
       |
       |/// An [Iterable] that delegates all operations to a base iterable.
       |///
       |/// This class can be used to hide non-`Iterable` methods of an iterable object,
       |/// or it can be extended to add extra functionality on top of an existing
       |/// iterable object.
       |class DelegatingIterable<E> extends _DelegatingIterableBase<E> {
       |  @override
       |  final Iterable<E> _base;
       |
       |  /// Creates a wrapper that forwards operations to [base].
      1|  const DelegatingIterable(Iterable<E> base) : _base = base;
       |
       |  /// Creates a wrapper that asserts the types of values in [base].
       |  ///
       |  /// This soundly converts an [Iterable] without a generic type to an
       |  /// `Iterable<E>` by asserting that its elements are instances of `E` whenever
       |  /// they're accessed. If they're not, it throws a [CastError].
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already an `Iterable<E>`, it's returned
       |  /// unmodified.
      0|  @Deprecated('Use iterable.cast<E> instead.')
      0|  static Iterable<E> typed<E>(Iterable base) => base.cast<E>();
       |}
       |
       |/// A [List] that delegates all operations to a base list.
       |///
       |/// This class can be used to hide non-`List` methods of a list object, or it
       |/// can be extended to add extra functionality on top of an existing list
       |/// object.
       |class DelegatingList<E> extends DelegatingIterable<E> implements List<E> {
      0|  const DelegatingList(List<E> base) : super(base);
       |
       |  /// Creates a wrapper that asserts the types of values in [base].
       |  ///
       |  /// This soundly converts a [List] without a generic type to a `List<E>` by
       |  /// asserting that its elements are instances of `E` whenever they're
       |  /// accessed. If they're not, it throws a [CastError]. Note that even if an
       |  /// operation throws a [CastError], it may still mutate the underlying
       |  /// collection.
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already a `List<E>`, it's returned
       |  /// unmodified.
      0|  @Deprecated('Use list.cast<E> instead.')
      0|  static List<E> typed<E>(List base) => base.cast<E>();
       |
      0|  List<E> get _listBase => _base;
       |
      0|  @override
      0|  E operator [](int index) => _listBase[index];
       |
      0|  @override
       |  void operator []=(int index, E value) {
      0|    _listBase[index] = value;
       |  }
       |
      0|  @override
      0|  List<E> operator +(List<E> other) => _listBase + other;
       |
      0|  @override
       |  void add(E value) {
      0|    _listBase.add(value);
       |  }
       |
      0|  @override
       |  void addAll(Iterable<E> iterable) {
      0|    _listBase.addAll(iterable);
       |  }
       |
      0|  @override
      0|  Map<int, E> asMap() => _listBase.asMap();
       |
      0|  @override
      0|  List<T> cast<T>() => _listBase.cast<T>();
       |
      0|  @override
       |  void clear() {
      0|    _listBase.clear();
       |  }
       |
      0|  @override
       |  void fillRange(int start, int end, [E fillValue]) {
      0|    _listBase.fillRange(start, end, fillValue);
       |  }
       |
      0|  @override
       |  set first(E value) {
      0|    if (isEmpty) throw RangeError.index(0, this);
      0|    this[0] = value;
       |  }
       |
      0|  @override
      0|  Iterable<E> getRange(int start, int end) => _listBase.getRange(start, end);
       |
      0|  @override
      0|  int indexOf(E element, [int start = 0]) => _listBase.indexOf(element, start);
       |
      0|  @override
       |  int indexWhere(bool Function(E) test, [int start = 0]) =>
      0|      _listBase.indexWhere(test, start);
       |
      0|  @override
       |  void insert(int index, E element) {
      0|    _listBase.insert(index, element);
       |  }
       |
      0|  @override
       |  void insertAll(int index, Iterable<E> iterable) {
      0|    _listBase.insertAll(index, iterable);
       |  }
       |
      0|  @override
       |  set last(E value) {
      0|    if (isEmpty) throw RangeError.index(0, this);
      0|    this[length - 1] = value;
       |  }
       |
      0|  @override
       |  int lastIndexOf(E element, [int start]) =>
      0|      _listBase.lastIndexOf(element, start);
       |
      0|  @override
       |  int lastIndexWhere(bool Function(E) test, [int start]) =>
      0|      _listBase.lastIndexWhere(test, start);
       |
      0|  @override
       |  set length(int newLength) {
      0|    _listBase.length = newLength;
       |  }
       |
      0|  @override
      0|  bool remove(Object value) => _listBase.remove(value);
       |
      0|  @override
      0|  E removeAt(int index) => _listBase.removeAt(index);
       |
      0|  @override
      0|  E removeLast() => _listBase.removeLast();
       |
      0|  @override
       |  void removeRange(int start, int end) {
      0|    _listBase.removeRange(start, end);
       |  }
       |
      0|  @override
       |  void removeWhere(bool Function(E) test) {
      0|    _listBase.removeWhere(test);
       |  }
       |
      0|  @override
       |  void replaceRange(int start, int end, Iterable<E> iterable) {
      0|    _listBase.replaceRange(start, end, iterable);
       |  }
       |
      0|  @override
       |  void retainWhere(bool Function(E) test) {
      0|    _listBase.retainWhere(test);
       |  }
       |
      0|  @deprecated
       |  @override
      0|  List<T> retype<T>() => cast<T>();
       |
      0|  @override
      0|  Iterable<E> get reversed => _listBase.reversed;
       |
      0|  @override
       |  void setAll(int index, Iterable<E> iterable) {
      0|    _listBase.setAll(index, iterable);
       |  }
       |
      0|  @override
       |  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {
      0|    _listBase.setRange(start, end, iterable, skipCount);
       |  }
       |
      0|  @override
       |  void shuffle([math.Random random]) {
      0|    _listBase.shuffle(random);
       |  }
       |
      0|  @override
       |  void sort([int Function(E, E) compare]) {
      0|    _listBase.sort(compare);
       |  }
       |
      0|  @override
      0|  List<E> sublist(int start, [int end]) => _listBase.sublist(start, end);
       |}
       |
       |/// A [Set] that delegates all operations to a base set.
       |///
       |/// This class can be used to hide non-`Set` methods of a set object, or it can
       |/// be extended to add extra functionality on top of an existing set object.
       |class DelegatingSet<E> extends DelegatingIterable<E> implements Set<E> {
      2|  const DelegatingSet(Set<E> base) : super(base);
       |
       |  /// Creates a wrapper that asserts the types of values in [base].
       |  ///
       |  /// This soundly converts a [Set] without a generic type to a `Set<E>` by
       |  /// asserting that its elements are instances of `E` whenever they're
       |  /// accessed. If they're not, it throws a [CastError]. Note that even if an
       |  /// operation throws a [CastError], it may still mutate the underlying
       |  /// collection.
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already a `Set<E>`, it's returned
       |  /// unmodified.
      0|  @Deprecated('Use set.cast<E> instead.')
      0|  static Set<E> typed<E>(Set base) => base.cast<E>();
       |
      2|  Set<E> get _setBase => _base;
       |
      0|  @override
      0|  bool add(E value) => _setBase.add(value);
       |
      0|  @override
       |  void addAll(Iterable<E> elements) {
      0|    _setBase.addAll(elements);
       |  }
       |
      0|  @override
      0|  Set<T> cast<T>() => _setBase.cast<T>();
       |
      0|  @override
       |  void clear() {
      0|    _setBase.clear();
       |  }
       |
      0|  @override
      0|  bool containsAll(Iterable<Object> other) => _setBase.containsAll(other);
       |
      0|  @override
      0|  Set<E> difference(Set<Object> other) => _setBase.difference(other);
       |
      0|  @override
      0|  Set<E> intersection(Set<Object> other) => _setBase.intersection(other);
       |
      0|  @override
      0|  E lookup(Object element) => _setBase.lookup(element);
       |
      0|  @override
      0|  bool remove(Object value) => _setBase.remove(value);
       |
      0|  @override
       |  void removeAll(Iterable<Object> elements) {
      0|    _setBase.removeAll(elements);
       |  }
       |
      0|  @override
       |  void removeWhere(bool Function(E) test) {
      0|    _setBase.removeWhere(test);
       |  }
       |
      0|  @override
       |  void retainAll(Iterable<Object> elements) {
      0|    _setBase.retainAll(elements);
       |  }
       |
      0|  @deprecated
       |  @override
      0|  Set<T> retype<T>() => cast<T>();
       |
      0|  @override
       |  void retainWhere(bool Function(E) test) {
      0|    _setBase.retainWhere(test);
       |  }
       |
      1|  @override
      2|  Set<E> union(Set<E> other) => _setBase.union(other);
       |
      0|  @override
      0|  Set<E> toSet() => DelegatingSet<E>(_setBase.toSet());
       |}
       |
       |/// A [Queue] that delegates all operations to a base queue.
       |///
       |/// This class can be used to hide non-`Queue` methods of a queue object, or it
       |/// can be extended to add extra functionality on top of an existing queue
       |/// object.
       |class DelegatingQueue<E> extends DelegatingIterable<E> implements Queue<E> {
      0|  const DelegatingQueue(Queue<E> queue) : super(queue);
       |
       |  /// Creates a wrapper that asserts the types of values in [base].
       |  ///
       |  /// This soundly converts a [Queue] without a generic type to a `Queue<E>` by
       |  /// asserting that its elements are instances of `E` whenever they're
       |  /// accessed. If they're not, it throws a [CastError]. Note that even if an
       |  /// operation throws a [CastError], it may still mutate the underlying
       |  /// collection.
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already a `Queue<E>`, it's returned
       |  /// unmodified.
      0|  @Deprecated('Use queue.cast<E> instead.')
      0|  static Queue<E> typed<E>(Queue base) => base.cast<E>();
       |
      0|  Queue<E> get _baseQueue => _base;
       |
      0|  @override
       |  void add(E value) {
      0|    _baseQueue.add(value);
       |  }
       |
      0|  @override
       |  void addAll(Iterable<E> iterable) {
      0|    _baseQueue.addAll(iterable);
       |  }
       |
      0|  @override
       |  void addFirst(E value) {
      0|    _baseQueue.addFirst(value);
       |  }
       |
      0|  @override
       |  void addLast(E value) {
      0|    _baseQueue.addLast(value);
       |  }
       |
      0|  @override
      0|  Queue<T> cast<T>() => _baseQueue.cast<T>();
       |
      0|  @override
       |  void clear() {
      0|    _baseQueue.clear();
       |  }
       |
      0|  @override
      0|  bool remove(Object object) => _baseQueue.remove(object);
       |
      0|  @override
       |  void removeWhere(bool Function(E) test) {
      0|    _baseQueue.removeWhere(test);
       |  }
       |
      0|  @override
       |  void retainWhere(bool Function(E) test) {
      0|    _baseQueue.retainWhere(test);
       |  }
       |
      0|  @deprecated
       |  @override
      0|  Queue<T> retype<T>() => cast<T>();
       |
      0|  @override
      0|  E removeFirst() => _baseQueue.removeFirst();
       |
      0|  @override
      0|  E removeLast() => _baseQueue.removeLast();
       |}
       |
       |/// A [Map] that delegates all operations to a base map.
       |///
       |/// This class can be used to hide non-`Map` methods of an object that extends
       |/// `Map`, or it can be extended to add extra functionality on top of an
       |/// existing map object.
       |class DelegatingMap<K, V> implements Map<K, V> {
       |  final Map<K, V> _base;
       |
      0|  const DelegatingMap(Map<K, V> base) : _base = base;
       |
       |  /// Creates a wrapper that asserts the types of keys and values in [base].
       |  ///
       |  /// This soundly converts a [Map] without generic types to a `Map<K, V>` by
       |  /// asserting that its keys are instances of `E` and its values are instances
       |  /// of `V` whenever they're accessed. If they're not, it throws a [CastError].
       |  /// Note that even if an operation throws a [CastError], it may still mutate
       |  /// the underlying collection.
       |  ///
       |  /// This forwards all operations to [base], so any changes in [base] will be
       |  /// reflected in [this]. If [base] is already a `Map<K, V>`, it's returned
       |  /// unmodified.
      0|  @Deprecated('Use map.cast<K, V> instead.')
      0|  static Map<K, V> typed<K, V>(Map base) => base.cast<K, V>();
       |
      0|  @override
      0|  V operator [](Object key) => _base[key];
       |
      0|  @override
       |  void operator []=(K key, V value) {
      0|    _base[key] = value;
       |  }
       |
      0|  @override
       |  void addAll(Map<K, V> other) {
      0|    _base.addAll(other);
       |  }
       |
      0|  @override
       |  void addEntries(Iterable<MapEntry<K, V>> entries) {
      0|    _base.addEntries(entries);
       |  }
       |
      0|  @override
       |  void clear() {
      0|    _base.clear();
       |  }
       |
      0|  @override
      0|  Map<K2, V2> cast<K2, V2>() => _base.cast<K2, V2>();
       |
      0|  @override
      0|  bool containsKey(Object key) => _base.containsKey(key);
       |
      0|  @override
      0|  bool containsValue(Object value) => _base.containsValue(value);
       |
      0|  @override
      0|  Iterable<MapEntry<K, V>> get entries => _base.entries;
       |
      0|  @override
       |  void forEach(void Function(K, V) f) {
      0|    _base.forEach(f);
       |  }
       |
      0|  @override
      0|  bool get isEmpty => _base.isEmpty;
       |
      0|  @override
      0|  bool get isNotEmpty => _base.isNotEmpty;
       |
      0|  @override
      0|  Iterable<K> get keys => _base.keys;
       |
      0|  @override
      0|  int get length => _base.length;
       |
      0|  @override
       |  Map<K2, V2> map<K2, V2>(MapEntry<K2, V2> Function(K, V) transform) =>
      0|      _base.map(transform);
       |
      0|  @override
       |  V putIfAbsent(K key, V Function() ifAbsent) =>
      0|      _base.putIfAbsent(key, ifAbsent);
       |
      0|  @override
      0|  V remove(Object key) => _base.remove(key);
       |
      0|  @override
      0|  void removeWhere(bool Function(K, V) test) => _base.removeWhere(test);
       |
      0|  @deprecated
      0|  Map<K2, V2> retype<K2, V2>() => cast<K2, V2>();
       |
      0|  @override
      0|  Iterable<V> get values => _base.values;
       |
      0|  @override
      0|  String toString() => _base.toString();
       |
      0|  @override
       |  V update(K key, V Function(V) update, {V Function() ifAbsent}) =>
      0|      _base.update(key, update, ifAbsent: ifAbsent);
       |
      0|  @override
      0|  void updateAll(V Function(K, V) update) => _base.updateAll(update);
       |}
       |
       |/// An unmodifiable [Set] view of the keys of a [Map].
       |///
       |/// The set delegates all operations to the underlying map.
       |///
       |/// A `Map` can only contain each key once, so its keys can always
       |/// be viewed as a `Set` without any loss, even if the [Map.keys]
       |/// getter only shows an [Iterable] view of the keys.
       |///
       |/// Note that [lookup] is not supported for this set.
       |class MapKeySet<E> extends _DelegatingIterableBase<E>
       |    with UnmodifiableSetMixin<E> {
       |  final Map<E, dynamic> _baseMap;
       |
      0|  MapKeySet(Map<E, dynamic> base) : _baseMap = base;
       |
      0|  @override
      0|  Iterable<E> get _base => _baseMap.keys;
       |
      0|  @override
       |  Set<T> cast<T>() {
      0|    if (this is MapKeySet<T>) {
       |      return this as MapKeySet<T>;
       |    }
      0|    return Set.castFrom<E, T>(this);
       |  }
       |
      0|  @override
      0|  bool contains(Object element) => _baseMap.containsKey(element);
       |
      0|  @override
      0|  bool get isEmpty => _baseMap.isEmpty;
       |
      0|  @override
      0|  bool get isNotEmpty => _baseMap.isNotEmpty;
       |
      0|  @override
      0|  int get length => _baseMap.length;
       |
      0|  @override
      0|  String toString() => "{${_base.join(', ')}}";
       |
      0|  @override
      0|  bool containsAll(Iterable<Object> other) => other.every(contains);
       |
       |  /// Returns a new set with the the elements of [this] that are not in [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] that are
       |  /// not elements of [other] according to `other.contains`.
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  @override
       |  Set<E> difference(Set<Object> other) =>
      0|      where((element) => !other.contains(element)).toSet();
       |
       |  /// Returns a new set which is the intersection between [this] and [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] that are
       |  /// also elements of [other] according to `other.contains`.
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  @override
      0|  Set<E> intersection(Set<Object> other) => where(other.contains).toSet();
       |
       |  /// Throws an [UnsupportedError] since there's no corresponding method for
       |  /// [Map]s.
      0|  @override
       |  E lookup(Object element) =>
      0|      throw UnsupportedError("MapKeySet doesn't support lookup().");
       |
      0|  @deprecated
       |  @override
      0|  Set<T> retype<T>() => Set.castFrom<E, T>(this);
       |
       |  /// Returns a new set which contains all the elements of [this] and [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] and all
       |  /// the elements of [other].
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  @override
      0|  Set<E> union(Set<E> other) => toSet()..addAll(other);
       |}
       |
       |/// Creates a modifiable [Set] view of the values of a [Map].
       |///
       |/// The `Set` view assumes that the keys of the `Map` can be uniquely determined
       |/// from the values. The `keyForValue` function passed to the constructor finds
       |/// the key for a single value. The `keyForValue` function should be consistent
       |/// with equality. If `value1 == value2` then `keyForValue(value1)` and
       |/// `keyForValue(value2)` should be considered equal keys by the underlying map,
       |/// and vice versa.
       |///
       |/// Modifying the set will modify the underlying map based on the key returned
       |/// by `keyForValue`.
       |///
       |/// If the `Map` contents are not compatible with the `keyForValue` function,
       |/// the set will not work consistently, and may give meaningless responses or do
       |/// inconsistent updates.
       |///
       |/// This set can, for example, be used on a map from database record IDs to the
       |/// records. It exposes the records as a set, and allows for writing both
       |/// `recordSet.add(databaseRecord)` and `recordMap[id]`.
       |///
       |/// Effectively, the map will act as a kind of index for the set.
       |class MapValueSet<K, V> extends _DelegatingIterableBase<V> implements Set<V> {
       |  final Map<K, V> _baseMap;
       |  final K Function(V) _keyForValue;
       |
       |  /// Creates a new [MapValueSet] based on [base].
       |  ///
       |  /// [keyForValue] returns the key in the map that should be associated with
       |  /// the given value. The set's notion of equality is identical to the equality
       |  /// of the return values of [keyForValue].
      0|  MapValueSet(Map<K, V> base, K Function(V) keyForValue)
       |      : _baseMap = base,
       |        _keyForValue = keyForValue;
       |
      0|  @override
      0|  Iterable<V> get _base => _baseMap.values;
       |
      0|  @override
       |  Set<T> cast<T>() {
      0|    if (this is Set<T>) {
       |      return this as Set<T>;
       |    }
      0|    return Set.castFrom<V, T>(this);
       |  }
       |
      0|  @override
       |  bool contains(Object element) {
      0|    if (element != null && element is! V) return false;
      0|    var key = _keyForValue(element as V);
       |
      0|    return _baseMap.containsKey(key);
       |  }
       |
      0|  @override
      0|  bool get isEmpty => _baseMap.isEmpty;
       |
      0|  @override
      0|  bool get isNotEmpty => _baseMap.isNotEmpty;
       |
      0|  @override
      0|  int get length => _baseMap.length;
       |
      0|  @override
      0|  String toString() => toSet().toString();
       |
      0|  @override
       |  bool add(V value) {
      0|    var key = _keyForValue(value);
       |    var result = false;
      0|    _baseMap.putIfAbsent(key, () {
       |      result = true;
       |      return value;
       |    });
       |    return result;
       |  }
       |
      0|  @override
      0|  void addAll(Iterable<V> elements) => elements.forEach(add);
       |
      0|  @override
      0|  void clear() => _baseMap.clear();
       |
      0|  @override
      0|  bool containsAll(Iterable<Object> other) => other.every(contains);
       |
       |  /// Returns a new set with the the elements of [this] that are not in [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] that are
       |  /// not elements of [other] according to `other.contains`.
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  @override
       |  Set<V> difference(Set<Object> other) =>
      0|      where((element) => !other.contains(element)).toSet();
       |
       |  /// Returns a new set which is the intersection between [this] and [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] that are
       |  /// also elements of [other] according to `other.contains`.
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  @override
      0|  Set<V> intersection(Set<Object> other) => where(other.contains).toSet();
       |
      0|  @override
       |  V lookup(Object element) {
      0|    if (element != null && element is! V) return null;
      0|    var key = _keyForValue(element as V);
       |
      0|    return _baseMap[key];
       |  }
       |
      0|  @override
       |  bool remove(Object element) {
      0|    if (element != null && element is! V) return false;
      0|    var key = _keyForValue(element as V);
       |
      0|    if (!_baseMap.containsKey(key)) return false;
      0|    _baseMap.remove(key);
       |    return true;
       |  }
       |
      0|  @override
      0|  void removeAll(Iterable<Object> elements) => elements.forEach(remove);
       |
      0|  @override
       |  void removeWhere(bool Function(V) test) {
      0|    var toRemove = [];
      0|    _baseMap.forEach((key, value) {
      0|      if (test(value)) toRemove.add(key);
       |    });
      0|    toRemove.forEach(_baseMap.remove);
       |  }
       |
      0|  @override
       |  void retainAll(Iterable<Object> elements) {
      0|    var valuesToRetain = Set<V>.identity();
      0|    for (var element in elements) {
      0|      if (element != null && element is! V) continue;
      0|      var key = _keyForValue(element as V);
       |
      0|      if (!_baseMap.containsKey(key)) continue;
      0|      valuesToRetain.add(_baseMap[key]);
       |    }
       |
      0|    var keysToRemove = [];
      0|    _baseMap.forEach((k, v) {
      0|      if (!valuesToRetain.contains(v)) keysToRemove.add(k);
       |    });
      0|    keysToRemove.forEach(_baseMap.remove);
       |  }
       |
      0|  @override
       |  void retainWhere(bool Function(V) test) =>
      0|      removeWhere((element) => !test(element));
       |
      0|  @deprecated
       |  @override
      0|  Set<T> retype<T>() => Set.castFrom<V, T>(this);
       |
       |  /// Returns a new set which contains all the elements of [this] and [other].
       |  ///
       |  /// That is, the returned set contains all the elements of this [Set] and all
       |  /// the elements of [other].
       |  ///
       |  /// Note that the returned set will use the default equality operation, which
       |  /// may be different than the equality operation [this] uses.
      0|  @override
      0|  Set<V> union(Set<V> other) => toSet()..addAll(other);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/empty_unmodifiable_set.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'unmodifiable_wrappers.dart';
       |
       |// Unfortunately, we can't use UnmodifiableSetMixin here, since const classes
       |// can't use mixins.
       |/// An unmodifiable, empty set that can have a const constructor.
       |class EmptyUnmodifiableSet<E> extends IterableBase<E>
       |    implements UnmodifiableSetView<E> {
      0|  static T _throw<T>() {
      0|    throw UnsupportedError('Cannot modify an unmodifiable Set');
       |  }
       |
      0|  @override
      0|  Iterator<E> get iterator => Iterable<E>.empty().iterator;
      0|  @override
       |  int get length => 0;
       |
      0|  const EmptyUnmodifiableSet();
       |
      0|  @override
      0|  EmptyUnmodifiableSet<T> cast<T>() => EmptyUnmodifiableSet<T>();
      0|  @override
       |  bool contains(Object element) => false;
      0|  @override
      0|  bool containsAll(Iterable<Object> other) => other.isEmpty;
      0|  @override
      0|  Iterable<E> followedBy(Iterable<E> other) => Set.from(other);
      0|  @override
       |  E lookup(Object element) => null;
      0|  @deprecated
       |  @override
      0|  EmptyUnmodifiableSet<T> retype<T>() => EmptyUnmodifiableSet<T>();
      0|  @override
       |  E singleWhere(bool Function(E) test, {E Function() orElse}) =>
      0|      super.singleWhere(test);
      0|  @override
      0|  Iterable<T> whereType<T>() => EmptyUnmodifiableSet<T>();
      0|  @override
       |  Set<E> toSet() => {};
      0|  @override
      0|  Set<E> union(Set<E> other) => Set.from(other);
      0|  @override
       |  Set<E> intersection(Set<Object> other) => {};
      0|  @override
       |  Set<E> difference(Set<Object> other) => {};
       |
      0|  @override
      0|  bool add(E value) => _throw();
      0|  @override
      0|  void addAll(Iterable<E> elements) => _throw();
      0|  @override
      0|  void clear() => _throw();
      0|  @override
      0|  bool remove(Object element) => _throw();
      0|  @override
      0|  void removeAll(Iterable<Object> elements) => _throw();
      0|  @override
      0|  void removeWhere(bool Function(E) test) => _throw();
      0|  @override
      0|  void retainWhere(bool Function(E) test) => _throw();
      0|  @override
      0|  void retainAll(Iterable<Object> elements) => _throw();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/collection-1.14.13/lib/src/utils.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A pair of values.
       |class Pair<E, F> {
       |  E first;
       |  F last;
       |
      0|  Pair(this.first, this.last);
       |}
       |
       |/// Returns a [Comparator] that asserts that its first argument is comparable.
      0|Comparator<T> defaultCompare<T>() =>
      0|    (value1, value2) => (value1 as Comparable).compareTo(value2);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.5/lib/src/eager_span_scanner.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:charcode/ascii.dart';
       |
       |import 'line_scanner.dart';
       |import 'span_scanner.dart';
       |
       |// TODO(nweiz): Currently this duplicates code in line_scanner.dart. Once
       |// sdk#23770 is fully complete, we should move the shared code into a mixin.
       |
       |/// A regular expression matching newlines across platforms.
      0|final _newlineRegExp = RegExp(r"\r\n?|\n");
       |
       |/// A [SpanScanner] that tracks the line and column eagerly, like [LineScanner].
       |class EagerSpanScanner extends SpanScanner {
      0|  int get line => _line;
       |  int _line = 0;
       |
      0|  int get column => _column;
       |  int _column = 0;
       |
      0|  LineScannerState get state =>
      0|      _EagerSpanScannerState(this, position, line, column);
       |
      0|  bool get _betweenCRLF => peekChar(-1) == $cr && peekChar() == $lf;
       |
      0|  set state(LineScannerState state) {
      0|    if (state is! _EagerSpanScannerState ||
      0|        !identical((state as _EagerSpanScannerState)._scanner, this)) {
      0|      throw ArgumentError("The given LineScannerState was not returned by "
       |          "this LineScanner.");
       |    }
       |
      0|    super.position = state.position;
      0|    _line = state.line;
      0|    _column = state.column;
       |  }
       |
      0|  set position(int newPosition) {
      0|    var oldPosition = position;
      0|    super.position = newPosition;
       |
      0|    if (newPosition > oldPosition) {
      0|      var newlines = _newlinesIn(string.substring(oldPosition, newPosition));
      0|      _line += newlines.length;
      0|      if (newlines.isEmpty) {
      0|        _column += newPosition - oldPosition;
       |      } else {
      0|        _column = newPosition - newlines.last.end;
       |      }
       |    } else {
      0|      var newlines = _newlinesIn(string.substring(newPosition, oldPosition));
      0|      if (_betweenCRLF) newlines.removeLast();
       |
      0|      _line -= newlines.length;
      0|      if (newlines.isEmpty) {
      0|        _column -= oldPosition - newPosition;
       |      } else {
      0|        _column =
      0|            newPosition - string.lastIndexOf(_newlineRegExp, newPosition) - 1;
       |      }
       |    }
       |  }
       |
      0|  EagerSpanScanner(String string, {sourceUrl, int position})
      0|      : super(string, sourceUrl: sourceUrl, position: position);
       |
      0|  bool scanChar(int character) {
      0|    if (!super.scanChar(character)) return false;
      0|    _adjustLineAndColumn(character);
       |    return true;
       |  }
       |
      0|  int readChar() {
      0|    var character = super.readChar();
      0|    _adjustLineAndColumn(character);
       |    return character;
       |  }
       |
       |  /// Adjusts [_line] and [_column] after having consumed [character].
      0|  void _adjustLineAndColumn(int character) {
      0|    if (character == $lf || (character == $cr && peekChar() != $lf)) {
      0|      _line += 1;
      0|      _column = 0;
       |    } else {
      0|      _column += 1;
       |    }
       |  }
       |
      0|  bool scan(Pattern pattern) {
      0|    if (!super.scan(pattern)) return false;
       |
      0|    var newlines = _newlinesIn(lastMatch[0]);
      0|    _line += newlines.length;
      0|    if (newlines.isEmpty) {
      0|      _column += lastMatch[0].length;
       |    } else {
      0|      _column = lastMatch[0].length - newlines.last.end;
       |    }
       |
       |    return true;
       |  }
       |
       |  /// Returns a list of [Match]es describing all the newlines in [text], which
       |  /// is assumed to end at [position].
      0|  List<Match> _newlinesIn(String text) {
      0|    var newlines = _newlineRegExp.allMatches(text).toList();
      0|    if (_betweenCRLF) newlines.removeLast();
       |    return newlines;
       |  }
       |}
       |
       |/// A class representing the state of an [EagerSpanScanner].
       |class _EagerSpanScannerState implements LineScannerState {
       |  final EagerSpanScanner _scanner;
       |  final int position;
       |  final int line;
       |  final int column;
       |
      0|  _EagerSpanScannerState(this._scanner, this.position, this.line, this.column);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/string_scanner-1.0.5/lib/src/relative_span_scanner.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'exception.dart';
       |import 'line_scanner.dart';
       |import 'span_scanner.dart';
       |import 'string_scanner.dart';
       |import 'utils.dart';
       |
       |/// A [SpanScanner] that scans within an existing [FileSpan].
       |///
       |/// This re-implements chunks of [SpanScanner] rather than using a dummy span or
       |/// inheritance because scanning is often a performance-critical operation, so
       |/// it's important to avoid adding extra overhead when relative scanning isn't
       |/// needed.
       |class RelativeSpanScanner extends StringScanner implements SpanScanner {
       |  /// The source of the scanner.
       |  ///
       |  /// This caches line break information and is used to generate [SourceSpan]s.
       |  final SourceFile _sourceFile;
       |
       |  /// The start location of the span within which this scanner is scanning.
       |  ///
       |  /// This is used to convert between span-relative and file-relative fields.
       |  final FileLocation _startLocation;
       |
      0|  int get line =>
      0|      _sourceFile.getLine(_startLocation.offset + position) -
      0|      _startLocation.line;
       |
      0|  int get column {
      0|    var line = _sourceFile.getLine(_startLocation.offset + position);
       |    var column =
      0|        _sourceFile.getColumn(_startLocation.offset + position, line: line);
      0|    return line == _startLocation.line
      0|        ? column - _startLocation.column
       |        : column;
       |  }
       |
      0|  LineScannerState get state => _SpanScannerState(this, position);
       |
      0|  set state(LineScannerState state) {
      0|    if (state is! _SpanScannerState ||
      0|        !identical((state as _SpanScannerState)._scanner, this)) {
      0|      throw ArgumentError("The given LineScannerState was not returned by "
       |          "this LineScanner.");
       |    }
       |
      0|    position = state.position;
       |  }
       |
      0|  FileSpan get lastSpan => _lastSpan;
       |  FileSpan _lastSpan;
       |
      0|  FileLocation get location =>
      0|      _sourceFile.location(_startLocation.offset + position);
       |
      0|  FileSpan get emptySpan => location.pointSpan();
       |
      0|  RelativeSpanScanner(FileSpan span)
      0|      : _sourceFile = span.file,
      0|        _startLocation = span.start,
      0|        super(span.text, sourceUrl: span.sourceUrl);
       |
      0|  FileSpan spanFrom(LineScannerState startState, [LineScannerState endState]) {
      0|    var endPosition = endState == null ? position : endState.position;
      0|    return _sourceFile.span(_startLocation.offset + startState.position,
      0|        _startLocation.offset + endPosition);
       |  }
       |
      0|  bool matches(Pattern pattern) {
      0|    if (!super.matches(pattern)) {
      0|      _lastSpan = null;
       |      return false;
       |    }
       |
      0|    _lastSpan = _sourceFile.span(_startLocation.offset + position,
      0|        _startLocation.offset + lastMatch.end);
       |    return true;
       |  }
       |
      0|  void error(String message, {Match match, int position, int length}) {
      0|    validateErrorArgs(string, match, position, length);
       |
      0|    if (match == null && position == null && length == null) match = lastMatch;
      0|    position ??= match == null ? this.position : match.start;
      0|    length ??= match == null ? 1 : match.end - match.start;
       |
      0|    var span = _sourceFile.span(_startLocation.offset + position,
      0|        _startLocation.offset + position + length);
      0|    throw StringScannerException(message, span, string);
       |  }
       |}
       |
       |/// A class representing the state of a [SpanScanner].
       |class _SpanScannerState implements LineScannerState {
       |  /// The [SpanScanner] that created this.
       |  final RelativeSpanScanner _scanner;
       |
       |  final int position;
      0|  int get line => _scanner._sourceFile.getLine(position);
      0|  int get column => _scanner._sourceFile.getColumn(position);
       |
      0|  _SpanScannerState(this._scanner, this.position);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/async_matcher.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:matcher/matcher.dart';
       |
       |import '../backend/invoker.dart';
       |import 'expect.dart';
       |
       |/// A matcher that does asynchronous computation.
       |///
       |/// Rather than implementing [matches], subclasses implement [matchAsync].
       |/// [AsyncMatcher.matches] ensures that the test doesn't complete until the
       |/// returned future completes, and [expect] returns a future that completes when
       |/// the returned future completes so that tests can wait for it.
       |abstract class AsyncMatcher extends Matcher {
      1|  const AsyncMatcher();
       |
       |  /// Returns `null` if this matches [item], or a [String] description of the
       |  /// failure if it doesn't match.
       |  ///
       |  /// This can return a [Future] or a synchronous value. If it returns a
       |  /// [Future], neither [expect] nor the test will complete until that [Future]
       |  /// completes.
       |  ///
       |  /// If this returns a [String] synchronously, [expect] will synchronously
       |  /// throw a [TestFailure] and [matches] will synchronusly return `false`.
       |  dynamic /*FutureOr<String>*/ matchAsync(item);
       |
      0|  @override
       |  bool matches(item, Map matchState) {
      0|    var result = matchAsync(item);
      0|    expect(result,
      0|        anyOf([equals(null), TypeMatcher<Future>(), TypeMatcher<String>()]),
       |        reason: 'matchAsync() may only return a String, a Future, or null.');
       |
      0|    if (result is Future) {
      0|      Invoker.current.addOutstandingCallback();
      0|      result.then((realResult) {
       |        if (realResult != null) {
      0|          fail(formatFailure(this, item, realResult as String));
       |        }
      0|        Invoker.current.removeOutstandingCallback();
       |      });
      0|    } else if (result is String) {
      0|      matchState[this] = result;
       |      return false;
       |    }
       |
       |    return true;
       |  }
       |
      0|  @override
       |  Description describeMismatch(
       |          item, Description description, Map matchState, bool verbose) =>
      0|      StringDescription(matchState[this] as String);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/frontend/format_stack_trace.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../backend/stack_trace_formatter.dart';
       |
       |/// The default formatter to use for formatting stack traces.
       |///
       |/// This is used in situations where the zone-scoped formatter is unavailable,
       |/// such as when running via `dart path/to/test.dart'.
      0|final _defaultFormatter = StackTraceFormatter();
       |
       |/// Converts [stackTrace] to a [Chain] according to the current test's
       |/// configuration.
       |///
       |/// If [verbose] is `true`, this doesn't fold out irrelevant stack frames. It
       |/// defaults to the current test's `verbose_trace` configuration.
      0|Chain formatStackTrace(StackTrace stackTrace, {bool verbose}) =>
      0|    (StackTraceFormatter.current ?? _defaultFormatter)
      0|        .formatStackTrace(stackTrace, verbose: verbose);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/stack_trace_formatter.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../util/stack_trace_mapper.dart';
       |import 'invoker.dart';
       |
       |/// The key used to look up [StackTraceFormatter.current] in a zone.
      0|final _currentKey = Object();
       |
       |/// A class that tracks how to format a stack trace according to the user's
       |/// configuration.
       |///
       |/// This can convert JavaScript stack traces to Dart using source maps, and fold
       |/// irrelevant frames out of the stack trace.
       |class StackTraceFormatter {
       |  /// A class that converts [trace] into a Dart stack trace, or `null` to use it
       |  /// as-is.
       |  StackTraceMapper _mapper;
       |
       |  /// The set of packages to fold when producing terse [Chain]s.
       |  var _except = {'test', 'stream_channel', 'test_api'};
       |
       |  /// If non-empty, all packages not in this list will be folded when producing
       |  /// terse [Chain]s.
       |  var _only = <String>{};
       |
       |  /// Returns the current manager, or `null` if this isn't called within a call
       |  /// to [asCurrent].
      0|  static StackTraceFormatter get current =>
      0|      Zone.current[_currentKey] as StackTraceFormatter;
       |
       |  /// Runs [body] with this as [StackTraceFormatter.current].
       |  ///
       |  /// This is zone-scoped, so this will be the current configuration in any
       |  /// asynchronous callbacks transitively created by [body].
      0|  T asCurrent<T>(T Function() body) =>
      0|      runZoned(body, zoneValues: {_currentKey: this});
       |
       |  /// Configure how stack traces are formatted.
       |  ///
       |  /// The [mapper] is used to convert JavaScript traces into Dart traces. The
       |  /// [except] set indicates packages whose frames should be folded away. If
       |  /// [only] is non-empty, it indicates packages whose frames should *not* be
       |  /// folded away.
      0|  void configure(
       |      {StackTraceMapper mapper, Set<String> except, Set<String> only}) {
      0|    if (mapper != null) _mapper = mapper;
      0|    if (except != null) _except = except;
      0|    if (only != null) _only = only;
       |  }
       |
       |  /// Converts [stackTrace] to a [Chain] and formats it according to the user's
       |  /// preferences.
       |  ///
       |  /// If [verbose] is `true`, this doesn't fold out irrelevant stack frames. It
       |  /// defaults to the current test's [Metadata.verboseTrace] configuration, or
       |  /// `false` if there is no current test.
      0|  Chain formatStackTrace(StackTrace stackTrace, {bool verbose}) {
       |    verbose ??=
      0|        Invoker.current?.liveTest?.test?.metadata?.verboseTrace ?? false;
       |
       |    var chain =
      0|        Chain.forTrace(_mapper?.mapStackTrace(stackTrace) ?? stackTrace);
       |    if (verbose) return chain;
       |
      0|    return chain.foldFrames((frame) {
      0|      if (_only.isNotEmpty) return !_only.contains(frame.package);
      0|      return _except.contains(frame.package);
       |    }, terse: true);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/util/test.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../backend/invoker.dart';
       |
       |/// Runs [body] with special error-handling behavior.
       |///
       |/// Errors emitted [body] will still cause the current test to fail, but they
       |/// won't cause it to *stop*. In particular, they won't remove any outstanding
       |/// callbacks registered outside of [body].
       |///
       |/// This may only be called within a test.
      0|Future errorsDontStopTest(dynamic Function() body) {
      0|  var completer = Completer();
       |
      0|  Invoker.current.addOutstandingCallback();
      0|  Invoker.current.waitForOutstandingCallbacks(() {
      0|    Future.sync(body).whenComplete(completer.complete);
      0|  }).then((_) => Invoker.current.removeOutstandingCallback());
       |
      0|  return completer.future;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/closed_exception.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An exception thrown by various front-end methods when the test framework has
       |/// been closed and a test must shut down as soon as possible.
       |class ClosedException implements Exception {
      0|  ClosedException();
       |
      0|  @override
       |  String toString() => 'This test has been closed.';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/group.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import 'group_entry.dart';
       |import 'metadata.dart';
       |import 'suite_platform.dart';
       |import 'test.dart';
       |
       |/// A group contains one or more tests and subgroups.
       |///
       |/// It includes metadata that applies to all contained tests.
       |class Group implements GroupEntry {
       |  @override
       |  final String name;
       |
       |  @override
       |  final Metadata metadata;
       |
       |  @override
       |  final Trace trace;
       |
       |  /// The children of this group.
       |  final List<GroupEntry> entries;
       |
       |  /// Returns a new root-level group.
      0|  Group.root(Iterable<GroupEntry> entries, {Metadata metadata})
      0|      : this(null, entries, metadata: metadata);
       |
       |  /// A test to run before all tests in the group.
       |  ///
       |  /// This is `null` if no `setUpAll` callbacks were declared.
       |  final Test setUpAll;
       |
       |  /// A test to run after all tests in the group.
       |  ///
       |  /// This is `null` if no `tearDown` callbacks were declared.
       |  final Test tearDownAll;
       |
       |  /// The number of tests (recursively) in this group.
      0|  int get testCount {
      0|    if (_testCount != null) return _testCount;
      0|    _testCount = entries.fold(
      0|        0, (count, entry) => count + (entry is Group ? entry.testCount : 1));
      0|    return _testCount;
       |  }
       |
       |  int _testCount;
       |
      1|  Group(this.name, Iterable<GroupEntry> entries,
       |      {Metadata metadata, this.trace, this.setUpAll, this.tearDownAll})
      1|      : entries = List<GroupEntry>.unmodifiable(entries),
      0|        metadata = metadata ?? Metadata();
       |
      1|  @override
       |  Group forPlatform(SuitePlatform platform) {
      3|    if (!metadata.testOn.evaluate(platform)) return null;
      2|    var newMetadata = metadata.forPlatform(platform);
      3|    var filtered = _map((entry) => entry.forPlatform(platform));
      1|    if (filtered.isEmpty && entries.isNotEmpty) return null;
      2|    return Group(name, filtered,
       |        metadata: newMetadata,
      1|        trace: trace,
      1|        setUpAll: setUpAll,
      1|        tearDownAll: tearDownAll);
       |  }
       |
      0|  @override
       |  Group filter(bool Function(Test) callback) {
      0|    var filtered = _map((entry) => entry.filter(callback));
      0|    if (filtered.isEmpty && entries.isNotEmpty) return null;
      0|    return Group(name, filtered,
      0|        metadata: metadata,
      0|        trace: trace,
      0|        setUpAll: setUpAll,
      0|        tearDownAll: tearDownAll);
       |  }
       |
       |  /// Returns the entries of this group mapped using [callback].
       |  ///
       |  /// Any `null` values returned by [callback] will be removed.
      1|  List<GroupEntry> _map(GroupEntry Function(GroupEntry) callback) {
      1|    return entries
      3|        .map((entry) => callback(entry))
      2|        .where((entry) => entry != null)
      1|        .toList();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/live_test.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'group.dart';
       |import 'message.dart';
       |import 'state.dart';
       |import 'suite.dart';
       |import 'test.dart';
       |
       |/// A runnable instance of a test.
       |///
       |/// This is distinct from [Test] in order to keep [Test] immutable. Running a
       |/// test requires state, and [LiveTest] provides a view of the state of the test
       |/// as it runs.
       |///
       |/// If the state changes, [state] will be updated before [onStateChange] fires.
       |/// Likewise, if an error is caught, it will be added to [errors] before being
       |/// emitted via [onError]. If an error causes a state change, [onStateChange]
       |/// will fire before [onError]. If an error or other state change causes the
       |/// test to complete, [onComplete] will complete after [onStateChange] and
       |/// [onError] fire.
       |abstract class LiveTest {
       |  /// The suite within which this test is being run.
       |  Suite get suite;
       |
       |  /// The groups within which this test is being run, from the outermost to the
       |  /// innermost.
       |  ///
       |  /// This will always contain at least the implicit top-level group.
       |  List<Group> get groups;
       |
       |  /// The running test.
       |  Test get test;
       |
       |  /// The current state of the running test.
       |  ///
       |  /// This starts as [Status.pending] and [Result.success]. It will be updated
       |  /// before [onStateChange] fires.
       |  ///
       |  /// Note that even if this is marked [Status.complete], the test may still be
       |  /// running code asynchronously. A test is considered complete either once it
       |  /// hits its first error or when all [expectAsync] callbacks have been called
       |  /// and any returned [Future] has completed, but it's possible for further
       |  /// processing to happen, which may cause further errors. It's even possible
       |  /// for a test that was marked [Status.complete] and [Result.success] to be
       |  /// marked as [Result.error] later.
       |  State get state;
       |
       |  /// Returns whether this test has completed.
       |  ///
       |  /// This is equivalent to [state.status] being [Status.complete].
       |  ///
       |  /// Note that even if this returns `true`, the test may still be
       |  /// running code asynchronously. A test is considered complete either once it
       |  /// hits its first error or when all [expectAsync] callbacks have been called
       |  /// and any returned [Future] has completed, but it's possible for further
       |  /// processing to happen, which may cause further errors.
      4|  bool get isComplete => state.status == Status.complete;
       |
       |  // A stream that emits a new [State] whenever [state] changes.
       |  //
       |  // This will only ever emit a [State] if it's different than the previous
       |  // [state]. It will emit an event after [state] has been updated. Note that
       |  // since this is an asynchronous stream, it's possible for [state] not to
       |  // match the [State] that it emits within the [Stream.listen] callback.
       |  Stream<State> get onStateChange;
       |
       |  /// An unmodifiable list of all errors that have been caught while running
       |  /// this test.
       |  ///
       |  /// This will be updated before [onError] fires. These errors are not
       |  /// guaranteed to have the same types as when they were thrown; for example,
       |  /// they may need to be serialized across isolate boundaries. The stack traces
       |  /// will be [Chain]s.
       |  List<AsyncError> get errors;
       |
       |  /// A stream that emits a new [AsyncError] whenever an error is caught.
       |  ///
       |  /// This will be emit an event after [errors] is updated. These errors are not
       |  /// guaranteed to have the same types as when they were thrown; for example,
       |  /// they may need to be serialized across isolate boundaries. The stack traces
       |  /// will be [Chain]s.
       |  Stream<AsyncError> get onError;
       |
       |  /// A stream that emits messages produced by the test.
       |  Stream<Message> get onMessage;
       |
       |  /// A [Future] that completes once the test is complete.
       |  ///
       |  /// This will complete after [onStateChange] has fired, and after [onError]
       |  /// has fired if the test completes because of an error. It's the same as the
       |  /// [Future] returned by [run].
       |  ///
       |  /// Note that even once this completes, the test may still be running code
       |  /// asynchronously. A test is considered complete either once it hits its
       |  /// first error or when all [expectAsync] callbacks have been called and any
       |  /// returned [Future] has completed, but it's possible for further processing
       |  /// to happen, which may cause further errors.
       |  Future get onComplete;
       |
       |  /// The name of this live test without any group prefixes.
      0|  String get individualName {
      0|    var group = groups.last;
      0|    if (group.name == null) return test.name;
      0|    if (!test.name.startsWith(group.name)) return test.name;
       |
       |    // The test will have the same name as the group for virtual tests created
       |    // to represent skipping the entire group.
      0|    if (test.name.length == group.name.length) return '';
       |
      0|    return test.name.substring(group.name.length + 1);
       |  }
       |
       |  /// Loads a copy of this [LiveTest] that's able to be run again.
      0|  LiveTest copy() => test.load(suite, groups: groups);
       |
       |  /// Signals that this test should start running as soon as possible.
       |  ///
       |  /// A test may not start running immediately for various reasons specific to
       |  /// the means by which it's defined. Until it starts running, [state] will
       |  /// continue to be marked [Status.pending].
       |  ///
       |  /// This returns the same [Future] as [onComplete]. It may not be called more
       |  /// than once.
       |  Future run();
       |
       |  /// Signals that this test should stop emitting events and release any
       |  /// resources it may have allocated.
       |  ///
       |  /// Once [close] is called, [onComplete] will complete if it hasn't already
       |  /// and [onStateChange] and [onError] will close immediately. This means that,
       |  /// if the test was running at the time [close] is called, it will never emit
       |  /// a [Status.complete] state-change event. Once a test is closed, [expect]
       |  /// and [expectAsync] will throw a [ClosedException] to help the test
       |  /// terminate as quickly as possible.
       |  ///
       |  /// This doesn't automatically happen after the test completes because there
       |  /// may be more asynchronous work going on in the background that could
       |  /// produce new errors.
       |  ///
       |  /// Returns a [Future] that completes once all resources are released *and*
       |  /// the test has completed. This allows the caller to wait until the test's
       |  /// tear-down logic has run.
       |  Future close();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/live_test_controller.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:collection';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import 'group.dart';
       |import 'live_test.dart';
       |import 'message.dart';
       |import 'state.dart';
       |import 'suite.dart';
       |import 'test.dart';
       |
       |/// A concrete [LiveTest] that enforces some lifecycle guarantees.
       |///
       |/// This automatically handles some of [LiveTest]'s guarantees, but for the most
       |/// part it's the caller's responsibility to make sure everything gets
       |/// dispatched in the correct order.
       |class LiveTestController extends LiveTest {
      0|  @Deprecated('Use this instance instead')
       |  LiveTest get liveTest => this;
       |
       |  @override
       |  final Suite suite;
       |
       |  @override
       |  final List<Group> groups;
       |
       |  @override
       |  final Test test;
       |
       |  /// The function that will actually start the test running.
       |  final void Function() _onRun;
       |
       |  /// A function to run when the test is closed.
       |  ///
       |  /// This may be `null`.
       |  final void Function() _onClose;
       |
       |  /// The list of errors caught by the test.
       |  final _errors = <AsyncError>[];
       |
      0|  @override
      0|  List<AsyncError> get errors => UnmodifiableListView(_errors);
       |
       |  /// The current state of the test.
       |  @override
       |  var state = const State(Status.pending, Result.success);
       |
       |  /// The controller for [onStateChange].
       |  ///
       |  /// This is synchronous to ensure that events are well-ordered across multiple
       |  /// streams.
       |  final _onStateChange = StreamController<State>.broadcast(sync: true);
      1|  @override
      2|  Stream<State> get onStateChange => _onStateChange.stream;
       |
       |  /// The controller for [onError].
       |  ///
       |  /// This is synchronous to ensure that events are well-ordered across multiple
       |  /// streams.
       |  final _onError = StreamController<AsyncError>.broadcast(sync: true);
      1|  @override
      2|  Stream<AsyncError> get onError => _onError.stream;
       |
       |  /// The controller for [onMessage].
       |  ///
       |  /// This is synchronous to ensure that events are well-ordered across multiple
       |  /// streams.
       |  final _onMessage = StreamController<Message>.broadcast(sync: true);
      1|  @override
      2|  Stream<Message> get onMessage => _onMessage.stream;
       |
       |  final completer = Completer<void>();
       |
       |  /// Whether [run] has been called.
       |  var _runCalled = false;
       |
       |  /// Whether [close] has been called.
      3|  bool get _isClosed => _onError.isClosed;
       |
       |  /// Creates a new controller for a [LiveTest].
       |  ///
       |  /// [test] is the test being run; [suite] is the suite that contains it.
       |  ///
       |  /// [onRun] is a function that's called from [LiveTest.run]. It should start
       |  /// the test running. The controller takes care of ensuring that
       |  /// [LiveTest.run] isn't called more than once and that [LiveTest.onComplete]
       |  /// is returned.
       |  ///
       |  /// [onClose] is a function that's called the first time [LiveTest.close] is
       |  /// called. It should clean up any resources that have been allocated for the
       |  /// test and ensure that the test finishes quickly if it's still running. It
       |  /// will only be called if [onRun] has been called first.
       |  ///
       |  /// If [groups] is passed, it's used to populate the list of groups that
       |  /// contain this test. Otherwise, `suite.group` is used.
      1|  LiveTestController(this.suite, this.test, this._onRun, this._onClose,
       |      {Iterable<Group> groups})
      1|      : groups = groups == null ? [suite.group] : List.unmodifiable(groups);
       |
       |  /// Adds an error to the [LiveTest].
       |  ///
       |  /// This both adds the error to [LiveTest.errors] and emits it via
       |  /// [LiveTest.onError]. [stackTrace] is automatically converted into a [Chain]
       |  /// if it's not one already.
      0|  void addError(error, StackTrace stackTrace) {
      0|    if (_isClosed) return;
       |
      0|    var asyncError = AsyncError(error, Chain.forTrace(stackTrace));
      0|    _errors.add(asyncError);
      0|    _onError.add(asyncError);
       |  }
       |
       |  /// Sets the current state of the [LiveTest] to [newState].
       |  ///
       |  /// If [newState] is different than the old state, this both sets
       |  /// [LiveTest.state] and emits the new state via [LiveTest.onStateChanged]. If
       |  /// it's not different, this does nothing.
      1|  void setState(State newState) {
      1|    if (_isClosed) return;
      2|    if (state == newState) return;
       |
      1|    state = newState;
      2|    _onStateChange.add(newState);
       |  }
       |
       |  /// Emits message over [LiveTest.onMessage].
      0|  void message(Message message) {
      0|    if (_onMessage.hasListener) {
      0|      _onMessage.add(message);
       |    } else {
       |      // Make sure all messages get surfaced one way or another to aid in
       |      // debugging.
      0|      Zone.root.print(message.text);
       |    }
       |  }
       |
      1|  @override
       |  Future<void> run() {
      1|    if (_runCalled) {
      0|      throw StateError('LiveTest.run() may not be called more than once.');
      1|    } else if (_isClosed) {
      0|      throw StateError('LiveTest.run() may not be called for a closed '
       |          'test.');
       |    }
      1|    _runCalled = true;
       |
      2|    _onRun();
      1|    return onComplete;
       |  }
       |
       |  /// Returns a future that completes when the test is complete.
       |  ///
       |  /// We also wait for the state to transition to Status.complete.
      1|  @override
      2|  Future<void> get onComplete => completer.future;
       |
      0|  @override
       |  Future<void> close() {
      0|    if (_isClosed) return onComplete;
       |
      0|    _onStateChange.close();
      0|    _onError.close();
       |
      0|    if (_runCalled) {
      0|      _onClose();
       |    } else {
      0|      completer.complete();
       |    }
       |
      0|    return onComplete;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/message.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A message emitted by a test.
       |///
       |/// A message encompasses any textual information that should be presented to
       |/// the user. Reporters are encouraged to visually distinguish different message
       |/// types.
       |class Message {
       |  final MessageType type;
       |
       |  final String text;
       |
      0|  Message(this.type, this.text);
       |
      0|  Message.print(this.text) : type = MessageType.print;
      0|  Message.skip(this.text) : type = MessageType.skip;
       |}
       |
       |class MessageType {
       |  /// A message explicitly printed by the user's test.
       |  static const print = MessageType._('print');
       |
       |  /// A message indicating that a test, or some portion of one, was skipped.
       |  static const skip = MessageType._('skip');
       |
       |  /// The name of the message type.
       |  final String name;
       |
      0|  factory MessageType.parse(String name) {
       |    switch (name) {
      0|      case 'print':
       |        return MessageType.print;
      0|      case 'skip':
       |        return MessageType.skip;
       |      default:
      0|        throw ArgumentError('Invalid message type "$name".');
       |    }
       |  }
       |
      0|  const MessageType._(this.name);
       |
      0|  @override
      0|  String toString() => name;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/metadata.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'package:boolean_selector/boolean_selector.dart';
       |import 'package:collection/collection.dart';
       |
       |import '../frontend/skip.dart';
       |import '../frontend/timeout.dart';
       |import '../utils.dart';
       |import 'platform_selector.dart';
       |import 'suite_platform.dart';
       |
       |/// Metadata for a test or test suite.
       |///
       |/// This metadata comes from declarations on the test itself; it doesn't include
       |/// configuration from the user.
       |class Metadata {
       |  /// Empty metadata with only default values.
       |  ///
       |  /// Using this is slightly more efficient than manually constructing a new
       |  /// metadata with no arguments.
      3|  static final empty = Metadata._();
       |
       |  /// The selector indicating which platforms the suite supports.
       |  final PlatformSelector testOn;
       |
       |  /// The modification to the timeout for the test or suite.
       |  final Timeout timeout;
       |
       |  /// Whether the test or suite should be skipped.
      2|  bool get skip => _skip ?? false;
       |  final bool _skip;
       |
       |  /// The reason the test or suite should be skipped, if given.
       |  final String skipReason;
       |
       |  /// Whether to use verbose stack traces.
      0|  bool get verboseTrace => _verboseTrace ?? false;
       |  final bool _verboseTrace;
       |
       |  /// Whether to chain stack traces.
      2|  bool get chainStackTraces => _chainStackTraces ?? true;
       |  final bool _chainStackTraces;
       |
       |  /// The user-defined tags attached to the test or suite.
       |  final Set<String> tags;
       |
       |  /// The number of times to re-run a test before being marked as a failure.
      0|  int get retry => _retry ?? 0;
       |  final int _retry;
       |
       |  /// Platform-specific metadata.
       |  ///
       |  /// Each key identifies a platform, and its value identifies the specific
       |  /// metadata for that platform. These can be applied by calling [forPlatform].
       |  final Map<PlatformSelector, Metadata> onPlatform;
       |
       |  /// Metadata that applies only when specific tags are applied.
       |  ///
       |  /// Tag-specific metadata is applied when merging this with other metadata.
       |  /// Note that unlike [onPlatform], the base metadata takes precedence over any
       |  /// tag-specific metadata.
       |  ///
       |  /// This is guaranteed not to have any keys that match [tags]; those are
       |  /// resolved when the metadata is constructed.
       |  final Map<BooleanSelector, Metadata> forTag;
       |
       |  /// The language version comment, if one is present.
       |  ///
       |  /// Only available for test suites and not individual tests.
       |  final String languageVersionComment;
       |
       |  /// Parses a user-provided map into the value for [onPlatform].
      1|  static Map<PlatformSelector, Metadata> _parseOnPlatform(
       |      Map<String, dynamic> onPlatform) {
      1|    if (onPlatform == null) return {};
       |
      0|    var result = <PlatformSelector, Metadata>{};
      0|    onPlatform.forEach((platform, metadata) {
      0|      if (metadata is Timeout || metadata is Skip) {
      0|        metadata = [metadata];
      0|      } else if (metadata is! List) {
      0|        throw ArgumentError('Metadata for platform "$platform" must be a '
       |            'Timeout, Skip, or List of those; was "$metadata".');
       |      }
       |
      0|      var selector = PlatformSelector.parse(platform);
       |
       |      Timeout timeout;
       |      dynamic skip;
      0|      for (var metadatum in metadata) {
      0|        if (metadatum is Timeout) {
       |          if (timeout != null) {
      0|            throw ArgumentError('Only a single Timeout may be declared for '
       |                '"$platform".');
       |          }
       |
       |          timeout = metadatum;
      0|        } else if (metadatum is Skip) {
       |          if (skip != null) {
      0|            throw ArgumentError('Only a single Skip may be declared for '
       |                '"$platform".');
       |          }
       |
      0|          skip = metadatum.reason ?? true;
       |        } else {
      0|          throw ArgumentError('Metadata for platform "$platform" must be a '
       |              'Timeout, Skip, or List of those; was "$metadata".');
       |        }
       |      }
       |
      0|      result[selector] = Metadata.parse(timeout: timeout, skip: skip);
       |    });
       |    return result;
       |  }
       |
       |  /// Parses a user-provided [String] or [Iterable] into the value for [tags].
       |  ///
       |  /// Throws an [ArgumentError] if [tags] is not a [String] or an [Iterable].
      1|  static Set<String> _parseTags(tags) {
       |    if (tags == null) return {};
      0|    if (tags is String) return {tags};
      0|    if (tags is! Iterable) {
      0|      throw ArgumentError.value(
       |          tags, 'tags', 'must be either a String or an Iterable.');
       |    }
       |
      0|    if ((tags as Iterable).any((tag) => tag is! String)) {
      0|      throw ArgumentError.value(tags, 'tags', 'must contain only Strings.');
       |    }
       |
      0|    return Set.from(tags as Iterable);
       |  }
       |
       |  /// Creates new Metadata.
       |  ///
       |  /// [testOn] defaults to [PlatformSelector.all].
       |  ///
       |  /// If [forTag] contains metadata that applies to [tags], that metadata is
       |  /// included inline in the returned value. The values directly passed to the
       |  /// constructor take precedence over tag-specific metadata.
      1|  factory Metadata(
       |      {PlatformSelector testOn,
       |      Timeout timeout,
       |      bool skip,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      int retry,
       |      String skipReason,
       |      Iterable<String> tags,
       |      Map<PlatformSelector, Metadata> onPlatform,
       |      Map<BooleanSelector, Metadata> forTag,
       |      String languageVersionComment}) {
       |    // Returns metadata without forTag resolved at all.
      2|    Metadata _unresolved() => Metadata._(
       |        testOn: testOn,
       |        timeout: timeout,
       |        skip: skip,
       |        verboseTrace: verboseTrace,
       |        chainStackTraces: chainStackTraces,
       |        retry: retry,
       |        skipReason: skipReason,
       |        tags: tags,
       |        onPlatform: onPlatform,
       |        forTag: forTag,
       |        languageVersionComment: languageVersionComment);
       |
       |    // If there's no tag-specific metadata, or if none of it applies, just
       |    // return the metadata as-is.
      1|    if (forTag == null || tags == null) return _unresolved();
      1|    tags = Set.from(tags);
      1|    forTag = Map.from(forTag);
       |
       |    // Otherwise, resolve the tag-specific components. Doing this eagerly means
       |    // we only have to resolve suite- or group-level tags once, rather than
       |    // doing it for every test individually.
      1|    var empty = Metadata._();
      3|    var merged = forTag.keys.toList().fold(empty, (Metadata merged, selector) {
      0|      if (!selector.evaluate(tags.contains)) return merged;
      0|      return merged.merge(forTag.remove(selector));
       |    });
       |
      2|    if (merged == empty) return _unresolved();
      0|    return merged.merge(_unresolved());
       |  }
       |
       |  /// Creates new Metadata.
       |  ///
       |  /// Unlike [new Metadata], this assumes [forTag] is already resolved.
      1|  Metadata._(
       |      {PlatformSelector testOn,
       |      Timeout timeout,
       |      bool skip,
       |      this.skipReason,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      int retry,
       |      Iterable<String> tags,
       |      Map<PlatformSelector, Metadata> onPlatform,
       |      Map<BooleanSelector, Metadata> forTag,
       |      this.languageVersionComment})
       |      : testOn = testOn ?? PlatformSelector.all,
       |        timeout = timeout ?? const Timeout.factor(1),
       |        _skip = skip,
       |        _verboseTrace = verboseTrace,
       |        _chainStackTraces = chainStackTraces,
       |        _retry = retry,
      2|        tags = UnmodifiableSetView(tags == null ? {} : tags.toSet()),
       |        onPlatform =
      1|            onPlatform == null ? const {} : UnmodifiableMapView(onPlatform),
      1|        forTag = forTag == null ? const {} : UnmodifiableMapView(forTag) {
      0|    if (retry != null) RangeError.checkNotNegative(retry, 'retry');
      1|    _validateTags();
       |  }
       |
       |  /// Creates a new Metadata, but with fields parsed from caller-friendly values
       |  /// where applicable.
       |  ///
       |  /// Throws a [FormatException] if any field is invalid.
      1|  Metadata.parse(
       |      {String testOn,
       |      Timeout timeout,
       |      dynamic skip,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      int retry,
       |      Map<String, dynamic> onPlatform,
       |      tags,
       |      this.languageVersionComment})
       |      : testOn = testOn == null
       |            ? PlatformSelector.all
      0|            : PlatformSelector.parse(testOn),
       |        timeout = timeout ?? const Timeout.factor(1),
      0|        _skip = skip == null ? null : skip != false,
       |        _verboseTrace = verboseTrace,
       |        _chainStackTraces = chainStackTraces,
       |        _retry = retry,
      1|        skipReason = skip is String ? skip : null,
      1|        onPlatform = _parseOnPlatform(onPlatform),
      1|        tags = _parseTags(tags),
       |        forTag = const {} {
      0|    if (skip != null && skip is! String && skip is! bool) {
      0|      throw ArgumentError('"skip" must be a String or a bool, was "$skip".');
       |    }
       |
      0|    if (retry != null) RangeError.checkNotNegative(retry, 'retry');
       |
      1|    _validateTags();
       |  }
       |
       |  /// Deserializes the result of [Metadata.serialize] into a new [Metadata].
      0|  Metadata.deserialize(serialized)
      0|      : testOn = serialized['testOn'] == null
       |            ? PlatformSelector.all
      0|            : PlatformSelector.parse(serialized['testOn'] as String),
      0|        timeout = _deserializeTimeout(serialized['timeout']),
      0|        _skip = serialized['skip'] as bool,
      0|        skipReason = serialized['skipReason'] as String,
      0|        _verboseTrace = serialized['verboseTrace'] as bool,
      0|        _chainStackTraces = serialized['chainStackTraces'] as bool,
      0|        _retry = serialized['retry'] as int,
      0|        tags = Set.from(serialized['tags'] as Iterable),
      0|        onPlatform = {
      0|          for (var pair in serialized['onPlatform'])
      0|            PlatformSelector.parse(pair.first as String):
      0|                Metadata.deserialize(pair.last)
       |        },
      0|        forTag = (serialized['forTag'] as Map).map((key, nested) => MapEntry(
      0|            BooleanSelector.parse(key as String),
      0|            Metadata.deserialize(nested))),
      0|        languageVersionComment = serialized['languageVersionComment'] as String;
       |
       |  /// Deserializes timeout from the format returned by [_serializeTimeout].
      0|  static Timeout _deserializeTimeout(serialized) {
      0|    if (serialized == 'none') return Timeout.none;
      0|    var scaleFactor = serialized['scaleFactor'];
      0|    if (scaleFactor != null) return Timeout.factor(scaleFactor as num);
      0|    return Timeout(Duration(microseconds: serialized['duration'] as int));
       |  }
       |
       |  /// Throws an [ArgumentError] if any tags in [tags] aren't hyphenated
       |  /// identifiers.
      1|  void _validateTags() {
      1|    var invalidTags = tags
      1|        .where((tag) => !tag.contains(anchoredHyphenatedIdentifier))
      1|        .map((tag) => '"$tag"')
      1|        .toList();
       |
      1|    if (invalidTags.isEmpty) return;
       |
      0|    throw ArgumentError("Invalid ${pluralize('tag', invalidTags.length)} "
      0|        '${toSentence(invalidTags)}. Tags must be (optionally hyphenated) '
       |        'Dart identifiers.');
       |  }
       |
       |  /// Throws a [FormatException] if any [PlatformSelector]s use any variables
       |  /// that don't appear either in [validVariables] or in the set of variables
       |  /// that are known to be valid for all selectors.
      1|  void validatePlatformSelectors(Set<String> validVariables) {
      2|    testOn.validate(validVariables);
      2|    onPlatform.forEach((selector, metadata) {
      0|      selector.validate(validVariables);
      0|      metadata.validatePlatformSelectors(validVariables);
       |    });
       |  }
       |
       |  /// Return a new [Metadata] that merges [this] with [other].
       |  ///
       |  /// If the two [Metadata]s have conflicting properties, [other] wins. If
       |  /// either has a [forTag] metadata for one of the other's tags, that metadata
       |  /// is merged as well.
      2|  Metadata merge(Metadata other) => Metadata(
      3|      testOn: testOn.intersection(other.testOn),
      3|      timeout: timeout.merge(other.timeout),
      2|      skip: other._skip ?? _skip,
      2|      skipReason: other.skipReason ?? skipReason,
      2|      verboseTrace: other._verboseTrace ?? _verboseTrace,
      2|      chainStackTraces: other._chainStackTraces ?? _chainStackTraces,
      2|      retry: other._retry ?? _retry,
      3|      tags: tags.union(other.tags),
      3|      onPlatform: mergeMaps(onPlatform, other.onPlatform,
      0|          value: (metadata1, metadata2) => metadata1.merge(metadata2)),
      3|      forTag: mergeMaps(forTag, other.forTag,
      0|          value: (metadata1, metadata2) => metadata1.merge(metadata2)),
       |      languageVersionComment:
      2|          other.languageVersionComment ?? languageVersionComment);
       |
       |  /// Returns a copy of [this] with the given fields changed.
      0|  Metadata change(
       |      {PlatformSelector testOn,
       |      Timeout timeout,
       |      bool skip,
       |      bool verboseTrace,
       |      bool chainStackTraces,
       |      int retry,
       |      String skipReason,
       |      Map<PlatformSelector, Metadata> onPlatform,
       |      Set<String> tags,
       |      Map<BooleanSelector, Metadata> forTag,
       |      String languageVersionComment}) {
      0|    testOn ??= this.testOn;
      0|    timeout ??= this.timeout;
      0|    skip ??= _skip;
      0|    verboseTrace ??= _verboseTrace;
      0|    chainStackTraces ??= _chainStackTraces;
      0|    retry ??= _retry;
      0|    skipReason ??= this.skipReason;
      0|    onPlatform ??= this.onPlatform;
      0|    tags ??= this.tags;
      0|    forTag ??= this.forTag;
      0|    languageVersionComment ??= this.languageVersionComment;
      0|    return Metadata(
       |        testOn: testOn,
       |        timeout: timeout,
       |        skip: skip,
       |        verboseTrace: verboseTrace,
       |        chainStackTraces: chainStackTraces,
       |        skipReason: skipReason,
       |        onPlatform: onPlatform,
       |        tags: tags,
       |        forTag: forTag,
       |        retry: retry,
       |        languageVersionComment: languageVersionComment);
       |  }
       |
       |  /// Returns a copy of [this] with all platform-specific metadata from
       |  /// [onPlatform] resolved.
      1|  Metadata forPlatform(SuitePlatform platform) {
      2|    if (onPlatform.isEmpty) return this;
       |
       |    var metadata = this;
      0|    onPlatform.forEach((platformSelector, platformMetadata) {
      0|      if (!platformSelector.evaluate(platform)) return;
      0|      metadata = metadata.merge(platformMetadata);
       |    });
      0|    return metadata.change(onPlatform: {});
       |  }
       |
       |  /// Serializes [this] into a JSON-safe object that can be deserialized using
       |  /// [Metadata.deserialize].
      0|  Map<String, dynamic> serialize() {
       |    // Make this a list to guarantee that the order is preserved.
      0|    var serializedOnPlatform = [];
      0|    onPlatform.forEach((key, value) {
      0|      serializedOnPlatform.add([key.toString(), value.serialize()]);
       |    });
       |
      0|    return {
      0|      'testOn': testOn == PlatformSelector.all ? null : testOn.toString(),
      0|      'timeout': _serializeTimeout(timeout),
      0|      'skip': _skip,
      0|      'skipReason': skipReason,
      0|      'verboseTrace': _verboseTrace,
      0|      'chainStackTraces': _chainStackTraces,
      0|      'retry': _retry,
      0|      'tags': tags.toList(),
       |      'onPlatform': serializedOnPlatform,
      0|      'forTag': forTag.map((selector, metadata) =>
      0|          MapEntry(selector.toString(), metadata.serialize())),
      0|      'languageVersionComment': languageVersionComment,
       |    };
       |  }
       |
       |  /// Serializes timeout into a JSON-safe object.
      0|  dynamic _serializeTimeout(Timeout timeout) {
      0|    if (timeout == Timeout.none) return 'none';
      0|    return {
       |      'duration':
      0|          timeout.duration == null ? null : timeout.duration.inMicroseconds,
      0|      'scaleFactor': timeout.scaleFactor
       |    };
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/state.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// The state of a [LiveTest].
       |///
       |/// A test's state is made up of two components, its [status] and its [result].
       |/// The [status] represents where the test is in its process of running; the
       |/// [result] represents the outcome as far as its known.
       |class State {
       |  /// Where the test is in its process of running.
       |  final Status status;
       |
       |  /// The outcome of the test, as far as it's known.
       |  ///
       |  /// Note that if [status] is [Status.pending], [result] will always be
       |  /// [Result.success] since the test hasn't yet had a chance to fail.
       |  final Result result;
       |
       |  /// Whether a test in this state is expected to be done running code.
       |  ///
       |  /// If [status] is [Status.complete] and [result] doesn't indicate an error, a
       |  /// properly-written test case should not be running any more code. However,
       |  /// it may have started asynchronous processes without notifying the test
       |  /// runner.
      0|  bool get shouldBeDone => status == Status.complete && result.isPassing;
       |
      1|  const State(this.status, this.result);
       |
      1|  @override
       |  bool operator ==(other) =>
      4|      other is State && status == other.status && result == other.result;
       |
      0|  @override
      0|  int get hashCode => status.hashCode ^ (7 * result.hashCode);
       |
      0|  @override
       |  String toString() {
      0|    if (status == Status.pending) return 'pending';
      0|    if (status == Status.complete) return result.toString();
      0|    if (result == Result.success) return 'running';
      0|    return 'running with $result';
       |  }
       |}
       |
       |/// Where the test is in its process of running.
       |class Status {
       |  /// The test has not yet begun running.
       |  static const pending = Status._('pending');
       |
       |  /// The test is currently running.
       |  static const running = Status._('running');
       |
       |  /// The test has finished running.
       |  ///
       |  /// Note that even if the test is marked [complete], it may still be running
       |  /// code asynchronously. A test is considered complete either once it hits its
       |  /// first error or when all [expectAsync] callbacks have been called and any
       |  /// returned [Future] has completed, but it's possible for further processing
       |  /// to happen, which may cause further errors.
       |  static const complete = Status._('complete');
       |
       |  /// The name of the status.
       |  final String name;
       |
      0|  factory Status.parse(String name) {
       |    switch (name) {
      0|      case 'pending':
       |        return Status.pending;
      0|      case 'running':
       |        return Status.running;
      0|      case 'complete':
       |        return Status.complete;
       |      default:
      0|        throw ArgumentError('Invalid status name "$name".');
       |    }
       |  }
       |
      0|  const Status._(this.name);
       |
      0|  @override
      0|  String toString() => name;
       |}
       |
       |/// The outcome of the test, as far as it's known.
       |class Result {
       |  /// The test has not yet failed in any way.
       |  ///
       |  /// Note that this doesn't mean that the test won't fail in the future.
       |  static const success = Result._('success');
       |
       |  /// The test, or some part of it, has been skipped.
       |  ///
       |  /// This implies that the test hasn't failed *yet*. However, it this doesn't
       |  /// mean that the test won't fail in the future.
       |  static const skipped = Result._('skipped');
       |
       |  /// The test has failed.
       |  ///
       |  /// A failure is specifically caused by a [TestFailure] being thrown; any
       |  /// other exception causes an error.
       |  static const failure = Result._('failure');
       |
       |  /// The test has crashed.
       |  ///
       |  /// Any exception other than a [TestFailure] is considered to be an error.
       |  static const error = Result._('error');
       |
       |  /// The name of the result.
       |  final String name;
       |
       |  /// Whether this is a passing result.
       |  ///
       |  /// A test is considered to have passed if it's a success or if it was
       |  /// skipped.
      2|  bool get isPassing => this == success || this == skipped;
       |
       |  /// Whether this is a failing result.
       |  ///
       |  /// A test is considered to have failed if it experiences a failure or an
       |  /// error.
      0|  bool get isFailing => !isPassing;
       |
      0|  factory Result.parse(String name) {
       |    switch (name) {
      0|      case 'success':
       |        return Result.success;
      0|      case 'skipped':
       |        return Result.skipped;
      0|      case 'failure':
       |        return Result.failure;
      0|      case 'error':
       |        return Result.error;
       |      default:
      0|        throw ArgumentError('Invalid result name "$name".');
       |    }
       |  }
       |
      0|  const Result._(this.name);
       |
      0|  @override
      0|  String toString() => name;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/suite.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'group.dart';
       |import 'metadata.dart';
       |import 'suite_platform.dart';
       |import 'test.dart';
       |
       |/// A test suite.
       |///
       |/// A test suite is a set of tests that are intended to be run together and that
       |/// share default configuration.
       |class Suite {
       |  /// The platform on which the suite is running.
       |  final SuitePlatform platform;
       |
       |  /// The path to the Dart test suite, or `null` if that path is unknown.
       |  final String path;
       |
       |  /// The metadata associated with this test suite.
       |  ///
       |  /// This is a shortcut for [group.metadata].
      0|  Metadata get metadata => group.metadata;
       |
       |  /// The top-level group for this test suite.
       |  final Group group;
       |
       |  /// Creates a new suite containing [entires].
       |  ///
       |  /// If [platform] and/or [os] are passed, [group] is filtered to match that
       |  /// platform information.
       |  ///
       |  /// If [os] is passed without [platform], throws an [ArgumentError].
      1|  Suite(Group group, this.platform, {this.path})
      1|      : group = _filterGroup(group, platform);
       |
       |  /// Returns [entries] filtered according to [platform] and [os].
       |  ///
       |  /// Gracefully handles [platform] being null.
      1|  static Group _filterGroup(Group group, SuitePlatform platform) {
      1|    var filtered = group.forPlatform(platform);
       |    if (filtered != null) return filtered;
      0|    return Group.root([], metadata: group.metadata);
       |  }
       |
       |  /// Returns a new suite with all tests matching [test] removed.
       |  ///
       |  /// Unlike [GroupEntry.filter], this never returns `null`. If all entries are
       |  /// filtered out, it returns an empty suite.
      0|  Suite filter(bool Function(Test) callback) {
      0|    var filtered = group.filter(callback);
      0|    filtered ??= Group.root([], metadata: metadata);
      0|    return Suite(filtered, platform, path: path);
       |  }
       |
      0|  bool get isLoadSuite => false;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/suite_platform.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'operating_system.dart';
       |import 'runtime.dart';
       |
       |/// The platform on which a test suite is loaded.
       |class SuitePlatform {
       |  /// The runtime that hosts the suite.
       |  final Runtime runtime;
       |
       |  /// The operating system on which the suite is running.
       |  ///
       |  /// This will always be [OperatingSystem.none] if `runtime.isBrowser` is
       |  /// true.
       |  final OperatingSystem os;
       |
       |  /// Whether we're running on Google-internal infrastructure.
       |  final bool inGoogle;
       |
       |  /// Creates a new platform with the given [runtime] and [os], which defaults
       |  /// to [OperatingSystem.none].
       |  ///
       |  /// Throws an [ArgumentError] if [runtime] is a browser and [os] is not
       |  /// `null` or [OperatingSystem.none].
      1|  SuitePlatform(this.runtime, {OperatingSystem os, this.inGoogle = false})
       |      : os = os ?? OperatingSystem.none {
      2|    if (runtime.isBrowser && this.os != OperatingSystem.none) {
      0|      throw ArgumentError('No OS should be passed for runtime "$runtime".');
       |    }
       |  }
       |
       |  /// Converts a JSON-safe representation generated by [serialize] back into a
       |  /// [SuitePlatform].
      0|  factory SuitePlatform.deserialize(Object serialized) {
       |    var map = serialized as Map;
      0|    return SuitePlatform(Runtime.deserialize(map['runtime']),
      0|        os: OperatingSystem.find(map['os'] as String),
      0|        inGoogle: map['inGoogle'] as bool);
       |  }
       |
       |  /// Converts [this] into a JSON-safe object that can be converted back to a
       |  /// [SuitePlatform] using [SuitePlatform.deserialize].
      0|  Object serialize() => {
      0|        'runtime': runtime.serialize(),
      0|        'os': os.identifier,
      0|        'inGoogle': inGoogle
       |      };
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/test.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import 'group.dart';
       |import 'group_entry.dart';
       |import 'live_test.dart';
       |import 'metadata.dart';
       |import 'suite.dart';
       |import 'suite_platform.dart';
       |
       |/// A single test.
       |///
       |/// A test is immutable and stateless, which means that it can't be run
       |/// directly. To run one, load a live version using [Test.load] and run it using
       |/// [LiveTest.run].
       |abstract class Test implements GroupEntry {
       |  @override
       |  String get name;
       |
       |  @override
       |  Metadata get metadata;
       |
       |  @override
       |  Trace get trace;
       |
       |  /// Loads a live version of this test, which can be used to run it a single
       |  /// time.
       |  ///
       |  /// [suite] is the suite within which this test is being run. If [groups] is
       |  /// passed, it's the list of groups containing this test; otherwise, it
       |  /// defaults to just containing `suite.group`.
       |  LiveTest load(Suite suite, {Iterable<Group> groups});
       |
       |  @override
       |  Test forPlatform(SuitePlatform platform);
       |
      0|  @override
      0|  Test filter(bool Function(Test) callback) => callback(this) ? this : null;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/operating_system.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An enum of all operating systems supported by Dart.
       |///
       |/// This is used for selecting which operating systems a test can run on. Even
       |/// for browser tests, this indicates the operating system of the machine
       |/// running the test runner.
       |class OperatingSystem {
       |  /// Microsoft Windows.
       |  static const windows = OperatingSystem._('Windows', 'windows');
       |
       |  /// Mac OS X.
       |  static const macOS = OperatingSystem._('OS X', 'mac-os');
       |
       |  /// GNU/Linux.
       |  static const linux = OperatingSystem._('Linux', 'linux');
       |
       |  /// Android.
       |  ///
       |  /// Since this is the operating system the test runner is running on, this
       |  /// won't be true when testing remotely on an Android browser.
       |  static const android = OperatingSystem._('Android', 'android');
       |
       |  /// iOS.
       |  ///
       |  /// Since this is the operating system the test runner is running on, this
       |  /// won't be true when testing remotely on an iOS browser.
       |  static const iOS = OperatingSystem._('iOS', 'ios');
       |
       |  /// No operating system.
       |  ///
       |  /// This is used when running in the browser, or if an unrecognized operating
       |  /// system is used. It can't be referenced by name in platform selectors.
       |  static const none = OperatingSystem._('none', 'none');
       |
       |  /// A list of all instances of [OperatingSystem] other than [none].
       |  static const all = [windows, macOS, linux, android, iOS];
       |
       |  /// Finds an operating system by its name.
       |  ///
       |  /// If no operating system is found, returns [none].
      0|  static OperatingSystem find(String identifier) =>
      0|      all.firstWhere((platform) => platform.identifier == identifier,
      0|          orElse: () => null);
       |
       |  /// Finds an operating system by the return value from `dart:io`'s
       |  /// `Platform.operatingSystem`.
       |  ///
       |  /// If no operating system is found, returns [none].
      0|  static OperatingSystem findByIoName(String name) {
       |    switch (name) {
      0|      case 'windows':
       |        return windows;
      0|      case 'macos':
       |        return macOS;
      0|      case 'linux':
       |        return linux;
      0|      case 'android':
       |        return android;
      0|      case 'ios':
       |        return iOS;
       |      default:
       |        return none;
       |    }
       |  }
       |
       |  /// The human-friendly of the operating system.
       |  final String name;
       |
       |  /// The identifier used to look up the operating system.
       |  final String identifier;
       |
       |  /// Whether this is a POSIX-ish operating system.
      0|  bool get isPosix => this != windows && this != none;
       |
      0|  const OperatingSystem._(this.name, this.identifier);
       |
      0|  @override
      0|  String toString() => name;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/runtime.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An enum of all Dart runtimes supported by the test runner.
       |class Runtime {
       |  // When adding new runtimes, be sure to update the baseline and derived
       |  // variable tests in test/backend/platform_selector/evaluate_test.
       |
       |  /// The command-line Dart VM.
       |  static const Runtime vm = Runtime('VM', 'vm', isDartVM: true);
       |
       |  /// Google Chrome.
       |  static const Runtime chrome =
       |      Runtime('Chrome', 'chrome', isBrowser: true, isJS: true, isBlink: true);
       |
       |  /// PhantomJS.
       |  static const Runtime phantomJS = Runtime('PhantomJS', 'phantomjs',
       |      isBrowser: true, isJS: true, isBlink: true, isHeadless: true);
       |
       |  /// Mozilla Firefox.
       |  static const Runtime firefox =
       |      Runtime('Firefox', 'firefox', isBrowser: true, isJS: true);
       |
       |  /// Apple Safari.
       |  static const Runtime safari =
       |      Runtime('Safari', 'safari', isBrowser: true, isJS: true);
       |
       |  /// Microsoft Internet Explorer.
       |  static const Runtime internetExplorer =
       |      Runtime('Internet Explorer', 'ie', isBrowser: true, isJS: true);
       |
       |  /// The command-line Node.js VM.
       |  static const Runtime nodeJS = Runtime('Node.js', 'node', isJS: true);
       |
       |  /// The platforms that are supported by the test runner by default.
       |  static const List<Runtime> builtIn = [
       |    Runtime.vm,
       |    Runtime.chrome,
       |    Runtime.phantomJS,
       |    Runtime.firefox,
       |    Runtime.safari,
       |    Runtime.internetExplorer,
       |    Runtime.nodeJS
       |  ];
       |
       |  /// The human-friendly name of the platform.
       |  final String name;
       |
       |  /// The identifier used to look up the platform.
       |  final String identifier;
       |
       |  /// The parent platform that this is based on, or `null` if there is no
       |  /// parent.
       |  final Runtime parent;
       |
       |  /// Returns whether this is a child of another platform.
      0|  bool get isChild => parent != null;
       |
       |  /// Whether this platform runs the Dart VM in any capacity.
       |  final bool isDartVM;
       |
       |  /// Whether this platform is a browser.
       |  final bool isBrowser;
       |
       |  /// Whether this platform runs Dart compiled to JavaScript.
       |  final bool isJS;
       |
       |  /// Whether this platform uses the Blink rendering engine.
       |  final bool isBlink;
       |
       |  /// Whether this platform has no visible window.
       |  final bool isHeadless;
       |
       |  /// Returns the platform this is based on, or [this] if it's not based on
       |  /// anything.
       |  ///
       |  /// That is, returns [parent] if it's non-`null` or [this] if it's `null`.
      0|  Runtime get root => parent ?? this;
       |
      0|  const Runtime(this.name, this.identifier,
       |      {this.isDartVM = false,
       |      this.isBrowser = false,
       |      this.isJS = false,
       |      this.isBlink = false,
       |      this.isHeadless = false})
       |      : parent = null;
       |
      0|  Runtime._child(this.name, this.identifier, this.parent)
      0|      : isDartVM = parent.isDartVM,
      0|        isBrowser = parent.isBrowser,
      0|        isJS = parent.isJS,
      0|        isBlink = parent.isBlink,
      0|        isHeadless = parent.isHeadless;
       |
       |  /// Converts a JSON-safe representation generated by [serialize] back into a
       |  /// [Runtime].
      0|  factory Runtime.deserialize(Object serialized) {
      0|    if (serialized is String) {
       |      return builtIn
      0|          .firstWhere((platform) => platform.identifier == serialized);
       |    }
       |
       |    var map = serialized as Map;
      0|    var parent = map['parent'];
       |    if (parent != null) {
       |      // Note that the returned platform's [parent] won't necessarily be `==` to
       |      // a separately-deserialized parent platform. This should be fine, though,
       |      // since we only deserialize platforms in the remote execution context
       |      // where they're only used to evaluate platform selectors.
      0|      return Runtime._child(map['name'] as String, map['identifier'] as String,
      0|          Runtime.deserialize(parent));
       |    }
       |
      0|    return Runtime(map['name'] as String, map['identifier'] as String,
      0|        isDartVM: map['isDartVM'] as bool,
      0|        isBrowser: map['isBrowser'] as bool,
      0|        isJS: map['isJS'] as bool,
      0|        isBlink: map['isBlink'] as bool,
      0|        isHeadless: map['isHeadless'] as bool);
       |  }
       |
       |  /// Converts [this] into a JSON-safe object that can be converted back to a
       |  /// [Runtime] using [Runtime.deserialize].
      0|  Object serialize() {
      0|    if (builtIn.contains(this)) return identifier;
       |
      0|    if (parent != null) {
      0|      return {
      0|        'name': name,
      0|        'identifier': identifier,
      0|        'parent': parent.serialize()
       |      };
       |    }
       |
      0|    return {
      0|      'name': name,
      0|      'identifier': identifier,
      0|      'isDartVM': isDartVM,
      0|      'isBrowser': isBrowser,
      0|      'isJS': isJS,
      0|      'isBlink': isBlink,
      0|      'isHeadless': isHeadless
       |    };
       |  }
       |
       |  /// Returns a child of [this] that counts as both this platform's identifier
       |  /// and the new [identifier].
       |  ///
       |  /// This may not be called on a platform that's already a child.
      0|  Runtime extend(String name, String identifier) {
      0|    if (parent == null) return Runtime._child(name, identifier, this);
      0|    throw StateError('A child platform may not be extended.');
       |  }
       |
      0|  @override
      0|  String toString() => name;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/backend/platform_selector.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:boolean_selector/boolean_selector.dart';
       |import 'package:source_span/source_span.dart';
       |
       |import 'operating_system.dart';
       |import 'runtime.dart';
       |import 'suite_platform.dart';
       |
       |/// The set of variable names that are valid for all platform selectors.
      0|final _universalValidVariables = {
       |  'posix',
       |  'dart-vm',
       |  'browser',
       |  'js',
       |  'blink',
       |  'google',
       |  for (var runtime in Runtime.builtIn) runtime.identifier,
       |  for (var os in OperatingSystem.all) os.identifier,
       |};
       |
       |/// An expression for selecting certain platforms, including operating systems
       |/// and browsers.
       |///
       |/// This uses the [boolean selector][] syntax.
       |///
       |/// [boolean selector]: https://pub.dev/packages/boolean_selector
       |class PlatformSelector {
       |  /// A selector that declares that a test can be run on all platforms.
       |  static const all = PlatformSelector._(BooleanSelector.all);
       |
       |  /// The boolean selector used to implement this selector.
       |  final BooleanSelector _inner;
       |
       |  /// The source span from which this selector was parsed.
       |  final SourceSpan _span;
       |
       |  /// Parses [selector].
       |  ///
       |  /// If [span] is passed, it indicates the location of the text for [selector]
       |  /// in a larger document. It's used for error reporting.
      0|  PlatformSelector.parse(String selector, [SourceSpan span])
       |      : _inner =
      0|            _wrapFormatException(() => BooleanSelector.parse(selector), span),
       |        _span = span;
       |
      0|  const PlatformSelector._(this._inner) : _span = null;
       |
       |  /// Runs [body] and wraps any [FormatException] it throws in a
       |  /// [SourceSpanFormatException] using [span].
       |  ///
       |  /// If [span] is `null`, runs [body] as-is.
      0|  static T _wrapFormatException<T>(T Function() body, SourceSpan span) {
      0|    if (span == null) return body();
       |
       |    try {
      0|      return body();
      0|    } on FormatException catch (error) {
      0|      throw SourceSpanFormatException(error.message, span);
       |    }
       |  }
       |
       |  /// Throws a [FormatException] if this selector uses any variables that don't
       |  /// appear either in [validVariables] or in the set of variables that are
       |  /// known to be valid for all selectors.
      1|  void validate(Set<String> validVariables) {
       |    if (identical(this, all)) return;
       |
      0|    _wrapFormatException(
      0|        () => _inner.validate((name) =>
      0|            _universalValidVariables.contains(name) ||
      0|            validVariables.contains(name)),
      0|        _span);
       |  }
       |
       |  /// Returns whether the selector matches the given [platform].
       |  ///
       |  /// [os] defaults to [OperatingSystem.none].
      1|  bool evaluate(SuitePlatform platform) {
      2|    return _inner.evaluate((String variable) {
      0|      if (variable == platform.runtime.identifier) return true;
      0|      if (variable == platform.runtime.parent?.identifier) return true;
      0|      if (variable == platform.os.identifier) return true;
       |      switch (variable) {
      0|        case 'dart-vm':
      0|          return platform.runtime.isDartVM;
      0|        case 'browser':
      0|          return platform.runtime.isBrowser;
      0|        case 'js':
      0|          return platform.runtime.isJS;
      0|        case 'blink':
      0|          return platform.runtime.isBlink;
      0|        case 'posix':
      0|          return platform.os.isPosix;
      0|        case 'google':
      0|          return platform.inGoogle;
       |        default:
       |          return false;
       |      }
       |    });
       |  }
       |
       |  /// Returns a new [PlatformSelector] that matches only platforms matched by
       |  /// both [this] and [other].
      1|  PlatformSelector intersection(PlatformSelector other) {
      1|    if (other == PlatformSelector.all) return this;
      0|    return PlatformSelector._(_inner.intersection(other._inner));
       |  }
       |
      0|  @override
      0|  String toString() => _inner.toString();
       |
      1|  @override
       |  bool operator ==(other) =>
      4|      other is PlatformSelector && _inner == other._inner;
       |
      0|  @override
      0|  int get hashCode => _inner.hashCode;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/all.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |
       |/// A selector that matches all inputs.
       |class All implements BooleanSelector {
       |  // TODO(nweiz): Stop explicitly providing a type argument when sdk#32412 is
       |  // fixed.
       |  @override
       |  final variables = const <String>[];
       |
      0|  const All();
       |
      1|  @override
       |  bool evaluate(bool Function(String variable) semantics) => true;
       |
      0|  @override
       |  BooleanSelector intersection(BooleanSelector other) => other;
       |
      0|  @override
       |  BooleanSelector union(BooleanSelector other) => this;
       |
      0|  @override
       |  void validate(bool Function(String variable) isDefined) {}
       |
      0|  @override
       |  String toString() => '<all>';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/impl.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |import 'ast.dart';
       |import 'evaluator.dart';
       |import 'intersection_selector.dart';
       |import 'parser.dart';
       |import 'union_selector.dart';
       |import 'validator.dart';
       |
       |/// The concrete implementation of a [BooleanSelector] parsed from a string.
       |///
       |/// This is separate from [BooleanSelector] so that [intersect] and [union] can
       |/// check to see whether they're passed a [BooleanSelectorImpl] or a different
       |/// class that implements [BooleanSelector].
       |class BooleanSelectorImpl implements BooleanSelector {
       |  /// The parsed AST.
       |  final Node _selector;
       |
       |  /// Parses [selector].
       |  ///
       |  /// This will throw a [SourceSpanFormatException] if the selector is
       |  /// malformed or if it uses an undefined variable.
      0|  BooleanSelectorImpl.parse(String selector)
      0|      : _selector = Parser(selector).parse();
       |
      0|  BooleanSelectorImpl._(this._selector);
       |
      0|  @override
      0|  Iterable<String> get variables => _selector.variables;
       |
      0|  @override
       |  bool evaluate(bool Function(String variable) semantics) =>
      0|      _selector.accept(Evaluator(semantics));
       |
      0|  @override
       |  BooleanSelector intersection(BooleanSelector other) {
      0|    if (other == BooleanSelector.all) return this;
      0|    if (other == BooleanSelector.none) return other;
      0|    return other is BooleanSelectorImpl
      0|        ? BooleanSelectorImpl._(AndNode(_selector, other._selector))
      0|        : IntersectionSelector(this, other);
       |  }
       |
      0|  @override
       |  BooleanSelector union(BooleanSelector other) {
      0|    if (other == BooleanSelector.all) return other;
      0|    if (other == BooleanSelector.none) return this;
      0|    return other is BooleanSelectorImpl
      0|        ? BooleanSelectorImpl._(OrNode(_selector, other._selector))
      0|        : UnionSelector(this, other);
       |  }
       |
      0|  @override
       |  void validate(bool Function(String variable) isDefined) {
      0|    _selector.accept(Validator(isDefined));
       |  }
       |
      0|  @override
      0|  String toString() => _selector.toString();
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is BooleanSelectorImpl && _selector == other._selector;
       |
      0|  @override
      0|  int get hashCode => _selector.hashCode;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/none.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |
       |/// A selector that matches no inputs.
       |class None implements BooleanSelector {
       |  // TODO(nweiz): Stop explicitly providing a type argument when sdk#32412 is
       |  // fixed.
       |  @override
       |  final variables = const <String>[];
       |
      0|  const None();
       |
      0|  @override
       |  bool evaluate(bool Function(String variable) semantics) => false;
       |
      0|  @override
       |  BooleanSelector intersection(BooleanSelector other) => this;
       |
      0|  @override
       |  BooleanSelector union(BooleanSelector other) => other;
       |
      0|  @override
       |  void validate(bool Function(String) isDefined) {}
       |
      0|  @override
       |  String toString() => '<none>';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/ast.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'visitor.dart';
       |
       |/// The superclass of nodes in the boolean selector abstract syntax tree.
       |abstract class Node {
       |  /// The span indicating where this node came from.
       |  ///
       |  /// This is a [FileSpan] because the nodes are parsed from a single continuous
       |  /// string, but the string itself isn't actually a file. It might come from a
       |  /// statically-parsed annotation or from a parameter.
       |  ///
       |  /// This may be `null` for nodes without source information.
       |  FileSpan get span;
       |
       |  /// All the variables in this node, in the order they appear.
       |  Iterable<String> get variables;
       |
       |  /// Calls the appropriate [Visitor] method on [this] and returns the result.
       |  T accept<T>(Visitor<T> visitor);
       |}
       |
       |/// A single variable.
       |class VariableNode implements Node {
       |  @override
       |  final FileSpan span;
       |
       |  /// The variable name.
       |  final String name;
       |
      0|  @override
      0|  Iterable<String> get variables => [name];
       |
      0|  VariableNode(this.name, [this.span]);
       |
      0|  @override
      0|  T accept<T>(Visitor<T> visitor) => visitor.visitVariable(this);
       |
      0|  @override
      0|  String toString() => name;
       |
      0|  @override
      0|  bool operator ==(other) => other is VariableNode && name == other.name;
       |
      0|  @override
      0|  int get hashCode => name.hashCode;
       |}
       |
       |/// A negation expression.
       |class NotNode implements Node {
       |  @override
       |  final FileSpan span;
       |
       |  /// The expression being negated.
       |  final Node child;
       |
      0|  @override
      0|  Iterable<String> get variables => child.variables;
       |
      0|  NotNode(this.child, [this.span]);
       |
      0|  @override
      0|  T accept<T>(Visitor<T> visitor) => visitor.visitNot(this);
       |
      0|  @override
       |  String toString() =>
      0|      child is VariableNode || child is NotNode ? '!$child' : '!($child)';
       |
      0|  @override
      0|  bool operator ==(other) => other is NotNode && child == other.child;
       |
      0|  @override
      0|  int get hashCode => ~child.hashCode;
       |}
       |
       |/// An or expression.
       |class OrNode implements Node {
      0|  @override
      0|  FileSpan get span => _expandSafe(left.span, right.span);
       |
       |  /// The left-hand branch of the expression.
       |  final Node left;
       |
       |  /// The right-hand branch of the expression.
       |  final Node right;
       |
       |  @override
       |  Iterable<String> get variables sync* {
       |    yield* left.variables;
       |    yield* right.variables;
       |  }
       |
      0|  OrNode(this.left, this.right);
       |
      0|  @override
      0|  T accept<T>(Visitor<T> visitor) => visitor.visitOr(this);
       |
      0|  @override
       |  String toString() {
      0|    var string1 = left is AndNode || left is ConditionalNode ? '($left)' : left;
       |    var string2 =
      0|        right is AndNode || right is ConditionalNode ? '($right)' : right;
       |
      0|    return '$string1 || $string2';
       |  }
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is OrNode && left == other.left && right == other.right;
       |
      0|  @override
      0|  int get hashCode => left.hashCode ^ right.hashCode;
       |}
       |
       |/// An and expression.
       |class AndNode implements Node {
      0|  @override
      0|  FileSpan get span => _expandSafe(left.span, right.span);
       |
       |  /// The left-hand branch of the expression.
       |  final Node left;
       |
       |  /// The right-hand branch of the expression.
       |  final Node right;
       |
       |  @override
       |  Iterable<String> get variables sync* {
       |    yield* left.variables;
       |    yield* right.variables;
       |  }
       |
      0|  AndNode(this.left, this.right);
       |
      0|  @override
      0|  T accept<T>(Visitor<T> visitor) => visitor.visitAnd(this);
       |
      0|  @override
       |  String toString() {
      0|    var string1 = left is OrNode || left is ConditionalNode ? '($left)' : left;
       |    var string2 =
      0|        right is OrNode || right is ConditionalNode ? '($right)' : right;
       |
      0|    return '$string1 && $string2';
       |  }
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is AndNode && left == other.left && right == other.right;
       |
      0|  @override
      0|  int get hashCode => left.hashCode ^ right.hashCode;
       |}
       |
       |/// A ternary conditional expression.
       |class ConditionalNode implements Node {
      0|  @override
      0|  FileSpan get span => _expandSafe(condition.span, whenFalse.span);
       |
       |  /// The condition expression to check.
       |  final Node condition;
       |
       |  /// The branch to run if the condition is true.
       |  final Node whenTrue;
       |
       |  /// The branch to run if the condition is false.
       |  final Node whenFalse;
       |
       |  @override
       |  Iterable<String> get variables sync* {
       |    yield* condition.variables;
       |    yield* whenTrue.variables;
       |    yield* whenFalse.variables;
       |  }
       |
      0|  ConditionalNode(this.condition, this.whenTrue, this.whenFalse);
       |
      0|  @override
      0|  T accept<T>(Visitor<T> visitor) => visitor.visitConditional(this);
       |
      0|  @override
       |  String toString() {
       |    var conditionString =
      0|        condition is ConditionalNode ? '($condition)' : condition;
      0|    var trueString = whenTrue is ConditionalNode ? '($whenTrue)' : whenTrue;
      0|    return '$conditionString ? $trueString : $whenFalse';
       |  }
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is ConditionalNode &&
      0|      condition == other.condition &&
      0|      whenTrue == other.whenTrue &&
      0|      whenFalse == other.whenFalse;
       |
      0|  @override
       |  int get hashCode =>
      0|      condition.hashCode ^ whenTrue.hashCode ^ whenFalse.hashCode;
       |}
       |
       |/// Like [FileSpan.expand], except if [start] and [end] are `null` or from
       |/// different files it returns `null` rather than throwing an error.
      0|FileSpan _expandSafe(FileSpan start, FileSpan end) {
       |  if (start == null || end == null) return null;
      0|  if (start.file != end.file) return null;
      0|  return start.expand(end);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/evaluator.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'ast.dart';
       |import 'visitor.dart';
       |
       |/// A visitor for evaluating boolean selectors against a specific set of
       |/// semantics.
       |class Evaluator implements Visitor<bool> {
       |  final bool Function(String variable) _semantics;
       |
      0|  Evaluator(this._semantics);
       |
      0|  @override
      0|  bool visitVariable(VariableNode node) => _semantics(node.name);
       |
      0|  @override
      0|  bool visitNot(NotNode node) => !node.child.accept(this);
       |
      0|  @override
       |  bool visitOr(OrNode node) =>
      0|      node.left.accept(this) || node.right.accept(this);
       |
      0|  @override
       |  bool visitAnd(AndNode node) =>
      0|      node.left.accept(this) && node.right.accept(this);
       |
      0|  @override
      0|  bool visitConditional(ConditionalNode node) => node.condition.accept(this)
      0|      ? node.whenTrue.accept(this)
      0|      : node.whenFalse.accept(this);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/intersection_selector.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |import 'union_selector.dart';
       |
       |/// A selector that matches inputs that both of its sub-selectors match.
       |class IntersectionSelector implements BooleanSelector {
       |  final BooleanSelector _selector1;
       |  final BooleanSelector _selector2;
       |
       |  @override
       |  Iterable<String> get variables sync* {
       |    yield* _selector1.variables;
       |    yield* _selector2.variables;
       |  }
       |
      0|  IntersectionSelector(this._selector1, this._selector2);
       |
      0|  @override
       |  bool evaluate(semantics) =>
      0|      _selector1.evaluate(semantics) && _selector2.evaluate(semantics);
       |
      0|  @override
       |  BooleanSelector intersection(BooleanSelector other) =>
      0|      IntersectionSelector(this, other);
       |
      0|  @override
      0|  BooleanSelector union(BooleanSelector other) => UnionSelector(this, other);
       |
      0|  @override
       |  void validate(bool Function(String variable) isDefined) {
      0|    _selector1.validate(isDefined);
      0|    _selector2.validate(isDefined);
       |  }
       |
      0|  @override
      0|  String toString() => '($_selector1) && ($_selector2)';
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is IntersectionSelector &&
      0|      _selector1 == other._selector1 &&
      0|      _selector2 == other._selector2;
       |
      0|  @override
      0|  int get hashCode => _selector1.hashCode ^ _selector2.hashCode;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/parser.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'ast.dart';
       |import 'scanner.dart';
       |import 'token.dart';
       |
       |/// A class for parsing a boolean selector.
       |///
       |/// Boolean selectors use a stripped-down version of the Dart expression syntax
       |/// that only contains variables, parentheses, and boolean operators. Variables
       |/// may also contain dashes, contrary to Dart's syntax; this allows consistency
       |/// with command-line arguments.
       |class Parser {
       |  /// The scanner that tokenizes the selector.
       |  final Scanner _scanner;
       |
      0|  Parser(String selector) : _scanner = Scanner(selector);
       |
       |  /// Parses the selector.
       |  ///
       |  /// This must only be called once per parser.
      0|  Node parse() {
      0|    var selector = _conditional();
       |
      0|    if (_scanner.peek().type != TokenType.endOfFile) {
      0|      throw SourceSpanFormatException(
      0|          'Expected end of input.', _scanner.peek().span);
       |    }
       |
       |    return selector;
       |  }
       |
       |  /// Parses a conditional:
       |  ///
       |  ///     conditionalExpression:
       |  ///       logicalOrExpression ("?" conditionalExpression ":"
       |  ///           conditionalExpression)?
      0|  Node _conditional() {
      0|    var condition = _or();
      0|    if (!_scanner.scan(TokenType.questionMark)) return condition;
       |
      0|    var whenTrue = _conditional();
      0|    if (!_scanner.scan(TokenType.colon)) {
      0|      throw SourceSpanFormatException('Expected ":".', _scanner.peek().span);
       |    }
       |
      0|    var whenFalse = _conditional();
      0|    return ConditionalNode(condition, whenTrue, whenFalse);
       |  }
       |
       |  /// Parses a logical or:
       |  ///
       |  ///     logicalOrExpression:
       |  ///       logicalAndExpression ("||" logicalOrExpression)?
      0|  Node _or() {
      0|    var left = _and();
      0|    if (!_scanner.scan(TokenType.or)) return left;
      0|    return OrNode(left, _or());
       |  }
       |
       |  /// Parses a logical and:
       |  ///
       |  ///     logicalAndExpression:
       |  ///       simpleExpression ("&&" logicalAndExpression)?
      0|  Node _and() {
      0|    var left = _simpleExpression();
      0|    if (!_scanner.scan(TokenType.and)) return left;
      0|    return AndNode(left, _and());
       |  }
       |
       |  /// Parses a simple expression:
       |  ///
       |  ///     simpleExpression:
       |  ///       "!" simpleExpression |
       |  ///           "(" conditionalExpression ")" |
       |  ///           IDENTIFIER
      0|  Node _simpleExpression() {
      0|    var token = _scanner.next();
      0|    switch (token.type) {
      0|      case TokenType.not:
      0|        var child = _simpleExpression();
      0|        return NotNode(child, token.span.expand(child.span));
       |
      0|      case TokenType.leftParen:
      0|        var child = _conditional();
      0|        if (!_scanner.scan(TokenType.rightParen)) {
      0|          throw SourceSpanFormatException(
      0|              'Expected ")".', _scanner.peek().span);
       |        }
       |        return child;
       |
      0|      case TokenType.identifier:
      0|        return VariableNode((token as IdentifierToken).name, token.span);
       |
       |      default:
      0|        throw SourceSpanFormatException('Expected expression.', token.span);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/union_selector.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import '../boolean_selector.dart';
       |import 'intersection_selector.dart';
       |
       |/// A selector that matches inputs that either of its sub-selectors match.
       |class UnionSelector implements BooleanSelector {
       |  final BooleanSelector _selector1;
       |  final BooleanSelector _selector2;
       |
      0|  UnionSelector(this._selector1, this._selector2);
       |
      0|  @override
       |  List<String> get variables =>
      0|      _selector1.variables.toList()..addAll(_selector2.variables);
       |
      0|  @override
       |  bool evaluate(bool Function(String variable) semantics) =>
      0|      _selector1.evaluate(semantics) || _selector2.evaluate(semantics);
       |
      0|  @override
       |  BooleanSelector intersection(BooleanSelector other) =>
      0|      IntersectionSelector(this, other);
       |
      0|  @override
      0|  BooleanSelector union(BooleanSelector other) => UnionSelector(this, other);
       |
      0|  @override
       |  void validate(bool Function(String variable) isDefined) {
      0|    _selector1.validate(isDefined);
      0|    _selector2.validate(isDefined);
       |  }
       |
      0|  @override
      0|  String toString() => '($_selector1) && ($_selector2)';
       |
      0|  @override
       |  bool operator ==(other) =>
      0|      other is UnionSelector &&
      0|      _selector1 == other._selector1 &&
      0|      _selector2 == other._selector2;
       |
      0|  @override
      0|  int get hashCode => _selector1.hashCode ^ _selector2.hashCode;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/validator.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |import 'ast.dart';
       |import 'visitor.dart';
       |
       |typedef _IsDefined = bool Function(String variable);
       |
       |/// An AST visitor that ensures that all variables are valid.
       |class Validator extends RecursiveVisitor {
       |  final _IsDefined _isDefined;
       |
      0|  Validator(this._isDefined);
       |
      0|  @override
       |  void visitVariable(VariableNode node) {
      0|    if (_isDefined(node.name)) return;
      0|    throw SourceSpanFormatException('Undefined variable.', node.span);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/visitor.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'ast.dart';
       |
       |/// The interface for visitors of the boolean selector AST.
       |abstract class Visitor<T> {
       |  T visitVariable(VariableNode node);
       |  T visitNot(NotNode node);
       |  T visitOr(OrNode node);
       |  T visitAnd(AndNode node);
       |  T visitConditional(ConditionalNode node);
       |}
       |
       |/// An abstract superclass for side-effect-based visitors.
       |///
       |/// The default implementations of this visitor's methods just traverse the AST
       |/// and do nothing with it.
       |abstract class RecursiveVisitor implements Visitor<void> {
      0|  const RecursiveVisitor();
       |
      0|  @override
       |  void visitVariable(VariableNode node) {}
       |
      0|  @override
       |  void visitNot(NotNode node) {
      0|    node.child.accept(this);
       |  }
       |
      0|  @override
       |  void visitOr(OrNode node) {
      0|    node.left.accept(this);
      0|    node.right.accept(this);
       |  }
       |
      0|  @override
       |  void visitAnd(AndNode node) {
      0|    node.left.accept(this);
      0|    node.right.accept(this);
       |  }
       |
      0|  @override
       |  void visitConditional(ConditionalNode node) {
      0|    node.condition.accept(this);
      0|    node.whenTrue.accept(this);
      0|    node.whenFalse.accept(this);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/scanner.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:string_scanner/string_scanner.dart';
       |
       |import 'token.dart';
       |
       |/// A regular expression matching both whitespace and single-line comments.
       |///
       |/// This will only match if consumes at least one character.
      0|final _whitespaceAndSingleLineComments = RegExp(r'([ \t\n]+|//[^\n]*(\n|$))+');
       |
       |/// A regular expression matching the body of a multi-line comment, after `/*`
       |/// but before `*/` or a nested `/*`.
       |///
       |/// This will only match if it consumes at least one character.
      0|final _multiLineCommentBody = RegExp(r'([^/*]|/[^*]|\*[^/])+');
       |
       |/// A regular expression matching a hyphenated identifier.
       |///
       |/// This is like a standard Dart identifier, except that it can also contain
       |/// hyphens.
      0|final _hyphenatedIdentifier = RegExp(r'[a-zA-Z_-][a-zA-Z0-9_-]*');
       |
       |/// A scanner that converts a boolean selector string into a stream of tokens.
       |class Scanner {
       |  /// The underlying string scanner.
       |  final SpanScanner _scanner;
       |
       |  /// The next token to emit.
       |  Token _next;
       |
       |  /// Whether the scanner has emitted a [TokenType.endOfFile] token.
       |  bool _endOfFileEmitted = false;
       |
      0|  Scanner(String selector) : _scanner = SpanScanner(selector);
       |
       |  /// Returns the next token that will be returned by [next].
       |  ///
       |  /// Throws a [StateError] if a [TokenType.endOfFile] token has already been
       |  /// consumed.
      0|  Token peek() => _next ??= _readNext();
       |
       |  /// Consumes and returns the next token in the stream.
       |  ///
       |  /// Throws a [StateError] if a [TokenType.endOfFile] token has already been
       |  /// consumed.
      0|  Token next() {
      0|    var token = _next ?? _readNext();
      0|    _endOfFileEmitted = token.type == TokenType.endOfFile;
      0|    _next = null;
       |    return token;
       |  }
       |
       |  /// If the next token matches [type], consumes it and returns `true`;
       |  /// otherwise, returns `false`.
       |  ///
       |  /// Throws a [StateError] if a [TokenType.endOfFile] token has already been
       |  /// consumed.
      0|  bool scan(TokenType type) {
      0|    if (peek().type != type) return false;
      0|    next();
       |    return true;
       |  }
       |
       |  /// Scan and return the next token in the stream.
      0|  Token _readNext() {
      0|    if (_endOfFileEmitted) throw StateError('No more tokens.');
       |
      0|    _consumeWhitespace();
      0|    if (_scanner.isDone) {
      0|      return Token(TokenType.endOfFile, _scanner.spanFrom(_scanner.state));
       |    }
       |
      0|    switch (_scanner.peekChar()) {
      0|      case 0x28 /* ( */ :
      0|        return _scanOperator(TokenType.leftParen);
      0|      case 0x29 /* ) */ :
      0|        return _scanOperator(TokenType.rightParen);
      0|      case 0x3F /* ? */ :
      0|        return _scanOperator(TokenType.questionMark);
      0|      case 0x3A /* : */ :
      0|        return _scanOperator(TokenType.colon);
      0|      case 0x21 /* ! */ :
      0|        return _scanOperator(TokenType.not);
      0|      case 0x7C /* | */ :
      0|        return _scanOr();
      0|      case 0x26 /* & */ :
      0|        return _scanAnd();
       |      default:
      0|        return _scanIdentifier();
       |    }
       |  }
       |
       |  /// Scans a single-character operator and returns a token of type [type].
       |  ///
       |  /// This assumes that the caller has already verified that the next character
       |  /// is correct for the given operator.
      0|  Token _scanOperator(TokenType type) {
      0|    var start = _scanner.state;
      0|    _scanner.readChar();
      0|    return Token(type, _scanner.spanFrom(start));
       |  }
       |
       |  /// Scans a `||` operator and returns the appropriate token.
       |  ///
       |  /// This validates that the next two characters are `||`.
      0|  Token _scanOr() {
      0|    var start = _scanner.state;
      0|    _scanner.expect('||');
      0|    return Token(TokenType.or, _scanner.spanFrom(start));
       |  }
       |
       |  /// Scans a `&&` operator and returns the appropriate token.
       |  ///
       |  /// This validates that the next two characters are `&&`.
      0|  Token _scanAnd() {
      0|    var start = _scanner.state;
      0|    _scanner.expect('&&');
      0|    return Token(TokenType.and, _scanner.spanFrom(start));
       |  }
       |
       |  /// Scans and returns an identifier token.
      0|  Token _scanIdentifier() {
      0|    _scanner.expect(_hyphenatedIdentifier, name: 'expression');
      0|    return IdentifierToken(_scanner.lastMatch[0], _scanner.lastSpan);
       |  }
       |
       |  /// Consumes all whitespace and comments immediately following the cursor's
       |  /// current position.
      0|  void _consumeWhitespace() {
      0|    while (_scanner.scan(_whitespaceAndSingleLineComments) ||
      0|        _multiLineComment()) {
       |      // Do nothing.
       |    }
       |  }
       |
       |  /// Consumes a single multi-line comment.
       |  ///
       |  /// Returns whether or not a comment was consumed.
      0|  bool _multiLineComment() {
      0|    if (!_scanner.scan('/*')) return false;
       |
      0|    while (_scanner.scan(_multiLineCommentBody) || _multiLineComment()) {
       |      // Do nothing.
       |    }
      0|    _scanner.expect('*/');
       |
       |    return true;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/boolean_selector-2.0.0/lib/src/token.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |/// A token in a boolean selector.
       |class Token {
       |  /// The type of the token.
       |  final TokenType type;
       |
       |  /// The span indicating where this token came from.
       |  ///
       |  /// This is a [FileSpan] because the tokens are parsed from a single
       |  /// continuous string, but the string itself isn't actually a file. It might
       |  /// come from a statically-parsed annotation or from a parameter.
       |  final FileSpan span;
       |
      0|  Token(this.type, this.span);
       |}
       |
       |/// A token representing an identifier.
       |class IdentifierToken implements Token {
       |  @override
       |  final type = TokenType.identifier;
       |  @override
       |  final FileSpan span;
       |
       |  /// The name of the identifier.
       |  final String name;
       |
      0|  IdentifierToken(this.name, this.span);
       |
      0|  @override
      0|  String toString() => 'identifier "$name"';
       |}
       |
       |/// An enumeration of types of tokens.
       |class TokenType {
       |  /// A `(` character.
       |  static const leftParen = TokenType._('left paren');
       |
       |  /// A `)` character.
       |  static const rightParen = TokenType._('right paren');
       |
       |  /// A `||` sequence.
       |  static const or = TokenType._('or');
       |
       |  /// A `&&` sequence.
       |  static const and = TokenType._('and');
       |
       |  /// A `!` character.
       |  static const not = TokenType._('not');
       |
       |  /// A `?` character.
       |  static const questionMark = TokenType._('question mark');
       |
       |  /// A `:` character.
       |  static const colon = TokenType._('colon');
       |
       |  /// A named identifier.
       |  static const identifier = TokenType._('identifier');
       |
       |  /// The end of the selector.
       |  static const endOfFile = TokenType._('end of file');
       |
       |  /// The name of the token type.
       |  final String name;
       |
      0|  const TokenType._(this.name);
       |
      0|  @override
      0|  String toString() => name;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/stream_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import 'src/guarantee_channel.dart';
       |import 'src/close_guarantee_channel.dart';
       |import 'src/stream_channel_transformer.dart';
       |
       |export 'src/delegating_stream_channel.dart';
       |export 'src/disconnector.dart';
       |export 'src/json_document_transformer.dart';
       |export 'src/multi_channel.dart';
       |export 'src/stream_channel_completer.dart';
       |export 'src/stream_channel_controller.dart';
       |export 'src/stream_channel_transformer.dart';
       |
       |/// An abstract class representing a two-way communication channel.
       |///
       |/// Users should consider the [stream] emitting a "done" event to be the
       |/// canonical indicator that the channel has closed. If they wish to close the
       |/// channel, they should close the [sink]canceling the stream subscription is
       |/// not sufficient. Protocol errors may be emitted through the stream or through
       |/// [sink].done, depending on their underlying cause. Note that the sink may
       |/// silently drop events if the channel closes before [sink].close is called.
       |///
       |/// Implementations are strongly encouraged to mix in or extend
       |/// [StreamChannelMixin] to get default implementations of the various instance
       |/// methods. Adding new methods to this interface will not be considered a
       |/// breaking change if implementations are also added to [StreamChannelMixin].
       |///
       |/// Implementations must provide the following guarantees:
       |///
       |/// * The stream is single-subscription, and must follow all the guarantees of
       |///   single-subscription streams.
       |///
       |/// * Closing the sink causes the stream to close before it emits any more
       |///   events.
       |///
       |/// * After the stream closes, the sink is automatically closed. If this
       |///   happens, sink methods should silently drop their arguments until
       |///   [sink].close is called.
       |///
       |/// * If the stream closes before it has a listener, the sink should silently
       |///   drop events if possible.
       |///
       |/// * Canceling the stream's subscription has no effect on the sink. The channel
       |///   must still be able to respond to the other endpoint closing the channel
       |///   even after the subscription has been canceled.
       |///
       |/// * The sink *either* forwards errors to the other endpoint *or* closes as
       |///   soon as an error is added and forwards that error to the [sink].done
       |///   future.
       |///
       |/// These guarantees allow users to interact uniformly with all implementations,
       |/// and ensure that either endpoint closing the stream produces consistent
       |/// behavior.
       |abstract class StreamChannel<T> {
       |  /// The single-subscription stream that emits values from the other endpoint.
       |  Stream<T> get stream;
       |
       |  /// The sink for sending values to the other endpoint.
       |  StreamSink<T> get sink;
       |
       |  /// Creates a new [StreamChannel] that communicates over [stream] and [sink].
       |  ///
       |  /// Note that this stream/sink pair must provide the guarantees listed in the
       |  /// [StreamChannel] documentation. If they don't do so natively,
       |  /// [StreamChannel.withGuarantees] should be used instead.
      0|  factory StreamChannel(Stream<T> stream, StreamSink<T> sink) =>
      0|      _StreamChannel<T>(stream, sink);
       |
       |  /// Creates a new [StreamChannel] that communicates over [stream] and [sink].
       |  ///
       |  /// Unlike [new StreamChannel], this enforces the guarantees listed in the
       |  /// [StreamChannel] documentation. This makes it somewhat less efficient than
       |  /// just wrapping a stream and a sink directly, so [new StreamChannel] should
       |  /// be used when the guarantees are provided natively.
       |  ///
       |  /// If [allowSinkErrors] is `false`, errors are not allowed to be passed to
       |  /// [sink]. If any are, the connection will close and the error will be
       |  /// forwarded to [sink].done.
      0|  factory StreamChannel.withGuarantees(Stream<T> stream, StreamSink<T> sink,
       |          {bool allowSinkErrors = true}) =>
      0|      GuaranteeChannel(stream, sink, allowSinkErrors: allowSinkErrors);
       |
       |  /// Creates a new [StreamChannel] that communicates over [stream] and [sink].
       |  ///
       |  /// This specifically enforces the second guarantee: closing the sink causes
       |  /// the stream to close before it emits any more events. This guarantee is
       |  /// invalidated when an asynchronous gap is added between the original
       |  /// stream's event dispatch and the returned stream's, for example by
       |  /// transforming it with a [StreamTransformer]. This is a lighter-weight way
       |  /// of preserving that guarantee in particular than
       |  /// [StreamChannel.withGuarantees].
      0|  factory StreamChannel.withCloseGuarantee(
       |          Stream<T> stream, StreamSink<T> sink) =>
      0|      CloseGuaranteeChannel(stream, sink);
       |
       |  /// Connects this to [other], so that any values emitted by either are sent
       |  /// directly to the other.
       |  void pipe(StreamChannel<T> other);
       |
       |  /// Transforms this using [transformer].
       |  ///
       |  /// This is identical to calling `transformer.bind(channel)`.
       |  StreamChannel<S> transform<S>(StreamChannelTransformer<S, T> transformer);
       |
       |  /// Transforms only the [stream] component of this using [transformer].
       |  StreamChannel<T> transformStream(StreamTransformer<T, T> transformer);
       |
       |  /// Transforms only the [sink] component of this using [transformer].
       |  StreamChannel<T> transformSink(StreamSinkTransformer<T, T> transformer);
       |
       |  /// Returns a copy of this with [stream] replaced by [change]'s return
       |  /// value.
       |  StreamChannel<T> changeStream(Stream<T> change(Stream<T> stream));
       |
       |  /// Returns a copy of this with [sink] replaced by [change]'s return
       |  /// value.
       |  StreamChannel<T> changeSink(StreamSink<T> change(StreamSink<T> sink));
       |
       |  /// Returns a copy of this with the generic type coerced to [S].
       |  ///
       |  /// If any events emitted by [stream] aren't of type [S], they're converted
       |  /// into [CastError] events. Similarly, if any events are added to [sink] that
       |  /// aren't of type [S], a [CastError] is thrown.
       |  StreamChannel<S> cast<S>();
       |}
       |
       |/// An implementation of [StreamChannel] that simply takes a stream and a sink
       |/// as parameters.
       |///
       |/// This is distinct from [StreamChannel] so that it can use
       |/// [StreamChannelMixin].
       |class _StreamChannel<T> extends StreamChannelMixin<T> {
       |  @override
       |  final Stream<T> stream;
       |  @override
       |  final StreamSink<T> sink;
       |
      0|  _StreamChannel(this.stream, this.sink);
       |}
       |
       |/// A mixin that implements the instance methods of [StreamChannel] in terms of
       |/// [stream] and [sink].
       |abstract class StreamChannelMixin<T> implements StreamChannel<T> {
      0|  @override
       |  void pipe(StreamChannel<T> other) {
      0|    stream.pipe(other.sink);
      0|    other.stream.pipe(sink);
       |  }
       |
      0|  @override
       |  StreamChannel<S> transform<S>(StreamChannelTransformer<S, T> transformer) =>
      0|      transformer.bind(this);
       |
      0|  @override
       |  StreamChannel<T> transformStream(StreamTransformer<T, T> transformer) =>
      0|      changeStream(transformer.bind);
       |
      0|  @override
       |  StreamChannel<T> transformSink(StreamSinkTransformer<T, T> transformer) =>
      0|      changeSink(transformer.bind);
       |
      0|  @override
       |  StreamChannel<T> changeStream(Stream<T> change(Stream<T> stream)) =>
      0|      StreamChannel.withCloseGuarantee(change(stream), sink);
       |
      0|  @override
       |  StreamChannel<T> changeSink(StreamSink<T> change(StreamSink<T> sink)) =>
      0|      StreamChannel.withCloseGuarantee(stream, change(sink));
       |
      0|  @override
      0|  StreamChannel<S> cast<S>() => StreamChannel(
      0|      DelegatingStream.typed(stream), DelegatingStreamSink.typed(sink));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/guarantee_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A [StreamChannel] that enforces the stream channel guarantees.
       |///
       |/// This is exposed via [new StreamChannel.withGuarantees].
       |class GuaranteeChannel<T> extends StreamChannelMixin<T> {
      0|  @override
      0|  Stream<T> get stream => _streamController.stream;
       |
      0|  @override
      0|  StreamSink<T> get sink => _sink;
       |  _GuaranteeSink<T> _sink;
       |
       |  /// The controller for [stream].
       |  ///
       |  /// This intermediate controller allows us to continue listening for a done
       |  /// event even after the user has canceled their subscription, and to send our
       |  /// own done event when the sink is closed.
       |  StreamController<T> _streamController;
       |
       |  /// The subscription to the inner stream.
       |  StreamSubscription<T> _subscription;
       |
       |  /// Whether the sink has closed, causing the underlying channel to disconnect.
       |  bool _disconnected = false;
       |
      0|  GuaranteeChannel(Stream<T> innerStream, StreamSink<T> innerSink,
       |      {bool allowSinkErrors = true}) {
      0|    _sink = _GuaranteeSink<T>(innerSink, this, allowErrors: allowSinkErrors);
       |
       |    // Enforce the single-subscription guarantee by changing a broadcast stream
       |    // to single-subscription.
      0|    if (innerStream.isBroadcast) {
       |      innerStream =
      0|          innerStream.transform(SingleSubscriptionTransformer<T, T>());
       |    }
       |
      0|    _streamController = StreamController<T>(
      0|        onListen: () {
       |          // If the sink has disconnected, we've already called
       |          // [_streamController.close].
      0|          if (_disconnected) return;
       |
      0|          _subscription = innerStream.listen(_streamController.add,
      0|              onError: _streamController.addError, onDone: () {
      0|            _sink._onStreamDisconnected();
      0|            _streamController.close();
       |          });
       |        },
       |        sync: true);
       |  }
       |
       |  /// Called by [_GuaranteeSink] when the user closes it.
       |  ///
       |  /// The sink closing indicates that the connection is closed, so the stream
       |  /// should stop emitting events.
      0|  void _onSinkDisconnected() {
      0|    _disconnected = true;
      0|    if (_subscription != null) _subscription.cancel();
      0|    _streamController.close();
       |  }
       |}
       |
       |/// The sink for [GuaranteeChannel].
       |///
       |/// This wraps the inner sink to ignore events and cancel any in-progress
       |/// [addStream] calls when the underlying channel closes.
       |class _GuaranteeSink<T> implements StreamSink<T> {
       |  /// The inner sink being wrapped.
       |  final StreamSink<T> _inner;
       |
       |  /// The [GuaranteeChannel] this belongs to.
       |  final GuaranteeChannel<T> _channel;
       |
      0|  @override
      0|  Future<void> get done => _doneCompleter.future;
       |  final _doneCompleter = Completer();
       |
       |  /// Whether connection is disconnected.
       |  ///
       |  /// This can happen because the stream has emitted a done event, or because
       |  /// the user added an error when [_allowErrors] is `false`.
       |  bool _disconnected = false;
       |
       |  /// Whether the user has called [close].
       |  bool _closed = false;
       |
       |  /// The subscription to the stream passed to [addStream], if a stream is
       |  /// currently being added.
       |  StreamSubscription<T> _addStreamSubscription;
       |
       |  /// The completer for the future returned by [addStream], if a stream is
       |  /// currently being added.
       |  Completer _addStreamCompleter;
       |
       |  /// Whether we're currently adding a stream with [addStream].
      0|  bool get _inAddStream => _addStreamSubscription != null;
       |
       |  /// Whether errors are passed on to the underlying sink.
       |  ///
       |  /// If this is `false`, any error passed to the sink is piped to [done] and
       |  /// the underlying sink is closed.
       |  final bool _allowErrors;
       |
      0|  _GuaranteeSink(this._inner, this._channel, {bool allowErrors = true})
       |      : _allowErrors = allowErrors;
       |
      0|  @override
       |  void add(T data) {
      0|    if (_closed) throw StateError("Cannot add event after closing.");
      0|    if (_inAddStream) {
      0|      throw StateError("Cannot add event while adding stream.");
       |    }
      0|    if (_disconnected) return;
       |
      0|    _inner.add(data);
       |  }
       |
      0|  @override
       |  void addError(error, [StackTrace stackTrace]) {
      0|    if (_closed) throw StateError("Cannot add event after closing.");
      0|    if (_inAddStream) {
      0|      throw StateError("Cannot add event while adding stream.");
       |    }
      0|    if (_disconnected) return;
       |
      0|    _addError(error, stackTrace);
       |  }
       |
       |  /// Like [addError], but doesn't check to ensure that an error can be added.
       |  ///
       |  /// This is called from [addStream], so it shouldn't fail if a stream is being
       |  /// added.
      0|  void _addError(error, [StackTrace stackTrace]) {
      0|    if (_allowErrors) {
      0|      _inner.addError(error, stackTrace);
       |      return;
       |    }
       |
      0|    _doneCompleter.completeError(error, stackTrace);
       |
       |    // Treat an error like both the stream and sink disconnecting.
      0|    _onStreamDisconnected();
      0|    _channel._onSinkDisconnected();
       |
       |    // Ignore errors from the inner sink. We're already surfacing one error, and
       |    // if the user handles it we don't want them to have another top-level.
      0|    _inner.close().catchError((_) {});
       |  }
       |
      0|  @override
       |  Future<void> addStream(Stream<T> stream) {
      0|    if (_closed) throw StateError("Cannot add stream after closing.");
      0|    if (_inAddStream) {
      0|      throw StateError("Cannot add stream while adding stream.");
       |    }
      0|    if (_disconnected) return Future.value();
       |
      0|    _addStreamCompleter = Completer.sync();
      0|    _addStreamSubscription = stream.listen(_inner.add,
      0|        onError: _addError, onDone: _addStreamCompleter.complete);
      0|    return _addStreamCompleter.future.then((_) {
      0|      _addStreamCompleter = null;
      0|      _addStreamSubscription = null;
       |    });
       |  }
       |
      0|  @override
       |  Future<void> close() {
      0|    if (_inAddStream) {
      0|      throw StateError("Cannot close sink while adding stream.");
       |    }
       |
      0|    if (_closed) return done;
      0|    _closed = true;
       |
      0|    if (!_disconnected) {
      0|      _channel._onSinkDisconnected();
      0|      _doneCompleter.complete(_inner.close());
       |    }
       |
      0|    return done;
       |  }
       |
       |  /// Called by [GuaranteeChannel] when the stream emits a done event.
       |  ///
       |  /// The stream being done indicates that the connection is closed, so the
       |  /// sink should stop forwarding events.
      0|  void _onStreamDisconnected() {
      0|    _disconnected = true;
      0|    if (!_doneCompleter.isCompleted) _doneCompleter.complete();
       |
      0|    if (!_inAddStream) return;
      0|    _addStreamCompleter.complete(_addStreamSubscription.cancel());
      0|    _addStreamCompleter = null;
      0|    _addStreamSubscription = null;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/close_guarantee_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A [StreamChannel] that specifically enforces the stream channel guarantee
       |/// that closing the sink causes the stream to close before it emits any more
       |/// events
       |///
       |/// This is exposed via [new StreamChannel.withCloseGuarantee].
       |class CloseGuaranteeChannel<T> extends StreamChannelMixin<T> {
      0|  @override
      0|  Stream<T> get stream => _stream;
       |  _CloseGuaranteeStream<T> _stream;
       |
      0|  @override
      0|  StreamSink<T> get sink => _sink;
       |  _CloseGuaranteeSink<T> _sink;
       |
       |  /// The subscription to the inner stream.
       |  StreamSubscription<T> _subscription;
       |
       |  /// Whether the sink has closed, causing the underlying channel to disconnect.
       |  bool _disconnected = false;
       |
      0|  CloseGuaranteeChannel(Stream<T> innerStream, StreamSink<T> innerSink) {
      0|    _sink = _CloseGuaranteeSink<T>(innerSink, this);
      0|    _stream = _CloseGuaranteeStream<T>(innerStream, this);
       |  }
       |}
       |
       |/// The stream for [CloseGuaranteeChannel].
       |///
       |/// This wraps the inner stream to save the subscription on the channel when
       |/// [listen] is called.
       |class _CloseGuaranteeStream<T> extends Stream<T> {
       |  /// The inner stream this is delegating to.
       |  final Stream<T> _inner;
       |
       |  /// The [CloseGuaranteeChannel] this belongs to.
       |  final CloseGuaranteeChannel<T> _channel;
       |
      0|  _CloseGuaranteeStream(this._inner, this._channel);
       |
      0|  @override
       |  StreamSubscription<T> listen(void onData(T event),
       |      {Function onError, void onDone(), bool cancelOnError}) {
       |    // If the channel is already disconnected, we shouldn't dispatch anything
       |    // but a done event.
      0|    if (_channel._disconnected) {
       |      onData = null;
       |      onError = null;
       |    }
       |
      0|    var subscription = _inner.listen(onData,
       |        onError: onError, onDone: onDone, cancelOnError: cancelOnError);
      0|    if (!_channel._disconnected) {
      0|      _channel._subscription = subscription;
       |    }
       |    return subscription;
       |  }
       |}
       |
       |/// The sink for [CloseGuaranteeChannel].
       |///
       |/// This wraps the inner sink to cancel the stream subscription when the sink is
       |/// canceled.
       |class _CloseGuaranteeSink<T> extends DelegatingStreamSink<T> {
       |  /// The [CloseGuaranteeChannel] this belongs to.
       |  final CloseGuaranteeChannel<T> _channel;
       |
      0|  _CloseGuaranteeSink(StreamSink<T> inner, this._channel) : super(inner);
       |
      0|  @override
       |  Future<void> close() {
      0|    var done = super.close();
      0|    _channel._disconnected = true;
      0|    if (_channel._subscription != null) {
       |      // Don't dispatch anything but a done event.
      0|      _channel._subscription.onData(null);
      0|      _channel._subscription.onError(null);
       |    }
       |    return done;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/stream_channel_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:convert';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A [StreamChannelTransformer] transforms the events being passed to and
       |/// emitted by a [StreamChannel].
       |///
       |/// This works on the same principle as [StreamTransformer] and
       |/// [StreamSinkTransformer]. Each transformer defines a [bind] method that takes
       |/// in the original [StreamChannel] and returns the transformed version.
       |///
       |/// Transformers must be able to have [bind] called multiple times. If a
       |/// subclass implements [bind] explicitly, it should be sure that the returned
       |/// stream follows the second stream channel guarantee: closing the sink causes
       |/// the stream to close before it emits any more events. This guarantee is
       |/// invalidated when an asynchronous gap is added between the original stream's
       |/// event dispatch and the returned stream's, for example by transforming it
       |/// with a [StreamTransformer]. The guarantee can be easily preserved using
       |/// [StreamChannel.withCloseGuarantee].
       |class StreamChannelTransformer<S, T> {
       |  /// The transformer to use on the channel's stream.
       |  final StreamTransformer<T, S> _streamTransformer;
       |
       |  /// The transformer to use on the channel's sink.
       |  final StreamSinkTransformer<S, T> _sinkTransformer;
       |
       |  /// Creates a [StreamChannelTransformer] from existing stream and sink
       |  /// transformers.
      0|  const StreamChannelTransformer(
       |      this._streamTransformer, this._sinkTransformer);
       |
       |  /// Creates a [StreamChannelTransformer] from a codec's encoder and decoder.
       |  ///
       |  /// All input to the inner channel's sink is encoded using [Codec.encoder],
       |  /// and all output from its stream is decoded using [Codec.decoder].
      0|  StreamChannelTransformer.fromCodec(Codec<S, T> codec)
      0|      : this(codec.decoder,
      0|            StreamSinkTransformer.fromStreamTransformer(codec.encoder));
       |
       |  /// Transforms the events sent to and emitted by [channel].
       |  ///
       |  /// Creates a new channel. When events are passed to the returned channel's
       |  /// sink, the transformer will transform them and pass the transformed
       |  /// versions to `channel.sink`. When events are emitted from the
       |  /// `channel.straem`, the transformer will transform them and pass the
       |  /// transformed versions to the returned channel's stream.
      0|  StreamChannel<S> bind(StreamChannel<T> channel) =>
      0|      StreamChannel<S>.withCloseGuarantee(
      0|          channel.stream.transform(_streamTransformer),
      0|          _sinkTransformer.bind(channel.sink));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/delegating_stream_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_channel.dart';
       |
       |/// A simple delegating wrapper around [StreamChannel].
       |///
       |/// Subclasses can override individual methods, or use this to expose only
       |/// [StreamChannel] methods.
       |class DelegatingStreamChannel<T> extends StreamChannelMixin<T> {
       |  /// The inner channel to which methods are forwarded.
       |  final StreamChannel<T> _inner;
       |
      0|  @override
      0|  Stream<T> get stream => _inner.stream;
      0|  @override
      0|  StreamSink<T> get sink => _inner.sink;
       |
      0|  DelegatingStreamChannel(this._inner);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/disconnector.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// Allows the caller to force a channel to disconnect.
       |///
       |/// When [disconnect] is called, the channel (or channels) transformed by this
       |/// transformer will act as though the remote end had disconnectedthe stream
       |/// will emit a done event, and the sink will ignore future inputs. The inner
       |/// sink will also be closed to notify the remote end of the disconnection.
       |///
       |/// If a channel is transformed after the [disconnect] has been called, it will
       |/// be disconnected immediately.
       |class Disconnector<T> implements StreamChannelTransformer<T, T> {
       |  /// Whether [disconnect] has been called.
      0|  bool get isDisconnected => _disconnectMemo.hasRun;
       |
       |  /// The sinks for transformed channels.
       |  ///
       |  /// Note that we assume that transformed channels provide the stream channel
       |  /// guarantees. This allows us to only track sinks, because we know closing
       |  /// the underlying sink will cause the stream to emit a done event.
       |  final _sinks = <_DisconnectorSink<T>>[];
       |
       |  /// Disconnects all channels that have been transformed.
       |  ///
       |  /// Returns a future that completes when all inner sinks' [StreamSink.close]
       |  /// futures have completed. Note that a [StreamController]'s sink won't close
       |  /// until the corresponding stream has a listener.
      0|  Future<void> disconnect() => _disconnectMemo.runOnce(() {
      0|        var futures = _sinks.map((sink) => sink._disconnect()).toList();
      0|        _sinks.clear();
      0|        return Future.wait(futures, eagerError: true);
       |      });
       |  final _disconnectMemo = AsyncMemoizer();
       |
      0|  @override
       |  StreamChannel<T> bind(StreamChannel<T> channel) {
      0|    return channel.changeSink((innerSink) {
      0|      var sink = _DisconnectorSink<T>(innerSink);
       |
      0|      if (isDisconnected) {
       |        // Ignore errors here, because otherwise there would be no way for the
       |        // user to handle them gracefully.
      0|        sink._disconnect().catchError((_) {});
       |      } else {
      0|        _sinks.add(sink);
       |      }
       |
       |      return sink;
       |    });
       |  }
       |}
       |
       |/// A sink wrapper that can force a disconnection.
       |class _DisconnectorSink<T> implements StreamSink<T> {
       |  /// The inner sink.
       |  final StreamSink<T> _inner;
       |
      0|  @override
      0|  Future<void> get done => _inner.done;
       |
       |  /// Whether [Disconnector.disconnect] has been called.
       |  var _isDisconnected = false;
       |
       |  /// Whether the user has called [close].
       |  var _closed = false;
       |
       |  /// The subscription to the stream passed to [addStream], if a stream is
       |  /// currently being added.
       |  StreamSubscription<T> _addStreamSubscription;
       |
       |  /// The completer for the future returned by [addStream], if a stream is
       |  /// currently being added.
       |  Completer _addStreamCompleter;
       |
       |  /// Whether we're currently adding a stream with [addStream].
      0|  bool get _inAddStream => _addStreamSubscription != null;
       |
      0|  _DisconnectorSink(this._inner);
       |
      0|  @override
       |  void add(T data) {
      0|    if (_closed) throw StateError("Cannot add event after closing.");
      0|    if (_inAddStream) {
      0|      throw StateError("Cannot add event while adding stream.");
       |    }
      0|    if (_isDisconnected) return;
       |
      0|    _inner.add(data);
       |  }
       |
      0|  @override
       |  void addError(error, [StackTrace stackTrace]) {
      0|    if (_closed) throw StateError("Cannot add event after closing.");
      0|    if (_inAddStream) {
      0|      throw StateError("Cannot add event while adding stream.");
       |    }
      0|    if (_isDisconnected) return;
       |
      0|    _inner.addError(error, stackTrace);
       |  }
       |
      0|  @override
       |  Future<void> addStream(Stream<T> stream) {
      0|    if (_closed) throw StateError("Cannot add stream after closing.");
      0|    if (_inAddStream) {
      0|      throw StateError("Cannot add stream while adding stream.");
       |    }
      0|    if (_isDisconnected) return Future.value();
       |
      0|    _addStreamCompleter = Completer.sync();
      0|    _addStreamSubscription = stream.listen(_inner.add,
      0|        onError: _inner.addError, onDone: _addStreamCompleter.complete);
      0|    return _addStreamCompleter.future.then((_) {
      0|      _addStreamCompleter = null;
      0|      _addStreamSubscription = null;
       |    });
       |  }
       |
      0|  @override
       |  Future<void> close() {
      0|    if (_inAddStream) {
      0|      throw StateError("Cannot close sink while adding stream.");
       |    }
       |
      0|    _closed = true;
      0|    return _inner.close();
       |  }
       |
       |  /// Disconnects this sink.
       |  ///
       |  /// This closes the underlying sink and stops forwarding events. It returns
       |  /// the [StreamSink.close] future for the underlying sink.
      0|  Future<void> _disconnect() {
      0|    _isDisconnected = true;
      0|    var future = _inner.close();
       |
      0|    if (_inAddStream) {
      0|      _addStreamCompleter.complete(_addStreamSubscription.cancel());
      0|      _addStreamCompleter = null;
      0|      _addStreamSubscription = null;
       |    }
       |
       |    return future;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/json_document_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |import 'stream_channel_transformer.dart';
       |
       |/// A [StreamChannelTransformer] that transforms JSON documentsstrings that
       |/// contain individual objects encoded as JSONinto decoded Dart objects.
       |///
       |/// This decodes JSON that's emitted by the transformed channel's stream, and
       |/// encodes objects so that JSON is passed to the transformed channel's sink.
       |///
       |/// If the transformed channel emits invalid JSON, this emits a
       |/// [FormatException]. If an unencodable object is added to the sink, it
       |/// synchronously throws a [JsonUnsupportedObjectError].
      0|final StreamChannelTransformer<Object, String> jsonDocument =
       |    const _JsonDocument();
       |
       |class _JsonDocument implements StreamChannelTransformer<Object, String> {
      0|  const _JsonDocument();
       |
      0|  @override
       |  StreamChannel<Object> bind(StreamChannel<String> channel) {
      0|    var stream = channel.stream.map(jsonDecode);
      0|    var sink = StreamSinkTransformer<Object, String>.fromHandlers(
      0|        handleData: (data, sink) {
      0|      sink.add(jsonEncode(data));
      0|    }).bind(channel.sink);
      0|    return StreamChannel.withCloseGuarantee(stream, sink);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/multi_channel.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A class that multiplexes multiple virtual channels across a single
       |/// underlying transport layer.
       |///
       |/// This should be connected to another [MultiChannel] on the other end of the
       |/// underlying channel. It starts with a single default virtual channel,
       |/// accessible via [stream] and [sink]. Additional virtual channels can be
       |/// created with [virtualChannel].
       |///
       |/// When a virtual channel is created by one endpoint, the other must connect to
       |/// it before messages may be sent through it. The first endpoint passes its
       |/// [VirtualChannel.id] to the second, which then creates a channel from that id
       |/// also using [virtualChannel]. For example:
       |///
       |/// ```dart
       |/// // First endpoint
       |/// var virtual = multiChannel.virtualChannel();
       |/// multiChannel.sink.add({
       |///   "channel": virtual.id
       |/// });
       |///
       |/// // Second endpoint
       |/// multiChannel.stream.listen((message) {
       |///   var virtual = multiChannel.virtualChannel(message["channel"]);
       |///   // ...
       |/// });
       |/// ```
       |///
       |/// Sending errors across a [MultiChannel] is not supported. Any errors from the
       |/// underlying stream will be reported only via the default
       |/// [MultiChannel.stream].
       |///
       |/// Each virtual channel may be closed individually. When all of them are
       |/// closed, the underlying [StreamSink] is closed automatically.
       |abstract class MultiChannel<T> implements StreamChannel<T> {
       |  /// The default input stream.
       |  ///
       |  /// This connects to the remote [sink].
       |  @override
       |  Stream<T> get stream;
       |
       |  /// The default output stream.
       |  ///
       |  /// This connects to the remote [stream]. If this is closed, the remote
       |  /// [stream] will close, but other virtual channels will remain open and new
       |  /// virtual channels may be opened.
       |  @override
       |  StreamSink<T> get sink;
       |
       |  /// Creates a new [MultiChannel] that sends and receives messages over
       |  /// [inner].
       |  ///
       |  /// The inner channel must take JSON-like objects.
      0|  factory MultiChannel(StreamChannel<dynamic> inner) => _MultiChannel<T>(inner);
       |
       |  /// Creates a new virtual channel.
       |  ///
       |  /// If [id] is not passed, this creates a virtual channel from scratch. Before
       |  /// it's used, its [VirtualChannel.id] must be sent to the remote endpoint
       |  /// where [virtualChannel] should be called with that id.
       |  ///
       |  /// If [id] is passed, this creates a virtual channel corresponding to the
       |  /// channel with that id on the remote channel.
       |  ///
       |  /// Throws an [ArgumentError] if a virtual channel already exists for [id].
       |  /// Throws a [StateError] if the underlying channel is closed.
       |  VirtualChannel<T> virtualChannel([int id]);
       |}
       |
       |/// The implementation of [MultiChannel].
       |///
       |/// This is private so that [VirtualChannel] can inherit from [MultiChannel]
       |/// without having to implement all the private members.
       |class _MultiChannel<T> extends StreamChannelMixin<T>
       |    implements MultiChannel<T> {
       |  /// The inner channel over which all communication is conducted.
       |  ///
       |  /// This will be `null` if the underlying communication channel is closed.
       |  StreamChannel<dynamic> _inner;
       |
       |  /// The subscription to [_inner].stream.
       |  StreamSubscription<dynamic> _innerStreamSubscription;
       |
      0|  @override
      0|  Stream<T> get stream => _mainController.foreign.stream;
      0|  @override
      0|  StreamSink<T> get sink => _mainController.foreign.sink;
       |
       |  /// The controller for this channel.
       |  final _mainController = StreamChannelController<T>(sync: true);
       |
       |  /// A map from input IDs to [StreamChannelController]s that should be used to
       |  /// communicate over those channels.
       |  final _controllers = <int, StreamChannelController<T>>{};
       |
       |  /// Input IDs of controllers in [_controllers] that we've received messages
       |  /// for but that have not yet had a local [virtualChannel] created.
       |  final _pendingIds = Set<int>();
       |
       |  /// Input IDs of virtual channels that used to exist but have since been
       |  /// closed.
       |  final _closedIds = Set<int>();
       |
       |  /// The next id to use for a local virtual channel.
       |  ///
       |  /// Ids are used to identify virtual channels. Each message is tagged with an
       |  /// id; the receiving [MultiChannel] uses this id to look up which
       |  /// [VirtualChannel] the message should be dispatched to.
       |  ///
       |  /// The id scheme for virtual channels is somewhat complicated. This is
       |  /// necessary to ensure that there are no conflicts even when both endpoints
       |  /// have virtual channels with the same id; since both endpoints can send and
       |  /// receive messages across each virtual channel, a nave scheme would make it
       |  /// impossible to tell whether a message was from a channel that originated in
       |  /// the remote endpoint or a reply on a channel that originated in the local
       |  /// endpoint.
       |  ///
       |  /// The trick is that each endpoint only uses odd ids for its own channels.
       |  /// When sending a message over a channel that was created by the remote
       |  /// endpoint, the channel's id plus one is used. This way each [MultiChannel]
       |  /// knows that if an incoming message has an odd id, it's coming from a
       |  /// channel that was originally created remotely, but if it has an even id,
       |  /// it's coming from a channel that was originally created locally.
       |  var _nextId = 1;
       |
      0|  _MultiChannel(this._inner) {
       |    // The default connection is a special case which has id 0 on both ends.
       |    // This allows it to begin connected without having to send over an id.
      0|    _controllers[0] = _mainController;
      0|    _mainController.local.stream.listen(
      0|        (message) => _inner.sink.add([0, message]),
      0|        onDone: () => _closeChannel(0, 0));
       |
      0|    _innerStreamSubscription = _inner.stream.listen((message) {
      0|      var id = message[0];
       |
       |      // If the channel was closed before an incoming message was processed,
       |      // ignore that message.
      0|      if (_closedIds.contains(id)) return;
       |
      0|      var controller = _controllers.putIfAbsent(id, () {
       |        // If we receive a message for a controller that doesn't have a local
       |        // counterpart yet, create a controller for it to buffer incoming
       |        // messages for when a local connection is created.
      0|        _pendingIds.add(id);
      0|        return StreamChannelController(sync: true);
       |      });
       |
      0|      if (message.length > 1) {
      0|        controller.local.sink.add(message[1]);
       |      } else {
       |        // A message without data indicates that the channel has been closed. We
       |        // can just close the sink here without doing any more cleanup, because
       |        // the sink closing will cause the stream to emit a done event which
       |        // will trigger more cleanup.
      0|        controller.local.sink.close();
       |      }
       |    },
      0|        onDone: _closeInnerChannel,
      0|        onError: _mainController.local.sink.addError);
       |  }
       |
      0|  @override
       |  VirtualChannel<T> virtualChannel([int id]) {
       |    int inputId;
       |    int outputId;
       |    if (id != null) {
       |      // Since the user is passing in an id, we're connected to a remote
       |      // VirtualChannel. This means messages they send over this channel will
       |      // have the original odd id, but our replies will have an even id.
       |      inputId = id;
      0|      outputId = id + 1;
       |    } else {
       |      // Since we're generating an id, we originated this VirtualChannel. This
       |      // means messages we send over this channel will have the original odd id,
       |      // but the remote channel's replies will have an even id.
      0|      inputId = _nextId + 1;
      0|      outputId = _nextId;
      0|      _nextId += 2;
       |    }
       |
       |    // If the inner channel has already closed, create new virtual channels in a
       |    // closed state.
      0|    if (_inner == null) {
      0|      return VirtualChannel._(this, inputId, Stream.empty(), NullStreamSink());
       |    }
       |
       |    StreamChannelController<T> controller;
      0|    if (_pendingIds.remove(inputId)) {
       |      // If we've already received messages for this channel, use the controller
       |      // where those messages are buffered.
      0|      controller = _controllers[inputId];
      0|    } else if (_controllers.containsKey(inputId) ||
      0|        _closedIds.contains(inputId)) {
      0|      throw ArgumentError("A virtual channel with id $id already exists.");
       |    } else {
      0|      controller = StreamChannelController(sync: true);
      0|      _controllers[inputId] = controller;
       |    }
       |
      0|    controller.local.stream.listen(
      0|        (message) => _inner.sink.add([outputId, message]),
      0|        onDone: () => _closeChannel(inputId, outputId));
      0|    return VirtualChannel._(
      0|        this, outputId, controller.foreign.stream, controller.foreign.sink);
       |  }
       |
       |  /// Closes the virtual channel for which incoming messages have [inputId] and
       |  /// outgoing messages have [outputId].
      0|  void _closeChannel(int inputId, int outputId) {
      0|    _closedIds.add(inputId);
      0|    var controller = _controllers.remove(inputId);
      0|    controller.local.sink.close();
       |
      0|    if (_inner == null) return;
       |
       |    // A message without data indicates that the virtual channel has been
       |    // closed.
      0|    _inner.sink.add([outputId]);
      0|    if (_controllers.isEmpty) _closeInnerChannel();
       |  }
       |
       |  /// Closes the underlying communication channel.
      0|  void _closeInnerChannel() {
      0|    _inner.sink.close();
      0|    _innerStreamSubscription.cancel();
      0|    _inner = null;
       |
       |    // Convert this to a list because the close is dispatched synchronously, and
       |    // that could conceivably remove a controller from [_controllers].
      0|    for (var controller in List.from(_controllers.values)) {
      0|      controller.local.sink.close();
       |    }
      0|    _controllers.clear();
       |  }
       |}
       |
       |/// A virtual channel created by [MultiChannel].
       |///
       |/// This implements [MultiChannel] for convenience.
       |/// [VirtualChannel.virtualChannel] is semantically identical to the parent's
       |/// [MultiChannel.virtualChannel].
       |class VirtualChannel<T> extends StreamChannelMixin<T>
       |    implements MultiChannel<T> {
       |  /// The [MultiChannel] that created this.
       |  final MultiChannel<T> _parent;
       |
       |  /// The identifier for this channel.
       |  ///
       |  /// This can be sent across the [MultiChannel] to provide the remote endpoint
       |  /// a means to connect to this channel. Nothing about this is guaranteed
       |  /// except that it will be JSON-serializable.
       |  final int id;
       |
       |  @override
       |  final Stream<T> stream;
       |  @override
       |  final StreamSink<T> sink;
       |
      0|  VirtualChannel._(this._parent, this.id, this.stream, this.sink);
       |
      0|  @override
      0|  VirtualChannel<T> virtualChannel([id]) => _parent.virtualChannel(id);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/stream_channel_completer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import '../stream_channel.dart';
       |
       |/// A [channel] where the source and destination are provided later.
       |///
       |/// The [channel] is a normal channel that can be listened to and that events
       |/// can be added to immediately, but until [setChannel] is called it won't emit
       |/// any events and all events added to it will be buffered.
       |class StreamChannelCompleter<T> {
       |  /// The completer for this channel's stream.
       |  final _streamCompleter = StreamCompleter<T>();
       |
       |  /// The completer for this channel's sink.
       |  final _sinkCompleter = StreamSinkCompleter<T>();
       |
       |  /// The channel for this completer.
      0|  StreamChannel<T> get channel => _channel;
       |  StreamChannel<T> _channel;
       |
       |  /// Whether [setChannel] has been called.
       |  bool _set = false;
       |
       |  /// Convert a `Future<StreamChannel>` to a `StreamChannel`.
       |  ///
       |  /// This creates a channel using a channel completer, and sets the source
       |  /// channel to the result of the future when the future completes.
       |  ///
       |  /// If the future completes with an error, the returned channel's stream will
       |  /// instead contain just that error. The sink will silently discard all
       |  /// events.
      0|  static StreamChannel fromFuture(Future<StreamChannel> channelFuture) {
      0|    var completer = StreamChannelCompleter();
      0|    channelFuture.then(completer.setChannel, onError: completer.setError);
      0|    return completer.channel;
       |  }
       |
      0|  StreamChannelCompleter() {
      0|    _channel = StreamChannel<T>(_streamCompleter.stream, _sinkCompleter.sink);
       |  }
       |
       |  /// Set a channel as the source and destination for [channel].
       |  ///
       |  /// A channel may be set at most once.
       |  ///
       |  /// Either [setChannel] or [setError] may be called at most once. Trying to
       |  /// call either of them again will fail.
      0|  void setChannel(StreamChannel<T> channel) {
      0|    if (_set) throw StateError("The channel has already been set.");
      0|    _set = true;
       |
      0|    _streamCompleter.setSourceStream(channel.stream);
      0|    _sinkCompleter.setDestinationSink(channel.sink);
       |  }
       |
       |  /// Indicates that there was an error connecting the channel.
       |  ///
       |  /// This makes the stream emit [error] and close. It makes the sink discard
       |  /// all its events.
       |  ///
       |  /// Either [setChannel] or [setError] may be called at most once. Trying to
       |  /// call either of them again will fail.
      0|  void setError(error, [StackTrace stackTrace]) {
      0|    if (_set) throw StateError("The channel has already been set.");
      0|    _set = true;
       |
      0|    _streamCompleter.setError(error, stackTrace);
      0|    _sinkCompleter.setDestinationSink(NullStreamSink());
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stream_channel-2.0.0/lib/src/stream_channel_controller.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_channel.dart';
       |
       |/// A controller for exposing a new [StreamChannel].
       |///
       |/// This exposes two connected [StreamChannel]s, [local] and [foreign]. The
       |/// user's code should use [local] to emit and receive events. Then [foreign]
       |/// can be returned for others to use. For example, here's a simplified version
       |/// of the implementation of [new IsolateChannel]:
       |///
       |/// ```dart
       |/// StreamChannel isolateChannel(ReceivePort receivePort, SendPort sendPort) {
       |///   var controller = new StreamChannelController(allowForeignErrors: false);
       |///
       |///   // Pipe all events from the receive port into the local sink...
       |///   receivePort.pipe(controller.local.sink);
       |///
       |///   // ...and all events from the local stream into the send port.
       |///   controller.local.stream.listen(sendPort.send, onDone: receivePort.close);
       |///
       |///   // Then return the foreign controller for your users to use.
       |///   return controller.foreign;
       |/// }
       |/// ```
       |class StreamChannelController<T> {
       |  /// The local channel.
       |  ///
       |  /// This channel should be used directly by the creator of this
       |  /// [StreamChannelController] to send and receive events.
      0|  StreamChannel<T> get local => _local;
       |  StreamChannel<T> _local;
       |
       |  /// The foreign channel.
       |  ///
       |  /// This channel should be returned to external users so they can communicate
       |  /// with [local].
      0|  StreamChannel<T> get foreign => _foreign;
       |  StreamChannel<T> _foreign;
       |
       |  /// Creates a [StreamChannelController].
       |  ///
       |  /// If [sync] is true, events added to either channel's sink are synchronously
       |  /// dispatched to the other channel's stream. This should only be done if the
       |  /// source of those events is already asynchronous.
       |  ///
       |  /// If [allowForeignErrors] is `false`, errors are not allowed to be passed to
       |  /// the foreign channel's sink. If any are, the connection will close and the
       |  /// error will be forwarded to the foreign channel's [StreamSink.done] future.
       |  /// This guarantees that the local stream will never emit errors.
      0|  StreamChannelController({bool allowForeignErrors = true, bool sync = false}) {
      0|    var localToForeignController = StreamController<T>(sync: sync);
      0|    var foreignToLocalController = StreamController<T>(sync: sync);
      0|    _local = StreamChannel<T>.withGuarantees(
      0|        foreignToLocalController.stream, localToForeignController.sink);
      0|    _foreign = StreamChannel<T>.withGuarantees(
      0|        localToForeignController.stream, foreignToLocalController.sink,
       |        allowSinkErrors: allowForeignErrors);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/async_cache.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |/// Runs asynchronous functions and caches the result for a period of time.
       |///
       |/// This class exists to cover the pattern of having potentially expensive code
       |/// such as file I/O, network access, or isolate computation that's unlikely to
       |/// change quickly run fewer times. For example:
       |///
       |/// ```dart
       |/// final _usersCache = new AsyncCache<List<String>>(const Duration(hours: 1));
       |///
       |/// /// Uses the cache if it exists, otherwise calls the closure:
       |/// Future<List<String>> get onlineUsers => _usersCache.fetch(() {
       |///   // Actually fetch online users here.
       |/// });
       |/// ```
       |///
       |/// This class's timing can be mocked using [`fake_async`][fake_async].
       |///
       |/// [fake_async]: https://pub.dev/packages/fake_async
       |class AsyncCache<T> {
       |  /// How long cached values stay fresh.
       |  final Duration _duration;
       |
       |  /// Cached results of a previous [fetchStream] call.
       |  StreamSplitter<T> _cachedStreamSplitter;
       |
       |  /// Cached results of a previous [fetch] call.
       |  Future<T> _cachedValueFuture;
       |
       |  /// Fires when the cache should be considered stale.
       |  Timer _stale;
       |
       |  /// Creates a cache that invalidates its contents after [duration] has passed.
       |  ///
       |  /// The [duration] starts counting after the Future returned by [fetch]
       |  /// completes, or after the Stream returned by [fetchStream] emits a done
       |  /// event.
      0|  AsyncCache(this._duration);
       |
       |  /// Creates a cache that invalidates after an in-flight request is complete.
       |  ///
       |  /// An ephemeral cache guarantees that a callback function will only be
       |  /// executed at most once concurrently. This is useful for requests for which
       |  /// data is updated frequently but stale data is acceptable.
      0|  factory AsyncCache.ephemeral() => AsyncCache(Duration.zero);
       |
       |  /// Returns a cached value from a previous call to [fetch], or runs [callback]
       |  /// to compute a new one.
       |  ///
       |  /// If [fetch] has been called recently enough, returns its previous return
       |  /// value. Otherwise, runs [callback] and returns its new return value.
      0|  Future<T> fetch(Future<T> Function() callback) async {
      0|    if (_cachedStreamSplitter != null) {
      0|      throw StateError('Previously used to cache via `fetchStream`');
       |    }
      0|    if (_cachedValueFuture == null) {
      0|      _cachedValueFuture = callback();
      0|      await _cachedValueFuture;
      0|      _startStaleTimer();
       |    }
      0|    return _cachedValueFuture;
       |  }
       |
       |  /// Returns a cached stream from a previous call to [fetchStream], or runs
       |  /// [callback] to compute a new stream.
       |  ///
       |  /// If [fetchStream] has been called recently enough, returns a copy of its
       |  /// previous return value. Otherwise, runs [callback] and returns its new
       |  /// return value.
      0|  Stream<T> fetchStream(Stream<T> Function() callback) {
      0|    if (_cachedValueFuture != null) {
      0|      throw StateError('Previously used to cache via `fetch`');
       |    }
      0|    _cachedStreamSplitter ??= StreamSplitter(
      0|        callback().transform(StreamTransformer.fromHandlers(handleDone: (sink) {
      0|      _startStaleTimer();
      0|      sink.close();
       |    })));
      0|    return _cachedStreamSplitter.split();
       |  }
       |
       |  /// Removes any cached value.
      0|  void invalidate() {
       |    // TODO: This does not return a future, but probably should.
      0|    _cachedValueFuture = null;
       |    // TODO: This does not await, but probably should.
      0|    _cachedStreamSplitter?.close();
      0|    _cachedStreamSplitter = null;
      0|    _stale?.cancel();
      0|    _stale = null;
       |  }
       |
      0|  void _startStaleTimer() {
      0|    _stale = Timer(_duration, invalidate);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/async_memoizer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A class for running an asynchronous function exactly once and caching its
       |/// result.
       |///
       |/// An `AsyncMemoizer` is used when some function may be run multiple times in
       |/// order to get its result, but it only actually needs to be run once for its
       |/// effect. To memoize the result of an async function, you can create a
       |/// memoizer outside the function (for example as an instance field if you want
       |/// to memoize the result of a method), and then wrap the function's body in a
       |/// call to [runOnce].
       |///
       |/// This is useful for methods like `close()` and getters that need to do
       |/// asynchronous work. For example:
       |///
       |/// ```dart
       |/// class SomeResource {
       |///   final _closeMemo = AsyncMemoizer();
       |///
       |///   Future close() => _closeMemo.runOnce(() {
       |///     // ...
       |///   });
       |/// }
       |/// ```
       |class AsyncMemoizer<T> {
       |  /// The future containing the method's result.
       |  ///
       |  /// This can be accessed at any time, and will fire once [runOnce] is called.
      3|  Future<T> get future => _completer.future;
       |  final _completer = Completer<T>();
       |
       |  /// Whether [runOnce] has been called yet.
      3|  bool get hasRun => _completer.isCompleted;
       |
       |  /// Runs the function, [computation], if it hasn't been run before.
       |  ///
       |  /// If [runOnce] has already been called, this returns the original result.
      1|  Future<T> runOnce(FutureOr<T> Function() computation) {
      4|    if (!hasRun) _completer.complete(Future.sync(computation));
      1|    return future;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/byte_collector.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:typed_data';
       |import 'cancelable_operation.dart';
       |
       |/// Collects an asynchronous sequence of byte lists into a single list of bytes.
       |///
       |/// If the [source] stream emits an error event,
       |/// the collection fails and the returned future completes with the same error.
       |///
       |/// If any of the input data are not valid bytes, they will be truncated to
       |/// an eight-bit unsigned value in the resulting list.
      0|Future<Uint8List> collectBytes(Stream<List<int>> source) {
      0|  return _collectBytes(source, (_, result) => result);
       |}
       |
       |/// Collects an asynchronous sequence of byte lists into a single list of bytes.
       |///
       |/// Returns a [CancelableOperation] that provides the result future and a way
       |/// to cancel the collection early.
       |///
       |/// If the [source] stream emits an error event,
       |/// the collection fails and the returned future completes with the same error.
       |///
       |/// If any of the input data are not valid bytes, they will be truncated to
       |/// an eight-bit unsigned value in the resulting list.
      0|CancelableOperation<Uint8List> collectBytesCancelable(
       |    Stream<List<int>> source) {
      0|  return _collectBytes(
       |      source,
      0|      (subscription, result) => CancelableOperation.fromFuture(result,
      0|          onCancel: subscription.cancel));
       |}
       |
       |/// Generalization over [collectBytes] and [collectBytesCancelable].
       |///
       |/// Performs all the same operations, but the final result is created
       |/// by the [result] function, which has access to the stream subscription
       |/// so it can cancel the operation.
      0|T _collectBytes<T>(Stream<List<int>> source,
       |    T Function(StreamSubscription<List<int>>, Future<Uint8List>) result) {
      0|  var byteLists = <List<int>>[];
       |  var length = 0;
      0|  var completer = Completer<Uint8List>.sync();
      0|  var subscription = source.listen(
      0|      (bytes) {
      0|        byteLists.add(bytes);
      0|        length += bytes.length;
       |      },
      0|      onError: completer.completeError,
      0|      onDone: () {
      0|        completer.complete(_collect(length, byteLists));
       |      },
       |      cancelOnError: true);
      0|  return result(subscription, completer.future);
       |}
       |
       |// Join a lists of bytes with a known total length into a single [Uint8List].
      0|Uint8List _collect(int length, List<List<int>> byteLists) {
      0|  var result = Uint8List(length);
       |  var i = 0;
      0|  for (var byteList in byteLists) {
      0|    var end = i + byteList.length;
      0|    result.setRange(i, end, byteList);
       |    i = end;
       |  }
       |  return result;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/cancelable_operation.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |import 'utils.dart';
       |
       |/// An asynchronous operation that can be cancelled.
       |///
       |/// The value of this operation is exposed as [value]. When this operation is
       |/// cancelled, [value] won't complete either successfully or with an error. If
       |/// [value] has already completed, cancelling the operation does nothing.
       |class CancelableOperation<T> {
       |  /// The completer that produced this operation.
       |  ///
       |  /// This is canceled when [cancel] is called.
       |  final CancelableCompleter<T> _completer;
       |
      0|  CancelableOperation._(this._completer);
       |
       |  /// Creates a [CancelableOperation] wrapping [inner].
       |  ///
       |  /// When this operation is canceled, [onCancel] will be called and any value
       |  /// or error produced by [inner] will be discarded. If [onCancel] returns a
       |  /// [Future], it will be forwarded to [cancel].
       |  ///
       |  /// [onCancel] will be called synchronously when the operation is canceled.
       |  /// It's guaranteed to only be called once.
       |  ///
       |  /// Calling this constructor is equivalent to creating a [CancelableCompleter]
       |  /// and completing it with [inner]. As such, [isCompleted] is true from the
       |  /// moment this [CancelableOperation] is created, regardless of whether
       |  /// [inner] has completed yet or not.
      0|  factory CancelableOperation.fromFuture(Future<T> inner,
       |      {FutureOr Function() onCancel}) {
      0|    var completer = CancelableCompleter<T>(onCancel: onCancel);
      0|    completer.complete(inner);
      0|    return completer.operation;
       |  }
       |
       |  /// The value returned by the operation.
      0|  Future<T> get value => _completer._inner.future;
       |
       |  /// Creates a [Stream] containing the result of this operation.
       |  ///
       |  /// This is like `value.asStream()`, but if a subscription to the stream is
       |  /// canceled, this is as well.
      0|  Stream<T> asStream() {
       |    var controller =
      0|        StreamController<T>(sync: true, onCancel: _completer._cancel);
       |
      0|    value.then((value) {
      0|      controller.add(value);
      0|      controller.close();
      0|    }, onError: (error, StackTrace stackTrace) {
      0|      controller.addError(error, stackTrace);
      0|      controller.close();
       |    });
      0|    return controller.stream;
       |  }
       |
       |  /// Creates a [Future] that completes when this operation completes *or* when
       |  /// it's cancelled.
       |  ///
       |  /// If this operation completes, this completes to the same result as [value].
       |  /// If this operation is cancelled, the returned future waits for the future
       |  /// returned by [cancel], then completes to [cancellationValue].
      0|  Future<T> valueOrCancellation([T cancellationValue]) {
      0|    var completer = Completer<T>.sync();
      0|    value.then((result) => completer.complete(result),
      0|        onError: completer.completeError);
       |
      0|    _completer._cancelMemo.future.then((_) {
      0|      completer.complete(cancellationValue);
      0|    }, onError: completer.completeError);
       |
      0|    return completer.future;
       |  }
       |
       |  /// Registers callbacks to be called when this operation completes.
       |  ///
       |  /// [onValue] and [onError] behave in the same way as [Future.then].
       |  ///
       |  /// If [onCancel] is provided, and this operation is canceled, the [onCancel]
       |  /// callback is called and the returned operation completes with the result.
       |  ///
       |  /// If [onCancel] is not given, and this operation is canceled, then the
       |  /// returned operation is canceled.
       |  ///
       |  /// If [propagateCancel] is `true` and the returned operation is canceled then
       |  /// this operation is canceled. The default is `false`.
      0|  CancelableOperation<R> then<R>(FutureOr<R> Function(T) onValue,
       |      {FutureOr<R> Function(Object, StackTrace) onError,
       |      FutureOr<R> Function() onCancel,
       |      bool propagateCancel = false}) {
       |    final completer =
      0|        CancelableCompleter<R>(onCancel: propagateCancel ? cancel : null);
       |
      0|    valueOrCancellation().then((T result) {
      0|      if (!completer.isCanceled) {
      0|        if (isCompleted) {
      0|          completer.complete(Future.sync(() => onValue(result)));
       |        } else if (onCancel != null) {
      0|          completer.complete(Future.sync(onCancel));
       |        } else {
      0|          completer._cancel();
       |        }
       |      }
      0|    }, onError: (error, StackTrace stackTrace) {
      0|      if (!completer.isCanceled) {
       |        if (onError != null) {
      0|          completer.complete(Future.sync(() => onError(error, stackTrace)));
       |        } else {
      0|          completer.completeError(error, stackTrace);
       |        }
       |      }
       |    });
      0|    return completer.operation;
       |  }
       |
       |  /// Cancels this operation.
       |  ///
       |  /// This returns the [Future] returned by the [CancelableCompleter]'s
       |  /// `onCancel` callback. Unlike [Stream.cancel], it never returns `null`.
      0|  Future cancel() => _completer._cancel();
       |
       |  /// Whether this operation has been canceled before it completed.
      0|  bool get isCanceled => _completer.isCanceled;
       |
       |  /// Whether the [CancelableCompleter] backing this operation has been
       |  /// completed.
       |  ///
       |  /// This value being true does not imply that the [value] future has
       |  /// completed, but merely that it is no longer possible to [cancel] the
       |  /// operation.
      0|  bool get isCompleted => _completer.isCompleted;
       |}
       |
       |/// A completer for a [CancelableOperation].
       |class CancelableCompleter<T> {
       |  /// The completer for the wrapped future.
       |  final Completer<T> _inner;
       |
       |  /// The callback to call if the future is canceled.
       |  final FutureOrCallback _onCancel;
       |
       |  /// Creates a new completer for a [CancelableOperation].
       |  ///
       |  /// When the future operation canceled, as long as the completer hasn't yet
       |  /// completed, [onCancel] is called. If [onCancel] returns a [Future], it's
       |  /// forwarded to [CancelableOperation.cancel].
       |  ///
       |  /// [onCancel] will be called synchronously when the operation is canceled.
       |  /// It's guaranteed to only be called once.
      0|  CancelableCompleter({FutureOr Function() onCancel})
       |      : _onCancel = onCancel,
      0|        _inner = Completer<T>() {
      0|    _operation = CancelableOperation<T>._(this);
       |  }
       |
       |  /// The operation controlled by this completer.
      0|  CancelableOperation<T> get operation => _operation;
       |  CancelableOperation<T> _operation;
       |
       |  /// Whether the completer has completed.
      0|  bool get isCompleted => _isCompleted;
       |  bool _isCompleted = false;
       |
       |  /// Whether the completer was canceled before being completed.
      0|  bool get isCanceled => _isCanceled;
       |  bool _isCanceled = false;
       |
       |  /// The memoizer for [_cancel].
       |  final _cancelMemo = AsyncMemoizer();
       |
       |  /// Completes [operation] to [value].
       |  ///
       |  /// If [value] is a [Future], this will complete to the result of that
       |  /// [Future] once it completes.
      0|  void complete([FutureOr<T> value]) {
      0|    if (_isCompleted) throw StateError('Operation already completed');
      0|    _isCompleted = true;
       |
      0|    if (value is! Future) {
      0|      if (_isCanceled) return;
      0|      _inner.complete(value);
       |      return;
       |    }
       |
       |    final future = value as Future<T>;
      0|    if (_isCanceled) {
       |      // Make sure errors from [value] aren't top-leveled.
      0|      future.catchError((_) {});
       |      return;
       |    }
       |
      0|    future.then((result) {
      0|      if (_isCanceled) return;
      0|      _inner.complete(result);
      0|    }, onError: (error, StackTrace stackTrace) {
      0|      if (_isCanceled) return;
      0|      _inner.completeError(error, stackTrace);
       |    });
       |  }
       |
       |  /// Completes [operation] to [error].
      0|  void completeError(Object error, [StackTrace stackTrace]) {
      0|    if (_isCompleted) throw StateError('Operation already completed');
      0|    _isCompleted = true;
       |
      0|    if (_isCanceled) return;
      0|    _inner.completeError(error, stackTrace);
       |  }
       |
       |  /// Cancel the completer.
      0|  Future _cancel() {
      0|    if (_inner.isCompleted) return Future.value();
       |
      0|    return _cancelMemo.runOnce(() {
      0|      _isCanceled = true;
      0|      if (_onCancel != null) return _onCancel();
       |    });
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/delegate/event_sink.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Simple delegating wrapper around an [EventSink].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [EventSink] methods of a subclass.
       |class DelegatingEventSink<T> implements EventSink<T> {
       |  final EventSink _sink;
       |
       |  /// Create a delegating sink forwarding calls to [sink].
      0|  DelegatingEventSink(EventSink<T> sink) : _sink = sink;
       |
      0|  DelegatingEventSink._(this._sink);
       |
       |  /// Creates a wrapper that coerces the type of [sink].
       |  ///
       |  /// Unlike [new DelegatingEventSink], this only requires its argument to be an
       |  /// instance of `EventSink`, not `EventSink<T>`. This means that calls to
       |  /// [add] may throw a [CastError] if the argument type doesn't match the
       |  /// reified type of [sink].
      0|  @Deprecated(
       |      'Use StreamController<T>(sync: true)..stream.cast<S>().pipe(sink)')
       |  static EventSink<T> typed<T>(EventSink sink) =>
      0|      sink is EventSink<T> ? sink : DelegatingEventSink._(sink);
       |
      0|  @override
       |  void add(T data) {
      0|    _sink.add(data);
       |  }
       |
      0|  @override
       |  void addError(error, [StackTrace stackTrace]) {
      0|    _sink.addError(error, stackTrace);
       |  }
       |
      0|  @override
       |  void close() {
      0|    _sink.close();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/delegate/future.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A wrapper that forwards calls to a [Future].
       |class DelegatingFuture<T> implements Future<T> {
       |  /// The wrapped [Future].
       |  final Future<T> _future;
       |
      0|  DelegatingFuture(this._future);
       |
       |  /// Creates a wrapper which throws if [future]'s value isn't an instance of
       |  /// `T`.
       |  ///
       |  /// This soundly converts a [Future] to a `Future<T>`, regardless of its
       |  /// original generic type, by asserting that its value is an instance of `T`
       |  /// whenever it's provided. If it's not, the future throws a [CastError].
      0|  @Deprecated('Use future.then((v) => v as T) instead.')
       |  static Future<T> typed<T>(Future future) =>
      0|      future is Future<T> ? future : future.then((v) => v as T);
       |
      0|  @override
      0|  Stream<T> asStream() => _future.asStream();
       |
      0|  @override
       |  Future<T> catchError(Function onError, {bool Function(Object error) test}) =>
      0|      _future.catchError(onError, test: test);
       |
      0|  @override
       |  Future<S> then<S>(FutureOr<S> Function(T) onValue, {Function onError}) =>
      0|      _future.then(onValue, onError: onError);
       |
      0|  @override
       |  Future<T> whenComplete(FutureOr Function() action) =>
      0|      _future.whenComplete(action);
       |
      0|  @override
       |  Future<T> timeout(Duration timeLimit, {FutureOr<T> Function() onTimeout}) =>
      0|      _future.timeout(timeLimit, onTimeout: onTimeout);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/delegate/sink.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Simple delegating wrapper around a [Sink].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [Sink] methods of a subclass.
       |class DelegatingSink<T> implements Sink<T> {
       |  final Sink _sink;
       |
       |  /// Create a delegating sink forwarding calls to [sink].
      1|  DelegatingSink(Sink<T> sink) : _sink = sink;
       |
      0|  DelegatingSink._(this._sink);
       |
       |  /// Creates a wrapper that coerces the type of [sink].
       |  ///
       |  /// Unlike [new DelegatingSink], this only requires its argument to be an
       |  /// instance of `Sink`, not `Sink<T>`. This means that calls to [add] may
       |  /// throw a [CastError] if the argument type doesn't match the reified type of
       |  /// [sink].
      0|  @Deprecated(
       |      'Use StreamController<T>(sync: true)..stream.cast<S>().pipe(sink)')
       |  static Sink<T> typed<T>(Sink sink) =>
      0|      sink is Sink<T> ? sink : DelegatingSink._(sink);
       |
      1|  @override
       |  void add(T data) {
      2|    _sink.add(data);
       |  }
       |
      1|  @override
       |  void close() {
      2|    _sink.close();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/delegate/stream.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Simple delegating wrapper around a [Stream].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [Stream] methods of a subclass.
       |///
       |/// Note that this is identical to [StreamView] in `dart:async`. It's provided
       |/// under this name for consistency with other `Delegating*` classes.
       |class DelegatingStream<T> extends StreamView<T> {
      0|  DelegatingStream(Stream<T> stream) : super(stream);
       |
       |  /// Creates a wrapper which throws if [stream]'s events aren't instances of
       |  /// `T`.
       |  ///
       |  /// This soundly converts a [Stream] to a `Stream<T>`, regardless of its
       |  /// original generic type, by asserting that its events are instances of `T`
       |  /// whenever they're provided. If they're not, the stream throws a
       |  /// [CastError].
      0|  @Deprecated('Use stream.cast instead')
      0|  static Stream<T> typed<T>(Stream stream) => stream.cast();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/delegate/stream_consumer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Simple delegating wrapper around a [StreamConsumer].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [StreamConsumer] methods of a subclass.
       |class DelegatingStreamConsumer<T> implements StreamConsumer<T> {
       |  final StreamConsumer _consumer;
       |
       |  /// Create a delegating consumer forwarding calls to [consumer].
      0|  DelegatingStreamConsumer(StreamConsumer<T> consumer) : _consumer = consumer;
       |
      0|  DelegatingStreamConsumer._(this._consumer);
       |
       |  /// Creates a wrapper that coerces the type of [consumer].
       |  ///
       |  /// Unlike [new StreamConsumer], this only requires its argument to be an
       |  /// instance of `StreamConsumer`, not `StreamConsumer<T>`. This means that
       |  /// calls to [addStream] may throw a [CastError] if the argument type doesn't
       |  /// match the reified type of [consumer].
      0|  @Deprecated(
       |      'Use StreamController<T>(sync: true)..stream.cast<S>().pipe(sink)')
       |  static StreamConsumer<T> typed<T>(StreamConsumer consumer) =>
      0|      consumer is StreamConsumer<T>
       |          ? consumer
      0|          : DelegatingStreamConsumer._(consumer);
       |
      0|  @override
      0|  Future addStream(Stream<T> stream) => _consumer.addStream(stream);
       |
      0|  @override
      0|  Future close() => _consumer.close();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/delegate/stream_sink.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Simple delegating wrapper around a [StreamSink].
       |///
       |/// Subclasses can override individual methods, or use this to expose only the
       |/// [StreamSink] methods of a subclass.
       |class DelegatingStreamSink<T> implements StreamSink<T> {
       |  final StreamSink _sink;
       |
      0|  @override
      0|  Future get done => _sink.done;
       |
       |  /// Create delegating sink forwarding calls to [sink].
      0|  DelegatingStreamSink(StreamSink<T> sink) : _sink = sink;
       |
      0|  DelegatingStreamSink._(this._sink);
       |
       |  /// Creates a wrapper that coerces the type of [sink].
       |  ///
       |  /// Unlike [new StreamSink], this only requires its argument to be an instance
       |  /// of `StreamSink`, not `StreamSink<T>`. This means that calls to [add] may
       |  /// throw a [CastError] if the argument type doesn't match the reified type of
       |  /// [sink].
      0|  @Deprecated(
       |      'Use StreamController<T>(sync: true)..stream.cast<S>().pipe(sink)')
       |  static StreamSink<T> typed<T>(StreamSink sink) =>
      0|      sink is StreamSink<T> ? sink : DelegatingStreamSink._(sink);
       |
      0|  @override
       |  void add(T data) {
      0|    _sink.add(data);
       |  }
       |
      0|  @override
       |  void addError(error, [StackTrace stackTrace]) {
      0|    _sink.addError(error, stackTrace);
       |  }
       |
      0|  @override
      0|  Future addStream(Stream<T> stream) => _sink.addStream(stream);
       |
      0|  @override
      0|  Future close() => _sink.close();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/delegate/stream_subscription.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../typed/stream_subscription.dart';
       |
       |/// Simple delegating wrapper around a [StreamSubscription].
       |///
       |/// Subclasses can override individual methods.
       |class DelegatingStreamSubscription<T> implements StreamSubscription<T> {
       |  final StreamSubscription<T> _source;
       |
       |  /// Create delegating subscription forwarding calls to [sourceSubscription].
      0|  DelegatingStreamSubscription(StreamSubscription<T> sourceSubscription)
       |      : _source = sourceSubscription;
       |
       |  /// Creates a wrapper which throws if [subscription]'s events aren't instances
       |  /// of `T`.
       |  ///
       |  /// This soundly converts a [StreamSubscription] to a `StreamSubscription<T>`,
       |  /// regardless of its original generic type, by asserting that its events are
       |  /// instances of `T` whenever they're provided. If they're not, the
       |  /// subscription throws a [CastError].
      0|  @Deprecated('Use Stream.cast instead')
       |  // TODO - Remove `TypeSafeStreamSubscription` and tests when removing this.
       |  static StreamSubscription<T> typed<T>(StreamSubscription subscription) =>
      0|      subscription is StreamSubscription<T>
       |          ? subscription
      0|          : TypeSafeStreamSubscription<T>(subscription);
       |
      0|  @override
       |  void onData(void Function(T) handleData) {
      0|    _source.onData(handleData);
       |  }
       |
      0|  @override
       |  void onError(Function handleError) {
      0|    _source.onError(handleError);
       |  }
       |
      0|  @override
       |  void onDone(void Function() handleDone) {
      0|    _source.onDone(handleDone);
       |  }
       |
      0|  @override
       |  void pause([Future resumeFuture]) {
      0|    _source.pause(resumeFuture);
       |  }
       |
      0|  @override
       |  void resume() {
      0|    _source.resume();
       |  }
       |
      0|  @override
      0|  Future cancel() => _source.cancel();
       |
      0|  @override
      0|  Future<E> asFuture<E>([E futureValue]) => _source.asFuture(futureValue);
       |
      0|  @override
      0|  bool get isPaused => _source.isPaused;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/future_group.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A collection of futures waits until all added [Future]s complete.
       |///
       |/// Futures are added to the group with [add]. Once you're finished adding
       |/// futures, signal that by calling [close]. Then, once all added futures have
       |/// completed, [future] will complete with a list of values from the futures in
       |/// the group, in the order they were added.
       |///
       |/// If any added future completes with an error, [future] will emit that error
       |/// and the group will be closed, regardless of the state of other futures in
       |/// the group.
       |///
       |/// This is similar to [Future.wait] with `eagerError` set to `true`, except
       |/// that a [FutureGroup] can have futures added gradually over time rather than
       |/// needing them all at once.
       |class FutureGroup<T> implements Sink<Future<T>> {
       |  /// The number of futures that have yet to complete.
       |  var _pending = 0;
       |
       |  /// Whether [close] has been called.
       |  var _closed = false;
       |
       |  /// The future that fires once [close] has been called and all futures in the
       |  /// group have completed.
       |  ///
       |  /// This will also complete with an error if any of the futures in the group
       |  /// fails, regardless of whether [close] was called.
      3|  Future<List<T>> get future => _completer.future;
       |  final _completer = Completer<List<T>>();
       |
       |  /// Whether this group has no pending futures.
      0|  bool get isIdle => _pending == 0;
       |
       |  /// A broadcast stream that emits a `null` event whenever the last pending
       |  /// future in this group completes.
       |  ///
       |  /// Once this group isn't waiting on any futures *and* [close] has been
       |  /// called, this stream will close.
      0|  Stream get onIdle =>
      0|      (_onIdleController ??= StreamController.broadcast(sync: true)).stream;
       |
       |  StreamController _onIdleController;
       |
       |  /// The values emitted by the futures that have been added to the group, in
       |  /// the order they were added.
       |  ///
       |  /// The slots for futures that haven't completed yet are `null`.
       |  final _values = <T>[];
       |
       |  /// Wait for [task] to complete.
      1|  @override
       |  void add(Future<T> task) {
      1|    if (_closed) throw StateError('The FutureGroup is closed.');
       |
       |    // Ensure that future values are put into [values] in the same order they're
       |    // added to the group by pre-allocating a slot for them and recording its
       |    // index.
      2|    var index = _values.length;
      2|    _values.add(null);
       |
      2|    _pending++;
      2|    task.then((value) {
      2|      if (_completer.isCompleted) return null;
       |
      2|      _pending--;
      2|      _values[index] = value;
       |
      2|      if (_pending != 0) return null;
      1|      if (_onIdleController != null) _onIdleController.add(null);
       |
      1|      if (!_closed) return null;
      1|      if (_onIdleController != null) _onIdleController.close();
      3|      _completer.complete(_values);
      1|    }).catchError((error, StackTrace stackTrace) {
      0|      if (_completer.isCompleted) return null;
      0|      _completer.completeError(error, stackTrace);
       |    });
       |  }
       |
       |  /// Signals to the group that the caller is done adding futures, and so
       |  /// [future] should fire once all added futures have completed.
      1|  @override
       |  void close() {
      1|    _closed = true;
      2|    if (_pending != 0) return;
      2|    if (_completer.isCompleted) return;
      3|    _completer.complete(_values);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/lazy_stream.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'stream_completer.dart';
       |import 'utils.dart';
       |
       |/// A [Stream] wrapper that forwards to another [Stream] that's initialized
       |/// lazily.
       |///
       |/// This class allows a concrete `Stream` to be created only once it has a
       |/// listener. It's useful to wrapping APIs that do expensive computation to
       |/// produce a `Stream`.
       |class LazyStream<T> extends Stream<T> {
       |  /// The callback that's called to create the inner stream.
       |  FutureOrCallback<Stream<T>> _callback;
       |
       |  /// Creates a single-subscription `Stream` that calls [callback] when it gets
       |  /// a listener and forwards to the returned stream.
      0|  LazyStream(FutureOr<Stream<T>> Function() callback) : _callback = callback {
       |    // Explicitly check for null because we null out [_callback] internally.
      0|    if (_callback == null) throw ArgumentError.notNull('callback');
       |  }
       |
      0|  @override
       |  StreamSubscription<T> listen(void Function(T) onData,
       |      {Function onError, void Function() onDone, bool cancelOnError}) {
      0|    if (_callback == null) {
      0|      throw StateError('Stream has already been listened to.');
       |    }
       |
       |    // Null out the callback before we invoke it to ensure that even while
       |    // running it, this can't be called twice.
      0|    var callback = _callback;
      0|    _callback = null;
      0|    var result = callback();
       |
       |    Stream<T> stream;
      0|    if (result is Future<Stream<T>>) {
      0|      stream = StreamCompleter.fromFuture(result);
       |    } else {
       |      stream = result as Stream<T>;
       |    }
       |
      0|    return stream.listen(onData,
       |        onError: onError, onDone: onDone, cancelOnError: cancelOnError);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/null_stream_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A [StreamSink] that discards all events.
       |///
       |/// The sink silently drops events until [close] is called, at which point it
       |/// throws [StateError]s when events are added. This is the same behavior as a
       |/// sink whose remote end has closed, such as when a [WebSocket] connection has
       |/// been closed.
       |///
       |/// This can be used when a sink is needed but no events are actually intended
       |/// to be added. The [NullStreamSink.error] constructor can be used to
       |/// represent errors when creating a sink, since [StreamSink.done] exposes sink
       |/// errors. For example:
       |///
       |/// ```dart
       |/// StreamSink<List<int>> openForWrite(String filename) {
       |///   try {
       |///     return RandomAccessSink(File(filename).openSync());
       |///   } on IOException catch (error, stackTrace) {
       |///     return NullStreamSink.error(error, stackTrace);
       |///   }
       |/// }
       |/// ```
       |class NullStreamSink<T> implements StreamSink<T> {
       |  @override
       |  final Future done;
       |
       |  /// Whether the sink has been closed.
       |  var _closed = false;
       |
       |  /// Whether an [addStream] call is pending.
       |  ///
       |  /// We don't actually add any events from streams, but it does return the
       |  /// [StreamSubscription.cancel] future so to be [StreamSink]-complaint we
       |  /// reject events until that completes.
       |  var _addingStream = false;
       |
       |  /// Creates a null sink.
       |  ///
       |  /// If [done] is passed, it's used as the [Sink.done] future. Otherwise, a
       |  /// completed future is used.
      0|  NullStreamSink({Future done}) : done = done ?? Future.value();
       |
       |  /// Creates a null sink whose [done] future emits [error].
       |  ///
       |  /// Note that this error will not be considered uncaught.
      0|  NullStreamSink.error(error, [StackTrace stackTrace])
      0|      : done = Future.error(error, stackTrace)
       |          // Don't top-level the error. This gives the user a change to call
       |          // [close] or [done], and matches the behavior of a remote endpoint
       |          // experiencing an error.
      0|          ..catchError((_) {});
       |
      0|  @override
       |  void add(T data) {
      0|    _checkEventAllowed();
       |  }
       |
      0|  @override
       |  void addError(error, [StackTrace stackTrace]) {
      0|    _checkEventAllowed();
       |  }
       |
      0|  @override
       |  Future addStream(Stream<T> stream) {
      0|    _checkEventAllowed();
       |
      0|    _addingStream = true;
      0|    var future = stream.listen(null).cancel() ?? Future.value();
      0|    return future.whenComplete(() {
      0|      _addingStream = false;
       |    });
       |  }
       |
       |  /// Throws a [StateError] if [close] has been called or an [addStream] call is
       |  /// pending.
      0|  void _checkEventAllowed() {
      0|    if (_closed) throw StateError('Cannot add to a closed sink.');
      0|    if (_addingStream) {
      0|      throw StateError('Cannot add to a sink while adding a stream.');
       |    }
       |  }
       |
      0|  @override
       |  Future close() {
      0|    _closed = true;
      0|    return done;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/restartable_timer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A non-periodic timer that can be restarted any number of times.
       |///
       |/// Once restarted (via [reset]), the timer counts down from its original
       |/// duration again.
       |class RestartableTimer implements Timer {
       |  /// The duration of the timer.
       |  final Duration _duration;
       |
       |  /// The callback to call when the timer fires.
       |  final ZoneCallback _callback;
       |
       |  /// The timer for the current or most recent countdown.
       |  ///
       |  /// This timer is canceled and overwritten every time this [RestartableTimer]
       |  /// is reset.
       |  Timer _timer;
       |
       |  /// Creates a new timer.
       |  ///
       |  /// The [callback] function is invoked after the given [duration]. Unlike a
       |  /// normal non-periodic [Timer], [callback] may be called more than once.
      0|  RestartableTimer(this._duration, this._callback)
      0|      : _timer = Timer(_duration, _callback);
       |
      0|  @override
      0|  bool get isActive => _timer.isActive;
       |
       |  /// Restarts the timer so that it counts down from its original duration
       |  /// again.
       |  ///
       |  /// This restarts the timer even if it has already fired or has been canceled.
      0|  void reset() {
      0|    _timer.cancel();
      0|    _timer = Timer(_duration, _callback);
       |  }
       |
      0|  @override
       |  void cancel() {
      0|    _timer.cancel();
       |  }
       |
       |  /// The number of durations preceding the most recent timer event on the most
       |  /// recent countdown.
       |  ///
       |  /// Calls to [reset] will also reset the tick so subsequent tick values may
       |  /// not be strictly larger than previous values.
      0|  @override
      0|  int get tick => _timer.tick;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/result/result.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'capture_sink.dart';
       |import 'capture_transformer.dart';
       |import 'error.dart';
       |import 'release_sink.dart';
       |import 'release_transformer.dart';
       |import 'value.dart';
       |import '../stream_sink_transformer.dart';
       |
       |/// The result of a computation.
       |///
       |/// Capturing a result (either a returned value or a thrown error) means
       |/// converting it into a [Result] - either a [ValueResult] or an [ErrorResult].
       |///
       |/// This value can release itself by writing itself either to a [EventSink] or a
       |/// [Completer], or by becoming a [Future].
       |///
       |/// A [Future] represents a potential result, one that might not have been
       |/// computed yet, and a [Result] is always a completed and available result.
       |abstract class Result<T> {
       |  /// A stream transformer that captures a stream of events into [Result]s.
       |  ///
       |  /// The result of the transformation is a stream of [Result] values and no
       |  /// error events. This is the transformer used by [captureStream].
       |  static const StreamTransformer<Object, Result<Object>>
       |      captureStreamTransformer = CaptureStreamTransformer<Object>();
       |
       |  /// A stream transformer that releases a stream of result events.
       |  ///
       |  /// The result of the transformation is a stream of values and error events.
       |  /// This is the transformer used by [releaseStream].
       |  static const StreamTransformer<Result<Object>, Object>
       |      releaseStreamTransformer = ReleaseStreamTransformer<Object>();
       |
       |  /// A sink transformer that captures events into [Result]s.
       |  ///
       |  /// The result of the transformation is a sink that only forwards [Result]
       |  /// values and no error events.
       |  static const StreamSinkTransformer<Object, Result<Object>>
       |      captureSinkTransformer =
       |      StreamSinkTransformer<Object, Result<Object>>.fromStreamTransformer(
       |          CaptureStreamTransformer<Object>());
       |
       |  /// A sink transformer that releases result events.
       |  ///
       |  /// The result of the transformation is a sink that forwards of values and
       |  /// error events.
       |  static const StreamSinkTransformer<Result<Object>, Object>
       |      releaseSinkTransformer =
       |      StreamSinkTransformer<Result<Object>, Object>.fromStreamTransformer(
       |          ReleaseStreamTransformer<Object>());
       |
       |  /// Creates a `Result` with the result of calling [computation].
       |  ///
       |  /// This generates either a [ValueResult] with the value returned by
       |  /// calling `computation`, or an [ErrorResult] with an error thrown by
       |  /// the call.
      0|  factory Result(T Function() computation) {
       |    try {
      0|      return ValueResult<T>(computation());
       |    } catch (e, s) {
      0|      return ErrorResult(e, s);
       |    }
       |  }
       |
       |  /// Creates a `Result` holding a value.
       |  ///
       |  /// Alias for [ValueResult.ValueResult].
       |  factory Result.value(T value) = ValueResult<T>;
       |
       |  /// Creates a `Result` holding an error.
       |  ///
       |  /// Alias for [ErrorResult.ErrorResult].
      0|  factory Result.error(Object error, [StackTrace stackTrace]) =>
      0|      ErrorResult(error, stackTrace);
       |
       |  /// Captures the result of a future into a `Result` future.
       |  ///
       |  /// The resulting future will never have an error.
       |  /// Errors have been converted to an [ErrorResult] value.
      0|  static Future<Result<T>> capture<T>(Future<T> future) {
      0|    return future.then((value) => ValueResult(value),
      0|        onError: (error, StackTrace stackTrace) =>
      0|            ErrorResult(error, stackTrace));
       |  }
       |
       |  /// Captures each future in [elements],
       |  ///
       |  /// Returns a (future of) a list of results for each element in [elements],
       |  /// in iteration order.
       |  /// Each future in [elements] is [capture]d and each non-future is
       |  /// wrapped as a [Result.value].
       |  /// The returned future will never have an error.
      0|  static Future<List<Result<T>>> captureAll<T>(Iterable<FutureOr<T>> elements) {
      0|    var results = <Result<T>>[];
       |    var pending = 0;
       |    Completer<List<Result<T>>> completer;
      0|    for (var element in elements) {
      0|      if (element is Future<T>) {
      0|        var i = results.length;
      0|        results.add(null);
      0|        pending++;
      0|        Result.capture<T>(element).then((result) {
      0|          results[i] = result;
      0|          if (--pending == 0) {
      0|            completer.complete(results);
       |          }
       |        });
       |      } else {
      0|        results.add(Result<T>.value(element as T));
       |      }
       |    }
      0|    if (pending == 0) {
      0|      return Future<List<Result<T>>>.value(results);
       |    }
      0|    completer = Completer<List<Result<T>>>();
      0|    return completer.future;
       |  }
       |
       |  /// Releases the result of a captured future.
       |  ///
       |  /// Converts the [Result] value of the given [future] to a value or error
       |  /// completion of the returned future.
       |  ///
       |  /// If [future] completes with an error, the returned future completes with
       |  /// the same error.
      0|  static Future<T> release<T>(Future<Result<T>> future) =>
      0|      future.then<T>((result) => result.asFuture);
       |
       |  /// Captures the results of a stream into a stream of [Result] values.
       |  ///
       |  /// The returned stream will not have any error events.
       |  /// Errors from the source stream have been converted to [ErrorResult]s.
      0|  static Stream<Result<T>> captureStream<T>(Stream<T> source) =>
      0|      source.transform(CaptureStreamTransformer<T>());
       |
       |  /// Releases a stream of [result] values into a stream of the results.
       |  ///
       |  /// `Result` values of the source stream become value or error events in
       |  /// the returned stream as appropriate.
       |  /// Errors from the source stream become errors in the returned stream.
      0|  static Stream<T> releaseStream<T>(Stream<Result<T>> source) =>
      0|      source.transform(ReleaseStreamTransformer<T>());
       |
       |  /// Releases results added to the returned sink as data and errors on [sink].
       |  ///
       |  /// A [Result] added to the returned sink is added as a data or error event
       |  /// on [sink]. Errors added to the returned sink are forwarded directly to
       |  /// [sink] and so is the [EventSink.close] calls.
      0|  static EventSink<Result<T>> releaseSink<T>(EventSink<T> sink) =>
      0|      ReleaseSink<T>(sink);
       |
       |  /// Captures the events of the returned sink into results on [sink].
       |  ///
       |  /// Data and error events added to the returned sink are captured into
       |  /// [Result] values and added as data events on the provided [sink].
       |  /// No error events are ever added to [sink].
       |  ///
       |  /// When the returned sink is closed, so is [sink].
      0|  static EventSink<T> captureSink<T>(EventSink<Result<T>> sink) =>
      0|      CaptureSink<T>(sink);
       |
       |  /// Converts a result of a result to a single result.
       |  ///
       |  /// If the result is an error, or it is a `Result` value
       |  /// which is then an error, then a result with that error is returned.
       |  /// Otherwise both levels of results are value results, and a single
       |  /// result with the value is returned.
      0|  static Result<T> flatten<T>(Result<Result<T>> result) {
      0|    if (result.isValue) return result.asValue.value;
      0|    return result.asError;
       |  }
       |
       |  /// Converts a sequence of results to a result of a list.
       |  ///
       |  /// Returns either a list of values if [results] doesn't contain any errors,
       |  /// or the first error result in [results].
      0|  static Result<List<T>> flattenAll<T>(Iterable<Result<T>> results) {
      0|    var values = <T>[];
      0|    for (var result in results) {
      0|      if (result.isValue) {
      0|        values.add(result.asValue.value);
       |      } else {
      0|        return result.asError;
       |      }
       |    }
      0|    return Result<List<T>>.value(values);
       |  }
       |
       |  /// Whether this result is a value result.
       |  ///
       |  /// Always the opposite of [isError].
       |  bool get isValue;
       |
       |  /// Whether this result is an error result.
       |  ///
       |  /// Always the opposite of [isValue].
       |  bool get isError;
       |
       |  /// If this is a value result, returns itself.
       |  ///
       |  /// Otherwise returns `null`.
       |  ValueResult<T> get asValue;
       |
       |  /// If this is an error result, returns itself.
       |  ///
       |  /// Otherwise returns `null`.
       |  ErrorResult get asError;
       |
       |  /// Completes a completer with this result.
       |  void complete(Completer<T> completer);
       |
       |  /// Adds this result to an [EventSink].
       |  ///
       |  /// Calls the sink's `add` or `addError` method as appropriate.
       |  void addTo(EventSink<T> sink);
       |
       |  /// A future that has been completed with this result as a value or an error.
       |  Future<T> get asFuture;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/result/error.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'result.dart';
       |import 'value.dart';
       |
       |/// A result representing a thrown error.
       |class ErrorResult implements Result<Null> {
       |  /// The error object that was thrown.
       |  final Object error;
       |
       |  /// The stack trace corresponding to where [error] was thrown.
       |  final StackTrace stackTrace;
       |
      0|  @override
       |  bool get isValue => false;
      0|  @override
       |  bool get isError => true;
      0|  @override
       |  ValueResult<Null> get asValue => null;
      0|  @override
       |  ErrorResult get asError => this;
       |
      0|  ErrorResult(this.error, this.stackTrace);
       |
      0|  @override
       |  void complete(Completer completer) {
      0|    completer.completeError(error, stackTrace);
       |  }
       |
      0|  @override
       |  void addTo(EventSink sink) {
      0|    sink.addError(error, stackTrace);
       |  }
       |
      0|  @override
      0|  Future<Null> get asFuture => Future<Null>.error(error, stackTrace);
       |
       |  /// Calls an error handler with the error and stacktrace.
       |  ///
       |  /// An async error handler function is either a function expecting two
       |  /// arguments, which will be called with the error and the stack trace, or it
       |  /// has to be a function expecting only one argument, which will be called
       |  /// with only the error.
      0|  void handle(Function errorHandler) {
      0|    if (errorHandler is ZoneBinaryCallback) {
      0|      errorHandler(error, stackTrace);
       |    } else {
      0|      errorHandler(error);
       |    }
       |  }
       |
      0|  @override
      0|  int get hashCode => error.hashCode ^ stackTrace.hashCode ^ 0x1d61823f;
       |
       |  /// This is equal only to an error result with equal [error] and [stackTrace].
      0|  @override
       |  bool operator ==(Object other) =>
      0|      other is ErrorResult &&
      0|      error == other.error &&
      0|      stackTrace == other.stackTrace;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/result/future.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../delegate/future.dart';
       |import 'result.dart';
       |
       |/// A [Future] wrapper that provides synchronous access to the result of the
       |/// wrapped [Future] once it's completed.
       |class ResultFuture<T> extends DelegatingFuture<T> {
       |  /// Whether the future has fired and [result] is available.
      0|  bool get isComplete => result != null;
       |
       |  /// The result of the wrapped [Future], if it's completed.
       |  ///
       |  /// If it hasn't completed yet, this will be `null`.
      0|  Result<T> get result => _result;
       |  Result<T> _result;
       |
      0|  ResultFuture(Future<T> future) : super(future) {
      0|    Result.capture(future).then((result) {
      0|      _result = result;
       |    });
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/result/value.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'result.dart';
       |import 'error.dart';
       |
       |/// A result representing a returned value.
       |class ValueResult<T> implements Result<T> {
       |  /// The result of a successful computation.
       |  final T value;
       |
      0|  @override
       |  bool get isValue => true;
      0|  @override
       |  bool get isError => false;
      0|  @override
       |  ValueResult<T> get asValue => this;
      0|  @override
       |  ErrorResult get asError => null;
       |
      0|  ValueResult(this.value);
       |
      0|  @override
       |  void complete(Completer<T> completer) {
      0|    completer.complete(value);
       |  }
       |
      0|  @override
       |  void addTo(EventSink<T> sink) {
      0|    sink.add(value);
       |  }
       |
      0|  @override
      0|  Future<T> get asFuture => Future.value(value);
       |
      0|  @override
      0|  int get hashCode => value.hashCode ^ 0x323f1d61;
       |
      0|  @override
       |  bool operator ==(Object other) =>
      0|      other is ValueResult && value == other.value;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/single_subscription_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A transformer that converts a broadcast stream into a single-subscription
       |/// stream.
       |///
       |/// This buffers the broadcast stream's events, which means that it starts
       |/// listening to a stream as soon as it's bound.
       |///
       |/// This also casts the source stream's events to type `T`. If the cast fails,
       |/// the result stream will emit a [CastError]. This behavior is deprecated, and
       |/// should not be relied upon.
       |class SingleSubscriptionTransformer<S, T> extends StreamTransformerBase<S, T> {
      0|  const SingleSubscriptionTransformer();
       |
      0|  @override
       |  Stream<T> bind(Stream<S> stream) {
       |    StreamSubscription<S> subscription;
       |    var controller =
      0|        StreamController<T>(sync: true, onCancel: () => subscription.cancel());
      0|    subscription = stream.listen((value) {
       |      // TODO(nweiz): When we release a new major version, get rid of the second
       |      // type parameter and avoid this conversion.
       |      try {
      0|        controller.add(value as T);
      0|      } on CastError catch (error, stackTrace) {
      0|        controller.addError(error, stackTrace);
       |      }
      0|    }, onError: controller.addError, onDone: controller.close);
      0|    return controller.stream;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_completer.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A single-subscription [stream] where the contents are provided later.
       |///
       |/// It is generally recommended that you never create a `Future<Stream>`
       |/// because you can just directly create a stream that doesn't do anything
       |/// until it's ready to do so.
       |/// This class can be used to create such a stream.
       |///
       |/// The [stream] is a normal stream that you can listen to immediately,
       |/// but until either [setSourceStream] or [setEmpty] is called,
       |/// the stream won't produce any events.
       |///
       |/// The same effect can be achieved by using a [StreamController]
       |/// and adding the stream using `addStream` when both
       |/// the controller's stream is listened to and the source stream is ready.
       |/// This class attempts to shortcut some of the overhead when possible.
       |/// For example, if the [stream] is only listened to
       |/// after the source stream has been set,
       |/// the listen is performed directly on the source stream.
       |class StreamCompleter<T> {
       |  /// The stream doing the actual work, is returned by [stream].
       |  final _stream = _CompleterStream<T>();
       |
       |  /// Convert a `Future<Stream>` to a `Stream`.
       |  ///
       |  /// This creates a stream using a stream completer,
       |  /// and sets the source stream to the result of the future when the
       |  /// future completes.
       |  ///
       |  /// If the future completes with an error, the returned stream will
       |  /// instead contain just that error.
      0|  static Stream<T> fromFuture<T>(Future<Stream<T>> streamFuture) {
      0|    var completer = StreamCompleter<T>();
      0|    streamFuture.then(completer.setSourceStream, onError: completer.setError);
      0|    return completer.stream;
       |  }
       |
       |  /// The stream of this completer.
       |  ///
       |  /// This stream is always a single-subscription stream.
       |  ///
       |  /// When a source stream is provided, its events will be forwarded to
       |  /// listeners on this stream.
       |  ///
       |  /// The stream can be listened either before or after a source stream
       |  /// is set.
      0|  Stream<T> get stream => _stream;
       |
       |  /// Set a stream as the source of events for the [StreamCompleter]'s
       |  /// [stream].
       |  ///
       |  /// The completer's `stream` will act exactly as [sourceStream].
       |  ///
       |  /// If the source stream is set before [stream] is listened to,
       |  /// the listen call on [stream] is forwarded directly to [sourceStream].
       |  ///
       |  /// If [stream] is listened to before setting the source stream,
       |  /// an intermediate subscription is created. It looks like a completely
       |  /// normal subscription, and can be paused or canceled, but it won't
       |  /// produce any events until a source stream is provided.
       |  ///
       |  /// If the `stream` subscription is canceled before a source stream is set,
       |  /// the source stream will be listened to and immediately canceled again.
       |  ///
       |  /// Otherwise, when the source stream is then set,
       |  /// it is immediately listened to, and its events are forwarded to the
       |  /// existing subscription.
       |  ///
       |  /// Any one of [setSourceStream], [setEmpty], and [setError] may be called at
       |  /// most once. Trying to call any of them again will fail.
      0|  void setSourceStream(Stream<T> sourceStream) {
      0|    if (_stream._isSourceStreamSet) {
      0|      throw StateError('Source stream already set');
       |    }
      0|    _stream._setSourceStream(sourceStream);
       |  }
       |
       |  /// Equivalent to setting an empty stream using [setSourceStream].
       |  ///
       |  /// Any one of [setSourceStream], [setEmpty], and [setError] may be called at
       |  /// most once. Trying to call any of them again will fail.
      0|  void setEmpty() {
      0|    if (_stream._isSourceStreamSet) {
      0|      throw StateError('Source stream already set');
       |    }
      0|    _stream._setEmpty();
       |  }
       |
       |  /// Completes this to a stream that emits [error] and then closes.
       |  ///
       |  /// This is useful when the process of creating the data for the stream fails.
       |  ///
       |  /// Any one of [setSourceStream], [setEmpty], and [setError] may be called at
       |  /// most once. Trying to call any of them again will fail.
      0|  void setError(error, [StackTrace stackTrace]) {
      0|    setSourceStream(Stream.fromFuture(Future.error(error, stackTrace)));
       |  }
       |}
       |
       |/// Stream completed by [StreamCompleter].
       |class _CompleterStream<T> extends Stream<T> {
       |  /// Controller for an intermediate stream.
       |  ///
       |  /// Created if the user listens on this stream before the source stream
       |  /// is set, or if using [_setEmpty] so there is no source stream.
       |  StreamController<T> _controller;
       |
       |  /// Source stream for the events provided by this stream.
       |  ///
       |  /// Set when the completer sets the source stream using [_setSourceStream]
       |  /// or [_setEmpty].
       |  Stream<T> _sourceStream;
       |
      0|  @override
       |  StreamSubscription<T> listen(void Function(T) onData,
       |      {Function onError, void Function() onDone, bool cancelOnError}) {
      0|    if (_controller == null) {
      0|      if (_sourceStream != null && !_sourceStream.isBroadcast) {
       |        // If the source stream is itself single subscription,
       |        // just listen to it directly instead of creating a controller.
      0|        return _sourceStream.listen(onData,
       |            onError: onError, onDone: onDone, cancelOnError: cancelOnError);
       |      }
      0|      _createController();
      0|      if (_sourceStream != null) {
      0|        _linkStreamToController();
       |      }
       |    }
      0|    return _controller.stream.listen(onData,
       |        onError: onError, onDone: onDone, cancelOnError: cancelOnError);
       |  }
       |
       |  /// Whether a source stream has been set.
       |  ///
       |  /// Used to throw an error if trying to set a source stream twice.
      0|  bool get _isSourceStreamSet => _sourceStream != null;
       |
       |  /// Sets the source stream providing the events for this stream.
       |  ///
       |  /// If set before the user listens, listen calls will be directed directly
       |  /// to the source stream. If the user listenes earlier, and intermediate
       |  /// stream is created using a stream controller, and the source stream is
       |  /// linked into that stream later.
      0|  void _setSourceStream(Stream<T> sourceStream) {
       |    assert(_sourceStream == null);
      0|    _sourceStream = sourceStream;
      0|    if (_controller != null) {
       |      // User has already listened, so provide the data through controller.
      0|      _linkStreamToController();
       |    }
       |  }
       |
       |  /// Links source stream to controller when both are available.
      0|  void _linkStreamToController() {
       |    assert(_controller != null);
       |    assert(_sourceStream != null);
      0|    _controller
      0|        .addStream(_sourceStream, cancelOnError: false)
      0|        .whenComplete(_controller.close);
       |  }
       |
       |  /// Sets an empty source stream.
       |  ///
       |  /// Uses [_controller] for the stream, then closes the controller
       |  /// immediately.
      0|  void _setEmpty() {
       |    assert(_sourceStream == null);
      0|    if (_controller == null) {
      0|      _createController();
       |    }
      0|    _sourceStream = _controller.stream; // Mark stream as set.
      0|    _controller.close();
       |  }
       |
       |  // Creates the [_controller].
      0|  void _createController() {
       |    assert(_controller == null);
      0|    _controller = StreamController<T>(sync: true);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_group.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A collection of streams whose events are unified and sent through a central
       |/// stream.
       |///
       |/// Both errors and data events are forwarded through [stream]. The streams in
       |/// the group won't be listened to until [stream] has a listener. **Note that
       |/// this means that events emitted by broadcast streams will be dropped until
       |/// [stream] has a listener.**
       |///
       |/// If the `StreamGroup` is constructed using [new StreamGroup], [stream] will
       |/// be single-subscription. In this case, if [stream] is paused or canceled, all
       |/// streams in the group will likewise be paused or canceled, respectively.
       |///
       |/// If the `StreamGroup` is constructed using [StreamGroup.broadcast],
       |/// [stream] will be a broadcast stream. In this case, the streams in the group
       |/// will never be paused and single-subscription streams in the group will never
       |/// be canceled. **Note that single-subscription streams in a broadcast group
       |/// may drop events if a listener is added and later removed.** Broadcast
       |/// streams in the group will be canceled once [stream] has no listeners, and
       |/// will be listened to again once [stream] has listeners.
       |///
       |/// [stream] won't close until [close] is called on the group *and* every stream
       |/// in the group closes.
       |class StreamGroup<T> implements Sink<Stream<T>> {
       |  /// The stream through which all events from streams in the group are emitted.
      3|  Stream<T> get stream => _controller.stream;
       |  StreamController<T> _controller;
       |
       |  /// Whether the group is closed, meaning that no more streams may be added.
       |  var _closed = false;
       |
       |  /// The current state of the group.
       |  ///
       |  /// See [_StreamGroupState] for detailed descriptions of each state.
       |  var _state = _StreamGroupState.dormant;
       |
       |  /// Streams that have been added to the group, and their subscriptions if they
       |  /// have been subscribed to.
       |  ///
       |  /// The subscriptions will be null until the group has a listener registered.
       |  /// If it's a broadcast group and it goes dormant again, broadcast stream
       |  /// subscriptions will be canceled and set to null again. Single-subscriber
       |  /// stream subscriptions will be left intact, since they can't be
       |  /// re-subscribed.
       |  final _subscriptions = <Stream<T>, StreamSubscription<T>>{};
       |
       |  /// Merges the events from [streams] into a single single-subscription stream.
       |  ///
       |  /// This is equivalent to adding [streams] to a group, closing that group, and
       |  /// returning its stream.
      0|  static Stream<T> merge<T>(Iterable<Stream<T>> streams) {
      0|    var group = StreamGroup<T>();
      0|    streams.forEach(group.add);
      0|    group.close();
      0|    return group.stream;
       |  }
       |
       |  /// Merges the events from [streams] into a single broadcast stream.
       |  ///
       |  /// This is equivalent to adding [streams] to a broadcast group, closing that
       |  /// group, and returning its stream.
      0|  static Stream<T> mergeBroadcast<T>(Iterable<Stream<T>> streams) {
      0|    var group = StreamGroup<T>.broadcast();
      0|    streams.forEach(group.add);
      0|    group.close();
      0|    return group.stream;
       |  }
       |
       |  /// Creates a new stream group where [stream] is single-subscriber.
      0|  StreamGroup() {
      0|    _controller = StreamController<T>(
      0|        onListen: _onListen,
      0|        onPause: _onPause,
      0|        onResume: _onResume,
      0|        onCancel: _onCancel,
       |        sync: true);
       |  }
       |
       |  /// Creates a new stream group where [stream] is a broadcast stream.
      1|  StreamGroup.broadcast() {
      2|    _controller = StreamController<T>.broadcast(
      2|        onListen: _onListen, onCancel: _onCancelBroadcast, sync: true);
       |  }
       |
       |  /// Adds [stream] as a member of this group.
       |  ///
       |  /// Any events from [stream] will be emitted through [this.stream]. If this
       |  /// group has a listener, [stream] will be listened to immediately; otherwise
       |  /// it will only be listened to once this group gets a listener.
       |  ///
       |  /// If this is a single-subscription group and its subscription has been
       |  /// canceled, [stream] will be canceled as soon as its added. If this returns
       |  /// a [Future], it will be returned from [add]. Otherwise, [add] returns
       |  /// `null`.
       |  ///
       |  /// Throws a [StateError] if this group is closed.
      1|  @override
       |  Future add(Stream<T> stream) {
      1|    if (_closed) {
      0|      throw StateError("Can't add a Stream to a closed StreamGroup.");
       |    }
       |
      2|    if (_state == _StreamGroupState.dormant) {
      0|      _subscriptions.putIfAbsent(stream, () => null);
      2|    } else if (_state == _StreamGroupState.canceled) {
       |      // Listen to the stream and cancel it immediately so that no one else can
       |      // listen, for consistency. If the stream has an onCancel listener this
       |      // will also fire that, which may help it clean up resources.
      0|      return stream.listen(null).cancel();
       |    } else {
      4|      _subscriptions.putIfAbsent(stream, () => _listenToStream(stream));
       |    }
       |
       |    return null;
       |  }
       |
       |  /// Removes [stream] as a member of this group.
       |  ///
       |  /// No further events from [stream] will be emitted through this group. If
       |  /// [stream] has been listened to, its subscription will be canceled.
       |  ///
       |  /// If [stream] has been listened to, this *synchronously* cancels its
       |  /// subscription. This means that any events from [stream] that haven't yet
       |  /// been emitted through this group will not be.
       |  ///
       |  /// If [stream]'s subscription is canceled, this returns
       |  /// [StreamSubscription.cancel]'s return value. Otherwise, it returns `null`.
      1|  Future remove(Stream<T> stream) {
      2|    var subscription = _subscriptions.remove(stream);
      1|    var future = subscription == null ? null : subscription.cancel();
      1|    if (_closed && _subscriptions.isEmpty) _controller.close();
       |    return future;
       |  }
       |
       |  /// A callback called when [stream] is listened to.
       |  ///
       |  /// This is called for both single-subscription and broadcast groups.
      1|  void _onListen() {
      1|    _state = _StreamGroupState.listening;
      2|    _subscriptions.forEach((stream, subscription) {
       |      // If this is a broadcast group and this isn't the first time it's been
       |      // listened to, there may still be some subscriptions to
       |      // single-subscription streams.
       |      if (subscription != null) return;
      0|      _subscriptions[stream] = _listenToStream(stream);
       |    });
       |  }
       |
       |  /// A callback called when [stream] is paused.
      0|  void _onPause() {
      0|    _state = _StreamGroupState.paused;
      0|    for (var subscription in _subscriptions.values) {
      0|      subscription.pause();
       |    }
       |  }
       |
       |  /// A callback called when [stream] is resumed.
      0|  void _onResume() {
      0|    _state = _StreamGroupState.listening;
      0|    for (var subscription in _subscriptions.values) {
      0|      subscription.resume();
       |    }
       |  }
       |
       |  /// A callback called when [stream] is canceled.
       |  ///
       |  /// This is only called for single-subscription groups.
      0|  Future _onCancel() {
      0|    _state = _StreamGroupState.canceled;
       |
      0|    var futures = _subscriptions.values
      0|        .map((subscription) => subscription.cancel())
      0|        .where((future) => future != null)
      0|        .toList();
       |
      0|    _subscriptions.clear();
      0|    return futures.isEmpty ? null : Future.wait(futures);
       |  }
       |
       |  /// A callback called when [stream]'s last listener is canceled.
       |  ///
       |  /// This is only called for broadcast groups.
      1|  void _onCancelBroadcast() {
      1|    _state = _StreamGroupState.dormant;
       |
      2|    _subscriptions.forEach((stream, subscription) {
       |      // Cancel the broadcast streams, since we can re-listen to those later,
       |      // but allow the single-subscription streams to keep firing. Their events
       |      // will still be added to [_controller], but then they'll be dropped since
       |      // it has no listeners.
      0|      if (!stream.isBroadcast) return;
      0|      subscription.cancel();
      0|      _subscriptions[stream] = null;
       |    });
       |  }
       |
       |  /// Starts actively forwarding events from [stream] to [_controller].
       |  ///
       |  /// This will pause the resulting subscription if [this] is paused.
      1|  StreamSubscription<T> _listenToStream(Stream<T> stream) {
      3|    var subscription = stream.listen(_controller.add,
      4|        onError: _controller.addError, onDone: () => remove(stream));
      2|    if (_state == _StreamGroupState.paused) subscription.pause();
       |    return subscription;
       |  }
       |
       |  /// Closes the group, indicating that no more streams will be added.
       |  ///
       |  /// If there are no streams in the group, [stream] is closed immediately.
       |  /// Otherwise, [stream] will close once all streams in the group close.
       |  ///
       |  /// Returns a [Future] that completes once [stream] has actually been closed.
      1|  @override
       |  Future close() {
      1|    if (_closed) return _controller.done;
       |
      1|    _closed = true;
      4|    if (_subscriptions.isEmpty) _controller.close();
       |
      2|    return _controller.done;
       |  }
       |}
       |
       |/// An enum of possible states of a [StreamGroup].
       |class _StreamGroupState {
       |  /// The group has no listeners.
       |  ///
       |  /// New streams added to the group will be listened once the group has a
       |  /// listener.
       |  static const dormant = _StreamGroupState('dormant');
       |
       |  /// The group has one or more listeners and is actively firing events.
       |  ///
       |  /// New streams added to the group will be immediately listeners.
       |  static const listening = _StreamGroupState('listening');
       |
       |  /// The group is paused and no more events will be fired until it resumes.
       |  ///
       |  /// New streams added to the group will be listened to, but then paused. They
       |  /// will be resumed once the group itself is resumed.
       |  ///
       |  /// This state is only used by single-subscriber groups.
       |  static const paused = _StreamGroupState('paused');
       |
       |  /// The group is canceled and no more events will be fired ever.
       |  ///
       |  /// New streams added to the group will be listened to, canceled, and
       |  /// discarded.
       |  ///
       |  /// This state is only used by single-subscriber groups.
       |  static const canceled = _StreamGroupState('canceled');
       |
       |  /// The name of the state.
       |  ///
       |  /// Used for debugging.
       |  final String name;
       |
      0|  const _StreamGroupState(this.name);
       |
      0|  @override
      0|  String toString() => name;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_queue.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:collection';
       |
       |import 'package:collection/collection.dart';
       |
       |import 'cancelable_operation.dart';
       |import 'result/result.dart';
       |import 'subscription_stream.dart';
       |import 'stream_completer.dart';
       |import 'stream_splitter.dart';
       |
       |/// An asynchronous pull-based interface for accessing stream events.
       |///
       |/// Wraps a stream and makes individual events available on request.
       |///
       |/// You can request (and reserve) one or more events from the stream,
       |/// and after all previous requests have been fulfilled, stream events
       |/// go towards fulfilling your request.
       |///
       |/// For example, if you ask for [next] two times, the returned futures
       |/// will be completed by the next two unrequested events from the stream.
       |///
       |/// The stream subscription is paused when there are no active
       |/// requests.
       |///
       |/// Some streams, including broadcast streams, will buffer
       |/// events while paused, so waiting too long between requests may
       |/// cause memory bloat somewhere else.
       |///
       |/// This is similar to, but more convenient than, a [StreamIterator].
       |/// A `StreamIterator` requires you to manually check when a new event is
       |/// available and you can only access the value of that event until you
       |/// check for the next one. A `StreamQueue` allows you to request, for example,
       |/// three events at a time, either individually, as a group using [take]
       |/// or [skip], or in any combination.
       |///
       |/// You can also ask to have the [rest] of the stream provided as
       |/// a new stream. This allows, for example, taking the first event
       |/// out of a stream and continuing to use the rest of the stream as a stream.
       |///
       |/// Example:
       |///
       |///     var events = StreamQueue<String>(someStreamOfLines);
       |///     var first = await events.next;
       |///     while (first.startsWith('#')) {
       |///       // Skip comments.
       |///       first = await events.next;
       |///     }
       |///
       |///     if (first.startsWith(MAGIC_MARKER)) {
       |///       var headerCount =
       |///           first.parseInt(first.substring(MAGIC_MARKER.length + 1));
       |///       handleMessage(headers: await events.take(headerCount),
       |///                     body: events.rest);
       |///       return;
       |///     }
       |///     // Error handling.
       |///
       |/// When you need no further events the `StreamQueue` should be closed
       |/// using [cancel]. This releases the underlying stream subscription.
       |class StreamQueue<T> {
       |  // This class maintains two queues: one of events and one of requests.
       |  // The active request (the one in front of the queue) is called with
       |  // the current event queue when it becomes active, every time a
       |  // new event arrives, and when the event source closes.
       |  //
       |  // If the request returns `true`, it's complete and will be removed from the
       |  // request queue.
       |  // If the request returns `false`, it needs more events, and will be called
       |  // again when new events are available. It may trigger a call itself by
       |  // calling [_updateRequests].
       |  // The request can remove events that it uses, or keep them in the event
       |  // queue until it has all that it needs.
       |  //
       |  // This model is very flexible and easily extensible.
       |  // It allows requests that don't consume events (like [hasNext]) or
       |  // potentially a request that takes either five or zero events, determined
       |  // by the content of the fifth event.
       |
       |  final Stream<T> _source;
       |
       |  /// Subscription on [_source] while listening for events.
       |  ///
       |  /// Set to subscription when listening, and set to `null` when the
       |  /// subscription is done (and [_isDone] is set to true).
       |  StreamSubscription<T> _subscription;
       |
       |  /// Whether the event source is done.
       |  bool _isDone = false;
       |
       |  /// Whether a closing operation has been performed on the stream queue.
       |  ///
       |  /// Closing operations are [cancel] and [rest].
       |  bool _isClosed = false;
       |
       |  /// The number of events dispatched by this queue.
       |  ///
       |  /// This counts error events. It doesn't count done events, or events
       |  /// dispatched to a stream returned by [rest].
      0|  int get eventsDispatched => _eventsReceived - _eventQueue.length;
       |
       |  /// The number of events received by this queue.
       |  var _eventsReceived = 0;
       |
       |  /// Queue of events not used by a request yet.
       |  final QueueList<Result<T>> _eventQueue = QueueList();
       |
       |  /// Queue of pending requests.
       |  ///
       |  /// Access through methods below to ensure consistency.
       |  final Queue<_EventRequest> _requestQueue = Queue();
       |
       |  /// Create a `StreamQueue` of the events of [source].
      0|  factory StreamQueue(Stream<T> source) => StreamQueue._(source);
       |
       |  // Private generative constructor to avoid subclasses.
      0|  StreamQueue._(this._source) {
       |    // Start listening immediately if we could otherwise lose events.
      0|    if (_source.isBroadcast) {
      0|      _ensureListening();
      0|      _pause();
       |    }
       |  }
       |
       |  /// Asks if the stream has any more events.
       |  ///
       |  /// Returns a future that completes with `true` if the stream has any
       |  /// more events, whether data or error.
       |  /// If the stream closes without producing any more events, the returned
       |  /// future completes with `false`.
       |  ///
       |  /// Can be used before using [next] to avoid getting an error in the
       |  /// future returned by `next` in the case where there are no more events.
       |  /// Another alternative is to use `take(1)` which returns either zero or
       |  /// one events.
      0|  Future<bool> get hasNext {
      0|    if (!_isClosed) {
      0|      var hasNextRequest = _HasNextRequest<T>();
      0|      _addRequest(hasNextRequest);
      0|      return hasNextRequest.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Look at the next [count] data events without consuming them.
       |  ///
       |  /// Works like [take] except that the events are left in the queue.
       |  /// If one of the next [count] events is an error, the returned future
       |  /// completes with this error, and the error is still left in the queue.
      0|  Future<List<T>> lookAhead(int count) {
      0|    if (count < 0) throw RangeError.range(count, 0, null, 'count');
      0|    if (!_isClosed) {
      0|      var request = _LookAheadRequest<T>(count);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Requests the next (yet unrequested) event from the stream.
       |  ///
       |  /// When the requested event arrives, the returned future is completed with
       |  /// the event.
       |  /// If the event is a data event, the returned future completes
       |  /// with its value.
       |  /// If the event is an error event, the returned future completes with
       |  /// its error and stack trace.
       |  /// If the stream closes before an event arrives, the returned future
       |  /// completes with a [StateError].
       |  ///
       |  /// It's possible to have several pending [next] calls (or other requests),
       |  /// and they will be completed in the order they were requested, by the
       |  /// first events that were not consumed by previous requeusts.
      0|  Future<T> get next {
      0|    if (!_isClosed) {
      0|      var nextRequest = _NextRequest<T>();
      0|      _addRequest(nextRequest);
      0|      return nextRequest.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Looks at the next (yet unrequested) event from the stream.
       |  ///
       |  /// Like [next] except that the event is not consumed.
       |  /// If the next event is an error event, it stays in the queue.
      0|  Future<T> get peek {
      0|    if (!_isClosed) {
      0|      var nextRequest = _PeekRequest<T>();
      0|      _addRequest(nextRequest);
      0|      return nextRequest.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Returns a stream of all the remaning events of the source stream.
       |  ///
       |  /// All requested [next], [skip] or [take] operations are completed
       |  /// first, and then any remaining events are provided as events of
       |  /// the returned stream.
       |  ///
       |  /// Using `rest` closes this stream queue. After getting the
       |  /// `rest` the caller may no longer request other events, like
       |  /// after calling [cancel].
      0|  Stream<T> get rest {
      0|    if (_isClosed) {
      0|      throw _failClosed();
       |    }
      0|    var request = _RestRequest<T>(this);
      0|    _isClosed = true;
      0|    _addRequest(request);
      0|    return request.stream;
       |  }
       |
       |  /// Skips the next [count] *data* events.
       |  ///
       |  /// The [count] must be non-negative.
       |  ///
       |  /// When successful, this is equivalent to using [take]
       |  /// and ignoring the result.
       |  ///
       |  /// If an error occurs before `count` data events have been skipped,
       |  /// the returned future completes with that error instead.
       |  ///
       |  /// If the stream closes before `count` data events,
       |  /// the remaining unskipped event count is returned.
       |  /// If the returned future completes with the integer `0`,
       |  /// then all events were succssfully skipped. If the value
       |  /// is greater than zero then the stream ended early.
      0|  Future<int> skip(int count) {
      0|    if (count < 0) throw RangeError.range(count, 0, null, 'count');
      0|    if (!_isClosed) {
      0|      var request = _SkipRequest<T>(count);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Requests the next [count] data events as a list.
       |  ///
       |  /// The [count] must be non-negative.
       |  ///
       |  /// Equivalent to calling [next] `count` times and
       |  /// storing the data values in a list.
       |  ///
       |  /// If an error occurs before `count` data events has
       |  /// been collected, the returned future completes with
       |  /// that error instead.
       |  ///
       |  /// If the stream closes before `count` data events,
       |  /// the returned future completes with the list
       |  /// of data collected so far. That is, the returned
       |  /// list may have fewer than [count] elements.
      0|  Future<List<T>> take(int count) {
      0|    if (count < 0) throw RangeError.range(count, 0, null, 'count');
      0|    if (!_isClosed) {
      0|      var request = _TakeRequest<T>(count);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
      0|    throw _failClosed();
       |  }
       |
       |  /// Requests a transaction that can conditionally consume events.
       |  ///
       |  /// The transaction can create copies of this queue at the current position
       |  /// using [StreamQueueTransaction.newQueue]. Each of these queues is
       |  /// independent of one another and of the parent queue. The transaction
       |  /// finishes when one of two methods is called:
       |  ///
       |  /// * [StreamQueueTransaction.commit] updates the parent queue's position to
       |  ///   match that of one of the copies.
       |  ///
       |  /// * [StreamQueueTransaction.reject] causes the parent queue to continue as
       |  ///   though [startTransaction] hadn't been called.
       |  ///
       |  /// Until the transaction finishes, this queue won't emit any events.
       |  ///
       |  /// See also [withTransaction] and [cancelable].
       |  ///
       |  /// ```dart
       |  /// /// Consumes all empty lines from the beginning of [lines].
       |  /// Future consumeEmptyLines(StreamQueue<String> lines) async {
       |  ///   while (await lines.hasNext) {
       |  ///     var transaction = lines.startTransaction();
       |  ///     var queue = transaction.newQueue();
       |  ///     if ((await queue.next).isNotEmpty) {
       |  ///       transaction.reject();
       |  ///       return;
       |  ///     } else {
       |  ///       transaction.commit(queue);
       |  ///     }
       |  ///   }
       |  /// }
       |  /// ```
      0|  StreamQueueTransaction<T> startTransaction() {
      0|    if (_isClosed) throw _failClosed();
       |
      0|    var request = _TransactionRequest(this);
      0|    _addRequest(request);
      0|    return request.transaction;
       |  }
       |
       |  /// Passes a copy of this queue to [callback], and updates this queue to match
       |  /// the copy's position if [callback] returns `true`.
       |  ///
       |  /// This queue won't emit any events until [callback] returns. If it returns
       |  /// `false`, this queue continues as though [withTransaction] hadn't been
       |  /// called. If it throws an error, this updates this queue to match the copy's
       |  /// position and throws the error from the returned `Future`.
       |  ///
       |  /// Returns the same value as [callback].
       |  ///
       |  /// See also [startTransaction] and [cancelable].
       |  ///
       |  /// ```dart
       |  /// /// Consumes all empty lines from the beginning of [lines].
       |  /// Future consumeEmptyLines(StreamQueue<String> lines) async {
       |  ///   while (await lines.hasNext) {
       |  ///     // Consume a line if it's empty, otherwise return.
       |  ///     if (!await lines.withTransaction(
       |  ///         (queue) async => (await queue.next).isEmpty)) {
       |  ///       return;
       |  ///     }
       |  ///   }
       |  /// }
       |  /// ```
      0|  Future<bool> withTransaction(Future<bool> Function(StreamQueue<T>) callback) {
      0|    var transaction = startTransaction();
       |
       |    /// Avoid async/await to ensure that [startTransaction] is called
       |    /// synchronously and so ends up in the right place in the request queue.
      0|    var queue = transaction.newQueue();
      0|    return callback(queue).then((result) {
       |      if (result) {
      0|        transaction.commit(queue);
       |      } else {
      0|        transaction.reject();
       |      }
       |      return result;
      0|    }, onError: (error) {
      0|      transaction.commit(queue);
       |      throw error;
       |    });
       |  }
       |
       |  /// Passes a copy of this queue to [callback], and updates this queue to match
       |  /// the copy's position once [callback] completes.
       |  ///
       |  /// If the returned [CancelableOperation] is canceled, this queue instead
       |  /// continues as though [cancelable] hadn't been called. Otherwise, it emits
       |  /// the same value or error as [callback].
       |  ///
       |  /// See also [startTransaction] and [withTransaction].
       |  ///
       |  /// ```dart
       |  /// final _stdinQueue = StreamQueue(stdin);
       |  ///
       |  /// /// Returns an operation that completes when the user sends a line to
       |  /// /// standard input.
       |  /// ///
       |  /// /// If the operation is canceled, stops waiting for user input.
       |  /// CancelableOperation<String> nextStdinLine() =>
       |  ///     _stdinQueue.cancelable((queue) => queue.next);
       |  /// ```
      0|  CancelableOperation<S> cancelable<S>(
       |      Future<S> Function(StreamQueue<T>) callback) {
      0|    var transaction = startTransaction();
      0|    var completer = CancelableCompleter<S>(onCancel: () {
      0|      transaction.reject();
       |    });
       |
      0|    var queue = transaction.newQueue();
      0|    completer.complete(callback(queue).whenComplete(() {
      0|      if (!completer.isCanceled) transaction.commit(queue);
       |    }));
       |
      0|    return completer.operation;
       |  }
       |
       |  /// Cancels the underlying event source.
       |  ///
       |  /// If [immediate] is `false` (the default), the cancel operation waits until
       |  /// all previously requested events have been processed, then it cancels the
       |  /// subscription providing the events.
       |  ///
       |  /// If [immediate] is `true`, the source is instead canceled
       |  /// immediately. Any pending events are completed as though the underlying
       |  /// stream had closed.
       |  ///
       |  /// The returned future completes with the result of calling
       |  /// `cancel`.
       |  ///
       |  /// After calling `cancel`, no further events can be requested.
       |  /// None of [lookAhead], [next], [peek], [rest], [skip], [take] or [cancel]
       |  /// may be called again.
      0|  Future cancel({bool immediate = false}) {
      0|    if (_isClosed) throw _failClosed();
      0|    _isClosed = true;
       |
       |    if (!immediate) {
      0|      var request = _CancelRequest<T>(this);
      0|      _addRequest(request);
      0|      return request.future;
       |    }
       |
      0|    if (_isDone && _eventQueue.isEmpty) return Future.value();
      0|    return _cancel();
       |  }
       |
       |  // ------------------------------------------------------------------
       |  // Methods that may be called from the request implementations to
       |  // control the event stream.
       |
       |  /// Matches events with requests.
       |  ///
       |  /// Called after receiving an event or when the event source closes.
       |  ///
       |  /// May be called by requests which have returned `false` (saying they
       |  /// are not yet done) so they can be checked again before any new
       |  /// events arrive.
       |  /// Any request returing `false` from `update` when `isDone` is `true`
       |  /// *must* call `_updateRequests` when they are ready to continue
       |  /// (since no further events will trigger the call).
      0|  void _updateRequests() {
      0|    while (_requestQueue.isNotEmpty) {
      0|      if (_requestQueue.first.update(_eventQueue, _isDone)) {
      0|        _requestQueue.removeFirst();
       |      } else {
       |        return;
       |      }
       |    }
       |
      0|    if (!_isDone) {
      0|      _pause();
       |    }
       |  }
       |
       |  /// Extracts a stream from the event source and makes this stream queue
       |  /// unusable.
       |  ///
       |  /// Can only be used by the very last request (the stream queue must
       |  /// be closed by that request).
       |  /// Only used by [rest].
      0|  Stream<T> _extractStream() {
       |    assert(_isClosed);
      0|    if (_isDone) {
      0|      return Stream<T>.empty();
       |    }
      0|    _isDone = true;
       |
      0|    if (_subscription == null) {
      0|      return _source;
       |    }
       |
      0|    var subscription = _subscription;
      0|    _subscription = null;
       |
      0|    var wasPaused = subscription.isPaused;
      0|    var result = SubscriptionStream<T>(subscription);
       |    // Resume after creating stream because that pauses the subscription too.
       |    // This way there won't be a short resumption in the middle.
      0|    if (wasPaused) subscription.resume();
       |    return result;
       |  }
       |
       |  /// Requests that the event source pauses events.
       |  ///
       |  /// This is called automatically when the request queue is empty.
       |  ///
       |  /// The event source is restarted by the next call to [_ensureListening].
      0|  void _pause() {
      0|    _subscription.pause();
       |  }
       |
       |  /// Ensures that we are listening on events from the event source.
       |  ///
       |  /// Starts listening for the first time or resumes after a [_pause].
       |  ///
       |  /// Is called automatically if a request requires more events.
      0|  void _ensureListening() {
      0|    if (_isDone) return;
      0|    if (_subscription == null) {
      0|      _subscription = _source.listen((data) {
      0|        _addResult(Result.value(data));
      0|      }, onError: (error, StackTrace stackTrace) {
      0|        _addResult(Result.error(error, stackTrace));
      0|      }, onDone: () {
      0|        _subscription = null;
      0|        _close();
       |      });
       |    } else {
      0|      _subscription.resume();
       |    }
       |  }
       |
       |  /// Cancels the underlying event source.
      0|  Future _cancel() {
      0|    if (_isDone) return null;
      0|    _subscription ??= _source.listen(null);
      0|    var future = _subscription.cancel();
      0|    _close();
       |    return future;
       |  }
       |
       |  // ------------------------------------------------------------------
       |  // Methods called by the event source to add events or say that it's
       |  // done.
       |
       |  /// Called when the event source adds a new data or error event.
       |  /// Always calls [_updateRequests] after adding.
      0|  void _addResult(Result<T> result) {
      0|    _eventsReceived++;
      0|    _eventQueue.add(result);
      0|    _updateRequests();
       |  }
       |
       |  /// Called when the event source is done.
       |  /// Always calls [_updateRequests] after adding.
      0|  void _close() {
      0|    _isDone = true;
      0|    _updateRequests();
       |  }
       |
       |  // ------------------------------------------------------------------
       |  // Internal helper methods.
       |
       |  /// Returns an error for when a request is made after cancel.
       |  ///
       |  /// Returns a [StateError] with a message saying that either
       |  /// [cancel] or [rest] have already been called.
      0|  Error _failClosed() {
      0|    return StateError('Already cancelled');
       |  }
       |
       |  /// Adds a new request to the queue.
       |  ///
       |  /// If the request queue is empty and the request can be completed
       |  /// immediately, it skips the queue.
      0|  void _addRequest(_EventRequest<T> request) {
      0|    if (_requestQueue.isEmpty) {
      0|      if (request.update(_eventQueue, _isDone)) return;
      0|      _ensureListening();
       |    }
      0|    _requestQueue.add(request);
       |  }
       |}
       |
       |/// A transaction on a [StreamQueue], created by [StreamQueue.startTransaction].
       |///
       |/// Copies of the parent queue may be created using [newQueue]. Calling [commit]
       |/// moves the parent queue to a copy's position, and calling [reject] causes it
       |/// to continue as though [StreamQueue.startTransaction] was never called.
       |class StreamQueueTransaction<T> {
       |  /// The parent queue on which this transaction is active.
       |  final StreamQueue<T> _parent;
       |
       |  /// The splitter that produces copies of the parent queue's stream.
       |  final StreamSplitter<T> _splitter;
       |
       |  /// Queues created using [newQueue].
       |  final _queues = <StreamQueue>{};
       |
       |  /// Whether [commit] has been called.
       |  var _committed = false;
       |
       |  /// Whether [reject] has been called.
       |  var _rejected = false;
       |
      0|  StreamQueueTransaction._(this._parent, Stream<T> source)
      0|      : _splitter = StreamSplitter(source);
       |
       |  /// Creates a new copy of the parent queue.
       |  ///
       |  /// This copy starts at the parent queue's position when
       |  /// [StreamQueue.startTransaction] was called. Its position can be committed
       |  /// to the parent queue using [commit].
      0|  StreamQueue<T> newQueue() {
      0|    var queue = StreamQueue(_splitter.split());
      0|    _queues.add(queue);
       |    return queue;
       |  }
       |
       |  /// Commits a queue created using [newQueue].
       |  ///
       |  /// The parent queue's position is updated to be the same as [queue]'s.
       |  /// Further requests on all queues created by this transaction, including
       |  /// [queue], will complete as though [cancel] were called with `immediate:
       |  /// true`.
       |  ///
       |  /// Throws a [StateError] if [commit] or [reject] have already been called, or
       |  /// if there are pending requests on [queue].
      0|  void commit(StreamQueue<T> queue) {
      0|    _assertActive();
      0|    if (!_queues.contains(queue)) {
      0|      throw ArgumentError("Queue doesn't belong to this transaction.");
      0|    } else if (queue._requestQueue.isNotEmpty) {
      0|      throw StateError("A queue with pending requests can't be committed.");
       |    }
      0|    _committed = true;
       |
       |    // Remove all events from the parent queue that were consumed by the
       |    // child queue.
      0|    for (var j = 0; j < queue.eventsDispatched; j++) {
      0|      _parent._eventQueue.removeFirst();
       |    }
       |
      0|    _done();
       |  }
       |
       |  /// Rejects this transaction without updating the parent queue.
       |  ///
       |  /// The parent will continue as though [StreamQueue.startTransaction] hadn't
       |  /// been called. Further requests on all queues created by this transaction
       |  /// will complete as though [cancel] were called with `immediate: true`.
       |  ///
       |  /// Throws a [StateError] if [commit] or [reject] have already been called.
      0|  void reject() {
      0|    _assertActive();
      0|    _rejected = true;
      0|    _done();
       |  }
       |
       |  // Cancels all [_queues], removes the [_TransactionRequest] from [_parent]'s
       |  // request queue, and runs the next request.
      0|  void _done() {
      0|    _splitter.close();
      0|    for (var queue in _queues) {
      0|      queue._cancel();
       |    }
       |    // If this is the active request in the queue, mark it as finished.
      0|    var currentRequest = _parent._requestQueue.first;
      0|    if (currentRequest is _TransactionRequest &&
      0|        currentRequest.transaction == this) {
      0|      _parent._requestQueue.removeFirst();
      0|      _parent._updateRequests();
       |    }
       |  }
       |
       |  /// Throws a [StateError] if [accept] or [reject] has already been called.
      0|  void _assertActive() {
      0|    if (_committed) {
      0|      throw StateError('This transaction has already been accepted.');
      0|    } else if (_rejected) {
      0|      throw StateError('This transaction has already been rejected.');
       |    }
       |  }
       |}
       |
       |/// Request object that receives events when they arrive, until fulfilled.
       |///
       |/// Each request that cannot be fulfilled immediately is represented by
       |/// an `_EventRequest` object in the request queue.
       |///
       |/// Events from the source stream are sent to the first request in the
       |/// queue until it reports itself as [isComplete].
       |///
       |/// When the first request in the queue `isComplete`, either when becoming
       |/// the first request or after receiving an event, its [close] methods is
       |/// called.
       |///
       |/// The [close] method is also called immediately when the source stream
       |/// is done.
       |abstract class _EventRequest<T> {
       |  /// Handle available events.
       |  ///
       |  /// The available events are provided as a queue. The `update` function
       |  /// should only remove events from the front of the event queue, e.g.,
       |  /// using [removeFirst].
       |  ///
       |  /// Returns `true` if the request is completed, or `false` if it needs
       |  /// more events.
       |  /// The call may keep events in the queue until the requeust is complete,
       |  /// or it may remove them immediately.
       |  ///
       |  /// If the method returns true, the request is considered fulfilled, and
       |  /// will never be called again.
       |  ///
       |  /// This method is called when a request reaches the front of the request
       |  /// queue, and if it returns `false`, it's called again every time a new event
       |  /// becomes available, or when the stream closes.
       |  /// If the function returns `false` when the stream has already closed
       |  /// ([isDone] is true), then the request must call
       |  /// [StreamQueue._updateRequests] itself when it's ready to continue.
       |  bool update(QueueList<Result<T>> events, bool isDone);
       |}
       |
       |/// Request for a [StreamQueue.next] call.
       |///
       |/// Completes the returned future when receiving the first event,
       |/// and is then complete.
       |class _NextRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by [StreamQueue.next].
       |  final _completer = Completer<T>();
       |
      0|  _NextRequest();
       |
      0|  Future<T> get future => _completer.future;
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (events.isNotEmpty) {
      0|      events.removeFirst().complete(_completer);
       |      return true;
       |    }
       |    if (isDone) {
      0|      _completer.completeError(StateError('No elements'), StackTrace.current);
       |      return true;
       |    }
       |    return false;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.peek] call.
       |///
       |/// Completes the returned future when receiving the first event,
       |/// and is then complete, but doesn't consume the event.
       |class _PeekRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by [StreamQueue.next].
       |  final _completer = Completer<T>();
       |
      0|  _PeekRequest();
       |
      0|  Future<T> get future => _completer.future;
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (events.isNotEmpty) {
      0|      events.first.complete(_completer);
       |      return true;
       |    }
       |    if (isDone) {
      0|      _completer.completeError(StateError('No elements'), StackTrace.current);
       |      return true;
       |    }
       |    return false;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.skip] call.
       |class _SkipRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by the skip call.
       |  final _completer = Completer<int>();
       |
       |  /// Number of remaining events to skip.
       |  ///
       |  /// The request [isComplete] when the values reaches zero.
       |  ///
       |  /// Decremented when an event is seen.
       |  /// Set to zero when an error is seen since errors abort the skip request.
       |  int _eventsToSkip;
       |
      0|  _SkipRequest(this._eventsToSkip);
       |
       |  /// The future completed when the correct number of events have been skipped.
      0|  Future<int> get future => _completer.future;
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    while (_eventsToSkip > 0) {
      0|      if (events.isEmpty) {
       |        if (isDone) break;
       |        return false;
       |      }
      0|      _eventsToSkip--;
       |
      0|      var event = events.removeFirst();
      0|      if (event.isError) {
      0|        _completer.completeError(event.asError.error, event.asError.stackTrace);
       |        return true;
       |      }
       |    }
      0|    _completer.complete(_eventsToSkip);
       |    return true;
       |  }
       |}
       |
       |/// Common superclass for [_TakeRequest] and [_LookAheadRequest].
       |abstract class _ListRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by the take call.
       |  final _completer = Completer<List<T>>();
       |
       |  /// List collecting events until enough have been seen.
       |  final _list = <T>[];
       |
       |  /// Number of events to capture.
       |  ///
       |  /// The request [isComplete] when the length of [_list] reaches
       |  /// this value.
       |  final int _eventsToTake;
       |
      0|  _ListRequest(this._eventsToTake);
       |
       |  /// The future completed when the correct number of events have been captured.
      0|  Future<List<T>> get future => _completer.future;
       |}
       |
       |/// Request for a [StreamQueue.take] call.
       |class _TakeRequest<T> extends _ListRequest<T> {
      0|  _TakeRequest(int eventsToTake) : super(eventsToTake);
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    while (_list.length < _eventsToTake) {
      0|      if (events.isEmpty) {
       |        if (isDone) break;
       |        return false;
       |      }
       |
      0|      var event = events.removeFirst();
      0|      if (event.isError) {
      0|        event.asError.complete(_completer);
       |        return true;
       |      }
      0|      _list.add(event.asValue.value);
       |    }
      0|    _completer.complete(_list);
       |    return true;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.lookAhead] call.
       |class _LookAheadRequest<T> extends _ListRequest<T> {
      0|  _LookAheadRequest(int eventsToTake) : super(eventsToTake);
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    while (_list.length < _eventsToTake) {
      0|      if (events.length == _list.length) {
       |        if (isDone) break;
       |        return false;
       |      }
      0|      var event = events.elementAt(_list.length);
      0|      if (event.isError) {
      0|        event.asError.complete(_completer);
       |        return true;
       |      }
      0|      _list.add(event.asValue.value);
       |    }
      0|    _completer.complete(_list);
       |    return true;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.cancel] call.
       |///
       |/// The request needs no events, it just waits in the request queue
       |/// until all previous events are fulfilled, then it cancels the stream queue
       |/// source subscription.
       |class _CancelRequest<T> implements _EventRequest<T> {
       |  /// Completer for the future returned by the `cancel` call.
       |  final _completer = Completer<void>();
       |
       |  /// When the event is completed, it needs to cancel the active subscription
       |  /// of the `StreamQueue` object, if any.
       |  final StreamQueue _streamQueue;
       |
      0|  _CancelRequest(this._streamQueue);
       |
       |  /// The future completed when the cancel request is completed.
      0|  Future get future => _completer.future;
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (_streamQueue._isDone) {
      0|      _completer.complete();
       |    } else {
      0|      _streamQueue._ensureListening();
      0|      _completer.complete(_streamQueue._extractStream().listen(null).cancel());
       |    }
       |    return true;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.rest] call.
       |///
       |/// The request is always complete, it just waits in the request queue
       |/// until all previous events are fulfilled, then it takes over the
       |/// stream events subscription and creates a stream from it.
       |class _RestRequest<T> implements _EventRequest<T> {
       |  /// Completer for the stream returned by the `rest` call.
       |  final _completer = StreamCompleter<T>();
       |
       |  /// The [StreamQueue] object that has this request queued.
       |  ///
       |  /// When the event is completed, it needs to cancel the active subscription
       |  /// of the `StreamQueue` object, if any.
       |  final StreamQueue<T> _streamQueue;
       |
      0|  _RestRequest(this._streamQueue);
       |
       |  /// The stream which will contain the remaining events of [_streamQueue].
      0|  Stream<T> get stream => _completer.stream;
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (events.isEmpty) {
      0|      if (_streamQueue._isDone) {
      0|        _completer.setEmpty();
       |      } else {
      0|        _completer.setSourceStream(_streamQueue._extractStream());
       |      }
       |    } else {
       |      // There are prefetched events which needs to be added before the
       |      // remaining stream.
      0|      var controller = StreamController<T>();
      0|      for (var event in events) {
      0|        event.addTo(controller);
       |      }
       |      controller
      0|          .addStream(_streamQueue._extractStream(), cancelOnError: false)
      0|          .whenComplete(controller.close);
      0|      _completer.setSourceStream(controller.stream);
       |    }
       |    return true;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.hasNext] call.
       |///
       |/// Completes the [future] with `true` if it sees any event,
       |/// but doesn't consume the event.
       |/// If the request is closed without seeing an event, then
       |/// the [future] is completed with `false`.
       |class _HasNextRequest<T> implements _EventRequest<T> {
       |  final _completer = Completer<bool>();
       |
      0|  Future<bool> get future => _completer.future;
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    if (events.isNotEmpty) {
      0|      _completer.complete(true);
       |      return true;
       |    }
       |    if (isDone) {
      0|      _completer.complete(false);
       |      return true;
       |    }
       |    return false;
       |  }
       |}
       |
       |/// Request for a [StreamQueue.startTransaction] call.
       |///
       |/// This request isn't complete until the user calls
       |/// [StreamQueueTransaction.commit] or [StreamQueueTransaction.reject], at which
       |/// point it manually removes itself from the request queue and calls
       |/// [StreamQueue._updateRequests].
       |class _TransactionRequest<T> implements _EventRequest<T> {
       |  /// The transaction created by this request.
      0|  StreamQueueTransaction<T> get transaction => _transaction;
       |  StreamQueueTransaction<T> _transaction;
       |
       |  /// The controller that passes events to [transaction].
       |  final _controller = StreamController<T>(sync: true);
       |
       |  /// The number of events passed to [_controller] so far.
       |  var _eventsSent = 0;
       |
      0|  _TransactionRequest(StreamQueue<T> parent) {
      0|    _transaction = StreamQueueTransaction._(parent, _controller.stream);
       |  }
       |
      0|  @override
       |  bool update(QueueList<Result<T>> events, bool isDone) {
      0|    while (_eventsSent < events.length) {
      0|      events[_eventsSent++].addTo(_controller);
       |    }
      0|    if (isDone && !_controller.isClosed) _controller.close();
      0|    return transaction._committed || _transaction._rejected;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_sink_completer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'null_stream_sink.dart';
       |
       |/// A [sink] where the destination is provided later.
       |///
       |/// The [sink] is a normal sink that you can add events to to immediately, but
       |/// until [setDestinationSink] is called, the events will be buffered.
       |///
       |/// The same effect can be achieved by using a [StreamController] and adding it
       |/// to the sink using [Sink.addStream] when the destination sink is ready. This
       |/// class attempts to shortcut some of the overhead when possible. For example,
       |/// if the [sink] only has events added after the destination sink has been set,
       |/// those events are added directly to the sink.
       |class StreamSinkCompleter<T> {
       |  /// The sink for this completer.
       |  ///
       |  /// When a destination sink is provided, events that have been passed to the
       |  /// sink will be forwarded to the destination.
       |  ///
       |  /// Events can be added to the sink either before or after a destination sink
       |  /// is set.
       |  final StreamSink<T> sink = _CompleterSink<T>();
       |
       |  /// Returns [sink] typed as a [_CompleterSink].
      0|  _CompleterSink<T> get _sink => sink as _CompleterSink<T>;
       |
       |  /// Convert a `Future<StreamSink>` to a `StreamSink`.
       |  ///
       |  /// This creates a sink using a sink completer, and sets the destination sink
       |  /// to the result of the future when the future completes.
       |  ///
       |  /// If the future completes with an error, the returned sink will instead
       |  /// be closed. Its [Sink.done] future will contain the error.
      0|  static StreamSink<T> fromFuture<T>(Future<StreamSink<T>> sinkFuture) {
      0|    var completer = StreamSinkCompleter<T>();
      0|    sinkFuture.then(completer.setDestinationSink, onError: completer.setError);
      0|    return completer.sink;
       |  }
       |
       |  /// Sets a sink as the destination for events from the [StreamSinkCompleter]'s
       |  /// [sink].
       |  ///
       |  /// The completer's [sink] will act exactly as [destinationSink].
       |  ///
       |  /// If the destination sink is set before events are added to [sink], further
       |  /// events are forwarded directly to [destinationSink].
       |  ///
       |  /// If events are added to [sink] before setting the destination sink, they're
       |  /// buffered until the destination is available.
       |  ///
       |  /// A destination sink may be set at most once.
       |  ///
       |  /// Either of [setDestinationSink] or [setError] may be called at most once.
       |  /// Trying to call either of them again will fail.
      0|  void setDestinationSink(StreamSink<T> destinationSink) {
      0|    if (_sink._destinationSink != null) {
      0|      throw StateError('Destination sink already set');
       |    }
      0|    _sink._setDestinationSink(destinationSink);
       |  }
       |
       |  /// Completes this to a closed sink whose [Sink.done] future emits [error].
       |  ///
       |  /// This is useful when the process of loading the sink fails.
       |  ///
       |  /// Either of [setDestinationSink] or [setError] may be called at most once.
       |  /// Trying to call either of them again will fail.
      0|  void setError(error, [StackTrace stackTrace]) {
      0|    setDestinationSink(NullStreamSink.error(error, stackTrace));
       |  }
       |}
       |
       |/// [StreamSink] completed by [StreamSinkCompleter].
       |class _CompleterSink<T> implements StreamSink<T> {
       |  /// Controller for an intermediate sink.
       |  ///
       |  /// Created if the user adds events to this sink before the destination sink
       |  /// is set.
       |  StreamController<T> _controller;
       |
       |  /// Completer for [done].
       |  ///
       |  /// Created if the user requests the [done] future before the destination sink
       |  /// is set.
       |  Completer _doneCompleter;
       |
       |  /// Destination sink for the events added to this sink.
       |  ///
       |  /// Set when [StreamSinkCompleter.setDestinationSink] is called.
       |  StreamSink<T> _destinationSink;
       |
       |  /// Whether events should be sent directly to [_destinationSink], as opposed
       |  /// to going through [_controller].
      0|  bool get _canSendDirectly => _controller == null && _destinationSink != null;
       |
      0|  @override
       |  Future get done {
      0|    if (_doneCompleter != null) return _doneCompleter.future;
      0|    if (_destinationSink == null) {
      0|      _doneCompleter = Completer.sync();
      0|      return _doneCompleter.future;
       |    }
      0|    return _destinationSink.done;
       |  }
       |
      0|  @override
       |  void add(T event) {
      0|    if (_canSendDirectly) {
      0|      _destinationSink.add(event);
       |    } else {
      0|      _ensureController();
      0|      _controller.add(event);
       |    }
       |  }
       |
      0|  @override
       |  void addError(error, [StackTrace stackTrace]) {
      0|    if (_canSendDirectly) {
      0|      _destinationSink.addError(error, stackTrace);
       |    } else {
      0|      _ensureController();
      0|      _controller.addError(error, stackTrace);
       |    }
       |  }
       |
      0|  @override
       |  Future addStream(Stream<T> stream) {
      0|    if (_canSendDirectly) return _destinationSink.addStream(stream);
       |
      0|    _ensureController();
      0|    return _controller.addStream(stream, cancelOnError: false);
       |  }
       |
      0|  @override
       |  Future close() {
      0|    if (_canSendDirectly) {
      0|      _destinationSink.close();
       |    } else {
      0|      _ensureController();
      0|      _controller.close();
       |    }
      0|    return done;
       |  }
       |
       |  /// Create [_controller] if it doesn't yet exist.
      0|  void _ensureController() {
      0|    _controller ??= StreamController(sync: true);
       |  }
       |
       |  /// Sets the destination sink to which events from this sink will be provided.
       |  ///
       |  /// If set before the user adds events, events will be added directly to the
       |  /// destination sink. If the user adds events earlier, an intermediate sink is
       |  /// created using a stream controller, and the destination sink is linked to
       |  /// it later.
      0|  void _setDestinationSink(StreamSink<T> sink) {
       |    assert(_destinationSink == null);
      0|    _destinationSink = sink;
       |
       |    // If the user has already added data, it's buffered in the controller, so
       |    // we add it to the sink.
      0|    if (_controller != null) {
       |      // Catch any error that may come from [addStream] or [sink.close]. They'll
       |      // be reported through [done] anyway.
       |      sink
      0|          .addStream(_controller.stream)
      0|          .whenComplete(sink.close)
      0|          .catchError((_) {});
       |    }
       |
       |    // If the user has already asked when the sink is done, connect the sink's
       |    // done callback to that completer.
      0|    if (_doneCompleter != null) {
      0|      _doneCompleter.complete(sink.done);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_sink_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'stream_sink_transformer/handler_transformer.dart';
       |import 'stream_sink_transformer/stream_transformer_wrapper.dart';
       |import 'stream_sink_transformer/typed.dart';
       |
       |/// A [StreamSinkTransformer] transforms the events being passed to a sink.
       |///
       |/// This works on the same principle as a [StreamTransformer]. Each transformer
       |/// defines a [bind] method that takes in the original [StreamSink] and returns
       |/// the transformed version. However, where a [StreamTransformer] transforms
       |/// events after they leave the stream, this transforms them before they enter
       |/// the sink.
       |///
       |/// Transformers must be able to have `bind` called used multiple times.
       |abstract class StreamSinkTransformer<S, T> {
       |  /// Creates a [StreamSinkTransformer] that transforms events and errors
       |  /// using [transformer].
       |  ///
       |  /// This is equivalent to piping all events from the outer sink through a
       |  /// stream transformed by [transformer] and from there into the inner sink.
       |  const factory StreamSinkTransformer.fromStreamTransformer(
       |      StreamTransformer<S, T> transformer) = StreamTransformerWrapper<S, T>;
       |
       |  /// Creates a [StreamSinkTransformer] that delegates events to the given
       |  /// handlers.
       |  ///
       |  /// The handlers work exactly as they do for [StreamTransformer.fromHandlers].
       |  /// They're called for each incoming event, and any actions on the sink
       |  /// they're passed are forwarded to the inner sink. If a handler is omitted,
       |  /// the event is passed through unaltered.
      0|  factory StreamSinkTransformer.fromHandlers(
       |      {void Function(S, EventSink<T>) handleData,
       |      void Function(Object, StackTrace, EventSink<T>) handleError,
       |      void Function(EventSink<T>) handleDone}) {
      0|    return HandlerTransformer<S, T>(handleData, handleError, handleDone);
       |  }
       |
       |  /// Transforms the events passed to [sink].
       |  ///
       |  /// Creates a new sink. When events are passed to the returned sink, it will
       |  /// transform them and pass the transformed versions to [sink].
       |  StreamSink<S> bind(StreamSink<T> sink);
       |
       |  /// Creates a wrapper that coerces the type of [transformer].
       |  ///
       |  /// This soundly converts a [StreamSinkTransformer] to a
       |  /// `StreamSinkTransformer<S, T>`, regardless of its original generic type.
       |  /// This means that calls to [StreamSink.add] on the returned sink may throw a
       |  /// [CastError] if the argument type doesn't match the reified type of the
       |  /// sink.
      0|  @deprecated
       |  // TODO remove TypeSafeStreamSinkTransformer
       |  static StreamSinkTransformer<S, T> typed<S, T>(
       |          StreamSinkTransformer transformer) =>
      0|      transformer is StreamSinkTransformer<S, T>
       |          ? transformer
      0|          : TypeSafeStreamSinkTransformer(transformer);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_splitter.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'future_group.dart';
       |import 'result/result.dart';
       |
       |/// A class that splits a single source stream into an arbitrary number of
       |/// (single-subscription) streams (called "branch") that emit the same events.
       |///
       |/// Each branch will emit all the same values and errors as the source stream,
       |/// regardless of which values have been emitted on other branches. This means
       |/// that the splitter stores every event that has been emitted so far, which may
       |/// consume a lot of memory. The user can call [close] to indicate that no more
       |/// branches will be created, and this memory will be released.
       |///
       |/// The source stream is only listened to once a branch is created *and listened
       |/// to*. It's paused when all branches are paused *or when all branches are
       |/// canceled*, and resumed once there's at least one branch that's listening and
       |/// unpaused. It's not canceled unless no branches are listening and [close] has
       |/// been called.
       |class StreamSplitter<T> {
       |  /// The wrapped stream.
       |  final Stream<T> _stream;
       |
       |  /// The subscription to [_stream].
       |  ///
       |  /// This will be `null` until a branch has a listener.
       |  StreamSubscription<T> _subscription;
       |
       |  /// The buffer of events or errors that have already been emitted by
       |  /// [_stream].
       |  final _buffer = <Result<T>>[];
       |
       |  /// The controllers for branches that are listening for future events from
       |  /// [_stream].
       |  ///
       |  /// Once a branch is canceled, it's removed from this list. When [_stream] is
       |  /// done, all branches are removed.
       |  final _controllers = <StreamController<T>>{};
       |
       |  /// A group of futures returned by [close].
       |  ///
       |  /// This is used to ensure that [close] doesn't complete until all
       |  /// [StreamController.close] and [StreamSubscription.cancel] calls complete.
       |  final _closeGroup = FutureGroup();
       |
       |  /// Whether [_stream] is done emitting events.
       |  var _isDone = false;
       |
       |  /// Whether [close] has been called.
       |  var _isClosed = false;
       |
       |  /// Splits [stream] into [count] identical streams.
       |  ///
       |  /// [count] defaults to 2. This is the same as creating [count] branches and
       |  /// then closing the [StreamSplitter].
      0|  static List<Stream<T>> splitFrom<T>(Stream<T> stream, [int count]) {
       |    count ??= 2;
      0|    var splitter = StreamSplitter<T>(stream);
      0|    var streams = List<Stream<T>>.generate(count, (_) => splitter.split());
      0|    splitter.close();
       |    return streams;
       |  }
       |
      0|  StreamSplitter(this._stream);
       |
       |  /// Returns a single-subscription stream that's a copy of the input stream.
       |  ///
       |  /// This will throw a [StateError] if [close] has been called.
      0|  Stream<T> split() {
      0|    if (_isClosed) {
      0|      throw StateError("Can't call split() on a closed StreamSplitter.");
       |    }
       |
      0|    var controller = StreamController<T>(
      0|        onListen: _onListen, onPause: _onPause, onResume: _onResume);
      0|    controller.onCancel = () => _onCancel(controller);
       |
      0|    for (var result in _buffer) {
      0|      result.addTo(controller);
       |    }
       |
      0|    if (_isDone) {
      0|      _closeGroup.add(controller.close());
       |    } else {
      0|      _controllers.add(controller);
       |    }
       |
      0|    return controller.stream;
       |  }
       |
       |  /// Indicates that no more branches will be requested via [split].
       |  ///
       |  /// This clears the internal buffer of events. If there are no branches or all
       |  /// branches have been canceled, this cancels the subscription to the input
       |  /// stream.
       |  ///
       |  /// Returns a [Future] that completes once all events have been processed by
       |  /// all branches and (if applicable) the subscription to the input stream has
       |  /// been canceled.
      0|  Future close() {
      0|    if (_isClosed) return _closeGroup.future;
      0|    _isClosed = true;
       |
      0|    _buffer.clear();
      0|    if (_controllers.isEmpty) _cancelSubscription();
       |
      0|    return _closeGroup.future;
       |  }
       |
       |  /// Cancel [_subscription] and close [_closeGroup].
       |  ///
       |  /// This should be called after all the branches' subscriptions have been
       |  /// canceled and the splitter has been closed. In that case, we won't use the
       |  /// events from [_subscription] any more, since there's nothing to pipe them
       |  /// to and no more branches will be created. If [_subscription] is done,
       |  /// canceling it will be a no-op.
       |  ///
       |  /// This may also be called before any branches have been created, in which
       |  /// case [_subscription] will be `null`.
      0|  void _cancelSubscription() {
       |    assert(_controllers.isEmpty);
       |    assert(_isClosed);
       |
       |    Future future;
      0|    if (_subscription != null) future = _subscription.cancel();
      0|    if (future != null) _closeGroup.add(future);
      0|    _closeGroup.close();
       |  }
       |
       |  // StreamController events
       |
       |  /// Subscribe to [_stream] if we haven't yet done so, and resume the
       |  /// subscription if we have.
      0|  void _onListen() {
      0|    if (_isDone) return;
       |
      0|    if (_subscription != null) {
       |      // Resume the subscription in case it was paused, either because all the
       |      // controllers were paused or because the last one was canceled. If it
       |      // wasn't paused, this will be a no-op.
      0|      _subscription.resume();
       |    } else {
      0|      _subscription =
      0|          _stream.listen(_onData, onError: _onError, onDone: _onDone);
       |    }
       |  }
       |
       |  /// Pauses [_subscription] if every controller is paused.
      0|  void _onPause() {
      0|    if (!_controllers.every((controller) => controller.isPaused)) return;
      0|    _subscription.pause();
       |  }
       |
       |  /// Resumes [_subscription].
       |  ///
       |  /// If [_subscription] wasn't paused, this is a no-op.
      0|  void _onResume() {
      0|    _subscription.resume();
       |  }
       |
       |  /// Removes [controller] from [_controllers] and cancels or pauses
       |  /// [_subscription] as appropriate.
       |  ///
       |  /// Since the controller emitting a done event will cause it to register as
       |  /// canceled, this is the only way that a controller is ever removed from
       |  /// [_controllers].
      0|  void _onCancel(StreamController controller) {
      0|    _controllers.remove(controller);
      0|    if (_controllers.isNotEmpty) return;
       |
      0|    if (_isClosed) {
      0|      _cancelSubscription();
       |    } else {
      0|      _subscription.pause();
       |    }
       |  }
       |
       |  // Stream events
       |
       |  /// Buffers [data] and passes it to [_controllers].
      0|  void _onData(T data) {
      0|    if (!_isClosed) _buffer.add(Result.value(data));
      0|    for (var controller in _controllers) {
      0|      controller.add(data);
       |    }
       |  }
       |
       |  /// Buffers [error] and passes it to [_controllers].
      0|  void _onError(Object error, StackTrace stackTrace) {
      0|    if (!_isClosed) _buffer.add(Result.error(error, stackTrace));
      0|    for (var controller in _controllers) {
      0|      controller.addError(error, stackTrace);
       |    }
       |  }
       |
       |  /// Marks [_controllers] as done.
      0|  void _onDone() {
      0|    _isDone = true;
      0|    for (var controller in _controllers) {
      0|      _closeGroup.add(controller.close());
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_subscription_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'async_memoizer.dart';
       |
       |typedef _AsyncHandler<T> = Future Function(StreamSubscription<T> inner);
       |
       |typedef _VoidHandler<T> = void Function(StreamSubscription<T> inner);
       |
       |/// Creates a [StreamTransformer] that modifies the behavior of subscriptions to
       |/// a stream.
       |///
       |/// When [StreamSubscription.cancel], [StreamSubscription.pause], or
       |/// [StreamSubscription.resume] is called, the corresponding handler is invoked.
       |/// By default, handlers just forward to the underlying subscription.
       |///
       |/// Guarantees that none of the [StreamSubscription] callbacks and none of the
       |/// callbacks passed to `subscriptionTransformer()` will be invoked once the
       |/// transformed [StreamSubscription] has been canceled and `handleCancel()` has
       |/// run. The [handlePause] and [handleResume] are invoked regardless of whether
       |/// the subscription is paused already or not.
       |///
       |/// In order to preserve [StreamSubscription] guarantees, **all callbacks must
       |/// synchronously call the corresponding method** on the inner
       |/// [StreamSubscription]: [handleCancel] must call `cancel()`, [handlePause]
       |/// must call `pause()`, and [handleResume] must call `resume()`.
      0|StreamTransformer<T, T> subscriptionTransformer<T>(
       |    {Future Function(StreamSubscription<T>) handleCancel,
       |    void Function(StreamSubscription<T>) handlePause,
       |    void Function(StreamSubscription<T>) handleResume}) {
      0|  return StreamTransformer((stream, cancelOnError) {
      0|    return _TransformedSubscription(
      0|        stream.listen(null, cancelOnError: cancelOnError),
      0|        handleCancel ?? (inner) => inner.cancel(),
       |        handlePause ??
      0|            (inner) {
      0|              inner.pause();
       |            },
       |        handleResume ??
      0|            (inner) {
      0|              inner.resume();
       |            });
       |  });
       |}
       |
       |/// A [StreamSubscription] wrapper that calls callbacks for subscription
       |/// methods.
       |class _TransformedSubscription<T> implements StreamSubscription<T> {
       |  /// The wrapped subscription.
       |  StreamSubscription<T> _inner;
       |
       |  /// The callback to run when [cancel] is called.
       |  final _AsyncHandler<T> _handleCancel;
       |
       |  /// The callback to run when [pause] is called.
       |  final _VoidHandler<T> _handlePause;
       |
       |  /// The callback to run when [resume] is called.
       |  final _VoidHandler<T> _handleResume;
       |
      0|  @override
      0|  bool get isPaused => _inner?.isPaused ?? false;
       |
      0|  _TransformedSubscription(
       |      this._inner, this._handleCancel, this._handlePause, this._handleResume);
       |
      0|  @override
       |  void onData(void Function(T) handleData) {
      0|    _inner?.onData(handleData);
       |  }
       |
      0|  @override
       |  void onError(Function handleError) {
      0|    _inner?.onError(handleError);
       |  }
       |
      0|  @override
       |  void onDone(void Function() handleDone) {
      0|    _inner?.onDone(handleDone);
       |  }
       |
      0|  @override
      0|  Future cancel() => _cancelMemoizer.runOnce(() {
      0|        var inner = _inner;
      0|        _inner.onData(null);
      0|        _inner.onDone(null);
       |
       |        // Setting onError to null will cause errors to be top-leveled.
      0|        _inner.onError((_, __) {});
      0|        _inner = null;
      0|        return _handleCancel(inner);
       |      });
       |  final _cancelMemoizer = AsyncMemoizer();
       |
      0|  @override
       |  void pause([Future resumeFuture]) {
      0|    if (_cancelMemoizer.hasRun) return;
      0|    if (resumeFuture != null) resumeFuture.whenComplete(resume);
      0|    _handlePause(_inner);
       |  }
       |
      0|  @override
       |  void resume() {
      0|    if (_cancelMemoizer.hasRun) return;
      0|    _handleResume(_inner);
       |  }
       |
      0|  @override
       |  Future<E> asFuture<E>([E futureValue]) =>
      0|      _inner?.asFuture(futureValue) ?? Completer<E>().future;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_zip.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// A stream that combines the values of other streams.
       |///
       |/// This emits lists of collected values from each input stream. The first list
       |/// contains the first value emitted by each stream, the second contains the
       |/// second value, and so on. The lists have the same ordering as the iterable
       |/// passed to [new StreamZip].
       |///
       |/// Any errors from any of the streams are forwarded directly to this stream.
       |class StreamZip<T> extends Stream<List<T>> {
       |  final Iterable<Stream<T>> _streams;
       |
      0|  StreamZip(Iterable<Stream<T>> streams) : _streams = streams;
       |
      0|  @override
       |  StreamSubscription<List<T>> listen(void Function(List<T>) onData,
       |      {Function onError, void Function() onDone, bool cancelOnError}) {
       |    cancelOnError = identical(true, cancelOnError);
      0|    var subscriptions = <StreamSubscription<T>>[];
       |    StreamController<List<T>> controller;
       |    List<T> current;
       |    var dataCount = 0;
       |
       |    /// Called for each data from a subscription in [subscriptions].
      0|    void handleData(int index, T data) {
      0|      current[index] = data;
      0|      dataCount++;
      0|      if (dataCount == subscriptions.length) {
       |        var data = current;
      0|        current = List(subscriptions.length);
       |        dataCount = 0;
      0|        for (var i = 0; i < subscriptions.length; i++) {
      0|          if (i != index) subscriptions[i].resume();
       |        }
      0|        controller.add(data);
       |      } else {
      0|        subscriptions[index].pause();
       |      }
       |    }
       |
       |    /// Called for each error from a subscription in [subscriptions].
       |    /// Except if [cancelOnError] is true, in which case the function below
       |    /// is used instead.
      0|    void handleError(Object error, StackTrace stackTrace) {
      0|      controller.addError(error, stackTrace);
       |    }
       |
       |    /// Called when a subscription has an error and [cancelOnError] is true.
       |    ///
       |    /// Prematurely cancels all subscriptions since we know that we won't
       |    /// be needing any more values.
      0|    void handleErrorCancel(Object error, StackTrace stackTrace) {
      0|      for (var i = 0; i < subscriptions.length; i++) {
      0|        subscriptions[i].cancel();
       |      }
      0|      controller.addError(error, stackTrace);
       |    }
       |
      0|    void handleDone() {
      0|      for (var i = 0; i < subscriptions.length; i++) {
      0|        subscriptions[i].cancel();
       |      }
      0|      controller.close();
       |    }
       |
       |    try {
      0|      for (var stream in _streams) {
      0|        var index = subscriptions.length;
      0|        subscriptions.add(stream.listen((data) {
      0|          handleData(index, data);
       |        },
       |            onError: cancelOnError ? handleError : handleErrorCancel,
       |            onDone: handleDone,
       |            cancelOnError: cancelOnError));
       |      }
       |    } catch (e) {
      0|      for (var i = subscriptions.length - 1; i >= 0; i--) {
      0|        subscriptions[i].cancel();
       |      }
       |      rethrow;
       |    }
       |
      0|    current = List(subscriptions.length);
       |
      0|    controller = StreamController<List<T>>(onPause: () {
      0|      for (var i = 0; i < subscriptions.length; i++) {
       |        // This may pause some subscriptions more than once.
       |        // These will not be resumed by onResume below, but must wait for the
       |        // next round.
      0|        subscriptions[i].pause();
       |      }
      0|    }, onResume: () {
      0|      for (var i = 0; i < subscriptions.length; i++) {
      0|        subscriptions[i].resume();
       |      }
      0|    }, onCancel: () {
      0|      for (var i = 0; i < subscriptions.length; i++) {
       |        // Canceling more than once is safe.
      0|        subscriptions[i].cancel();
       |      }
       |    });
       |
      0|    if (subscriptions.isEmpty) {
      0|      controller.close();
       |    }
      0|    return controller.stream.listen(onData,
       |        onError: onError, onDone: onDone, cancelOnError: cancelOnError);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/subscription_stream.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'delegate/stream_subscription.dart';
       |
       |/// A [Stream] adapter for a [StreamSubscription].
       |///
       |/// This class allows a `StreamSubscription` to be treated as a `Stream`.
       |///
       |/// The subscription is paused until the stream is listened to,
       |/// then it is resumed and the events are passed on to the
       |/// stream's new subscription.
       |///
       |/// This class assumes that is has control over the original subscription.
       |/// If other code is accessing the subscription, results may be unpredictable.
       |class SubscriptionStream<T> extends Stream<T> {
       |  /// The subscription providing the events for this stream.
       |  StreamSubscription<T> _source;
       |
       |  /// Create a single-subscription `Stream` from [subscription].
       |  ///
       |  /// The `subscription` should not be paused. This class will not resume prior
       |  /// pauses, so being paused is indistinguishable from not providing any
       |  /// events.
       |  ///
       |  /// If the `subscription` doesn't send any `done` events, neither will this
       |  /// stream. That may be an issue if `subscription` was made to cancel on
       |  /// an error.
      0|  SubscriptionStream(StreamSubscription<T> subscription)
       |      : _source = subscription {
      0|    _source.pause();
       |    // Clear callbacks to avoid keeping them alive unnecessarily.
      0|    _source.onData(null);
      0|    _source.onError(null);
      0|    _source.onDone(null);
       |  }
       |
      0|  @override
       |  StreamSubscription<T> listen(void Function(T) onData,
       |      {Function onError, void Function() onDone, bool cancelOnError}) {
      0|    if (_source == null) {
      0|      throw StateError('Stream has already been listened to.');
       |    }
      0|    cancelOnError = (true == cancelOnError);
      0|    var subscription = _source;
      0|    _source = null;
       |
       |    var result = cancelOnError
      0|        ? _CancelOnErrorSubscriptionWrapper<T>(subscription)
       |        : subscription;
      0|    result.onData(onData);
      0|    result.onError(onError);
      0|    result.onDone(onDone);
      0|    subscription.resume();
       |    return result;
       |  }
       |}
       |
       |/// Subscription wrapper that cancels on error.
       |///
       |/// Used by [SubscriptionStream] when forwarding a subscription
       |/// created with `cancelOnError` as `true` to one with (assumed)
       |/// `cancelOnError` as `false`. It automatically cancels the
       |/// source subscription on the first error.
       |class _CancelOnErrorSubscriptionWrapper<T>
       |    extends DelegatingStreamSubscription<T> {
      0|  _CancelOnErrorSubscriptionWrapper(StreamSubscription<T> subscription)
      0|      : super(subscription);
       |
      0|  @override
       |  void onError(Function handleError) {
       |    // Cancel when receiving an error.
      0|    super.onError((error, StackTrace stackTrace) {
      0|      var cancelFuture = super.cancel();
       |      if (cancelFuture != null) {
       |        // Wait for the cancel to complete before sending the error event.
      0|        cancelFuture.whenComplete(() {
      0|          if (handleError is ZoneBinaryCallback) {
      0|            handleError(error, stackTrace);
       |          } else {
      0|            handleError(error);
       |          }
       |        });
       |      } else {
      0|        if (handleError is ZoneBinaryCallback) {
      0|          handleError(error, stackTrace);
       |        } else {
      0|          handleError(error);
       |        }
       |      }
       |    });
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/typed_stream_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |/// Creates a wrapper that coerces the type of [transformer].
       |///
       |/// This soundly converts a [StreamTransformer] to a `StreamTransformer<S, T>`,
       |/// regardless of its original generic type, by asserting that the events
       |/// emitted by the transformed stream are instances of `T` whenever they're
       |/// provided. If they're not, the stream throws a [CastError].
      0|@Deprecated('Use Stream.cast after binding a transformer instead')
       |StreamTransformer<S, T> typedStreamTransformer<S, T>(
       |        StreamTransformer transformer) =>
      0|    transformer is StreamTransformer<S, T>
       |        ? transformer
      0|        : _TypeSafeStreamTransformer(transformer);
       |
       |/// A wrapper that coerces the type of the stream returned by an inner
       |/// transformer.
       |class _TypeSafeStreamTransformer<S, T> extends StreamTransformerBase<S, T> {
       |  final StreamTransformer _inner;
       |
      0|  _TypeSafeStreamTransformer(this._inner);
       |
      0|  @override
      0|  Stream<T> bind(Stream<S> stream) => _inner.bind(stream).cast();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/typed/stream_subscription.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |class TypeSafeStreamSubscription<T> implements StreamSubscription<T> {
       |  final StreamSubscription _subscription;
       |
      0|  @override
      0|  bool get isPaused => _subscription.isPaused;
       |
      0|  TypeSafeStreamSubscription(this._subscription);
       |
      0|  @override
       |  void onData(void Function(T) handleData) {
      0|    _subscription.onData((data) => handleData(data as T));
       |  }
       |
      0|  @override
       |  void onError(Function handleError) {
      0|    _subscription.onError(handleError);
       |  }
       |
      0|  @override
       |  void onDone(void Function() handleDone) {
      0|    _subscription.onDone(handleDone);
       |  }
       |
      0|  @override
       |  void pause([Future resumeFuture]) {
      0|    _subscription.pause(resumeFuture);
       |  }
       |
      0|  @override
       |  void resume() {
      0|    _subscription.resume();
       |  }
       |
      0|  @override
      0|  Future cancel() => _subscription.cancel();
       |
      0|  @override
      0|  Future<E> asFuture<E>([E futureValue]) => _subscription.asFuture(futureValue);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/result/capture_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'result.dart';
       |
       |/// Used by [Result.captureSink].
       |class CaptureSink<T> implements EventSink<T> {
       |  final EventSink<Result<T>> _sink;
       |
      0|  CaptureSink(EventSink<Result<T>> sink) : _sink = sink;
       |
      0|  @override
       |  void add(T value) {
      0|    _sink.add(Result<T>.value(value));
       |  }
       |
      0|  @override
       |  void addError(Object error, [StackTrace stackTrace]) {
      0|    _sink.add(Result.error(error, stackTrace));
       |  }
       |
      0|  @override
       |  void close() {
      0|    _sink.close();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/result/capture_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'result.dart';
       |import 'capture_sink.dart';
       |
       |/// A stream transformer that captures a stream of events into [Result]s.
       |///
       |/// The result of the transformation is a stream of [Result] values and no
       |/// error events. Exposed by [Result.captureStream].
       |class CaptureStreamTransformer<T> extends StreamTransformerBase<T, Result<T>> {
      0|  const CaptureStreamTransformer();
       |
      0|  @override
       |  Stream<Result<T>> bind(Stream<T> source) =>
      0|      Stream<Result<T>>.eventTransformed(
      0|          source, (sink) => CaptureSink<T>(sink));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/result/release_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'result.dart';
       |
       |/// Used by [Result.releaseSink].
       |class ReleaseSink<T> implements EventSink<Result<T>> {
       |  final EventSink<T> _sink;
       |
      0|  ReleaseSink(this._sink);
       |
      0|  @override
       |  void add(Result<T> result) {
      0|    result.addTo(_sink);
       |  }
       |
      0|  @override
       |  void addError(Object error, [StackTrace stackTrace]) {
       |    // Errors may be added by intermediate processing, even if it is never
       |    // added by CaptureSink.
      0|    _sink.addError(error, stackTrace);
       |  }
       |
      0|  @override
       |  void close() {
      0|    _sink.close();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/result/release_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'result.dart';
       |import 'release_sink.dart';
       |
       |/// A transformer that releases result events as data and error events.
       |class ReleaseStreamTransformer<T> extends StreamTransformerBase<Result<T>, T> {
      0|  const ReleaseStreamTransformer();
       |
      0|  @override
       |  Stream<T> bind(Stream<Result<T>> source) {
      0|    return Stream<T>.eventTransformed(source, _createSink);
       |  }
       |
       |  // Since Stream.eventTransformed is not generic, this method can be static.
      0|  static EventSink<Result> _createSink(EventSink sink) => ReleaseSink(sink);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_sink_transformer/handler_transformer.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_sink_transformer.dart';
       |import '../delegate/stream_sink.dart';
       |
       |/// The type of the callback for handling data events.
       |typedef HandleData<S, T> = void Function(S data, EventSink<T> sink);
       |
       |/// The type of the callback for handling error events.
       |typedef HandleError<T> = void Function(
       |    Object error, StackTrace stackTrace, EventSink<T> sink);
       |
       |/// The type of the callback for handling done events.
       |typedef HandleDone<T> = void Function(EventSink<T> sink);
       |
       |/// A [StreamSinkTransformer] that delegates events to the given handlers.
       |class HandlerTransformer<S, T> implements StreamSinkTransformer<S, T> {
       |  /// The handler for data events.
       |  final HandleData<S, T> _handleData;
       |
       |  /// The handler for error events.
       |  final HandleError<T> _handleError;
       |
       |  /// The handler for done events.
       |  final HandleDone<T> _handleDone;
       |
      0|  HandlerTransformer(this._handleData, this._handleError, this._handleDone);
       |
      0|  @override
      0|  StreamSink<S> bind(StreamSink<T> sink) => _HandlerSink<S, T>(this, sink);
       |}
       |
       |/// A sink created by [HandlerTransformer].
       |class _HandlerSink<S, T> implements StreamSink<S> {
       |  /// The transformer that created this sink.
       |  final HandlerTransformer<S, T> _transformer;
       |
       |  /// The original sink that's being transformed.
       |  final StreamSink<T> _inner;
       |
       |  /// The wrapper for [_inner] whose [StreamSink.close] method can't emit
       |  /// errors.
       |  final StreamSink<T> _safeCloseInner;
       |
      0|  @override
      0|  Future get done => _inner.done;
       |
      0|  _HandlerSink(this._transformer, StreamSink<T> inner)
       |      : _inner = inner,
      0|        _safeCloseInner = _SafeCloseSink<T>(inner);
       |
      0|  @override
       |  void add(S event) {
      0|    if (_transformer._handleData == null) {
      0|      _inner.add(event as T);
       |    } else {
      0|      _transformer._handleData(event, _safeCloseInner);
       |    }
       |  }
       |
      0|  @override
       |  void addError(error, [StackTrace stackTrace]) {
      0|    if (_transformer._handleError == null) {
      0|      _inner.addError(error, stackTrace);
       |    } else {
      0|      _transformer._handleError(error, stackTrace, _safeCloseInner);
       |    }
       |  }
       |
      0|  @override
       |  Future addStream(Stream<S> stream) {
      0|    return _inner.addStream(stream.transform(
      0|        StreamTransformer<S, T>.fromHandlers(
      0|            handleData: _transformer._handleData,
      0|            handleError: _transformer._handleError,
       |            handleDone: _closeSink)));
       |  }
       |
      0|  @override
       |  Future close() {
      0|    if (_transformer._handleDone == null) return _inner.close();
       |
      0|    _transformer._handleDone(_safeCloseInner);
      0|    return _inner.done;
       |  }
       |}
       |
       |/// A wrapper for [StreamSink]s that swallows any errors returned by [close].
       |///
       |/// [HandlerTransformer] passes this to its handlers to ensure that when they
       |/// call [close], they don't leave any dangling [Future]s behind that might emit
       |/// unhandleable errors.
       |class _SafeCloseSink<T> extends DelegatingStreamSink<T> {
      0|  _SafeCloseSink(StreamSink<T> inner) : super(inner);
       |
      0|  @override
      0|  Future close() => super.close().catchError((_) {});
       |}
       |
       |/// A function to pass as a [StreamTransformer]'s `handleDone` callback.
      0|void _closeSink(EventSink sink) {
      0|  sink.close();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_sink_transformer/stream_transformer_wrapper.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_sink_transformer.dart';
       |
       |/// A [StreamSinkTransformer] that wraps a pre-existing [StreamTransformer].
       |class StreamTransformerWrapper<S, T> implements StreamSinkTransformer<S, T> {
       |  /// The wrapped transformer.
       |  final StreamTransformer<S, T> _transformer;
       |
      0|  const StreamTransformerWrapper(this._transformer);
       |
      0|  @override
       |  StreamSink<S> bind(StreamSink<T> sink) =>
      0|      _StreamTransformerWrapperSink<S, T>(_transformer, sink);
       |}
       |
       |/// A sink created by [StreamTransformerWrapper].
       |class _StreamTransformerWrapperSink<S, T> implements StreamSink<S> {
       |  /// The controller through which events are passed.
       |  ///
       |  /// This is used to create a stream that can be transformed by the wrapped
       |  /// transformer.
       |  final _controller = StreamController<S>(sync: true);
       |
       |  /// The original sink that's being transformed.
       |  final StreamSink<T> _inner;
       |
      0|  @override
      0|  Future get done => _inner.done;
       |
      0|  _StreamTransformerWrapperSink(
       |      StreamTransformer<S, T> transformer, this._inner) {
      0|    _controller.stream
      0|        .transform(transformer)
      0|        .listen(_inner.add, onError: _inner.addError, onDone: () {
       |      // Ignore any errors that come from this call to [_inner.close]. The
       |      // user can access them through [done] or the value returned from
       |      // [this.close], and we don't want them to get top-leveled.
      0|      _inner.close().catchError((_) {});
       |    });
       |  }
       |
      0|  @override
       |  void add(S event) {
      0|    _controller.add(event);
       |  }
       |
      0|  @override
       |  void addError(error, [StackTrace stackTrace]) {
      0|    _controller.addError(error, stackTrace);
       |  }
       |
      0|  @override
      0|  Future addStream(Stream<S> stream) => _controller.addStream(stream);
       |
      0|  @override
       |  Future close() {
      0|    _controller.close();
      0|    return _inner.done;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/async-2.4.2/lib/src/stream_sink_transformer/typed.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import '../stream_sink_transformer.dart';
       |
       |/// A wrapper that coerces the generic type of the sink returned by an inner
       |/// transformer to `S`.
       |class TypeSafeStreamSinkTransformer<S, T>
       |    implements StreamSinkTransformer<S, T> {
       |  final StreamSinkTransformer _inner;
       |
      0|  TypeSafeStreamSinkTransformer(this._inner);
       |
      0|  @override
      0|  StreamSink<S> bind(StreamSink<T> sink) => StreamController(sync: true)
      0|    ..stream.cast<dynamic>().pipe(_inner.bind(sink));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/core_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'feature_matcher.dart';
       |import 'interfaces.dart';
       |import 'type_matcher.dart';
       |import 'util.dart';
       |
       |/// Returns a matcher that matches the isEmpty property.
       |const Matcher isEmpty = _Empty();
       |
       |class _Empty extends Matcher {
      0|  const _Empty();
       |
      0|  @override
      0|  bool matches(item, Map matchState) => item.isEmpty;
       |
      0|  @override
      0|  Description describe(Description description) => description.add('empty');
       |}
       |
       |/// Returns a matcher that matches the isNotEmpty property.
       |const Matcher isNotEmpty = _NotEmpty();
       |
       |class _NotEmpty extends Matcher {
      0|  const _NotEmpty();
       |
      0|  @override
      0|  bool matches(item, Map matchState) => item.isNotEmpty;
       |
      0|  @override
      0|  Description describe(Description description) => description.add('non-empty');
       |}
       |
       |/// A matcher that matches any null value.
       |const Matcher isNull = _IsNull();
       |
       |/// A matcher that matches any non-null value.
       |const Matcher isNotNull = _IsNotNull();
       |
       |class _IsNull extends Matcher {
      0|  const _IsNull();
      0|  @override
       |  bool matches(item, Map matchState) => item == null;
      0|  @override
      0|  Description describe(Description description) => description.add('null');
       |}
       |
       |class _IsNotNull extends Matcher {
      0|  const _IsNotNull();
      1|  @override
       |  bool matches(item, Map matchState) => item != null;
      0|  @override
      0|  Description describe(Description description) => description.add('not null');
       |}
       |
       |/// A matcher that matches the Boolean value true.
       |const Matcher isTrue = _IsTrue();
       |
       |/// A matcher that matches anything except the Boolean value true.
       |const Matcher isFalse = _IsFalse();
       |
       |class _IsTrue extends Matcher {
      0|  const _IsTrue();
      0|  @override
      0|  bool matches(item, Map matchState) => item == true;
      0|  @override
      0|  Description describe(Description description) => description.add('true');
       |}
       |
       |class _IsFalse extends Matcher {
      0|  const _IsFalse();
      0|  @override
      0|  bool matches(item, Map matchState) => item == false;
      0|  @override
      0|  Description describe(Description description) => description.add('false');
       |}
       |
       |/// A matcher that matches the numeric value NaN.
       |const Matcher isNaN = _IsNaN();
       |
       |/// A matcher that matches any non-NaN value.
       |const Matcher isNotNaN = _IsNotNaN();
       |
       |class _IsNaN extends FeatureMatcher<num> {
      0|  const _IsNaN();
      0|  @override
       |  bool typedMatches(num item, Map matchState) =>
      0|      double.nan.compareTo(item) == 0;
      0|  @override
      0|  Description describe(Description description) => description.add('NaN');
       |}
       |
       |class _IsNotNaN extends FeatureMatcher<num> {
      0|  const _IsNotNaN();
      0|  @override
       |  bool typedMatches(num item, Map matchState) =>
      0|      double.nan.compareTo(item) != 0;
      0|  @override
      0|  Description describe(Description description) => description.add('not NaN');
       |}
       |
       |/// Returns a matches that matches if the value is the same instance
       |/// as [expected], using [identical].
      0|Matcher same(expected) => _IsSameAs(expected);
       |
       |class _IsSameAs extends Matcher {
       |  final Object _expected;
      0|  const _IsSameAs(this._expected);
      0|  @override
      0|  bool matches(item, Map matchState) => identical(item, _expected);
       |  // If all types were hashable we could show a hash here.
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('same instance as ').addDescriptionOf(_expected);
       |}
       |
       |/// A matcher that matches any value.
       |const Matcher anything = _IsAnything();
       |
       |class _IsAnything extends Matcher {
      0|  const _IsAnything();
      0|  @override
       |  bool matches(item, Map matchState) => true;
      0|  @override
      0|  Description describe(Description description) => description.add('anything');
       |}
       |
       |/// **DEPRECATED** Use [isA] instead.
       |///
       |/// A matcher that matches if an object is an instance of [T] (or a subtype).
       |@Deprecated('Use `isA<MyType>()` instead.')
       |// ignore: camel_case_types
       |class isInstanceOf<T> extends TypeMatcher<T> {
      0|  const isInstanceOf();
       |}
       |
       |/// A matcher that matches a function call against no exception.
       |///
       |/// The function will be called once. Any exceptions will be silently swallowed.
       |/// The value passed to expect() should be a reference to the function.
       |/// Note that the function cannot take arguments; to handle this
       |/// a wrapper will have to be created.
       |const Matcher returnsNormally = _ReturnsNormally();
       |
       |class _ReturnsNormally extends FeatureMatcher<Function> {
      0|  const _ReturnsNormally();
       |
      0|  @override
       |  bool typedMatches(Function f, Map matchState) {
       |    try {
      0|      f();
       |      return true;
       |    } catch (e, s) {
      0|      addStateInfo(matchState, {'exception': e, 'stack': s});
       |      return false;
       |    }
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('return normally');
       |
      0|  @override
       |  Description describeTypedMismatch(Function item,
       |      Description mismatchDescription, Map matchState, bool verbose) {
      0|    mismatchDescription.add('threw ').addDescriptionOf(matchState['exception']);
       |    if (verbose) {
      0|      mismatchDescription.add(' at ').add(matchState['stack'].toString());
       |    }
       |    return mismatchDescription;
       |  }
       |}
       |
       |/// A matcher for [Map].
       |const isMap = TypeMatcher<Map>();
       |
       |/// A matcher for [List].
       |const isList = TypeMatcher<List>();
       |
       |/// Returns a matcher that matches if an object has a length property
       |/// that matches [matcher].
      0|Matcher hasLength(matcher) => _HasLength(wrapMatcher(matcher));
       |
       |class _HasLength extends Matcher {
       |  final Matcher _matcher;
      0|  const _HasLength([Matcher matcher]) : _matcher = matcher;
       |
      0|  @override
       |  bool matches(item, Map matchState) {
       |    try {
       |      // This is harmless code that will throw if no length property
       |      // but subtle enough that an optimizer shouldn't strip it out.
      0|      if (item.length * item.length >= 0) {
      0|        return _matcher.matches(item.length, matchState);
       |      }
       |    } catch (e) {
       |      return false;
       |    }
      0|    throw UnsupportedError('Should never get here');
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('an object with length of ').addDescriptionOf(_matcher);
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
       |    try {
       |      // We want to generate a different description if there is no length
       |      // property; we use the same trick as in matches().
      0|      if (item.length * item.length >= 0) {
       |        return mismatchDescription
      0|            .add('has length of ')
      0|            .addDescriptionOf(item.length);
       |      }
       |    } catch (e) {
      0|      return mismatchDescription.add('has no length property');
       |    }
      0|    throw UnsupportedError('Should never get here');
       |  }
       |}
       |
       |/// Returns a matcher that matches if the match argument contains the expected
       |/// value.
       |///
       |/// For [String]s this means substring matching;
       |/// for [Map]s it means the map has the key, and for [Iterable]s
       |/// it means the iterable has a matching element. In the case of iterables,
       |/// [expected] can itself be a matcher.
      0|Matcher contains(expected) => _Contains(expected);
       |
       |class _Contains extends Matcher {
       |  final Object _expected;
       |
      0|  const _Contains(this._expected);
       |
      0|  @override
       |  bool matches(item, Map matchState) {
      0|    var expected = _expected;
      0|    if (item is String) {
      0|      return expected is Pattern && item.contains(expected);
      0|    } else if (item is Iterable) {
      0|      if (expected is Matcher) {
      0|        return item.any((e) => expected.matches(e, matchState));
       |      } else {
      0|        return item.contains(_expected);
       |      }
      0|    } else if (item is Map) {
      0|      return item.containsKey(_expected);
       |    }
       |    return false;
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('contains ').addDescriptionOf(_expected);
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is String || item is Iterable || item is Map) {
       |      return super
      0|          .describeMismatch(item, mismatchDescription, matchState, verbose);
       |    } else {
      0|      return mismatchDescription.add('is not a string, map or iterable');
       |    }
       |  }
       |}
       |
       |/// Returns a matcher that matches if the match argument is in
       |/// the expected value. This is the converse of [contains].
      0|Matcher isIn(expected) {
      0|  if (expected is Iterable) {
      0|    return _In(expected, expected.contains);
      0|  } else if (expected is String) {
      0|    return _In<Pattern>(expected, expected.contains);
      0|  } else if (expected is Map) {
      0|    return _In(expected, expected.containsKey);
       |  }
       |
      0|  throw ArgumentError.value(
       |      expected, 'expected', 'Only Iterable, Map, and String are supported.');
       |}
       |
       |class _In<T> extends FeatureMatcher<T> {
       |  final Object _source;
       |  final bool Function(T) _containsFunction;
       |
      0|  const _In(this._source, this._containsFunction);
       |
      0|  @override
      0|  bool typedMatches(T item, Map matchState) => _containsFunction(item);
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('is in ').addDescriptionOf(_source);
       |}
       |
       |/// Returns a matcher that uses an arbitrary function that returns
       |/// true or false for the actual value.
       |///
       |/// For example:
       |///
       |///     expect(v, predicate((x) => ((x % 2) == 0), "is even"))
      1|Matcher predicate<T>(bool Function(T) f,
       |        [String description = 'satisfies function']) =>
      1|    _Predicate(f, description);
       |
       |typedef _PredicateFunction<T> = bool Function(T value);
       |
       |class _Predicate<T> extends FeatureMatcher<T> {
       |  final _PredicateFunction<T> _matcher;
       |  final String _description;
       |
      1|  _Predicate(this._matcher, this._description);
       |
      1|  @override
      2|  bool typedMatches(T item, Map matchState) => _matcher(item);
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add(_description);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/custom_matcher.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import 'description.dart';
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// A useful utility class for implementing other matchers through inheritance.
       |/// Derived classes should call the base constructor with a feature name and
       |/// description, and an instance matcher, and should implement the
       |/// [featureValueOf] abstract method.
       |///
       |/// The feature description will typically describe the item and the feature,
       |/// while the feature name will just name the feature. For example, we may
       |/// have a Widget class where each Widget has a price; we could make a
       |/// [CustomMatcher] that can make assertions about prices with:
       |///
       |/// ```dart
       |/// class HasPrice extends CustomMatcher {
       |///   HasPrice(matcher) : super("Widget with price that is", "price", matcher);
       |///   featureValueOf(actual) => (actual as Widget).price;
       |/// }
       |/// ```
       |///
       |/// and then use this for example like:
       |///
       |/// ```dart
       |/// expect(inventoryItem, HasPrice(greaterThan(0)));
       |/// ```
       |class CustomMatcher extends Matcher {
       |  final String _featureDescription;
       |  final String _featureName;
       |  final Matcher _matcher;
       |
      0|  CustomMatcher(this._featureDescription, this._featureName, matcher)
      0|      : _matcher = wrapMatcher(matcher);
       |
       |  /// Override this to extract the interesting feature.
      0|  Object featureValueOf(actual) => actual;
       |
      0|  @override
       |  bool matches(item, Map matchState) {
       |    try {
      0|      var f = featureValueOf(item);
      0|      if (_matcher.matches(f, matchState)) return true;
      0|      addStateInfo(matchState, {'custom.feature': f});
       |    } catch (exception, stack) {
      0|      addStateInfo(matchState, {
      0|        'custom.exception': exception.toString(),
      0|        'custom.stack': Chain.forTrace(stack)
      0|            .foldFrames(
      0|                (frame) =>
      0|                    frame.package == 'test' ||
      0|                    frame.package == 'stream_channel' ||
      0|                    frame.package == 'matcher',
       |                terse: true)
      0|            .toString()
       |      });
       |    }
       |    return false;
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add(_featureDescription).add(' ').addDescriptionOf(_matcher);
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (matchState['custom.exception'] != null) {
       |      mismatchDescription
      0|          .add('threw ')
      0|          .addDescriptionOf(matchState['custom.exception'])
      0|          .add('\n')
      0|          .add(matchState['custom.stack'].toString());
       |      return mismatchDescription;
       |    }
       |
       |    mismatchDescription
      0|        .add('has ')
      0|        .add(_featureName)
      0|        .add(' with value ')
      0|        .addDescriptionOf(matchState['custom.feature']);
      0|    var innerDescription = StringDescription();
       |
      0|    _matcher.describeMismatch(matchState['custom.feature'], innerDescription,
      0|        matchState['state'] as Map, verbose);
       |
      0|    if (innerDescription.length > 0) {
      0|      mismatchDescription.add(' which ').add(innerDescription.toString());
       |    }
       |    return mismatchDescription;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/description.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |import 'pretty_print.dart';
       |
       |/// The default implementation of [Description]. This should rarely need
       |/// substitution, although conceivably it is a place where other languages
       |/// could be supported.
       |class StringDescription implements Description {
       |  final StringBuffer _out = StringBuffer();
       |
       |  /// Initialize the description with initial contents [init].
      0|  StringDescription([String init = '']) {
      0|    _out.write(init);
       |  }
       |
      0|  @override
      0|  int get length => _out.length;
       |
       |  /// Get the description as a string.
      0|  @override
      0|  String toString() => _out.toString();
       |
       |  /// Append [text] to the description.
      0|  @override
       |  Description add(String text) {
      0|    _out.write(text);
       |    return this;
       |  }
       |
       |  /// Change the value of the description.
      0|  @override
       |  Description replace(String text) {
      0|    _out.clear();
      0|    return add(text);
       |  }
       |
       |  /// Appends a description of [value]. If it is an IMatcher use its
       |  /// describe method; if it is a string use its literal value after
       |  /// escaping any embedded control characters; otherwise use its
       |  /// toString() value and wrap it in angular "quotes".
      0|  @override
       |  Description addDescriptionOf(value) {
      0|    if (value is Matcher) {
      0|      value.describe(this);
       |    } else {
      0|      add(prettyPrint(value, maxLineLength: 80, maxItems: 25));
       |    }
       |    return this;
       |  }
       |
       |  /// Append an [Iterable] [list] of objects to the description, using the
       |  /// specified [separator] and framing the list with [start]
       |  /// and [end].
      0|  @override
       |  Description addAll(
       |      String start, String separator, String end, Iterable list) {
       |    var separate = false;
      0|    add(start);
      0|    for (var item in list) {
       |      if (separate) {
      0|        add(separator);
       |      }
      0|      addDescriptionOf(item);
       |      separate = true;
       |    }
      0|    add(end);
       |    return this;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/equals_matcher.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'feature_matcher.dart';
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// Returns a matcher that matches if the value is structurally equal to
       |/// [expected].
       |///
       |/// If [expected] is a [Matcher], then it matches using that. Otherwise it tests
       |/// for equality using `==` on the expected value.
       |///
       |/// For [Iterable]s and [Map]s, this will recursively match the elements. To
       |/// handle cyclic structures a recursion depth [limit] can be provided. The
       |/// default limit is 100. [Set]s will be compared order-independently.
      2|Matcher equals(expected, [int limit = 100]) => expected is String
      1|    ? _StringEqualsMatcher(expected)
      1|    : _DeepMatcher(expected, limit);
       |
       |typedef _RecursiveMatcher = _Mismatch Function(dynamic, dynamic, String, int);
       |
       |/// A special equality matcher for strings.
       |class _StringEqualsMatcher extends FeatureMatcher<String> {
       |  final String _value;
       |
      1|  _StringEqualsMatcher(this._value);
       |
      1|  @override
      2|  bool typedMatches(String item, Map matchState) => _value == item;
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.addDescriptionOf(_value);
       |
      0|  @override
       |  Description describeTypedMismatch(String item,
       |      Description mismatchDescription, Map matchState, bool verbose) {
      0|    var buff = StringBuffer();
      0|    buff.write('is different.');
      0|    var escapedItem = escape(item);
      0|    var escapedValue = escape(_value);
      0|    var minLength = escapedItem.length < escapedValue.length
      0|        ? escapedItem.length
      0|        : escapedValue.length;
       |    var start = 0;
      0|    for (; start < minLength; start++) {
      0|      if (escapedValue.codeUnitAt(start) != escapedItem.codeUnitAt(start)) {
       |        break;
       |      }
       |    }
      0|    if (start == minLength) {
      0|      if (escapedValue.length < escapedItem.length) {
      0|        buff.write(' Both strings start the same, but the actual value also'
       |            ' has the following trailing characters: ');
      0|        _writeTrailing(buff, escapedItem, escapedValue.length);
       |      } else {
      0|        buff.write(' Both strings start the same, but the actual value is'
       |            ' missing the following trailing characters: ');
      0|        _writeTrailing(buff, escapedValue, escapedItem.length);
       |      }
       |    } else {
      0|      buff.write('\nExpected: ');
      0|      _writeLeading(buff, escapedValue, start);
      0|      _writeTrailing(buff, escapedValue, start);
      0|      buff.write('\n  Actual: ');
      0|      _writeLeading(buff, escapedItem, start);
      0|      _writeTrailing(buff, escapedItem, start);
      0|      buff.write('\n          ');
      0|      for (var i = start > 10 ? 14 : start; i > 0; i--) {
      0|        buff.write(' ');
       |      }
      0|      buff.write('^\n Differ at offset $start');
       |    }
       |
      0|    return mismatchDescription.add(buff.toString());
       |  }
       |
      0|  static void _writeLeading(StringBuffer buff, String s, int start) {
      0|    if (start > 10) {
      0|      buff.write('... ');
      0|      buff.write(s.substring(start - 10, start));
       |    } else {
      0|      buff.write(s.substring(0, start));
       |    }
       |  }
       |
      0|  static void _writeTrailing(StringBuffer buff, String s, int start) {
      0|    if (start + 10 > s.length) {
      0|      buff.write(s.substring(start));
       |    } else {
      0|      buff.write(s.substring(start, start + 10));
      0|      buff.write(' ...');
       |    }
       |  }
       |}
       |
       |class _DeepMatcher extends Matcher {
       |  final Object _expected;
       |  final int _limit;
       |
      1|  _DeepMatcher(this._expected, [int limit = 1000]) : _limit = limit;
       |
      0|  _Mismatch _compareIterables(Iterable expected, Object actual,
       |      _RecursiveMatcher matcher, int depth, String location) {
      0|    if (actual is Iterable) {
      0|      var expectedIterator = expected.iterator;
      0|      var actualIterator = actual.iterator;
      0|      for (var index = 0;; index++) {
       |        // Advance in lockstep.
      0|        var expectedNext = expectedIterator.moveNext();
      0|        var actualNext = actualIterator.moveNext();
       |
       |        // If we reached the end of both, we succeeded.
       |        if (!expectedNext && !actualNext) return null;
       |
       |        // Fail if their lengths are different.
      0|        var newLocation = '$location[$index]';
       |        if (!expectedNext) {
      0|          return _Mismatch.simple(newLocation, actual, 'longer than expected');
       |        }
       |        if (!actualNext) {
      0|          return _Mismatch.simple(newLocation, actual, 'shorter than expected');
       |        }
       |
       |        // Match the elements.
      0|        var rp = matcher(expectedIterator.current, actualIterator.current,
       |            newLocation, depth);
       |        if (rp != null) return rp;
       |      }
       |    } else {
      0|      return _Mismatch.simple(location, actual, 'is not Iterable');
       |    }
       |  }
       |
      0|  _Mismatch _compareSets(Set expected, Object actual, _RecursiveMatcher matcher,
       |      int depth, String location) {
      0|    if (actual is Iterable) {
      0|      var other = actual.toSet();
       |
      0|      for (var expectedElement in expected) {
      0|        if (other.every((actualElement) =>
      0|            matcher(expectedElement, actualElement, location, depth) != null)) {
      0|          return _Mismatch(
       |              location,
       |              actual,
      0|              (description, verbose) => description
      0|                  .add('does not contain ')
      0|                  .addDescriptionOf(expectedElement));
       |        }
       |      }
       |
      0|      if (other.length > expected.length) {
      0|        return _Mismatch.simple(location, actual, 'larger than expected');
      0|      } else if (other.length < expected.length) {
      0|        return _Mismatch.simple(location, actual, 'smaller than expected');
       |      } else {
       |        return null;
       |      }
       |    } else {
      0|      return _Mismatch.simple(location, actual, 'is not Iterable');
       |    }
       |  }
       |
      1|  _Mismatch _recursiveMatch(
       |      Object expected, Object actual, String location, int depth) {
       |    // If the expected value is a matcher, try to match it.
      1|    if (expected is Matcher) {
      0|      var matchState = {};
      0|      if (expected.matches(actual, matchState)) return null;
      0|      return _Mismatch(location, actual, (description, verbose) {
      0|        var oldLength = description.length;
      0|        expected.describeMismatch(actual, description, matchState, verbose);
      0|        if (depth > 0 && description.length == oldLength) {
      0|          description.add('does not match ');
      0|          expected.describe(description);
       |        }
       |      });
       |    } else {
       |      // Otherwise, test for equality.
       |      try {
      1|        if (expected == actual) return null;
       |      } catch (e) {
       |        // TODO(gram): Add a test for this case.
      0|        return _Mismatch(
       |            location,
       |            actual,
      0|            (description, verbose) =>
      0|                description.add('== threw ').addDescriptionOf(e));
       |      }
       |    }
       |
      0|    if (depth > _limit) {
      0|      return _Mismatch.simple(
       |          location, actual, 'recursion depth limit exceeded');
       |    }
       |
       |    // If _limit is 1 we can only recurse one level into object.
      0|    if (depth == 0 || _limit > 1) {
      0|      if (expected is Set) {
      0|        return _compareSets(
      0|            expected, actual, _recursiveMatch, depth + 1, location);
      0|      } else if (expected is Iterable) {
      0|        return _compareIterables(
      0|            expected, actual, _recursiveMatch, depth + 1, location);
      0|      } else if (expected is Map) {
      0|        if (actual is! Map) {
      0|          return _Mismatch.simple(location, actual, 'expected a map');
       |        }
       |        var map = actual as Map;
       |        var err =
      0|            (expected.length == map.length) ? '' : 'has different length and ';
      0|        for (var key in expected.keys) {
      0|          if (!map.containsKey(key)) {
      0|            return _Mismatch(
       |                location,
       |                actual,
      0|                (description, verbose) => description
      0|                    .add('${err}is missing map key ')
      0|                    .addDescriptionOf(key));
       |          }
       |        }
       |
      0|        for (var key in map.keys) {
      0|          if (!expected.containsKey(key)) {
      0|            return _Mismatch(
       |                location,
       |                actual,
      0|                (description, verbose) => description
      0|                    .add('${err}has extra map key ')
      0|                    .addDescriptionOf(key));
       |          }
       |        }
       |
      0|        for (var key in expected.keys) {
      0|          var rp = _recursiveMatch(
      0|              expected[key], map[key], "$location['$key']", depth + 1);
       |          if (rp != null) return rp;
       |        }
       |
       |        return null;
       |      }
       |    }
       |
       |    // If we have recursed, show the expected value too; if not, expect() will
       |    // show it for us.
      0|    if (depth > 0) {
      0|      return _Mismatch(location, actual,
      0|          (description, verbose) => description.addDescriptionOf(expected),
       |          instead: true);
       |    } else {
      0|      return _Mismatch(location, actual, null);
       |    }
       |  }
       |
      1|  @override
       |  bool matches(Object actual, Map matchState) {
      2|    var mismatch = _recursiveMatch(_expected, actual, '', 0);
       |    if (mismatch == null) return true;
      0|    addStateInfo(matchState, {'mismatch': mismatch});
       |    return false;
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.addDescriptionOf(_expected);
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    var mismatch = matchState['mismatch'] as _Mismatch;
      0|    if (mismatch.location.isNotEmpty) {
       |      mismatchDescription
      0|          .add('at location ')
      0|          .add(mismatch.location)
      0|          .add(' is ')
      0|          .addDescriptionOf(mismatch.actual);
      0|      if (mismatch.describeProblem != null) {
       |        mismatchDescription
      0|            .add(' ${mismatch.instead ? 'instead of' : 'which'} ');
      0|        mismatch.describeProblem(mismatchDescription, verbose);
       |      }
       |    } else {
       |      // If we didn't get a good reason, that would normally be a
       |      // simple 'is <value>' message. We only add that if the mismatch
       |      // description is non empty (so we are supplementing the mismatch
       |      // description).
      0|      if (mismatch.describeProblem == null) {
      0|        if (mismatchDescription.length > 0) {
      0|          mismatchDescription.add('is ').addDescriptionOf(item);
       |        }
       |      } else {
      0|        mismatch.describeProblem(mismatchDescription, verbose);
       |      }
       |    }
       |    return mismatchDescription;
       |  }
       |}
       |
       |class _Mismatch {
       |  /// A human-readable description of the location within the collection where
       |  /// the mismatch occurred.
       |  final String location;
       |
       |  /// The actual value found at [location].
       |  final Object actual;
       |
       |  /// Callback that can create a detailed description of the problem.
       |  final void Function(Description, bool verbose) describeProblem;
       |
       |  /// If `true`, [describeProblem] describes the expected value, so when the
       |  /// final mismatch description is pieced together, it will be preceded by
       |  /// `instead of` (e.g. `at location [2] is <3> instead of <4>`).  If `false`,
       |  /// [describeProblem] is a problem description from a sub-matcher, so when the
       |  /// final mismatch description is pieced together, it will be preceded by
       |  /// `which` (e.g. `at location [2] is <foo> which has length of 3`).
       |  final bool instead;
       |
      0|  _Mismatch(this.location, this.actual, this.describeProblem,
       |      {this.instead = false});
       |
      0|  _Mismatch.simple(this.location, this.actual, String problem,
       |      {this.instead = false})
      0|      : describeProblem = ((description, verbose) => description.add(problem));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/interfaces.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Matchers build up their error messages by appending to Description objects.
       |///
       |/// This interface is implemented by StringDescription.
       |///
       |/// This interface is unlikely to need other implementations, but could be
       |/// useful to replace in some cases - e.g. language conversion.
       |abstract class Description {
       |  int get length;
       |
       |  /// Change the value of the description.
       |  Description replace(String text);
       |
       |  /// This is used to add arbitrary text to the description.
       |  Description add(String text);
       |
       |  /// This is used to add a meaningful description of a value.
       |  Description addDescriptionOf(value);
       |
       |  /// This is used to add a description of an [Iterable] [list],
       |  /// with appropriate [start] and [end] markers and inter-element [separator].
       |  Description addAll(String start, String separator, String end, Iterable list);
       |}
       |
       |/// The base class for all matchers.
       |///
       |/// [matches] and [describe] must be implemented by subclasses.
       |///
       |/// Subclasses can override [describeMismatch] if a more specific description is
       |/// required when the matcher fails.
       |abstract class Matcher {
      1|  const Matcher();
       |
       |  /// Does the matching of the actual vs expected values.
       |  ///
       |  /// [item] is the actual value. [matchState] can be supplied
       |  /// and may be used to add details about the mismatch that are too
       |  /// costly to determine in [describeMismatch].
       |  bool matches(item, Map matchState);
       |
       |  /// Builds a textual description of the matcher.
       |  Description describe(Description description);
       |
       |  /// Builds a textual description of a specific mismatch.
       |  ///
       |  /// [item] is the value that was tested by [matches]; [matchState] is
       |  /// the [Map] that was passed to and supplemented by [matches]
       |  /// with additional information about the mismatch, and [mismatchDescription]
       |  /// is the [Description] that is being built to describe the mismatch.
       |  ///
       |  /// A few matchers make use of the [verbose] flag to provide detailed
       |  /// information that is not typically included but can be of help in
       |  /// diagnosing failures, such as stack traces.
      0|  Description describeMismatch(item, Description mismatchDescription,
       |          Map matchState, bool verbose) =>
       |      mismatchDescription;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/iterable_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'description.dart';
       |import 'equals_matcher.dart';
       |import 'feature_matcher.dart';
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// Returns a matcher which matches [Iterable]s in which all elements
       |/// match the given [matcher].
      0|Matcher everyElement(matcher) => _EveryElement(wrapMatcher(matcher));
       |
       |class _EveryElement extends _IterableMatcher {
       |  final Matcher _matcher;
       |
      0|  _EveryElement(this._matcher);
       |
      0|  @override
       |  bool typedMatches(Iterable item, Map matchState) {
       |    var i = 0;
      0|    for (var element in item) {
      0|      if (!_matcher.matches(element, matchState)) {
      0|        addStateInfo(matchState, {'index': i, 'element': element});
       |        return false;
       |      }
      0|      ++i;
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('every element(').addDescriptionOf(_matcher).add(')');
       |
      0|  @override
       |  Description describeTypedMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (matchState['index'] != null) {
      0|      var index = matchState['index'];
      0|      var element = matchState['element'];
       |      mismatchDescription
      0|          .add('has value ')
      0|          .addDescriptionOf(element)
      0|          .add(' which ');
      0|      var subDescription = StringDescription();
      0|      _matcher.describeMismatch(
      0|          element, subDescription, matchState['state'] as Map, verbose);
      0|      if (subDescription.length > 0) {
      0|        mismatchDescription.add(subDescription.toString());
       |      } else {
      0|        mismatchDescription.add("doesn't match ");
      0|        _matcher.describe(mismatchDescription);
       |      }
      0|      mismatchDescription.add(' at index $index');
       |      return mismatchDescription;
       |    }
       |    return super
      0|        .describeMismatch(item, mismatchDescription, matchState, verbose);
       |  }
       |}
       |
       |/// Returns a matcher which matches [Iterable]s in which at least one
       |/// element matches the given [matcher].
      0|Matcher anyElement(matcher) => _AnyElement(wrapMatcher(matcher));
       |
       |class _AnyElement extends _IterableMatcher {
       |  final Matcher _matcher;
       |
      0|  _AnyElement(this._matcher);
       |
      0|  @override
       |  bool typedMatches(Iterable item, Map matchState) =>
      0|      item.any((e) => _matcher.matches(e, matchState));
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('some element ').addDescriptionOf(_matcher);
       |}
       |
       |/// Returns a matcher which matches [Iterable]s that have the same
       |/// length and the same elements as [expected], in the same order.
       |///
       |/// This is equivalent to [equals] but does not recurse.
      0|Matcher orderedEquals(Iterable expected) => _OrderedEquals(expected);
       |
       |class _OrderedEquals extends _IterableMatcher {
       |  final Iterable _expected;
       |  final Matcher _matcher;
       |
      0|  _OrderedEquals(this._expected) : _matcher = equals(_expected, 1);
       |
      0|  @override
       |  bool typedMatches(Iterable item, Map matchState) =>
      0|      _matcher.matches(item, matchState);
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('equals ').addDescriptionOf(_expected).add(' ordered');
       |
      0|  @override
       |  Description describeTypedMismatch(Iterable item,
       |      Description mismatchDescription, Map matchState, bool verbose) {
      0|    return _matcher.describeMismatch(
       |        item, mismatchDescription, matchState, verbose);
       |  }
       |}
       |
       |/// Returns a matcher which matches [Iterable]s that have the same length and
       |/// the same elements as [expected], but not necessarily in the same order.
       |///
       |/// Note that this is worst case O(n^2) runtime and memory usage so it should
       |/// only be used on small iterables.
      0|Matcher unorderedEquals(Iterable expected) => _UnorderedEquals(expected);
       |
       |class _UnorderedEquals extends _UnorderedMatches {
       |  final List _expectedValues;
       |
      0|  _UnorderedEquals(Iterable expected)
      0|      : _expectedValues = expected.toList(),
      0|        super(expected.map(equals));
       |
      0|  @override
       |  Description describe(Description description) => description
      0|      .add('equals ')
      0|      .addDescriptionOf(_expectedValues)
      0|      .add(' unordered');
       |}
       |
       |/// Iterable matchers match against [Iterable]s. We add this intermediate
       |/// class to give better mismatch error messages than the base Matcher class.
       |abstract class _IterableMatcher extends FeatureMatcher<Iterable> {
      0|  const _IterableMatcher();
       |}
       |
       |/// Returns a matcher which matches [Iterable]s whose elements match the
       |/// matchers in [expected], but not necessarily in the same order.
       |///
       |/// Note that this is worst case O(n^2) runtime and memory usage so it should
       |/// only be used on small iterables.
      0|Matcher unorderedMatches(Iterable expected) => _UnorderedMatches(expected);
       |
       |class _UnorderedMatches extends _IterableMatcher {
       |  final List<Matcher> _expected;
       |  final bool _allowUnmatchedValues;
       |
      0|  _UnorderedMatches(Iterable expected, {bool allowUnmatchedValues})
      0|      : _expected = expected.map(wrapMatcher).toList(),
       |        _allowUnmatchedValues = allowUnmatchedValues ?? false;
       |
      0|  String _test(List values) {
       |    // Check the lengths are the same.
      0|    if (_expected.length > values.length) {
      0|      return 'has too few elements (${values.length} < ${_expected.length})';
      0|    } else if (!_allowUnmatchedValues && _expected.length < values.length) {
      0|      return 'has too many elements (${values.length} > ${_expected.length})';
       |    }
       |
      0|    var edges = List.generate(values.length, (_) => <int>[], growable: false);
      0|    for (var v = 0; v < values.length; v++) {
      0|      for (var m = 0; m < _expected.length; m++) {
      0|        if (_expected[m].matches(values[v], {})) {
      0|          edges[v].add(m);
       |        }
       |      }
       |    }
       |    // The index into `values` matched with each matcher or `null` if no value
       |    // has been matched yet.
      0|    var matched = List<int>(_expected.length);
      0|    for (var valueIndex = 0; valueIndex < values.length; valueIndex++) {
      0|      _findPairing(edges, valueIndex, matched);
       |    }
       |    for (var matcherIndex = 0;
      0|        matcherIndex < _expected.length;
      0|        matcherIndex++) {
      0|      if (matched[matcherIndex] == null) {
      0|        final description = StringDescription()
      0|            .add('has no match for ')
      0|            .addDescriptionOf(_expected[matcherIndex])
      0|            .add(' at index $matcherIndex');
       |        final remainingUnmatched =
      0|            matched.sublist(matcherIndex + 1).where((m) => m == null).length;
      0|        return remainingUnmatched == 0
      0|            ? description.toString()
       |            : description
      0|                .add(' along with $remainingUnmatched other unmatched')
      0|                .toString();
       |      }
       |    }
       |    return null;
       |  }
       |
      0|  @override
       |  bool typedMatches(Iterable item, Map mismatchState) =>
      0|      _test(item.toList()) == null;
       |
      0|  @override
       |  Description describe(Description description) => description
      0|      .add('matches ')
      0|      .addAll('[', ', ', ']', _expected)
      0|      .add(' unordered');
       |
      0|  @override
       |  Description describeTypedMismatch(item, Description mismatchDescription,
       |          Map matchState, bool verbose) =>
      0|      mismatchDescription.add(_test(item.toList()));
       |
       |  /// Returns `true` if the value at [valueIndex] can be paired with some
       |  /// unmatched matcher and updates the state of [matched].
       |  ///
       |  /// If there is a conflict where multiple values may match the same matcher
       |  /// recursively looks for a new place to match the old value. [reserved]
       |  /// tracks the matchers that have been used _during_ this search.
      0|  bool _findPairing(List<List<int>> edges, int valueIndex, List<int> matched,
       |      [Set<int> reserved]) {
       |    reserved ??= <int>{};
       |    final possiblePairings =
      0|        edges[valueIndex].where((m) => !reserved.contains(m));
      0|    for (final matcherIndex in possiblePairings) {
      0|      reserved.add(matcherIndex);
      0|      final previouslyMatched = matched[matcherIndex];
       |      if (previouslyMatched == null ||
       |          // If the matcher isn't already free, check whether the existing value
       |          // occupying the matcher can be bumped to another one.
      0|          _findPairing(edges, matched[matcherIndex], matched, reserved)) {
      0|        matched[matcherIndex] = valueIndex;
       |        return true;
       |      }
       |    }
       |    return false;
       |  }
       |}
       |
       |/// A pairwise matcher for [Iterable]s.
       |///
       |/// The [comparator] function, taking an expected and an actual argument, and
       |/// returning whether they match, will be applied to each pair in order.
       |/// [description] should be a meaningful name for the comparator.
      0|Matcher pairwiseCompare<S, T>(Iterable<S> expected,
       |        bool Function(S, T) comparator, String description) =>
      0|    _PairwiseCompare(expected, comparator, description);
       |
       |typedef _Comparator<S, T> = bool Function(S a, T b);
       |
       |class _PairwiseCompare<S, T> extends _IterableMatcher {
       |  final Iterable<S> _expected;
       |  final _Comparator<S, T> _comparator;
       |  final String _description;
       |
      0|  _PairwiseCompare(this._expected, this._comparator, this._description);
       |
      0|  @override
       |  bool typedMatches(Iterable item, Map matchState) {
      0|    if (item.length != _expected.length) return false;
      0|    var iterator = item.iterator;
       |    var i = 0;
      0|    for (var e in _expected) {
      0|      iterator.moveNext();
      0|      if (!_comparator(e, iterator.current as T)) {
      0|        addStateInfo(matchState,
      0|            {'index': i, 'expected': e, 'actual': iterator.current});
       |        return false;
       |      }
      0|      i++;
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('pairwise $_description ').addDescriptionOf(_expected);
       |
      0|  @override
       |  Description describeTypedMismatch(Iterable item,
       |      Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item.length != _expected.length) {
       |      return mismatchDescription
      0|          .add('has length ${item.length} instead of ${_expected.length}');
       |    } else {
       |      return mismatchDescription
      0|          .add('has ')
      0|          .addDescriptionOf(matchState['actual'])
      0|          .add(' which is not $_description ')
      0|          .addDescriptionOf(matchState['expected'])
      0|          .add(' at index ${matchState["index"]}');
       |    }
       |  }
       |}
       |
       |/// Matches [Iterable]s which contain an element matching every value in
       |/// [expected] in any order, and may contain additional values.
       |///
       |/// For example: `[0, 1, 0, 2, 0]` matches `containsAll([1, 2])` and
       |/// `containsAll([2, 1])` but not `containsAll([1, 2, 3])`.
       |///
       |/// Will only match values which implement [Iterable].
       |///
       |/// Each element in the value will only be considered a match for a single
       |/// matcher in [expected] even if it could satisfy more than one. For instance
       |/// `containsAll([greaterThan(1), greaterThan(2)])` will not be satisfied by
       |/// `[3]`. To check that all matchers are satisfied within an iterable and allow
       |/// the same element to satisfy multiple matchers use
       |/// `allOf(matchers.map(contains))`.
       |///
       |/// Note that this is worst case O(n^2) runtime and memory usage so it should
       |/// only be used on small iterables.
      0|Matcher containsAll(Iterable expected) => _ContainsAll(expected);
       |
       |class _ContainsAll extends _UnorderedMatches {
       |  final Iterable _unwrappedExpected;
       |
      0|  _ContainsAll(Iterable expected)
       |      : _unwrappedExpected = expected,
      0|        super(expected.map(wrapMatcher), allowUnmatchedValues: true);
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('contains all of ').addDescriptionOf(_unwrappedExpected);
       |}
       |
       |/// Matches [Iterable]s which contain an element matching every value in
       |/// [expected] in the same order, but may contain additional values interleaved
       |/// throughout.
       |///
       |/// For example: `[0, 1, 0, 2, 0]` matches `containsAllInOrder([1, 2])` but not
       |/// `containsAllInOrder([2, 1])` or `containsAllInOrder([1, 2, 3])`.
       |///
       |/// Will only match values which implement [Iterable].
      0|Matcher containsAllInOrder(Iterable expected) => _ContainsAllInOrder(expected);
       |
       |class _ContainsAllInOrder extends _IterableMatcher {
       |  final Iterable _expected;
       |
      0|  _ContainsAllInOrder(this._expected);
       |
      0|  String _test(Iterable item, Map matchState) {
      0|    var matchers = _expected.map(wrapMatcher).toList();
       |    var matcherIndex = 0;
      0|    for (var value in item) {
      0|      if (matchers[matcherIndex].matches(value, matchState)) matcherIndex++;
      0|      if (matcherIndex == matchers.length) return null;
       |    }
      0|    return StringDescription()
      0|        .add('did not find a value matching ')
      0|        .addDescriptionOf(matchers[matcherIndex])
      0|        .add(' following expected prior values')
      0|        .toString();
       |  }
       |
      0|  @override
       |  bool typedMatches(Iterable item, Map matchState) =>
      0|      _test(item, matchState) == null;
       |
      0|  @override
       |  Description describe(Description description) => description
      0|      .add('contains in order(')
      0|      .addDescriptionOf(_expected)
      0|      .add(')');
       |
      0|  @override
       |  Description describeTypedMismatch(Iterable item,
       |          Description mismatchDescription, Map matchState, bool verbose) =>
      0|      mismatchDescription.add(_test(item, matchState));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/map_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// Returns a matcher which matches maps containing the given [value].
      0|Matcher containsValue(value) => _ContainsValue(value);
       |
       |class _ContainsValue extends Matcher {
       |  final Object _value;
       |
      0|  const _ContainsValue(this._value);
       |
      0|  @override
      0|  bool matches(item, Map matchState) => item.containsValue(_value);
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('contains value ').addDescriptionOf(_value);
       |}
       |
       |/// Returns a matcher which matches maps containing the key-value pair
       |/// with [key] => [value].
      0|Matcher containsPair(key, value) => _ContainsMapping(key, wrapMatcher(value));
       |
       |class _ContainsMapping extends Matcher {
       |  final Object _key;
       |  final Matcher _valueMatcher;
       |
      0|  const _ContainsMapping(this._key, this._valueMatcher);
       |
      0|  @override
       |  bool matches(item, Map matchState) =>
      0|      item.containsKey(_key) && _valueMatcher.matches(item[_key], matchState);
       |
      0|  @override
       |  Description describe(Description description) {
       |    return description
      0|        .add('contains pair ')
      0|        .addDescriptionOf(_key)
      0|        .add(' => ')
      0|        .addDescriptionOf(_valueMatcher);
       |  }
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (!item.containsKey(_key)) {
       |      return mismatchDescription
      0|          .add(" doesn't contain key ")
      0|          .addDescriptionOf(_key);
       |    } else {
       |      mismatchDescription
      0|          .add(' contains key ')
      0|          .addDescriptionOf(_key)
      0|          .add(' but with value ');
      0|      _valueMatcher.describeMismatch(
      0|          item[_key], mismatchDescription, matchState, verbose);
       |      return mismatchDescription;
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/numeric_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'feature_matcher.dart';
       |import 'interfaces.dart';
       |
       |/// Returns a matcher which matches if the match argument is within [delta]
       |/// of some [value].
       |///
       |/// In other words, this matches if the match argument is greater than
       |/// than or equal [value]-[delta] and less than or equal to [value]+[delta].
      0|Matcher closeTo(num value, num delta) => _IsCloseTo(value, delta);
       |
       |class _IsCloseTo extends FeatureMatcher<num> {
       |  final num _value, _delta;
       |
      0|  const _IsCloseTo(this._value, this._delta);
       |
      0|  @override
       |  bool typedMatches(item, Map matchState) {
      0|    var diff = item - _value;
      0|    if (diff < 0) diff = -diff;
      0|    return diff <= _delta;
       |  }
       |
      0|  @override
       |  Description describe(Description description) => description
      0|      .add('a numeric value within ')
      0|      .addDescriptionOf(_delta)
      0|      .add(' of ')
      0|      .addDescriptionOf(_value);
       |
      0|  @override
       |  Description describeTypedMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    var diff = item - _value;
      0|    if (diff < 0) diff = -diff;
      0|    return mismatchDescription.add(' differs by ').addDescriptionOf(diff);
       |  }
       |}
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than or equal to [low] and less than or equal to [high].
      0|Matcher inInclusiveRange(num low, num high) => _InRange(low, high, true, true);
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than [low] and less than [high].
      0|Matcher inExclusiveRange(num low, num high) =>
      0|    _InRange(low, high, false, false);
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than [low] and less than or equal to [high].
      0|Matcher inOpenClosedRange(num low, num high) =>
      0|    _InRange(low, high, false, true);
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than or equal to a [low] and less than [high].
      0|Matcher inClosedOpenRange(num low, num high) =>
      0|    _InRange(low, high, true, false);
       |
       |class _InRange extends FeatureMatcher<num> {
       |  final num _low, _high;
       |  final bool _lowMatchValue, _highMatchValue;
       |
      0|  const _InRange(
       |      this._low, this._high, this._lowMatchValue, this._highMatchValue);
       |
      0|  @override
       |  bool typedMatches(value, Map matchState) {
      0|    if (value < _low || value > _high) {
       |      return false;
       |    }
      0|    if (value == _low) {
      0|      return _lowMatchValue;
       |    }
      0|    if (value == _high) {
      0|      return _highMatchValue;
       |    }
       |    // Value may still be outside if range if it can't be compared.
      0|    return value > _low && value < _high;
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('be in range from '
      0|          "$_low (${_lowMatchValue ? 'inclusive' : 'exclusive'}) to "
      0|          "$_high (${_highMatchValue ? 'inclusive' : 'exclusive'})");
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/operator_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// This returns a matcher that inverts [matcher] to its logical negation.
      0|Matcher isNot(matcher) => _IsNot(wrapMatcher(matcher));
       |
       |class _IsNot extends Matcher {
       |  final Matcher _matcher;
       |
      0|  const _IsNot(this._matcher);
       |
      0|  @override
      0|  bool matches(item, Map matchState) => !_matcher.matches(item, matchState);
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('not ').addDescriptionOf(_matcher);
       |}
       |
       |/// This returns a matcher that matches if all of the matchers passed as
       |/// arguments (up to 7) match.
       |///
       |/// Instead of passing the matchers separately they can be passed as a single
       |/// List argument. Any argument that is not a matcher is implicitly wrapped in a
       |/// Matcher to check for equality.
      0|Matcher allOf(arg0, [arg1, arg2, arg3, arg4, arg5, arg6]) {
      0|  return _AllOf(_wrapArgs(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
       |}
       |
       |class _AllOf extends Matcher {
       |  final List<Matcher> _matchers;
       |
      0|  const _AllOf(this._matchers);
       |
      0|  @override
       |  bool matches(item, Map matchState) {
      0|    for (var matcher in _matchers) {
      0|      if (!matcher.matches(item, matchState)) {
      0|        addStateInfo(matchState, {'matcher': matcher});
       |        return false;
       |      }
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    var matcher = matchState['matcher'];
      0|    matcher.describeMismatch(
      0|        item, mismatchDescription, matchState['state'], verbose);
       |    return mismatchDescription;
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.addAll('(', ' and ', ')', _matchers);
       |}
       |
       |/// Matches if any of the given matchers evaluate to true.
       |///
       |/// The arguments can be a set of matchers as separate parameters
       |/// (up to 7), or a List of matchers.
       |///
       |/// The matchers are evaluated from left to right using short-circuit
       |/// evaluation, so evaluation stops as soon as a matcher returns true.
       |///
       |/// Any argument that is not a matcher is implicitly wrapped in a
       |/// Matcher to check for equality.
      1|Matcher anyOf(arg0, [arg1, arg2, arg3, arg4, arg5, arg6]) {
      2|  return _AnyOf(_wrapArgs(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
       |}
       |
       |class _AnyOf extends Matcher {
       |  final List<Matcher> _matchers;
       |
      1|  const _AnyOf(this._matchers);
       |
      1|  @override
       |  bool matches(item, Map matchState) {
      2|    for (var matcher in _matchers) {
      1|      if (matcher.matches(item, matchState)) {
       |        return true;
       |      }
       |    }
       |    return false;
       |  }
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.addAll('(', ' or ', ')', _matchers);
       |}
       |
      1|List<Matcher> _wrapArgs(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
       |  Iterable args;
      1|  if (arg0 is List) {
       |    if (arg1 != null ||
       |        arg2 != null ||
       |        arg3 != null ||
       |        arg4 != null ||
       |        arg5 != null ||
       |        arg6 != null) {
      0|      throw ArgumentError('If arg0 is a List, all other arguments must be'
       |          ' null.');
       |    }
       |
       |    args = arg0;
       |  } else {
      0|    args = [arg0, arg1, arg2, arg3, arg4, arg5, arg6].where((e) => e != null);
       |  }
       |
      2|  return args.map(wrapMatcher).toList();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/order_matchers.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than the given [value].
      0|Matcher greaterThan(value) =>
      0|    _OrderingMatcher(value, false, false, true, 'a value greater than');
       |
       |/// Returns a matcher which matches if the match argument is greater
       |/// than or equal to the given [value].
      0|Matcher greaterThanOrEqualTo(value) => _OrderingMatcher(
       |    value, true, false, true, 'a value greater than or equal to');
       |
       |/// Returns a matcher which matches if the match argument is less
       |/// than the given [value].
      0|Matcher lessThan(value) =>
      0|    _OrderingMatcher(value, false, true, false, 'a value less than');
       |
       |/// Returns a matcher which matches if the match argument is less
       |/// than or equal to the given [value].
      0|Matcher lessThanOrEqualTo(value) =>
      0|    _OrderingMatcher(value, true, true, false, 'a value less than or equal to');
       |
       |/// A matcher which matches if the match argument is zero.
       |const Matcher isZero =
       |    _OrderingMatcher(0, true, false, false, 'a value equal to');
       |
       |/// A matcher which matches if the match argument is non-zero.
       |const Matcher isNonZero =
       |    _OrderingMatcher(0, false, true, true, 'a value not equal to');
       |
       |/// A matcher which matches if the match argument is positive.
       |const Matcher isPositive =
       |    _OrderingMatcher(0, false, false, true, 'a positive value', false);
       |
       |/// A matcher which matches if the match argument is zero or negative.
       |const Matcher isNonPositive =
       |    _OrderingMatcher(0, true, true, false, 'a non-positive value', false);
       |
       |/// A matcher which matches if the match argument is negative.
       |const Matcher isNegative =
       |    _OrderingMatcher(0, false, true, false, 'a negative value', false);
       |
       |/// A matcher which matches if the match argument is zero or positive.
       |const Matcher isNonNegative =
       |    _OrderingMatcher(0, true, false, true, 'a non-negative value', false);
       |
       |// TODO(kevmoo) Note that matchers that use _OrderingComparison only use
       |// `==` and `<` operators to evaluate the match. Or change the matcher.
       |class _OrderingMatcher extends Matcher {
       |  /// Expected value.
       |  final Object _value;
       |
       |  /// What to return if actual == expected
       |  final bool _equalValue;
       |
       |  /// What to return if actual < expected
       |  final bool _lessThanValue;
       |
       |  /// What to return if actual > expected
       |  final bool _greaterThanValue;
       |
       |  /// Textual name of the inequality
       |  final String _comparisonDescription;
       |
       |  /// Whether to include the expected value in the description
       |  final bool _valueInDescription;
       |
      0|  const _OrderingMatcher(this._value, this._equalValue, this._lessThanValue,
       |      this._greaterThanValue, this._comparisonDescription,
       |      [bool valueInDescription = true])
       |      : _valueInDescription = valueInDescription;
       |
      0|  @override
       |  bool matches(item, Map matchState) {
      0|    if (item == _value) {
      0|      return _equalValue;
      0|    } else if (item < _value) {
      0|      return _lessThanValue;
      0|    } else if (item > _value) {
      0|      return _greaterThanValue;
       |    } else {
       |      return false;
       |    }
       |  }
       |
      0|  @override
       |  Description describe(Description description) {
      0|    if (_valueInDescription) {
       |      return description
      0|          .add(_comparisonDescription)
      0|          .add(' ')
      0|          .addDescriptionOf(_value);
       |    } else {
      0|      return description.add(_comparisonDescription);
       |    }
       |  }
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    mismatchDescription.add('is not ');
      0|    return describe(mismatchDescription);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/string_matchers.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'feature_matcher.dart';
       |import 'interfaces.dart';
       |
       |/// Returns a matcher which matches if the match argument is a string and
       |/// is equal to [value] when compared case-insensitively.
      0|Matcher equalsIgnoringCase(String value) => _IsEqualIgnoringCase(value);
       |
       |class _IsEqualIgnoringCase extends FeatureMatcher<String> {
       |  final String _value;
       |  final String _matchValue;
       |
      0|  _IsEqualIgnoringCase(String value)
       |      : _value = value,
      0|        _matchValue = value.toLowerCase();
       |
      0|  @override
       |  bool typedMatches(String item, Map matchState) =>
      0|      _matchValue == item.toLowerCase();
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.addDescriptionOf(_value).add(' ignoring case');
       |}
       |
       |/// Returns a matcher which matches if the match argument is a string and
       |/// is equal to [value], ignoring whitespace.
       |///
       |/// In this matcher, "ignoring whitespace" means comparing with all runs of
       |/// whitespace collapsed to single space characters and leading and trailing
       |/// whitespace removed.
       |///
       |/// For example, the following will all match successfully:
       |///
       |///     expect("hello   world", equalsIgnoringWhitespace("hello world"));
       |///     expect("  hello world", equalsIgnoringWhitespace("hello world"));
       |///     expect("hello world  ", equalsIgnoringWhitespace("hello world"));
       |///
       |/// The following will not match:
       |///
       |///     expect("helloworld", equalsIgnoringWhitespace("hello world"));
       |///     expect("he llo world", equalsIgnoringWhitespace("hello world"));
      0|Matcher equalsIgnoringWhitespace(String value) =>
      0|    _IsEqualIgnoringWhitespace(value);
       |
       |class _IsEqualIgnoringWhitespace extends FeatureMatcher<String> {
       |  final String _matchValue;
       |
      0|  _IsEqualIgnoringWhitespace(String value)
      0|      : _matchValue = collapseWhitespace(value);
       |
      0|  @override
       |  bool typedMatches(String item, Map matchState) =>
      0|      _matchValue == collapseWhitespace(item);
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.addDescriptionOf(_matchValue).add(' ignoring whitespace');
       |
      0|  @override
       |  Description describeTypedMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
       |    return mismatchDescription
      0|        .add('is ')
      0|        .addDescriptionOf(collapseWhitespace(item))
      0|        .add(' with whitespace compressed');
       |  }
       |}
       |
       |/// Returns a matcher that matches if the match argument is a string and
       |/// starts with [prefixString].
      0|Matcher startsWith(String prefixString) => _StringStartsWith(prefixString);
       |
       |class _StringStartsWith extends FeatureMatcher<String> {
       |  final String _prefix;
       |
      0|  const _StringStartsWith(this._prefix);
       |
      0|  @override
      0|  bool typedMatches(item, Map matchState) => item.startsWith(_prefix);
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('a string starting with ').addDescriptionOf(_prefix);
       |}
       |
       |/// Returns a matcher that matches if the match argument is a string and
       |/// ends with [suffixString].
      0|Matcher endsWith(String suffixString) => _StringEndsWith(suffixString);
       |
       |class _StringEndsWith extends FeatureMatcher<String> {
       |  final String _suffix;
       |
      0|  const _StringEndsWith(this._suffix);
       |
      0|  @override
      0|  bool typedMatches(item, Map matchState) => item.endsWith(_suffix);
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add('a string ending with ').addDescriptionOf(_suffix);
       |}
       |
       |/// Returns a matcher that matches if the match argument is a string and
       |/// contains a given list of [substrings] in relative order.
       |///
       |/// For example, `stringContainsInOrder(["a", "e", "i", "o", "u"])` will match
       |/// "abcdefghijklmnopqrstuvwxyz".
       |
      0|Matcher stringContainsInOrder(List<String> substrings) =>
      0|    _StringContainsInOrder(substrings);
       |
       |class _StringContainsInOrder extends FeatureMatcher<String> {
       |  final List<String> _substrings;
       |
      0|  const _StringContainsInOrder(this._substrings);
       |
      0|  @override
       |  bool typedMatches(item, Map matchState) {
       |    var fromIndex = 0;
      0|    for (var s in _substrings) {
      0|      fromIndex = item.indexOf(s, fromIndex);
      0|      if (fromIndex < 0) return false;
       |    }
       |    return true;
       |  }
       |
      0|  @override
      0|  Description describe(Description description) => description.addAll(
      0|      'a string containing ', ', ', ' in order', _substrings);
       |}
       |
       |/// Returns a matcher that matches if the match argument is a string and
       |/// matches the regular expression given by [re].
       |///
       |/// [re] can be a [RegExp] instance or a [String]; in the latter case it will be
       |/// used to create a RegExp instance.
      0|Matcher matches(re) => _MatchesRegExp(re);
       |
       |class _MatchesRegExp extends FeatureMatcher<String> {
       |  RegExp _regexp;
       |
      0|  _MatchesRegExp(re) {
      0|    if (re is String) {
      0|      _regexp = RegExp(re);
      0|    } else if (re is RegExp) {
      0|      _regexp = re;
       |    } else {
      0|      throw ArgumentError('matches requires a regexp or string');
       |    }
       |  }
       |
      0|  @override
      0|  bool typedMatches(item, Map matchState) => _regexp.hasMatch(item);
       |
      0|  @override
       |  Description describe(Description description) =>
      0|      description.add("match '${_regexp.pattern}'");
       |}
       |
       |/// Utility function to collapse whitespace runs to single spaces
       |/// and strip leading/trailing whitespace.
      0|String collapseWhitespace(String string) {
      0|  var result = StringBuffer();
       |  var skipSpace = true;
      0|  for (var i = 0; i < string.length; i++) {
      0|    var character = string[i];
      0|    if (_isWhitespace(character)) {
       |      if (!skipSpace) {
      0|        result.write(' ');
       |        skipSpace = true;
       |      }
       |    } else {
      0|      result.write(character);
       |      skipSpace = false;
       |    }
       |  }
      0|  return result.toString().trim();
       |}
       |
      0|bool _isWhitespace(String ch) =>
      0|    ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/type_matcher.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'having_matcher.dart';
       |import 'interfaces.dart';
       |
       |/// Returns a matcher that matches objects with type [T].
       |///
       |/// ```dart
       |/// expect(shouldBeDuration, isA<Duration>());
       |/// ```
       |///
       |/// Expectations can be chained on top of the type using the
       |/// [TypeMatcher.having] method to add additional constraints.
      2|TypeMatcher<T> isA<T>() => TypeMatcher<T>();
       |
       |/// A [Matcher] subclass that supports validating the [Type] of the target
       |/// object.
       |///
       |/// ```dart
       |/// expect(shouldBeDuration, TypeMatcher<Duration>());
       |/// ```
       |///
       |/// If you want to further validate attributes of the specified [Type], use the
       |/// [having] function.
       |///
       |/// ```dart
       |/// void shouldThrowRangeError(int value) {
       |///   throw RangeError.range(value, 10, 20);
       |/// }
       |///
       |/// expect(
       |///     () => shouldThrowRangeError(5),
       |///     throwsA(const TypeMatcher<RangeError>()
       |///         .having((e) => e.start, 'start', greaterThanOrEqualTo(10))
       |///         .having((e) => e.end, 'end', lessThanOrEqualTo(20))));
       |/// ```
       |///
       |/// Notice that you can chain multiple calls to [having] to verify multiple
       |/// aspects of an object.
       |///
       |/// Note: All of the top-level `isType` matchers exposed by this package are
       |/// instances of [TypeMatcher], so you can use the [having] function without
       |/// creating your own instance.
       |///
       |/// ```dart
       |/// expect(
       |///     () => shouldThrowRangeError(5),
       |///     throwsA(isRangeError
       |///         .having((e) => e.start, 'start', greaterThanOrEqualTo(10))
       |///         .having((e) => e.end, 'end', lessThanOrEqualTo(20))));
       |/// ```
       |class TypeMatcher<T> extends Matcher {
       |  final String _name;
       |
       |  /// Create a matcher matches instances of type [T].
       |  ///
       |  /// For a fluent API to create TypeMatchers see [isA].
      1|  const TypeMatcher(
       |      [@Deprecated('Provide a type argument to TypeMatcher and omit the name. '
       |          'This argument will be removed in the next release.')
       |          String name])
       |      : _name =
       |            // ignore: deprecated_member_use_from_same_package
       |            name;
       |
       |  /// Returns a new [TypeMatcher] that validates the existing type as well as
       |  /// a specific [feature] of the object with the provided [matcher].
       |  ///
       |  /// Provides a human-readable [description] of the [feature] to make debugging
       |  /// failures easier.
       |  ///
       |  /// ```dart
       |  /// /// Validates that the object is a [RangeError] with a message containing
       |  /// /// the string 'details' and `start` and `end` properties that are `null`.
       |  /// final _rangeMatcher = isRangeError
       |  ///    .having((e) => e.message, 'message', contains('details'))
       |  ///    .having((e) => e.start, 'start', isNull)
       |  ///    .having((e) => e.end, 'end', isNull);
       |  /// ```
      0|  TypeMatcher<T> having(
       |          Object Function(T) feature, String description, Object matcher) =>
      0|      HavingMatcher(this, description, feature, matcher);
       |
      0|  @override
       |  Description describe(Description description) {
      0|    var name = _name ?? _stripDynamic(T);
      0|    return description.add("<Instance of '$name'>");
       |  }
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    var name = _name ?? _stripDynamic(T);
      0|    return mismatchDescription.add("is not an instance of '$name'");
       |  }
       |
      1|  @override
      1|  bool matches(Object item, Map matchState) => item is T;
       |}
       |
      0|final _dart2DynamicArgs = RegExp('<dynamic(, dynamic)*>');
       |
       |/// With this expression `{}.runtimeType.toString`,
       |/// Dart 1: "<Instance of Map>
       |/// Dart 2: "<Instance of Map<dynamic, dynamic>>"
       |///
       |/// This functions returns the Dart 1 output, when Dart 2 runtime semantics
       |/// are enabled.
      0|String _stripDynamic(Type type) =>
      0|    type.toString().replaceAll(_dart2DynamicArgs, '');
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/util.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'core_matchers.dart';
       |import 'equals_matcher.dart';
       |import 'interfaces.dart';
       |
       |typedef _Predicate<T> = bool Function(T value);
       |
       |/// A [Map] between whitespace characters and their escape sequences.
       |const _escapeMap = {
       |  '\n': r'\n',
       |  '\r': r'\r',
       |  '\f': r'\f',
       |  '\b': r'\b',
       |  '\t': r'\t',
       |  '\v': r'\v',
       |  '\x7F': r'\x7F', // delete
       |};
       |
       |/// A [RegExp] that matches whitespace characters that should be escaped.
      0|final _escapeRegExp = RegExp(
       |    '[\\x00-\\x07\\x0E-\\x1F${_escapeMap.keys.map(_getHexLiteral).join()}]');
       |
       |/// Useful utility for nesting match states.
      0|void addStateInfo(Map matchState, Map values) {
      0|  var innerState = Map.from(matchState);
      0|  matchState.clear();
      0|  matchState['state'] = innerState;
      0|  matchState.addAll(values);
       |}
       |
       |/// Takes an argument and returns an equivalent [Matcher].
       |///
       |/// If the argument is already a matcher this does nothing,
       |/// else if the argument is a function, it generates a predicate
       |/// function matcher, else it generates an equals matcher.
      1|Matcher wrapMatcher(x) {
      1|  if (x is Matcher) {
       |    return x;
      1|  } else if (x is _Predicate<Object>) {
       |    // x is already a predicate that can handle anything
      0|    return predicate(x);
      1|  } else if (x is _Predicate<Null>) {
       |    // x is a unary predicate, but expects a specific type
       |    // so wrap it.
       |    // ignore: unnecessary_lambdas
      0|    return predicate((a) => (x as dynamic)(a));
       |  } else {
      1|    return equals(x);
       |  }
       |}
       |
       |/// Returns [str] with all whitespace characters represented as their escape
       |/// sequences.
       |///
       |/// Backslash characters are escaped as `\\`
      0|String escape(String str) {
      0|  str = str.replaceAll('\\', r'\\');
      0|  return str.replaceAllMapped(_escapeRegExp, (match) {
      0|    var mapped = _escapeMap[match[0]];
       |    if (mapped != null) return mapped;
      0|    return _getHexLiteral(match[0]);
       |  });
       |}
       |
       |/// Given single-character string, return the hex-escaped equivalent.
      0|String _getHexLiteral(String input) {
      0|  var rune = input.runes.single;
      0|  return r'\x' + rune.toRadixString(16).toUpperCase().padLeft(2, '0');
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/feature_matcher.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'interfaces.dart';
       |import 'type_matcher.dart';
       |
       |/// A package-private [TypeMatcher] implementation that makes it easy for
       |/// subclasses to validate aspects of specific types while providing consistent
       |/// type checking.
       |abstract class FeatureMatcher<T> extends TypeMatcher<T> {
      1|  const FeatureMatcher();
       |
      1|  @override
       |  bool matches(item, Map matchState) =>
      2|      super.matches(item, matchState) && typedMatches(item, matchState);
       |
       |  bool typedMatches(T item, Map matchState);
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    if (item is T) {
      0|      return describeTypedMismatch(
       |          item, mismatchDescription, matchState, verbose);
       |    }
       |
      0|    return super.describe(mismatchDescription.add('not an '));
       |  }
       |
      0|  Description describeTypedMismatch(T item, Description mismatchDescription,
       |          Map matchState, bool verbose) =>
       |      mismatchDescription;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/having_matcher.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'custom_matcher.dart';
       |import 'interfaces.dart';
       |import 'type_matcher.dart';
       |import 'util.dart';
       |
       |/// A package-private [TypeMatcher] implementation that handles is returned
       |/// by calls to [TypeMatcher.having].
       |class HavingMatcher<T> implements TypeMatcher<T> {
       |  final TypeMatcher<T> _parent;
       |  final List<_FunctionMatcher<T>> _functionMatchers;
       |
      0|  HavingMatcher(TypeMatcher<T> parent, String description,
       |      Object Function(T) feature, Object matcher,
       |      [Iterable<_FunctionMatcher<T>> existing])
       |      : _parent = parent,
      0|        _functionMatchers = [
      0|          ...?existing,
      0|          _FunctionMatcher<T>(description, feature, matcher)
       |        ];
       |
      0|  @override
       |  TypeMatcher<T> having(
       |          Object Function(T) feature, String description, Object matcher) =>
      0|      HavingMatcher(_parent, description, feature, matcher, _functionMatchers);
       |
      0|  @override
       |  bool matches(item, Map matchState) {
      0|    for (var matcher in <Matcher>[_parent].followedBy(_functionMatchers)) {
      0|      if (!matcher.matches(item, matchState)) {
      0|        addStateInfo(matchState, {'matcher': matcher});
       |        return false;
       |      }
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  Description describeMismatch(
       |      item, Description mismatchDescription, Map matchState, bool verbose) {
      0|    var matcher = matchState['matcher'] as Matcher;
      0|    matcher.describeMismatch(
      0|        item, mismatchDescription, matchState['state'] as Map, verbose);
       |    return mismatchDescription;
       |  }
       |
      0|  @override
       |  Description describe(Description description) => description
      0|      .add('')
      0|      .addDescriptionOf(_parent)
      0|      .add(' with ')
      0|      .addAll('', ' and ', '', _functionMatchers);
       |}
       |
       |class _FunctionMatcher<T> extends CustomMatcher {
       |  final dynamic Function(T value) _feature;
       |
      0|  _FunctionMatcher(String name, this._feature, matcher)
      0|      : super('`$name`:', '`$name`', matcher);
       |
      0|  @override
      0|  Object featureValueOf(covariant T actual) => _feature(actual);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/matcher-0.12.9/lib/src/pretty_print.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'description.dart';
       |import 'interfaces.dart';
       |import 'util.dart';
       |
       |/// Returns a pretty-printed representation of [object].
       |///
       |/// If [maxLineLength] is passed, this will attempt to ensure that each line is
       |/// no longer than [maxLineLength] characters long. This isn't guaranteed, since
       |/// individual objects may have string representations that are too long, but
       |/// most lines will be less than [maxLineLength] long.
       |///
       |/// If [maxItems] is passed, [Iterable]s and [Map]s will only print their first
       |/// [maxItems] members or key/value pairs, respectively.
      0|String prettyPrint(object, {int maxLineLength, int maxItems}) {
      0|  String _prettyPrint(object, int indent, Set seen, bool top) {
       |    // If the object is a matcher, use its description.
      0|    if (object is Matcher) {
      0|      var description = StringDescription();
      0|      object.describe(description);
      0|      return '<$description>';
       |    }
       |
       |    // Avoid looping infinitely on recursively-nested data structures.
      0|    if (seen.contains(object)) return '(recursive)';
      0|    seen = seen.union({object});
      0|    String pp(child) => _prettyPrint(child, indent + 2, seen, false);
       |
      0|    if (object is Iterable) {
       |      // Print the type name for non-List iterables.
      0|      var type = object is List ? '' : _typeName(object) + ':';
       |
       |      // Truncate the list of strings if it's longer than [maxItems].
      0|      var strings = object.map(pp).toList();
      0|      if (maxItems != null && strings.length > maxItems) {
      0|        strings.replaceRange(maxItems - 1, strings.length, ['...']);
       |      }
       |
       |      // If the printed string is short and doesn't contain a newline, print it
       |      // as a single line.
      0|      var singleLine = "$type[${strings.join(', ')}]";
       |      if ((maxLineLength == null ||
      0|              singleLine.length + indent <= maxLineLength) &&
      0|          !singleLine.contains('\n')) {
       |        return singleLine;
       |      }
       |
       |      // Otherwise, print each member on its own line.
      0|      return '$type[\n' +
      0|          strings.map((string) {
      0|            return _indent(indent + 2) + string;
      0|          }).join(',\n') +
      0|          '\n' +
      0|          _indent(indent) +
       |          ']';
      0|    } else if (object is Map) {
       |      // Convert the contents of the map to string representations.
      0|      var strings = object.keys.map((key) {
      0|        return '${pp(key)}: ${pp(object[key])}';
      0|      }).toList();
       |
       |      // Truncate the list of strings if it's longer than [maxItems].
      0|      if (maxItems != null && strings.length > maxItems) {
      0|        strings.replaceRange(maxItems - 1, strings.length, ['...']);
       |      }
       |
       |      // If the printed string is short and doesn't contain a newline, print it
       |      // as a single line.
      0|      var singleLine = '{${strings.join(", ")}}';
       |      if ((maxLineLength == null ||
      0|              singleLine.length + indent <= maxLineLength) &&
      0|          !singleLine.contains('\n')) {
       |        return singleLine;
       |      }
       |
       |      // Otherwise, print each key/value pair on its own line.
      0|      return '{\n' +
      0|          strings.map((string) {
      0|            return _indent(indent + 2) + string;
      0|          }).join(',\n') +
      0|          '\n' +
      0|          _indent(indent) +
       |          '}';
      0|    } else if (object is String) {
       |      // Escape strings and print each line on its own line.
      0|      var lines = object.split('\n');
      0|      return "'" +
      0|          lines.map(_escapeString).join("\\n'\n${_indent(indent + 2)}'") +
       |          "'";
       |    } else {
      0|      var value = object.toString().replaceAll('\n', _indent(indent) + '\n');
      0|      var defaultToString = value.startsWith('Instance of ');
       |
       |      // If this is the top-level call to [prettyPrint], wrap the value on angle
       |      // brackets to set it apart visually.
      0|      if (top) value = '<$value>';
       |
       |      // Print the type of objects with custom [toString] methods. Primitive
       |      // objects and objects that don't implement a custom [toString] don't need
       |      // to have their types printed.
      0|      if (object is num ||
      0|          object is bool ||
      0|          object is Function ||
      0|          object is RegExp ||
      0|          object is MapEntry ||
      0|          object is Expando ||
       |          object == null ||
       |          defaultToString) {
       |        return value;
       |      } else {
      0|        return '${_typeName(object)}:$value';
       |      }
       |    }
       |  }
       |
      0|  return _prettyPrint(object, 0, <Object>{}, true);
       |}
       |
      0|String _indent(int length) => List.filled(length, ' ').join('');
       |
       |/// Returns the name of the type of [x] with fallbacks for core types with
       |/// private implementations.
      0|String _typeName(x) {
      0|  if (x is Type) return 'Type';
      0|  if (x is Uri) return 'Uri';
      0|  if (x is Set) return 'Set';
      0|  if (x is BigInt) return 'BigInt';
      0|  return '${x.runtimeType}';
       |}
       |
       |/// Returns [source] with any control characters replaced by their escape
       |/// sequences.
       |///
       |/// This doesn't add quotes to the string, but it does escape single quote
       |/// characters so that single quotes can be applied externally.
      0|String _escapeString(String source) => escape(source).replaceAll("'", r"\'");
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/chain.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:math' as math;
       |
       |import 'frame.dart';
       |import 'lazy_chain.dart';
       |import 'stack_zone_specification.dart';
       |import 'trace.dart';
       |import 'utils.dart';
       |
       |/// A function that handles errors in the zone wrapped by [Chain.capture].
       |@Deprecated('Will be removed in stack_trace 2.0.0.')
       |typedef ChainHandler = void Function(dynamic error, Chain chain);
       |
       |/// An opaque key used to track the current [StackZoneSpecification].
      3|final _specKey = Object();
       |
       |/// A chain of stack traces.
       |///
       |/// A stack chain is a collection of one or more stack traces that collectively
       |/// represent the path from [main] through nested function calls to a particular
       |/// code location, usually where an error was thrown. Multiple stack traces are
       |/// necessary when using asynchronous functions, since the program's stack is
       |/// reset before each asynchronous callback is run.
       |///
       |/// Stack chains can be automatically tracked using [Chain.capture]. This sets
       |/// up a new [Zone] in which the current stack chain is tracked and can be
       |/// accessed using [new Chain.current]. Any errors that would be top-leveled in
       |/// the zone can be handled, along with their associated chains, with the
       |/// `onError` callback. For example:
       |///
       |///     Chain.capture(() {
       |///       // ...
       |///     }, onError: (error, stackChain) {
       |///       print("Caught error $error\n"
       |///             "$stackChain");
       |///     });
       |class Chain implements StackTrace {
       |  /// The stack traces that make up this chain.
       |  ///
       |  /// Like the frames in a stack trace, the traces are ordered from most local
       |  /// to least local. The first one is the trace where the actual exception was
       |  /// raised, the second one is where that callback was scheduled, and so on.
       |  final List<Trace> traces;
       |
       |  /// The [StackZoneSpecification] for the current zone.
      0|  static StackZoneSpecification get _currentSpec =>
      0|      Zone.current[_specKey] as StackZoneSpecification;
       |
       |  /// If [when] is `true`, runs [callback] in a [Zone] in which the current
       |  /// stack chain is tracked and automatically associated with (most) errors.
       |  ///
       |  /// If [when] is `false`, this does not track stack chains. Instead, it's
       |  /// identical to [runZoned], except that it wraps any errors in [new
       |  /// Chain.forTrace]which will only wrap the trace unless there's a different
       |  /// [Chain.capture] active. This makes it easy for the caller to only capture
       |  /// stack chains in debug mode or during development.
       |  ///
       |  /// If [onError] is passed, any error in the zone that would otherwise go
       |  /// unhandled is passed to it, along with the [Chain] associated with that
       |  /// error. Note that if [callback] produces multiple unhandled errors,
       |  /// [onError] may be called more than once. If [onError] isn't passed, the
       |  /// parent Zone's `unhandledErrorHandler` will be called with the error and
       |  /// its chain.
       |  ///
       |  /// If [errorZone] is `true`, the zone this creates will be an error zone,
       |  /// even if [onError] isn't passed. This means that any errors that would
       |  /// cross the zone boundary are considered unhandled. If [errorZone] is
       |  /// `false`, [onError] must be `null`.
       |  ///
       |  /// If [callback] returns a value, it will be returned by [capture] as well.
      1|  static T capture<T>(T Function() callback,
       |      {void Function(Object error, Chain) onError,
       |      bool when = true,
       |      bool errorZone = true}) {
       |    if (!errorZone && onError != null) {
      0|      throw ArgumentError.value(
       |          onError, 'onError', 'must be null if errorZone is false');
       |    }
       |
       |    if (!when) {
       |      void Function(Object, StackTrace) newOnError;
       |      if (onError != null) {
      0|        newOnError = (error, stackTrace) {
      0|          onError(
       |              error,
       |              stackTrace == null
      0|                  ? Chain.current()
      0|                  : Chain.forTrace(stackTrace));
       |        };
       |      }
       |
      0|      return runZoned(callback, onError: newOnError);
       |    }
       |
      1|    var spec = StackZoneSpecification(onError, errorZone: errorZone);
      2|    return runZoned(() {
       |      try {
      1|        return callback();
       |      } catch (error, stackTrace) {
       |        // TODO(nweiz): Don't special-case this when issue 19566 is fixed.
      0|        Zone.current.handleUncaughtError(error, stackTrace);
       |        return null;
       |      }
       |    },
      1|        zoneSpecification: spec.toSpec(),
      3|        zoneValues: {_specKey: spec, StackZoneSpecification.disableKey: false});
       |  }
       |
       |  /// If [when] is `true` and this is called within a [Chain.capture] zone, runs
       |  /// [callback] in a [Zone] in which chain capturing is disabled.
       |  ///
       |  /// If [callback] returns a value, it will be returned by [disable] as well.
      0|  static T disable<T>(T Function() callback, {bool when = true}) {
       |    var zoneValues =
      0|        when ? {_specKey: null, StackZoneSpecification.disableKey: true} : null;
       |
      0|    return runZoned(callback, zoneValues: zoneValues);
       |  }
       |
       |  /// Returns [futureOrStream] unmodified.
       |  ///
       |  /// Prior to Dart 1.7, this was necessary to ensure that stack traces for
       |  /// exceptions reported with [Completer.completeError] and
       |  /// [StreamController.addError] were tracked correctly.
      0|  @Deprecated('Chain.track is not necessary in Dart 1.7+.')
       |  static dynamic track(futureOrStream) => futureOrStream;
       |
       |  /// Returns the current stack chain.
       |  ///
       |  /// By default, the first frame of the first trace will be the line where
       |  /// [Chain.current] is called. If [level] is passed, the first trace will
       |  /// start that many frames up instead.
       |  ///
       |  /// If this is called outside of a [capture] zone, it just returns a
       |  /// single-trace chain.
      0|  factory Chain.current([int level = 0]) {
      0|    if (_currentSpec != null) return _currentSpec.currentChain(level + 1);
       |
      0|    var chain = Chain.forTrace(StackTrace.current);
      0|    return LazyChain(() {
       |      // JS includes a frame for the call to StackTrace.current, but the VM
       |      // doesn't, so we skip an extra frame in a JS context.
      0|      var first = Trace(chain.traces.first.frames.skip(level + (inJS ? 2 : 1)),
      0|          original: chain.traces.first.original.toString());
      0|      return Chain([first]..addAll(chain.traces.skip(1)));
       |    });
       |  }
       |
       |  /// Returns the stack chain associated with [trace].
       |  ///
       |  /// The first stack trace in the returned chain will always be [trace]
       |  /// (converted to a [Trace] if necessary). If there is no chain associated
       |  /// with [trace] or if this is called outside of a [capture] zone, this just
       |  /// returns a single-trace chain containing [trace].
       |  ///
       |  /// If [trace] is already a [Chain], it will be returned as-is.
      0|  factory Chain.forTrace(StackTrace trace) {
      0|    if (trace is Chain) return trace;
      0|    if (_currentSpec != null) return _currentSpec.chainFor(trace);
      0|    if (trace is Trace) return Chain([trace]);
      0|    return LazyChain(() => Chain.parse(trace.toString()));
       |  }
       |
       |  /// Parses a string representation of a stack chain.
       |  ///
       |  /// If [chain] is the output of a call to [Chain.toString], it will be parsed
       |  /// as a full stack chain. Otherwise, it will be parsed as in [Trace.parse]
       |  /// and returned as a single-trace chain.
      0|  factory Chain.parse(String chain) {
      0|    if (chain.isEmpty) return Chain([]);
      0|    if (chain.contains(vmChainGap)) {
      0|      return Chain(chain
      0|          .split(vmChainGap)
      0|          .where((line) => line.isNotEmpty)
      0|          .map((trace) => Trace.parseVM(trace)));
       |    }
      0|    if (!chain.contains(chainGap)) return Chain([Trace.parse(chain)]);
       |
      0|    return Chain(
      0|        chain.split(chainGap).map((trace) => Trace.parseFriendly(trace)));
       |  }
       |
       |  /// Returns a new [Chain] comprised of [traces].
      0|  Chain(Iterable<Trace> traces) : traces = List<Trace>.unmodifiable(traces);
       |
       |  /// Returns a terser version of [this].
       |  ///
       |  /// This calls [Trace.terse] on every trace in [traces], and discards any
       |  /// trace that contain only internal frames.
       |  ///
       |  /// This won't do anything with a raw JavaScript trace, since there's no way
       |  /// to determine which frames come from which Dart libraries. However, the
       |  /// [`source_map_stack_trace`][source_map_stack_trace] package can be used to
       |  /// convert JavaScript traces into Dart-style traces.
       |  ///
       |  /// [source_map_stack_trace]: https://pub.dev/packages/source_map_stack_trace
      0|  Chain get terse => foldFrames((_) => false, terse: true);
       |
       |  /// Returns a new [Chain] based on [this] where multiple stack frames matching
       |  /// [predicate] are folded together.
       |  ///
       |  /// This means that whenever there are multiple frames in a row that match
       |  /// [predicate], only the last one is kept. In addition, traces that are
       |  /// composed entirely of frames matching [predicate] are omitted.
       |  ///
       |  /// This is useful for limiting the amount of library code that appears in a
       |  /// stack trace by only showing user code and code that's called by user code.
       |  ///
       |  /// If [terse] is true, this will also fold together frames from the core
       |  /// library or from this package, and simplify core library frames as in
       |  /// [Trace.terse].
      0|  Chain foldFrames(bool Function(Frame) predicate, {bool terse = false}) {
       |    var foldedTraces =
      0|        traces.map((trace) => trace.foldFrames(predicate, terse: terse));
      0|    var nonEmptyTraces = foldedTraces.where((trace) {
       |      // Ignore traces that contain only folded frames.
      0|      if (trace.frames.length > 1) return true;
      0|      if (trace.frames.isEmpty) return false;
       |
       |      // In terse mode, the trace may have removed an outer folded frame,
       |      // leaving a single non-folded frame. We can detect a folded frame because
       |      // it has no line information.
       |      if (!terse) return false;
      0|      return trace.frames.single.line != null;
       |    });
       |
       |    // If all the traces contain only internal processing, preserve the last
       |    // (top-most) one so that the chain isn't empty.
      0|    if (nonEmptyTraces.isEmpty && foldedTraces.isNotEmpty) {
      0|      return Chain([foldedTraces.last]);
       |    }
       |
      0|    return Chain(nonEmptyTraces);
       |  }
       |
       |  /// Converts [this] to a [Trace].
       |  ///
       |  /// The trace version of a chain is just the concatenation of all the traces
       |  /// in the chain.
      0|  Trace toTrace() => Trace(traces.expand((trace) => trace.frames));
       |
      0|  @override
       |  String toString() {
       |    // Figure out the longest path so we know how much to pad.
      0|    var longest = traces.map((trace) {
      0|      return trace.frames
      0|          .map((frame) => frame.location.length)
      0|          .fold(0, math.max);
      0|    }).fold(0, math.max);
       |
       |    // Don't call out to [Trace.toString] here because that doesn't ensure that
       |    // padding is consistent across all traces.
      0|    return traces.map((trace) {
      0|      return trace.frames.map((frame) {
      0|        return '${frame.location.padRight(longest)}  ${frame.member}\n';
      0|      }).join();
      0|    }).join(chainGap);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/frame.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:path/path.dart' as path;
       |
       |import 'trace.dart';
       |import 'unparsed_frame.dart';
       |
       |// #1      Foo._bar (file:///home/nweiz/code/stuff.dart:42:21)
       |// #1      Foo._bar (file:///home/nweiz/code/stuff.dart:42)
       |// #1      Foo._bar (file:///home/nweiz/code/stuff.dart)
      0|final _vmFrame = RegExp(r'^#\d+\s+(\S.*) \((.+?)((?::\d+){0,2})\)$');
       |
       |//     at Object.stringify (native)
       |//     at VW.call$0 (https://example.com/stuff.dart.js:560:28)
       |//     at VW.call$0 (eval as fn
       |//         (https://example.com/stuff.dart.js:560:28), efn:3:28)
       |//     at https://example.com/stuff.dart.js:560:28
      0|final _v8Frame =
       |    RegExp(r'^\s*at (?:(\S.*?)(?: \[as [^\]]+\])? \((.*)\)|(.*))$');
       |
       |// https://example.com/stuff.dart.js:560:28
       |// https://example.com/stuff.dart.js:560
      0|final _v8UrlLocation = RegExp(r'^(.*?):(\d+)(?::(\d+))?$|native$');
       |
       |// eval as function (https://example.com/stuff.dart.js:560:28), efn:3:28
       |// eval as function (https://example.com/stuff.dart.js:560:28)
       |// eval as function (eval as otherFunction
       |//     (https://example.com/stuff.dart.js:560:28))
      0|final _v8EvalLocation =
       |    RegExp(r'^eval at (?:\S.*?) \((.*)\)(?:, .*?:\d+:\d+)?$');
       |
       |// anonymous/<@https://example.com/stuff.js line 693 > Function:3:40
       |// anonymous/<@https://example.com/stuff.js line 693 > eval:3:40
      0|final _firefoxEvalLocation =
       |    RegExp(r'(\S+)@(\S+) line (\d+) >.* (Function|eval):\d+:\d+');
       |
       |// .VW.call$0@https://example.com/stuff.dart.js:560
       |// .VW.call$0("arg")@https://example.com/stuff.dart.js:560
       |// .VW.call$0/name<@https://example.com/stuff.dart.js:560
       |// .VW.call$0@https://example.com/stuff.dart.js:560:36
       |// https://example.com/stuff.dart.js:560
      0|final _firefoxSafariFrame = RegExp(r'^'
       |    r'(?:' // Member description. Not present in some Safari frames.
       |    r'([^@(/]*)' // The actual name of the member.
       |    r'(?:\(.*\))?' // Arguments to the member, sometimes captured by Firefox.
       |    r'((?:/[^/]*)*)' // Extra characters indicating a nested closure.
       |    r'(?:\(.*\))?' // Arguments to the closure.
       |    r'@'
       |    r')?'
       |    r'(.*?)' // The frame's URL.
       |    r':'
       |    r'(\d*)' // The line number. Empty in Safari if it's unknown.
       |    r'(?::(\d*))?' // The column number. Not present in older browsers and
       |    // empty in Safari if it's unknown.
       |    r'$');
       |
       |// foo/bar.dart 10:11 Foo._bar
       |// foo/bar.dart 10:11 (anonymous function).dart.fn
       |// https://dart.dev/foo/bar.dart Foo._bar
       |// data:... 10:11 Foo._bar
      0|final _friendlyFrame = RegExp(r'^(\S+)(?: (\d+)(?::(\d+))?)?\s+([^\d].*)$');
       |
       |/// A regular expression that matches asynchronous member names generated by the
       |/// VM.
      0|final _asyncBody = RegExp(r'<(<anonymous closure>|[^>]+)_async_body>');
       |
      0|final _initialDot = RegExp(r'^\.');
       |
       |/// A single stack frame. Each frame points to a precise location in Dart code.
       |class Frame {
       |  /// The URI of the file in which the code is located.
       |  ///
       |  /// This URI will usually have the scheme `dart`, `file`, `http`, or `https`.
       |  final Uri uri;
       |
       |  /// The line number on which the code location is located.
       |  ///
       |  /// This can be null, indicating that the line number is unknown or
       |  /// unimportant.
       |  final int line;
       |
       |  /// The column number of the code location.
       |  ///
       |  /// This can be null, indicating that the column number is unknown or
       |  /// unimportant.
       |  final int column;
       |
       |  /// The name of the member in which the code location occurs.
       |  ///
       |  /// Anonymous closures are represented as `<fn>` in this member string.
       |  final String member;
       |
       |  /// Whether this stack frame comes from the Dart core libraries.
      0|  bool get isCore => uri.scheme == 'dart';
       |
       |  /// Returns a human-friendly description of the library that this stack frame
       |  /// comes from.
       |  ///
       |  /// This will usually be the string form of [uri], but a relative URI will be
       |  /// used if possible. Data URIs will be truncated.
      0|  String get library {
      0|    if (uri.scheme == 'data') return 'data:...';
      0|    return path.prettyUri(uri);
       |  }
       |
       |  /// Returns the name of the package this stack frame comes from, or `null` if
       |  /// this stack frame doesn't come from a `package:` URL.
      0|  String get package {
      0|    if (uri.scheme != 'package') return null;
      0|    return uri.path.split('/').first;
       |  }
       |
       |  /// A human-friendly description of the code location.
      0|  String get location {
      0|    if (line == null) return library;
      0|    if (column == null) return '$library $line';
      0|    return '$library $line:$column';
       |  }
       |
       |  /// Returns a single frame of the current stack.
       |  ///
       |  /// By default, this will return the frame above the current method. If
       |  /// [level] is `0`, it will return the current method's frame; if [level] is
       |  /// higher than `1`, it will return higher frames.
      0|  factory Frame.caller([int level = 1]) {
      0|    if (level < 0) {
      0|      throw ArgumentError('Argument [level] must be greater than or equal '
       |          'to 0.');
       |    }
       |
      0|    return Trace.current(level + 1).frames.first;
       |  }
       |
       |  /// Parses a string representation of a Dart VM stack frame.
      0|  factory Frame.parseVM(String frame) => _catchFormatException(frame, () {
       |        // The VM sometimes folds multiple stack frames together and replaces
       |        // them with "...".
      0|        if (frame == '...') {
      0|          return Frame(Uri(), null, null, '...');
       |        }
       |
      0|        var match = _vmFrame.firstMatch(frame);
      0|        if (match == null) return UnparsedFrame(frame);
       |
       |        // Get the pieces out of the regexp match. Function, URI and line should
       |        // always be found. The column is optional.
      0|        var member = match[1]
      0|            .replaceAll(_asyncBody, '<async>')
      0|            .replaceAll('<anonymous closure>', '<fn>');
      0|        var uri = match[2].startsWith('<data:')
      0|            ? Uri.dataFromString('')
      0|            : Uri.parse(match[2]);
       |
      0|        var lineAndColumn = match[3].split(':');
       |        var line =
      0|            lineAndColumn.length > 1 ? int.parse(lineAndColumn[1]) : null;
       |        var column =
      0|            lineAndColumn.length > 2 ? int.parse(lineAndColumn[2]) : null;
      0|        return Frame(uri, line, column, member);
       |      });
       |
       |  /// Parses a string representation of a Chrome/V8 stack frame.
      0|  factory Frame.parseV8(String frame) => _catchFormatException(frame, () {
      0|        var match = _v8Frame.firstMatch(frame);
      0|        if (match == null) return UnparsedFrame(frame);
       |
       |        // v8 location strings can be arbitrarily-nested, since it adds a layer
       |        // of nesting for each eval performed on that line.
      0|        Frame parseLocation(String location, String member) {
      0|          var evalMatch = _v8EvalLocation.firstMatch(location);
       |          while (evalMatch != null) {
      0|            location = evalMatch[1];
      0|            evalMatch = _v8EvalLocation.firstMatch(location);
       |          }
       |
      0|          if (location == 'native') {
      0|            return Frame(Uri.parse('native'), null, null, member);
       |          }
       |
      0|          var urlMatch = _v8UrlLocation.firstMatch(location);
      0|          if (urlMatch == null) return UnparsedFrame(frame);
       |
      0|          final uri = _uriOrPathToUri(urlMatch[1]);
      0|          final line = int.parse(urlMatch[2]);
      0|          final column = urlMatch[3] != null ? int.parse(urlMatch[3]) : null;
      0|          return Frame(uri, line, column, member);
       |        }
       |
       |        // V8 stack frames can be in two forms.
      0|        if (match[2] != null) {
       |          // The first form looks like " at FUNCTION (LOCATION)". V8 proper
       |          // lists anonymous functions within eval as "<anonymous>", while IE10
       |          // lists them as "Anonymous function".
      0|          return parseLocation(
      0|              match[2],
      0|              match[1]
      0|                  .replaceAll('<anonymous>', '<fn>')
      0|                  .replaceAll('Anonymous function', '<fn>')
      0|                  .replaceAll('(anonymous function)', '<fn>'));
       |        } else {
       |          // The second form looks like " at LOCATION", and is used for
       |          // anonymous functions.
      0|          return parseLocation(match[3], '<fn>');
       |        }
       |      });
       |
       |  /// Parses a string representation of a JavaScriptCore stack trace.
      0|  factory Frame.parseJSCore(String frame) => Frame.parseV8(frame);
       |
       |  /// Parses a string representation of an IE stack frame.
       |  ///
       |  /// IE10+ frames look just like V8 frames. Prior to IE10, stack traces can't
       |  /// be retrieved.
      0|  factory Frame.parseIE(String frame) => Frame.parseV8(frame);
       |
       |  /// Parses a Firefox 'eval' or 'function' stack frame.
       |  ///
       |  /// for example:
       |  /// anonymous/<@https://example.com/stuff.js line 693 > Function:3:40
       |  /// anonymous/<@https://example.com/stuff.js line 693 > eval:3:40
      0|  factory Frame._parseFirefoxEval(String frame) =>
      0|      _catchFormatException(frame, () {
      0|        final match = _firefoxEvalLocation.firstMatch(frame);
      0|        if (match == null) return UnparsedFrame(frame);
      0|        var member = match[1].replaceAll('/<', '');
      0|        final uri = _uriOrPathToUri(match[2]);
      0|        final line = int.parse(match[3]);
      0|        if (member.isEmpty || member == 'anonymous') {
       |          member = '<fn>';
       |        }
      0|        return Frame(uri, line, null, member);
       |      });
       |
       |  /// Parses a string representation of a Firefox stack frame.
      0|  factory Frame.parseFirefox(String frame) => _catchFormatException(frame, () {
      0|        var match = _firefoxSafariFrame.firstMatch(frame);
      0|        if (match == null) return UnparsedFrame(frame);
       |
      0|        if (match[3].contains(' line ')) {
      0|          return Frame._parseFirefoxEval(frame);
       |        }
       |
       |        // Normally this is a URI, but in a jsshell trace it can be a path.
      0|        var uri = _uriOrPathToUri(match[3]);
       |
       |        String member;
      0|        if (match[1] != null) {
      0|          member = match[1];
      0|          member +=
      0|              List.filled('/'.allMatches(match[2]).length, '.<fn>').join();
      0|          if (member == '') member = '<fn>';
       |
       |          // Some Firefox members have initial dots. We remove them for
       |          // consistency with other platforms.
      0|          member = member.replaceFirst(_initialDot, '');
       |        } else {
       |          member = '<fn>';
       |        }
       |
      0|        var line = match[4] == '' ? null : int.parse(match[4]);
       |        var column =
      0|            match[5] == null || match[5] == '' ? null : int.parse(match[5]);
      0|        return Frame(uri, line, column, member);
       |      });
       |
       |  /// Parses a string representation of a Safari 6.0 stack frame.
       |  @Deprecated('Use Frame.parseSafari instead.')
      0|  factory Frame.parseSafari6_0(String frame) => Frame.parseFirefox(frame);
       |
       |  /// Parses a string representation of a Safari 6.1+ stack frame.
       |  @Deprecated('Use Frame.parseSafari instead.')
      0|  factory Frame.parseSafari6_1(String frame) => Frame.parseFirefox(frame);
       |
       |  /// Parses a string representation of a Safari stack frame.
      0|  factory Frame.parseSafari(String frame) => Frame.parseFirefox(frame);
       |
       |  /// Parses this package's string representation of a stack frame.
      0|  factory Frame.parseFriendly(String frame) => _catchFormatException(frame, () {
      0|        var match = _friendlyFrame.firstMatch(frame);
       |        if (match == null) {
      0|          throw FormatException(
      0|              "Couldn't parse package:stack_trace stack trace line '$frame'.");
       |        }
       |        // Fake truncated data urls generated by the friendly stack trace format
       |        // cause Uri.parse to throw an exception so we have to special case
       |        // them.
      0|        var uri = match[1] == 'data:...'
      0|            ? Uri.dataFromString('')
      0|            : Uri.parse(match[1]);
       |        // If there's no scheme, this is a relative URI. We should interpret it
       |        // as relative to the current working directory.
      0|        if (uri.scheme == '') {
      0|          uri = path.toUri(path.absolute(path.fromUri(uri)));
       |        }
       |
      0|        var line = match[2] == null ? null : int.parse(match[2]);
      0|        var column = match[3] == null ? null : int.parse(match[3]);
      0|        return Frame(uri, line, column, match[4]);
       |      });
       |
       |  /// A regular expression matching an absolute URI.
      0|  static final _uriRegExp = RegExp(r'^[a-zA-Z][-+.a-zA-Z\d]*://');
       |
       |  /// A regular expression matching a Windows path.
      0|  static final _windowsRegExp = RegExp(r'^([a-zA-Z]:[\\/]|\\\\)');
       |
       |  /// Converts [uriOrPath], which can be a URI, a Windows path, or a Posix path,
       |  /// to a URI (absolute if possible).
      0|  static Uri _uriOrPathToUri(String uriOrPath) {
      0|    if (uriOrPath.contains(_uriRegExp)) {
      0|      return Uri.parse(uriOrPath);
      0|    } else if (uriOrPath.contains(_windowsRegExp)) {
      0|      return Uri.file(uriOrPath, windows: true);
      0|    } else if (uriOrPath.startsWith('/')) {
      0|      return Uri.file(uriOrPath, windows: false);
       |    }
       |
       |    // As far as I've seen, Firefox and V8 both always report absolute paths in
       |    // their stack frames. However, if we do get a relative path, we should
       |    // handle it gracefully.
      0|    if (uriOrPath.contains('\\')) return path.windows.toUri(uriOrPath);
      0|    return Uri.parse(uriOrPath);
       |  }
       |
       |  /// Runs [body] and returns its result.
       |  ///
       |  /// If [body] throws a [FormatException], returns an [UnparsedFrame] with
       |  /// [text] instead.
      0|  static Frame _catchFormatException(String text, Frame Function() body) {
       |    try {
      0|      return body();
      0|    } on FormatException catch (_) {
      0|      return UnparsedFrame(text);
       |    }
       |  }
       |
      0|  Frame(this.uri, this.line, this.column, this.member);
       |
      0|  @override
      0|  String toString() => '$location in $member';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/trace.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:math' as math;
       |
       |import 'chain.dart';
       |import 'frame.dart';
       |import 'lazy_trace.dart';
       |import 'unparsed_frame.dart';
       |import 'utils.dart';
       |import 'vm_trace.dart';
       |
      0|final _terseRegExp = RegExp(r'(-patch)?([/\\].*)?$');
       |
       |/// A RegExp to match V8's stack traces.
       |///
       |/// V8's traces start with a line that's either just "Error" or else is a
       |/// description of the exception that occurred. That description can be multiple
       |/// lines, so we just look for any line other than the first that begins with
       |/// three or four spaces and "at".
      0|final _v8Trace = RegExp(r'\n    ?at ');
       |
       |/// A RegExp to match indidual lines of V8's stack traces.
       |///
       |/// This is intended to filter out the leading exception details of the trace
       |/// though it is possible for the message to match this as well.
      0|final _v8TraceLine = RegExp(r'    ?at ');
       |
       |/// A RegExp to match Firefox's eval and Function stack traces.
       |///
       |/// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/stack
       |///
       |/// These stack traces looks like:
       |///     anonymous/<@https://example.com/stuff.js line 693 > Function:3:40
       |///     anonymous/<@https://example.com/stuff.js line 693 > eval:3:40
      0|final _firefoxEvalTrace = RegExp(r'@\S+ line \d+ >.* (Function|eval):\d+:\d+');
       |
       |/// A RegExp to match Firefox and Safari's stack traces.
       |///
       |/// Firefox and Safari have very similar stack trace formats, so we use the same
       |/// logic for parsing them.
       |///
       |/// Firefox's trace frames start with the name of the function in which the
       |/// error occurred, possibly including its parameters inside `()`. For example,
       |/// `.VW.call$0("arg")@https://example.com/stuff.dart.js:560`.
       |///
       |/// Safari traces occasionally don't include the initial method name followed by
       |/// "@", and they always have both the line and column number (or just a
       |/// trailing colon if no column number is available). They can also contain
       |/// empty lines or lines consisting only of `[native code]`.
      0|final _firefoxSafariTrace = RegExp(
       |    r'^'
       |    r'(' // Member description. Not present in some Safari frames.
       |    r'([.0-9A-Za-z_$/<]|\(.*\))*' // Member name and arguments.
       |    r'@'
       |    r')?'
       |    r'[^\s]*' // Frame URL.
       |    r':\d*' // Line or column number. Some older frames only have a line number.
       |    r'$',
       |    multiLine: true);
       |
       |/// A RegExp to match this package's stack traces.
      0|final _friendlyTrace =
       |    RegExp(r'^[^\s<][^\s]*( \d+(:\d+)?)?[ \t]+[^\s]+$', multiLine: true);
       |
       |/// A stack trace, comprised of a list of stack frames.
       |class Trace implements StackTrace {
       |  /// The stack frames that comprise this stack trace.
       |  final List<Frame> frames;
       |
       |  /// The original stack trace from which this trace was parsed.
       |  final StackTrace original;
       |
       |  /// Returns a human-readable representation of [stackTrace]. If [terse] is
       |  /// set, this folds together multiple stack frames from the Dart core
       |  /// libraries, so that only the core library method directly called from user
       |  /// code is visible (see [Trace.terse]).
      0|  static String format(StackTrace stackTrace, {bool terse = true}) {
      0|    var trace = Trace.from(stackTrace);
      0|    if (terse) trace = trace.terse;
      0|    return trace.toString();
       |  }
       |
       |  /// Returns the current stack trace.
       |  ///
       |  /// By default, the first frame of this trace will be the line where
       |  /// [Trace.current] is called. If [level] is passed, the trace will start that
       |  /// many frames up instead.
      0|  factory Trace.current([int level = 0]) {
      0|    if (level < 0) {
      0|      throw ArgumentError('Argument [level] must be greater than or equal '
       |          'to 0.');
       |    }
       |
      0|    var trace = Trace.from(StackTrace.current);
      0|    return LazyTrace(() {
       |      // JS includes a frame for the call to StackTrace.current, but the VM
       |      // doesn't, so we skip an extra frame in a JS context.
      0|      return Trace(trace.frames.skip(level + (inJS ? 2 : 1)),
      0|          original: trace.original.toString());
       |    });
       |  }
       |
       |  /// Returns a new stack trace containing the same data as [trace].
       |  ///
       |  /// If [trace] is a native [StackTrace], its data will be parsed out; if it's
       |  /// a [Trace], it will be returned as-is.
      1|  factory Trace.from(StackTrace trace) {
       |    // Normally explicitly validating null arguments is bad Dart style, but here
       |    // the natural failure will only occur when the LazyTrace is materialized,
       |    // and we want to provide an error that's more local to the actual problem.
       |    if (trace == null) {
      0|      throw ArgumentError('Cannot create a Trace from null.');
       |    }
       |
      1|    if (trace is Trace) return trace;
      0|    if (trace is Chain) return trace.toTrace();
      0|    return LazyTrace(() => Trace.parse(trace.toString()));
       |  }
       |
       |  /// Parses a string representation of a stack trace.
       |  ///
       |  /// [trace] should be formatted in the same way as a Dart VM or browser stack
       |  /// trace. If it's formatted as a stack chain, this will return the equivalent
       |  /// of [Chain.toTrace].
      0|  factory Trace.parse(String trace) {
       |    try {
      0|      if (trace.isEmpty) return Trace(<Frame>[]);
      0|      if (trace.contains(_v8Trace)) return Trace.parseV8(trace);
      0|      if (trace.contains('\tat ')) return Trace.parseJSCore(trace);
      0|      if (trace.contains(_firefoxSafariTrace) ||
      0|          trace.contains(_firefoxEvalTrace)) {
      0|        return Trace.parseFirefox(trace);
       |      }
      0|      if (trace.contains(chainGap)) return Chain.parse(trace).toTrace();
      0|      if (trace.contains(_friendlyTrace)) {
      0|        return Trace.parseFriendly(trace);
       |      }
       |
       |      // Default to parsing the stack trace as a VM trace. This is also hit on
       |      // IE and Safari, where the stack trace is just an empty string (issue
       |      // 11257).
      0|      return Trace.parseVM(trace);
      0|    } on FormatException catch (error) {
      0|      throw FormatException('${error.message}\nStack trace:\n$trace');
       |    }
       |  }
       |
       |  /// Parses a string representation of a Dart VM stack trace.
      0|  Trace.parseVM(String trace) : this(_parseVM(trace), original: trace);
       |
      0|  static List<Frame> _parseVM(String trace) {
       |    // Ignore [vmChainGap]. This matches the behavior of
       |    // `Chain.parse().toTrace()`.
       |    var lines = trace
      0|        .trim()
      0|        .replaceAll(vmChainGap, '')
      0|        .split('\n')
      0|        .where((line) => line.isNotEmpty);
       |
      0|    if (lines.isEmpty) {
      0|      return [];
       |    }
       |
       |    var frames = lines
      0|        .take(lines.length - 1)
      0|        .map((line) => Frame.parseVM(line))
      0|        .toList();
       |
       |    // TODO(nweiz): Remove this when issue 23614 is fixed.
      0|    if (!lines.last.endsWith('.da')) {
      0|      frames.add(Frame.parseVM(lines.last));
       |    }
       |
       |    return frames;
       |  }
       |
       |  /// Parses a string representation of a Chrome/V8 stack trace.
      0|  Trace.parseV8(String trace)
      0|      : this(
       |            trace
      0|                .split('\n')
      0|                .skip(1)
       |                // It's possible that an Exception's description contains a line
       |                // that looks like a V8 trace line, which will screw this up.
       |                // Unfortunately, that's impossible to detect.
      0|                .skipWhile((line) => !line.startsWith(_v8TraceLine))
      0|                .map((line) => Frame.parseV8(line)),
       |            original: trace);
       |
       |  /// Parses a string representation of a JavaScriptCore stack trace.
      0|  Trace.parseJSCore(String trace)
      0|      : this(
       |            trace
      0|                .split('\n')
      0|                .where((line) => line != '\tat ')
      0|                .map((line) => Frame.parseV8(line)),
       |            original: trace);
       |
       |  /// Parses a string representation of an Internet Explorer stack trace.
       |  ///
       |  /// IE10+ traces look just like V8 traces. Prior to IE10, stack traces can't
       |  /// be retrieved.
      0|  Trace.parseIE(String trace) : this.parseV8(trace);
       |
       |  /// Parses a string representation of a Firefox stack trace.
      0|  Trace.parseFirefox(String trace)
      0|      : this(
       |            trace
      0|                .trim()
      0|                .split('\n')
      0|                .where((line) => line.isNotEmpty && line != '[native code]')
      0|                .map((line) => Frame.parseFirefox(line)),
       |            original: trace);
       |
       |  /// Parses a string representation of a Safari stack trace.
      0|  Trace.parseSafari(String trace) : this.parseFirefox(trace);
       |
       |  /// Parses a string representation of a Safari 6.1+ stack trace.
      0|  @Deprecated('Use Trace.parseSafari instead.')
      0|  Trace.parseSafari6_1(String trace) : this.parseSafari(trace);
       |
       |  /// Parses a string representation of a Safari 6.0 stack trace.
      0|  @Deprecated('Use Trace.parseSafari instead.')
       |  Trace.parseSafari6_0(String trace)
      0|      : this(
       |            trace
      0|                .trim()
      0|                .split('\n')
      0|                .where((line) => line != '[native code]')
      0|                .map((line) => Frame.parseFirefox(line)),
       |            original: trace);
       |
       |  /// Parses this package's string representation of a stack trace.
       |  ///
       |  /// This also parses string representations of [Chain]s. They parse to the
       |  /// same trace that [Chain.toTrace] would return.
      0|  Trace.parseFriendly(String trace)
      0|      : this(
      0|            trace.isEmpty
      0|                ? []
       |                : trace
      0|                    .trim()
      0|                    .split('\n')
       |                    // Filter out asynchronous gaps from [Chain]s.
      0|                    .where((line) => !line.startsWith('====='))
      0|                    .map((line) => Frame.parseFriendly(line)),
       |            original: trace);
       |
       |  /// Returns a new [Trace] comprised of [frames].
      0|  Trace(Iterable<Frame> frames, {String original})
      0|      : frames = List<Frame>.unmodifiable(frames),
      0|        original = StackTrace.fromString(original);
       |
       |  /// Returns a VM-style [StackTrace] object.
       |  ///
       |  /// The return value's [toString] method will always return a string
       |  /// representation in the Dart VM's stack trace format, regardless of what
       |  /// platform is being used.
      0|  StackTrace get vmTrace => VMTrace(frames);
       |
       |  /// Returns a terser version of [this].
       |  ///
       |  /// This is accomplished by folding together multiple stack frames from the
       |  /// core library or from this package, as in [foldFrames]. Remaining core
       |  /// library frames have their libraries, "-patch" suffixes, and line numbers
       |  /// removed. If the outermost frame of the stack trace is a core library
       |  /// frame, it's removed entirely.
       |  ///
       |  /// This won't do anything with a raw JavaScript trace, since there's no way
       |  /// to determine which frames come from which Dart libraries. However, the
       |  /// [`source_map_stack_trace`][source_map_stack_trace] package can be used to
       |  /// convert JavaScript traces into Dart-style traces.
       |  ///
       |  /// [source_map_stack_trace]: https://pub.dev/packages/source_map_stack_trace
       |  ///
       |  /// For custom folding, see [foldFrames].
      0|  Trace get terse => foldFrames((_) => false, terse: true);
       |
       |  /// Returns a new [Trace] based on [this] where multiple stack frames matching
       |  /// [predicate] are folded together.
       |  ///
       |  /// This means that whenever there are multiple frames in a row that match
       |  /// [predicate], only the last one is kept. This is useful for limiting the
       |  /// amount of library code that appears in a stack trace by only showing user
       |  /// code and code that's called by user code.
       |  ///
       |  /// If [terse] is true, this will also fold together frames from the core
       |  /// library or from this package, simplify core library frames, and
       |  /// potentially remove the outermost frame as in [Trace.terse].
      0|  Trace foldFrames(bool Function(Frame) predicate, {bool terse = false}) {
       |    if (terse) {
       |      var oldPredicate = predicate;
      0|      predicate = (frame) {
      0|        if (oldPredicate(frame)) return true;
       |
      0|        if (frame.isCore) return true;
      0|        if (frame.package == 'stack_trace') return true;
       |
       |        // Ignore async stack frames without any line or column information.
       |        // These come from the VM's async/await implementation and represent
       |        // internal frames. They only ever show up in stack chains and are
       |        // always surrounded by other traces that are actually useful, so we can
       |        // just get rid of them.
       |        // TODO(nweiz): Get rid of this logic some time after issue 22009 is
       |        // fixed.
      0|        if (!frame.member.contains('<async>')) return false;
      0|        return frame.line == null;
       |      };
       |    }
       |
      0|    var newFrames = <Frame>[];
      0|    for (var frame in frames.reversed) {
      0|      if (frame is UnparsedFrame || !predicate(frame)) {
      0|        newFrames.add(frame);
      0|      } else if (newFrames.isEmpty || !predicate(newFrames.last)) {
      0|        newFrames.add(Frame(frame.uri, frame.line, frame.column, frame.member));
       |      }
       |    }
       |
       |    if (terse) {
      0|      newFrames = newFrames.map((frame) {
      0|        if (frame is UnparsedFrame || !predicate(frame)) return frame;
      0|        var library = frame.library.replaceAll(_terseRegExp, '');
      0|        return Frame(Uri.parse(library), null, null, frame.member);
      0|      }).toList();
       |
      0|      if (newFrames.length > 1 && predicate(newFrames.first)) {
      0|        newFrames.removeAt(0);
       |      }
       |    }
       |
      0|    return Trace(newFrames.reversed, original: original.toString());
       |  }
       |
      0|  @override
       |  String toString() {
       |    // Figure out the longest path so we know how much to pad.
       |    var longest =
      0|        frames.map((frame) => frame.location.length).fold(0, math.max);
       |
       |    // Print out the stack trace nicely formatted.
      0|    return frames.map((frame) {
      0|      if (frame is UnparsedFrame) return '$frame\n';
      0|      return '${frame.location.padRight(longest)}  ${frame.member}\n';
      0|    }).join();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/unparsed_frame.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'frame.dart';
       |
       |/// A frame that failed to parse.
       |///
       |/// The [member] property contains the original frame's contents.
       |class UnparsedFrame implements Frame {
       |  @override
       |  final Uri uri = Uri(path: 'unparsed');
       |  @override
       |  final int line = null;
       |  @override
       |  final int column = null;
       |  @override
       |  final bool isCore = false;
       |  @override
       |  final String library = 'unparsed';
       |  @override
       |  final String package = null;
       |  @override
       |  final String location = 'unparsed';
       |
       |  @override
       |  final String member;
       |
      0|  UnparsedFrame(this.member);
       |
      0|  @override
      0|  String toString() => member;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/lazy_trace.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'frame.dart';
       |import 'trace.dart';
       |
       |/// A thunk for lazily constructing a [Trace].
       |typedef TraceThunk = Trace Function();
       |
       |/// A wrapper around a [TraceThunk]. This works around issue 9579 by avoiding
       |/// the conversion of native [StackTrace]s to strings until it's absolutely
       |/// necessary.
       |class LazyTrace implements Trace {
       |  final TraceThunk _thunk;
       |  Trace _inner;
       |
      1|  LazyTrace(this._thunk);
       |
      0|  Trace get _trace => _inner ??= _thunk();
       |
      0|  @override
      0|  List<Frame> get frames => _trace.frames;
      0|  @override
      0|  StackTrace get original => _trace.original;
      0|  @override
      0|  StackTrace get vmTrace => _trace.vmTrace;
      0|  @override
      0|  Trace get terse => LazyTrace(() => _trace.terse);
      0|  @override
       |  Trace foldFrames(bool Function(Frame) predicate, {bool terse = false}) =>
      0|      LazyTrace(() => _trace.foldFrames(predicate, terse: terse));
      0|  @override
      0|  String toString() => _trace.toString();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/utils.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// The line used in the string representation of stack chains to represent
       |/// the gap between traces.
       |const chainGap = '===== asynchronous gap ===========================\n';
       |
       |/// The line used in the string representation of VM stack chains to represent
       |/// the gap between traces.
      0|final vmChainGap = RegExp(r'^<asynchronous suspension>\n?$', multiLine: true);
       |
       |// TODO(nweiz): When cross-platform imports work, use them to set this.
       |/// Whether we're running in a JS context.
      0|final bool inJS = 0.0 is int;
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/vm_trace.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'frame.dart';
       |
       |/// An implementation of [StackTrace] that emulates the behavior of the VM's
       |/// implementation.
       |///
       |/// In particular, when [toString] is called, this returns a string in the VM's
       |/// stack trace format.
       |class VMTrace implements StackTrace {
       |  /// The stack frames that comprise this stack trace.
       |  final List<Frame> frames;
       |
      0|  VMTrace(this.frames);
       |
      0|  @override
       |  String toString() {
       |    var i = 1;
      0|    return frames.map((frame) {
      0|      var number = '#${i++}'.padRight(8);
      0|      var member = frame.member
      0|          .replaceAllMapped(RegExp(r'[^.]+\.<async>'),
      0|              (match) => '${match[1]}.<${match[1]}_async_body>')
      0|          .replaceAll('<fn>', '<anonymous closure>');
      0|      var line = frame.line ?? 0;
      0|      var column = frame.column ?? 0;
      0|      return '$number$member (${frame.uri}:$line:$column)\n';
      0|    }).join();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/lazy_chain.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'chain.dart';
       |import 'frame.dart';
       |import 'lazy_trace.dart';
       |import 'trace.dart';
       |
       |/// A thunk for lazily constructing a [Chain].
       |typedef ChainThunk = Chain Function();
       |
       |/// A wrapper around a [ChainThunk]. This works around issue 9579 by avoiding
       |/// the conversion of native [StackTrace]s to strings until it's absolutely
       |/// necessary.
       |class LazyChain implements Chain {
       |  final ChainThunk _thunk;
       |  Chain _inner;
       |
      0|  LazyChain(this._thunk);
       |
      0|  Chain get _chain => _inner ??= _thunk();
       |
      0|  @override
      0|  List<Trace> get traces => _chain.traces;
      0|  @override
      0|  Chain get terse => _chain.terse;
      0|  @override
       |  Chain foldFrames(bool Function(Frame) predicate, {bool terse = false}) =>
      0|      LazyChain(() => _chain.foldFrames(predicate, terse: terse));
      0|  @override
      0|  Trace toTrace() => LazyTrace(() => _chain.toTrace());
      0|  @override
      0|  String toString() => _chain.toString();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/stack_trace-1.9.6/lib/src/stack_zone_specification.dart
       |// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'chain.dart';
       |import 'lazy_chain.dart';
       |import 'lazy_trace.dart';
       |import 'trace.dart';
       |import 'utils.dart';
       |
       |/// A class encapsulating the zone specification for a [Chain.capture] zone.
       |///
       |/// Until they're materialized and exposed to the user, stack chains are tracked
       |/// as linked lists of [Trace]s using the [_Node] class. These nodes are stored
       |/// in three distinct ways:
       |///
       |/// * When a callback is registered, a node is created and stored as a captured
       |///   local variable until the callback is run.
       |///
       |/// * When a callback is run, its captured node is set as the [_currentNode] so
       |///   it can be available to [Chain.current] and to be linked into additional
       |///   chains when more callbacks are scheduled.
       |///
       |/// * When a callback throws an error or a Future or Stream emits an error, the
       |///   current node is associated with that error's stack trace using the
       |///   [_chains] expando.
       |///
       |/// Since [ZoneSpecification] can't be extended or even implemented, in order to
       |/// get a real [ZoneSpecification] instance it's necessary to call [toSpec].
       |class StackZoneSpecification {
       |  /// An opaque object used as a zone value to disable chain tracking in a given
       |  /// zone.
       |  ///
       |  /// If `Zone.current[disableKey]` is `true`, no stack chains will be tracked.
      3|  static final disableKey = Object();
       |
       |  /// Whether chain-tracking is disabled in the current zone.
      5|  bool get _disabled => Zone.current[disableKey] == true;
       |
       |  /// The expando that associates stack chains with [StackTrace]s.
       |  ///
       |  /// The chains are associated with stack traces rather than errors themselves
       |  /// because it's a common practice to throw strings as errors, which can't be
       |  /// used with expandos.
       |  ///
       |  /// The chain associated with a given stack trace doesn't contain a node for
       |  /// that stack trace.
       |  final _chains = Expando<_Node>('stack chains');
       |
       |  /// The error handler for the zone.
       |  ///
       |  /// If this is null, that indicates that any unhandled errors should be passed
       |  /// to the parent zone.
       |  final void Function(Object error, Chain) _onError;
       |
       |  /// The most recent node of the current stack chain.
       |  _Node _currentNode;
       |
       |  /// Whether this is an error zone.
       |  final bool _errorZone;
       |
      1|  StackZoneSpecification(this._onError, {bool errorZone = true})
       |      : _errorZone = errorZone;
       |
       |  /// Converts [this] to a real [ZoneSpecification].
      1|  ZoneSpecification toSpec() {
      1|    return ZoneSpecification(
      1|        handleUncaughtError: _errorZone ? _handleUncaughtError : null,
      1|        registerCallback: _registerCallback,
      1|        registerUnaryCallback: _registerUnaryCallback,
      1|        registerBinaryCallback: _registerBinaryCallback,
      1|        errorCallback: _errorCallback);
       |  }
       |
       |  /// Returns the current stack chain.
       |  ///
       |  /// By default, the first frame of the first trace will be the line where
       |  /// [currentChain] is called. If [level] is passed, the first trace will start
       |  /// that many frames up instead.
      0|  Chain currentChain([int level = 0]) => _createNode(level + 1).toChain();
       |
       |  /// Returns the stack chain associated with [trace], if one exists.
       |  ///
       |  /// The first stack trace in the returned chain will always be [trace]
       |  /// (converted to a [Trace] if necessary). If there is no chain associated
       |  /// with [trace], this just returns a single-trace chain containing [trace].
      0|  Chain chainFor(StackTrace trace) {
      0|    if (trace is Chain) return trace;
      0|    trace ??= StackTrace.current;
       |
      0|    var previous = _chains[trace] ?? _currentNode;
       |    if (previous == null) {
       |      // If there's no [_currentNode], we're running synchronously beneath
       |      // [Chain.capture] and we should fall back to the VM's stack chaining. We
       |      // can't use [Chain.from] here because it'll just call [chainFor] again.
      0|      if (trace is Trace) return Chain([trace]);
      0|      return LazyChain(() => Chain.parse(trace.toString()));
       |    } else {
      0|      if (trace is! Trace) {
       |        var original = trace;
      0|        trace = LazyTrace(() => Trace.parse(_trimVMChain(original)));
       |      }
       |
      0|      return _Node(trace, previous).toChain();
       |    }
       |  }
       |
       |  /// Tracks the current stack chain so it can be set to [_currentChain] when
       |  /// [f] is run.
      1|  ZoneCallback<R> _registerCallback<R>(
       |      Zone self, ZoneDelegate parent, Zone zone, R Function() f) {
      1|    if (f == null || _disabled) return parent.registerCallback(zone, f);
      1|    var node = _createNode(1);
      3|    return parent.registerCallback(zone, () => _run(f, node));
       |  }
       |
       |  /// Tracks the current stack chain so it can be set to [_currentChain] when
       |  /// [f] is run.
      1|  ZoneUnaryCallback<R, T> _registerUnaryCallback<R, T>(
       |      Zone self, ZoneDelegate parent, Zone zone, R Function(T) f) {
      1|    if (f == null || _disabled) return parent.registerUnaryCallback(zone, f);
      1|    var node = _createNode(1);
      2|    return parent.registerUnaryCallback(zone, (arg) {
      3|      return _run(() => f(arg), node);
       |    });
       |  }
       |
       |  /// Tracks the current stack chain so it can be set to [_currentChain] when
       |  /// [f] is run.
      1|  ZoneBinaryCallback<R, T1, T2> _registerBinaryCallback<R, T1, T2>(
       |      Zone self, ZoneDelegate parent, Zone zone, R Function(T1, T2) f) {
      1|    if (f == null || _disabled) return parent.registerBinaryCallback(zone, f);
       |
      1|    var node = _createNode(1);
      1|    return parent.registerBinaryCallback(zone, (arg1, arg2) {
      0|      return _run(() => f(arg1, arg2), node);
       |    });
       |  }
       |
       |  /// Looks up the chain associated with [stackTrace] and passes it either to
       |  /// [_onError] or [parent]'s error handler.
      0|  void _handleUncaughtError(
       |      Zone self, ZoneDelegate parent, Zone zone, error, StackTrace stackTrace) {
      0|    if (_disabled) {
      0|      parent.handleUncaughtError(zone, error, stackTrace);
       |      return;
       |    }
       |
      0|    var stackChain = chainFor(stackTrace);
      0|    if (_onError == null) {
      0|      parent.handleUncaughtError(zone, error, stackChain);
       |      return;
       |    }
       |
       |    // TODO(nweiz): Currently this copies a lot of logic from [runZoned]. Just
       |    // allow [runBinary] to throw instead once issue 18134 is fixed.
       |    try {
      0|      self.parent.runBinary(_onError, error, stackChain);
       |    } catch (newError, newStackTrace) {
       |      if (identical(newError, error)) {
      0|        parent.handleUncaughtError(zone, error, stackChain);
       |      } else {
      0|        parent.handleUncaughtError(zone, newError, newStackTrace);
       |      }
       |    }
       |  }
       |
       |  /// Attaches the current stack chain to [stackTrace], replacing it if
       |  /// necessary.
      0|  AsyncError _errorCallback(Zone self, ZoneDelegate parent, Zone zone,
       |      Object error, StackTrace stackTrace) {
      0|    if (_disabled) return parent.errorCallback(zone, error, stackTrace);
       |
       |    // Go up two levels to get through [_CustomZone.errorCallback].
       |    if (stackTrace == null) {
      0|      stackTrace = _createNode(2).toChain();
       |    } else {
      0|      if (_chains[stackTrace] == null) _chains[stackTrace] = _createNode(2);
       |    }
       |
      0|    var asyncError = parent.errorCallback(zone, error, stackTrace);
      0|    return asyncError ?? AsyncError(error, stackTrace);
       |  }
       |
       |  /// Creates a [_Node] with the current stack trace and linked to
       |  /// [_currentNode].
       |  ///
       |  /// By default, the first frame of the first trace will be the line where
       |  /// [_createNode] is called. If [level] is passed, the first trace will start
       |  /// that many frames up instead.
      1|  _Node _createNode([int level = 0]) =>
      4|      _Node(_currentTrace(level + 1), _currentNode);
       |
       |  // TODO(nweiz): use a more robust way of detecting and tracking errors when
       |  // issue 15105 is fixed.
       |  /// Runs [f] with [_currentNode] set to [node].
       |  ///
       |  /// If [f] throws an error, this associates [node] with that error's stack
       |  /// trace.
      1|  T _run<T>(T Function() f, _Node node) {
      1|    var previousNode = _currentNode;
      1|    _currentNode = node;
       |    try {
      1|      return f();
       |    } catch (e, stackTrace) {
       |      // We can see the same stack trace multiple times if it's rethrown through
       |      // guarded callbacks.  The innermost chain will have the most
       |      // information so it should take precedence.
      0|      _chains[stackTrace] ??= node;
       |      rethrow;
       |    } finally {
      1|      _currentNode = previousNode;
       |    }
       |  }
       |
       |  /// Like [new Trace.current], but if the current stack trace has VM chaining
       |  /// enabled, this only returns the innermost sub-trace.
      1|  Trace _currentTrace([int level]) {
       |    level ??= 0;
      1|    var stackTrace = StackTrace.current;
      1|    return LazyTrace(() {
      0|      var text = _trimVMChain(stackTrace);
      0|      var trace = Trace.parse(text);
       |      // JS includes a frame for the call to StackTrace.current, but the VM
       |      // doesn't, so we skip an extra frame in a JS context.
      0|      return Trace(trace.frames.skip(level + (inJS ? 2 : 1)), original: text);
       |    });
       |  }
       |
       |  /// Removes the VM's stack chains from the native [trace], since we're
       |  /// generating our own and we don't want duplicate frames.
      0|  String _trimVMChain(StackTrace trace) {
      0|    var text = trace.toString();
      0|    var index = text.indexOf(vmChainGap);
      0|    return index == -1 ? text : text.substring(0, index);
       |  }
       |}
       |
       |/// A linked list node representing a single entry in a stack chain.
       |class _Node {
       |  /// The stack trace for this link of the chain.
       |  final Trace trace;
       |
       |  /// The previous node in the chain.
       |  final _Node previous;
       |
      2|  _Node(StackTrace trace, [this.previous]) : trace = Trace.from(trace);
       |
       |  /// Converts this to a [Chain].
      0|  Chain toChain() {
      0|    var nodes = <Trace>[];
       |    var node = this;
       |    while (node != null) {
      0|      nodes.add(node.trace);
      0|      node = node.previous;
       |    }
      0|    return Chain(nodes);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/util/remote_exception.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |
       |import '../frontend/expect.dart';
       |
       |/// An exception that was thrown remotely.
       |///
       |/// This could be an exception thrown in a different isolate, a different
       |/// process, or on an entirely different computer.
       |class RemoteException implements Exception {
       |  /// The original exception's message, if it had one.
       |  ///
       |  /// If the original exception was a plain string, this will contain that
       |  /// string.
       |  final String message;
       |
       |  /// The value of the original exception's `runtimeType.toString()`.
       |  final String type;
       |
       |  /// The value of the original exception's `toString()`.
       |  final String _toString;
       |
       |  /// Serializes [error] and [stackTrace] into a JSON-safe object.
       |  ///
       |  /// Other than JSON- and isolate-safety, no guarantees are made about the
       |  /// serialized format.
      0|  static Map<String, dynamic> serialize(error, StackTrace stackTrace) {
       |    String message;
      0|    if (error is String) {
       |      message = error;
       |    } else {
       |      try {
      0|        message = error.message.toString();
      0|      } on NoSuchMethodError catch (_) {
       |        // Do nothing.
       |      }
       |    }
       |
      0|    final supertype = (error is TestFailure) ? 'TestFailure' : null;
       |
      0|    return {
       |      'message': message,
      0|      'type': error.runtimeType.toString(),
       |      'supertype': supertype,
      0|      'toString': error.toString(),
      0|      'stackChain': Chain.forTrace(stackTrace).toString()
       |    };
       |  }
       |
       |  /// Deserializes an exception serialized with [RemoteException.serialize].
       |  ///
       |  /// The returned [AsyncError] is guaranteed to have a [RemoteException] as its
       |  /// error and a [Chain] as its stack trace.
      0|  static AsyncError deserialize(serialized) {
      0|    return AsyncError(_deserializeException(serialized),
      0|        Chain.parse(serialized['stackChain'] as String));
       |  }
       |
       |  /// Deserializes the exception portion of [serialized].
      0|  static RemoteException _deserializeException(serialized) {
      0|    final message = serialized['message'] as String;
      0|    final type = serialized['type'] as String;
      0|    final toString = serialized['toString'] as String;
       |
      0|    switch (serialized['supertype'] as String) {
      0|      case 'TestFailure':
      0|        return _RemoteTestFailure(message, type, toString);
       |      default:
      0|        return RemoteException._(message, type, toString);
       |    }
       |  }
       |
      0|  RemoteException._(this.message, this.type, this._toString);
       |
      0|  @override
      0|  String toString() => _toString;
       |}
       |
       |/// A subclass of [RemoteException] that implements [TestFailure].
       |///
       |/// It's important to preserve [TestFailure]-ness, because tests have different
       |/// results depending on whether an exception was a failure or an error.
       |class _RemoteTestFailure extends RemoteException implements TestFailure {
      0|  _RemoteTestFailure(String message, String type, String toString)
      0|      : super._(message, type, toString);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/util/placeholder.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A class that's used as a default argument to detect whether an argument was
       |/// passed.
       |///
       |/// We use a custom class for this rather than just `const Object()` so that
       |/// callers can't accidentally pass the placeholder value.
       |class _Placeholder {
      0|  const _Placeholder();
       |}
       |
       |/// A placeholder to use as a default argument value to detect whether an
       |/// argument was passed.
       |const placeholder = _Placeholder();
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/runtime_selection.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |
       |/// A runtime on which the user has chosen to run tests.
       |class RuntimeSelection {
       |  /// The name of the runtime.
       |  final String name;
       |
       |  /// The location in the configuration file of this runtime string, or `null`
       |  /// if it was defined outside a configuration file (for example, on the
       |  /// command line).
       |  final SourceSpan span;
       |
      0|  RuntimeSelection(this.name, [this.span]);
       |
      0|  @override
      0|  bool operator ==(other) => other is RuntimeSelection && other.name == name;
       |
      0|  @override
      0|  int get hashCode => name.hashCode;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/environment.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart';
       |
       |/// The abstract class of environments in which test suites are
       |/// loadedspecifically, browsers and the Dart VM.
       |abstract class Environment {
       |  /// Whether this environment supports interactive debugging.
       |  bool get supportsDebugging;
       |
       |  /// The URL of the Dart VM Observatory for this environment, or `null` if this
       |  /// environment doesn't run the Dart VM or the URL couldn't be detected.
       |  Uri get observatoryUrl;
       |
       |  /// The URL of the remote debugger for this environment, or `null` if it isn't
       |  /// enabled.
       |  Uri get remoteDebuggerUrl;
       |
       |  /// A broadcast stream that emits a `null` event whenever the user tells the
       |  /// environment to restart the current test once it's finished.
       |  ///
       |  /// Never emits an error, and never closes.
       |  Stream get onRestart;
       |
       |  /// Displays information indicating that the test runner is paused.
       |  ///
       |  /// The returned operation will complete when the user takes action within the
       |  /// environment that should unpause the runner. If the runner is unpaused
       |  /// elsewhere, the operation should be canceled.
       |  CancelableOperation displayPause();
       |}
       |
       |/// The default environment for platform plugins.
       |class PluginEnvironment implements Environment {
       |  @override
       |  final supportsDebugging = false;
      0|  @override
      0|  Stream get onRestart => StreamController.broadcast().stream;
       |
      0|  const PluginEnvironment();
       |
      0|  @override
       |  Uri get observatoryUrl => null;
       |
      0|  @override
       |  Uri get remoteDebuggerUrl => null;
       |
      0|  @override
      0|  CancelableOperation displayPause() => throw UnsupportedError(
       |      'PluginEnvironment.displayPause is not supported.');
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/load_exception.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:source_span/source_span.dart';
       |import 'package:test_api/src/utils.dart'; // ignore: implementation_imports
       |
       |class LoadException implements Exception {
       |  final String path;
       |
       |  final Object innerError;
       |
      0|  LoadException(this.path, this.innerError);
       |
      0|  @override
       |  String toString({bool color = false}) {
      0|    var buffer = StringBuffer();
      0|    if (color) buffer.write('\u001b[31m'); // red
      0|    buffer.write('Failed to load "$path":');
      0|    if (color) buffer.write('\u001b[0m'); // no color
       |
      0|    var innerString = getErrorMessage(innerError);
      0|    if (innerError is SourceSpanException) {
      0|      innerString = (innerError as SourceSpanException)
      0|          .toString(color: color)
      0|          .replaceFirst(' of $path', '');
       |    }
       |
      0|    buffer.write(innerString.contains('\n') ? '\n' : ' ');
      0|    buffer.write(innerString);
      0|    return buffer.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/load_suite.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:stack_trace/stack_trace.dart';
       |import 'package:stream_channel/stream_channel.dart';
       |import 'package:test_api/src/backend/group.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/invoker.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/metadata.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/runtime.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/suite.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/suite_platform.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/test.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/utils.dart'; // ignore: implementation_imports
       |
       |import '../../test_core.dart';
       |import '../util/io_stub.dart'
       |    // ignore: uri_does_not_exist
       |    if (dart.library.io) '../util/io.dart';
       |import 'load_exception.dart';
       |import 'plugin/environment.dart';
       |import 'runner_suite.dart';
       |import 'suite.dart';
       |
       |/// The timeout for loading a test suite.
       |///
       |/// We want this to be long enough that even a very large application being
       |/// compiled with dart2js doesn't trigger it, but short enough that it fires
       |/// before the host kills it. For example, Google's Forge service has a
       |/// 15-minute timeout.
      0|final _timeout = Duration(minutes: 12);
       |
       |/// A [Suite] emitted by a [Loader] that provides a test-like interface for
       |/// loading a test file.
       |///
       |/// This is used to expose the current status of test loading to the user. It's
       |/// important to provide users visibility into what's taking a long time and
       |/// where failures occur. And since some tests may be loaded at the same time as
       |/// others are run, it's useful to provide that visibility in the form of a test
       |/// suite so that it can integrate well into the existing reporting interface
       |/// without too much extra logic.
       |///
       |/// A suite is constructed with logic necessary to produce a test suite. As with
       |/// a normal test body, this logic isn't run until [LiveTest.run] is called. The
       |/// suite itself is returned by [suite] once it's avaialble, but any errors or
       |/// prints will be emitted through the running [LiveTest].
       |class LoadSuite extends Suite implements RunnerSuite {
       |  @override
       |  final environment = const PluginEnvironment();
       |  @override
       |  final SuiteConfiguration config;
       |  @override
       |  final isDebugging = false;
       |  @override
       |  final onDebugging = StreamController<bool>().stream;
       |
      0|  @override
       |  bool get isLoadSuite => true;
       |
       |  /// A future that completes to the loaded suite once the suite's test has been
       |  /// run and completed successfully.
       |  ///
       |  /// This will return `null` if the suite is unavailable for some reason (for
       |  /// example if an error occurred while loading it).
      0|  Future<RunnerSuite> get suite async => (await _suiteAndZone)?.first;
       |
       |  /// A future that completes to a pair of [suite] and the load test's [Zone].
       |  ///
       |  /// This will return `null` if the suite is unavailable for some reason (for
       |  /// example if an error occurred while loading it).
       |  final Future<Pair<RunnerSuite, Zone>> _suiteAndZone;
       |
       |  /// Returns the test that loads the suite.
       |  ///
       |  /// Load suites are guaranteed to only contain one test. This is a utility
       |  /// method for accessing it directly.
      0|  Test get test => this.group.entries.single as Test;
       |
       |  /// Creates a load suite named [name] on [platform].
       |  ///
       |  /// [body] may return either a [RunnerSuite] or a [Future] that completes to a
       |  /// [RunnerSuite]. Its return value is forwarded through [suite], although if
       |  /// it throws an error that will be forwarded through the suite's test.
       |  ///
       |  /// If the the load test is closed before [body] is complete, it will close
       |  /// the suite returned by [body] once it completes.
      0|  factory LoadSuite(String name, SuiteConfiguration config,
       |      SuitePlatform platform, FutureOr<RunnerSuite> Function() body,
       |      {String path}) {
      0|    var completer = Completer<Pair<RunnerSuite, Zone>>.sync();
      0|    return LoadSuite._(name, config, platform, () {
      0|      var invoker = Invoker.current;
      0|      invoker.addOutstandingCallback();
       |
      0|      unawaited(() async {
      0|        var suite = await body();
      0|        if (completer.isCompleted) {
       |          // If the load test has already been closed, close the suite it
       |          // generated.
      0|          await suite?.close();
       |          return;
       |        }
       |
      0|        completer.complete(suite == null ? null : Pair(suite, Zone.current));
      0|        invoker.removeOutstandingCallback();
      0|      }());
       |
       |      // If the test completes before the body callback, either an out-of-band
       |      // error occurred or the test was canceled. Either way, we return a `null`
       |      // suite.
      0|      invoker.liveTest.onComplete.then((_) {
      0|        if (!completer.isCompleted) completer.complete();
       |      });
       |
       |      // If the test is forcibly closed, let it complete, since load tests don't
       |      // have timeouts.
      0|      invoker.onClose.then((_) => invoker.removeOutstandingCallback());
      0|    }, completer.future, path: path);
       |  }
       |
       |  /// A utility constructor for a load suite that just throws [exception].
       |  ///
       |  /// The suite's name will be based on [exception]'s path.
      0|  factory LoadSuite.forLoadException(
       |      LoadException exception, SuiteConfiguration config,
       |      {SuitePlatform platform, StackTrace stackTrace}) {
      0|    stackTrace ??= Trace.current();
       |
      0|    return LoadSuite(
      0|        'loading ${exception.path}',
      0|        config ?? SuiteConfiguration.empty,
      0|        platform ?? currentPlatform(Runtime.vm),
      0|        () => Future.error(exception, stackTrace),
      0|        path: exception.path);
       |  }
       |
       |  /// A utility constructor for a load suite that just emits [suite].
      0|  factory LoadSuite.forSuite(RunnerSuite suite) {
      0|    return LoadSuite(
      0|        'loading ${suite.path}', suite.config, suite.platform, () => suite,
      0|        path: suite.path);
       |  }
       |
      0|  LoadSuite._(String name, this.config, SuitePlatform platform,
       |      void Function() body, this._suiteAndZone, {String path})
      0|      : super(
      0|            Group.root(
      0|                [LocalTest(name, Metadata(timeout: Timeout(_timeout)), body)]),
       |            platform,
       |            path: path);
       |
       |  /// A constructor used by [changeSuite].
      0|  LoadSuite._changeSuite(LoadSuite old, this._suiteAndZone)
      0|      : config = old.config,
      0|        super(old.group, old.platform, path: old.path);
       |
       |  /// A constructor used by [filter].
      0|  LoadSuite._filtered(LoadSuite old, Group filtered)
      0|      : config = old.config,
      0|        _suiteAndZone = old._suiteAndZone,
      0|        super(old.group, old.platform, path: old.path);
       |
       |  /// Creates a new [LoadSuite] that's identical to this one, but that
       |  /// transforms [suite] once it's loaded.
       |  ///
       |  /// If [suite] completes to `null`, [change] won't be run. [change] is run
       |  /// within the load test's zone, so any errors or prints it emits will be
       |  /// associated with that test.
      0|  LoadSuite changeSuite(RunnerSuite Function(RunnerSuite) change) {
      0|    return LoadSuite._changeSuite(this, _suiteAndZone.then((pair) {
       |      if (pair == null) return null;
       |
      0|      var zone = pair.last;
       |      RunnerSuite newSuite;
      0|      zone.runGuarded(() {
      0|        newSuite = change(pair.first);
       |      });
      0|      return newSuite == null ? null : Pair(newSuite, zone);
       |    }));
       |  }
       |
       |  /// Runs the test and returns the suite.
       |  ///
       |  /// Rather than emitting errors through a [LiveTest], this just pipes them
       |  /// through the return value.
      0|  Future<RunnerSuite> getSuite() async {
      0|    var liveTest = test.load(this);
      0|    liveTest.onMessage.listen((message) => print(message.text));
      0|    await liveTest.run();
       |
      0|    if (liveTest.errors.isEmpty) return await suite;
       |
      0|    var error = liveTest.errors.first;
      0|    await Future.error(error.error, error.stackTrace);
       |    throw 'unreachable';
       |  }
       |
      0|  @override
       |  LoadSuite filter(bool Function(Test) callback) {
      0|    var filtered = this.group.filter(callback);
      0|    filtered ??= Group.root([], metadata: metadata);
      0|    return LoadSuite._filtered(this, filtered);
       |  }
       |
      0|  @override
       |  StreamChannel channel(String name) =>
      0|      throw UnsupportedError('LoadSuite.channel() is not supported.');
       |
       |  @override
      0|  Future close() async {}
       |
      0|  @override
       |  Future<Map<String, dynamic>> gatherCoverage() =>
      0|      throw UnsupportedError('Coverage is not supported for LoadSuite tests.');
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/util/io.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:core' as core;
       |import 'dart:core';
       |import 'dart:convert';
       |import 'dart:io';
       |import 'dart:isolate';
       |
       |import 'package:async/async.dart';
       |import 'package:package_config/package_config.dart';
       |import 'package:path/path.dart' as p;
       |
       |import 'package:test_api/src/backend/operating_system.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/runtime.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/suite_platform.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/utils.dart'; // ignore: implementation_imports
       |
       |/// The default line length for output when there isn't a terminal attached to
       |/// stdout.
       |const _defaultLineLength = 200;
       |
       |/// Whether the test runner is running on Google-internal infrastructure.
      0|final bool inGoogle = Platform.version.contains('(google3)');
       |
       |/// The maximum line length for output.
      0|final int lineLength = () {
       |  try {
       |    return stdout.terminalColumns;
       |  } on UnsupportedError {
       |    // This can throw an [UnsupportedError] if we're running in a JS context
       |    // where `dart:io` is unavaiable.
       |    return _defaultLineLength;
       |  } on StdoutException {
       |    return _defaultLineLength;
       |  }
       |}();
       |
       |/// A comment which forces the language version to be that of the current
       |/// packages default.
       |///
       |/// If the cwd is not a package, this returns an empty string which ends up
       |/// defaulting to the current sdk version.
      0|final Future<String> rootPackageLanguageVersionComment = () async {
       |  var packageConfig = await loadPackageConfigUri(await Isolate.packageConfig);
       |  var rootPackage = packageConfig.packageOf(Uri.file(p.absolute('foo.dart')));
       |  if (rootPackage == null) return '';
       |  return '// @dart=${rootPackage.languageVersion}';
       |}();
       |
       |/// The root directory of the Dart SDK.
      0|final String sdkDir = p.dirname(p.dirname(Platform.resolvedExecutable));
       |
       |/// The current operating system.
      0|final currentOS = OperatingSystem.findByIoName(Platform.operatingSystem);
       |
       |/// Returns a [SuitePlatform] with the given [runtime], and with [os] and
       |/// [inGoogle] determined automatically.
       |///
       |/// If [runtime] is a browser, this will set [os] to [OperatingSystem.none].
      0|SuitePlatform currentPlatform(Runtime runtime) => SuitePlatform(runtime,
      0|    os: runtime.isBrowser ? OperatingSystem.none : currentOS,
      0|    inGoogle: inGoogle);
       |
       |/// A queue of lines of standard input.
       |///
       |/// Also returns an empty stream for Fuchsia since Fuchsia components can't
       |/// access stdin.
      0|final stdinLines = StreamQueue(
       |    Platform.isFuchsia ? Stream<String>.empty() : lineSplitter.bind(stdin));
       |
       |/// Whether this is being run as a subprocess in the test package's own tests.
      0|bool inTestTests = Platform.environment['_DART_TEST_TESTING'] == 'true';
       |
       |/// The root directory below which to nest temporary directories created by the
       |/// test runner.
       |///
       |/// This is configurable so that the test code can validate that the runner
       |/// cleans up after itself fully.
      0|final _tempDir = Platform.environment.containsKey('_UNITTEST_TEMP_DIR')
       |    ? Platform.environment['_UNITTEST_TEMP_DIR']
       |    : Directory.systemTemp.path;
       |
       |/// Whether or not the current terminal supports ansi escape codes.
       |///
       |/// Otherwise only printable ASCII characters should be used.
      0|bool get canUseSpecialChars =>
      0|    (!Platform.isWindows || stdout.supportsAnsiEscapes) && !inTestTests;
       |
       |/// Creates a temporary directory and returns its path.
      0|String createTempDir() =>
      0|    Directory(_tempDir).createTempSync('dart_test_').resolveSymbolicLinksSync();
       |
       |/// Creates a temporary directory and passes its path to [fn].
       |///
       |/// Once the [Future] returned by [fn] completes, the temporary directory and
       |/// all its contents are deleted. [fn] can also return `null`, in which case
       |/// the temporary directory is deleted immediately afterwards.
       |///
       |/// Returns a future that completes to the value that the future returned from
       |/// [fn] completes to.
      0|Future withTempDir(Future Function(String) fn) {
      0|  return Future.sync(() {
      0|    var tempDir = createTempDir();
      0|    return Future.sync(() => fn(tempDir))
      0|        .whenComplete(() => Directory(tempDir).deleteSync(recursive: true));
       |  });
       |}
       |
       |/// Wraps [text] so that it fits within [lineLength].
       |///
       |/// This preserves existing newlines and doesn't consider terminal color escapes
       |/// part of a word's length. It only splits words on spaces, not on other sorts
       |/// of whitespace.
      0|String wordWrap(String text) {
      0|  return text.split('\n').map((originalLine) {
      0|    var buffer = StringBuffer();
       |    var lengthSoFar = 0;
      0|    for (var word in originalLine.split(' ')) {
      0|      var wordLength = withoutColors(word).length;
      0|      if (wordLength > lineLength) {
      0|        if (lengthSoFar != 0) buffer.writeln();
      0|        buffer.writeln(word);
      0|      } else if (lengthSoFar == 0) {
      0|        buffer.write(word);
       |        lengthSoFar = wordLength;
      0|      } else if (lengthSoFar + 1 + wordLength > lineLength) {
      0|        buffer.writeln();
      0|        buffer.write(word);
       |        lengthSoFar = wordLength;
       |      } else {
      0|        buffer.write(' $word');
      0|        lengthSoFar += 1 + wordLength;
       |      }
       |    }
      0|    return buffer.toString();
      0|  }).join('\n');
       |}
       |
       |/// Print a warning containing [message].
       |///
       |/// This automatically wraps lines if they get too long. If [color] is passed,
       |/// it controls whether the warning header is color; otherwise, it defaults to
       |/// [canUseSpecialChars].
       |///
       |/// If [print] is `true`, this prints the message using [print] to associate it
       |/// with the current test. Otherwise, it prints it using [stderr].
      0|void warn(String message, {bool color, bool print = false}) {
      0|  color ??= canUseSpecialChars;
       |  var header = color ? '\u001b[33mWarning:\u001b[0m' : 'Warning:';
      0|  (print ? core.print : stderr.writeln)(wordWrap('$header $message\n'));
       |}
       |
       |/// Repeatedly finds a probably-unused port on localhost and passes it to
       |/// [tryPort] until it binds successfully.
       |///
       |/// [tryPort] should return a non-`null` value or a Future completing to a
       |/// non-`null` value once it binds successfully. This value will be returned
       |/// by [getUnusedPort] in turn.
       |///
       |/// This is necessary for ensuring that our port binding isn't flaky for
       |/// applications that don't print out the bound port.
      0|Future<T> getUnusedPort<T>(FutureOr<T> Function(int port) tryPort) async {
       |  T value;
      0|  await Future.doWhile(() async {
      0|    value = await tryPort(await getUnsafeUnusedPort());
       |    return value == null;
       |  });
       |  return value;
       |}
       |
       |/// Whether this computer supports binding to IPv6 addresses.
       |var _maySupportIPv6 = true;
       |
       |/// Returns a port that is probably, but not definitely, not in use.
       |///
       |/// This has a built-in race condition: another process may bind this port at
       |/// any time after this call has returned. If at all possible, callers should
       |/// use [getUnusedPort] instead.
      0|Future<int> getUnsafeUnusedPort() async {
       |  int port;
       |  if (_maySupportIPv6) {
       |    try {
      0|      final socket = await ServerSocket.bind(InternetAddress.loopbackIPv6, 0,
       |          v6Only: true);
      0|      port = socket.port;
      0|      await socket.close();
      0|    } on SocketException {
       |      _maySupportIPv6 = false;
       |    }
       |  }
       |  if (!_maySupportIPv6) {
      0|    final socket = await RawServerSocket.bind(InternetAddress.loopbackIPv4, 0);
      0|    port = socket.port;
      0|    await socket.close();
       |  }
       |  return port;
       |}
       |
       |/// Returns the full URL of the Chrome remote debugger for the main page.
       |///
       |/// This takes the [base] remote debugger URL (which points to a browser-wide
       |/// page) and uses its JSON API to find the resolved URL for debugging the host
       |/// page.
      0|Future<Uri> getRemoteDebuggerUrl(Uri base) async {
       |  try {
      0|    var client = HttpClient();
      0|    var request = await client.getUrl(base.resolve('/json/list'));
      0|    var response = await request.close();
       |    var jsonObject =
      0|        await json.fuse(utf8).decoder.bind(response).single as List;
      0|    return base.resolve(jsonObject.first['devtoolsFrontendUrl'] as String);
       |  } catch (_) {
       |    // If we fail to talk to the remote debugger protocol, give up and return
       |    // the raw URL rather than crashing.
       |    return base;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/package_config.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A package configuration is a way to assign file paths to package URIs,
       |/// and vice-versa,
       |library package_config.package_config_discovery;
       |
       |import "dart:io" show File, Directory;
       |import "dart:typed_data" show Uint8List;
       |
       |import "src/discovery.dart" as discover;
       |import "src/errors.dart" show throwError;
       |import "src/package_config.dart";
       |import "src/package_config_io.dart";
       |
       |export "package_config_types.dart";
       |
       |/// Reads a specific package configuration file.
       |///
       |/// The file must exist and be readable.
       |/// It must be either a valid `package_config.json` file
       |/// or a valid `.packages` file.
       |/// It is considered a `package_config.json` file if its first character
       |/// is a `{`.
       |///
       |/// If the file is a `.packages` file (the file name is `.packages`)
       |/// and [preferNewest] is true, the default, also checks if there is
       |/// a `.dart_tool/package_config.json` file next
       |/// to the original file, and if so, loads that instead.
       |/// If [preferNewest] is set to false, a directly specified `.packages` file
       |/// is loaded even if there is an available `package_config.json` file.
       |/// The caller can determine this from the [PackageConfig.version]
       |/// being 1 and look for a `package_config.json` file themselves.
       |///
       |/// If [onError] is provided, the configuration file parsing will report errors
       |/// by calling that function, and then try to recover.
       |/// The returned package configuration is a *best effort* attempt to create
       |/// a valid configuration from the invalid configuration file.
       |/// If no [onError] is provided, errors are thrown immediately.
      0|Future<PackageConfig> loadPackageConfig(File file,
       |        {bool preferNewest = true, void onError(Object error)}) =>
      0|    readAnyConfigFile(file, preferNewest, onError ?? throwError);
       |
       |/// Reads a specific package configuration URI.
       |///
       |/// The file of the URI must exist and be readable.
       |/// It must be either a valid `package_config.json` file
       |/// or a valid `.packages` file.
       |/// It is considered a `package_config.json` file if its first
       |/// non-whitespace character is a `{`.
       |///
       |/// If [preferNewest] is true, the default, and the file is a `.packages` file,
       |/// as determined by its file name being `.packages`,
       |/// first checks if there is a `.dart_tool/package_config.json` file
       |/// next to the original file, and if so, loads that instead.
       |/// The [file] *must not* be a `package:` URI.
       |/// If [preferNewest] is set to false, a directly specified `.packages` file
       |/// is loaded even if there is an available `package_config.json` file.
       |/// The caller can determine this from the [PackageConfig.version]
       |/// being 1 and look for a `package_config.json` file themselves.
       |///
       |/// If [loader] is provided, URIs are loaded using that function.
       |/// The future returned by the loader must complete with a [Uint8List]
       |/// containing the entire file content encoded as UTF-8,
       |/// or with `null` if the file does not exist.
       |/// The loader may throw at its own discretion, for situations where
       |/// it determines that an error might be need user attention,
       |/// but it is always allowed to return `null`.
       |/// This function makes no attempt to catch such errors.
       |/// As such, it may throw any error that [loader] throws.
       |///
       |/// If no [loader] is supplied, a default loader is used which
       |/// only accepts `file:`,  `http:` and `https:` URIs,
       |/// and which uses the platform file system and HTTP requests to
       |/// fetch file content. The default loader never throws because
       |/// of an I/O issue, as long as the location URIs are valid.
       |/// As such, it does not distinguish between a file not existing,
       |/// and it being temporarily locked or unreachable.
       |///
       |/// If [onError] is provided, the configuration file parsing will report errors
       |/// by calling that function, and then try to recover.
       |/// The returned package configuration is a *best effort* attempt to create
       |/// a valid configuration from the invalid configuration file.
       |/// If no [onError] is provided, errors are thrown immediately.
      0|Future<PackageConfig> loadPackageConfigUri(Uri file,
       |        {Future<Uint8List /*?*/ > loader(Uri uri) /*?*/,
       |        bool preferNewest = true,
       |        void onError(Object error)}) =>
      0|    readAnyConfigFileUri(file, loader, onError ?? throwError, preferNewest);
       |
       |/// Finds a package configuration relative to [directory].
       |///
       |/// If [directory] contains a package configuration,
       |/// either a `.dart_tool/package_config.json` file or,
       |/// if not, a `.packages`, then that file is loaded.
       |///
       |/// If no file is found in the current directory,
       |/// then the parent directories are checked recursively,
       |/// all the way to the root directory, to check if those contains
       |/// a package configuration.
       |/// If [recurse] is set to [false], this parent directory check is not
       |/// performed.
       |///
       |/// If [onError] is provided, the configuration file parsing will report errors
       |/// by calling that function, and then try to recover.
       |/// The returned package configuration is a *best effort* attempt to create
       |/// a valid configuration from the invalid configuration file.
       |/// If no [onError] is provided, errors are thrown immediately.
       |///
       |/// Returns `null` if no configuration file is found.
      0|Future<PackageConfig> findPackageConfig(Directory directory,
       |        {bool recurse = true, void onError(Object error)}) =>
      0|    discover.findPackageConfig(directory, recurse, onError ?? throwError);
       |
       |/// Finds a package configuration relative to [location].
       |///
       |/// If [location] contains a package configuration,
       |/// either a `.dart_tool/package_config.json` file or,
       |/// if not, a `.packages`, then that file is loaded.
       |/// The [location] URI *must not* be a `package:` URI.
       |/// It should be a hierarchical URI which is supported
       |/// by [loader].
       |///
       |/// If no file is found in the current directory,
       |/// then the parent directories are checked recursively,
       |/// all the way to the root directory, to check if those contains
       |/// a package configuration.
       |/// If [recurse] is set to [false], this parent directory check is not
       |/// performed.
       |///
       |/// If [loader] is provided, URIs are loaded using that function.
       |/// The future returned by the loader must complete with a [Uint8List]
       |/// containing the entire file content,
       |/// or with `null` if the file does not exist.
       |/// The loader may throw at its own discretion, for situations where
       |/// it determines that an error might be need user attention,
       |/// but it is always allowed to return `null`.
       |/// This function makes no attempt to catch such errors.
       |///
       |/// If no [loader] is supplied, a default loader is used which
       |/// only accepts `file:`,  `http:` and `https:` URIs,
       |/// and which uses the platform file system and HTTP requests to
       |/// fetch file content. The default loader never throws because
       |/// of an I/O issue, as long as the location URIs are valid.
       |/// As such, it does not distinguish between a file not existing,
       |/// and it being temporarily locked or unreachable.
       |///
       |/// If [onError] is provided, the configuration file parsing will report errors
       |/// by calling that function, and then try to recover.
       |/// The returned package configuration is a *best effort* attempt to create
       |/// a valid configuration from the invalid configuration file.
       |/// If no [onError] is provided, errors are thrown immediately.
       |///
       |/// Returns `null` if no configuration file is found.
      0|Future<PackageConfig> findPackageConfigUri(Uri location,
       |        {bool recurse = true,
       |        Future<Uint8List /*?*/ > loader(Uri uri),
       |        void onError(Object error)}) =>
      0|    discover.findPackageConfigUri(
       |        location, loader, onError ?? throwError, recurse);
       |
       |/// Writes a package configuration to the provided directory.
       |///
       |/// Writes `.dart_tool/package_config.json` relative to [directory].
       |/// If the `.dart_tool/` directory does not exist, it is created.
       |/// If it cannot be created, this operation fails.
       |///
       |/// Also writes a `.packages` file in [directory].
       |/// This will stop happening eventually as the `.packages` file becomes
       |/// discontinued.
       |/// A comment is generated if `[PackageConfig.extraData]` contains a
       |/// `"generator"` entry.
      0|Future<void> savePackageConfig(
       |        PackageConfig configuration, Directory directory) =>
      0|    writePackageConfigJsonFile(configuration, directory);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/discovery.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:io";
       |import 'dart:typed_data';
       |
       |import 'package_config_io.dart';
       |
       |import "errors.dart";
       |import "package_config_impl.dart";
       |import "package_config_json.dart";
       |import "packages_file.dart" as packages_file;
       |import "util_io.dart" show defaultLoader, pathJoin;
       |
      0|final Uri packageConfigJsonPath = Uri(path: ".dart_tool/package_config.json");
      0|final Uri dotPackagesPath = Uri(path: ".packages");
      0|final Uri currentPath = Uri(path: ".");
      0|final Uri parentPath = Uri(path: "..");
       |
       |/// Discover the package configuration for a Dart script.
       |///
       |/// The [baseDirectory] points to the directory of the Dart script.
       |/// A package resolution strategy is found by going through the following steps,
       |/// and stopping when something is found.
       |///
       |/// * Check if a `.dart_tool/package_config.json` file exists in the directory.
       |/// * Check if a `.packages` file exists in the directory.
       |/// * Repeat these checks for the parent directories until reaching the
       |///   root directory if [recursive] is true.
       |///
       |/// If any of these tests succeed, a `PackageConfig` class is returned.
       |/// Returns `null` if no configuration was found. If a configuration
       |/// is needed, then the caller can supply [PackageConfig.empty].
      0|Future<PackageConfig /*?*/ > findPackageConfig(
       |    Directory baseDirectory, bool recursive, void onError(Object error)) async {
       |  var directory = baseDirectory;
      0|  if (!directory.isAbsolute) directory = directory.absolute;
      0|  if (!await directory.exists()) {
       |    return null;
       |  }
       |  do {
       |    // Check for $cwd/.packages
      0|    var packageConfig = await findPackagConfigInDirectory(directory, onError);
       |    if (packageConfig != null) return packageConfig;
       |    if (!recursive) break;
       |    // Check in parent directories.
      0|    var parentDirectory = directory.parent;
      0|    if (parentDirectory.path == directory.path) break;
       |    directory = parentDirectory;
       |  } while (true);
       |  return null;
       |}
       |
       |/// Similar to [findPackageConfig] but based on a URI.
      0|Future<PackageConfig /*?*/ > findPackageConfigUri(
       |    Uri location,
       |    Future<Uint8List /*?*/ > loader(Uri uri) /*?*/,
       |    void onError(Object error) /*?*/,
       |    bool recursive) async {
      0|  if (location.isScheme("package")) {
      0|    onError(PackageConfigArgumentError(
       |        location, "location", "Must not be a package: URI"));
       |    return null;
       |  }
       |  if (loader == null) {
      0|    if (location.isScheme("file")) {
      0|      return findPackageConfig(
      0|          Directory.fromUri(location.resolveUri(currentPath)),
       |          recursive,
       |          onError);
       |    }
       |    loader = defaultLoader;
       |  }
      0|  if (!location.path.endsWith("/")) location = location.resolveUri(currentPath);
       |  while (true) {
      0|    var file = location.resolveUri(packageConfigJsonPath);
      0|    var bytes = await loader(file);
       |    if (bytes != null) {
      0|      return parsePackageConfigBytes(bytes, file, onError);
       |    }
      0|    file = location.resolveUri(dotPackagesPath);
      0|    bytes = await loader(file);
       |    if (bytes != null) {
      0|      return packages_file.parse(bytes, file, onError);
       |    }
       |    if (!recursive) break;
      0|    var parent = location.resolveUri(parentPath);
      0|    if (parent == location) break;
       |    location = parent;
       |  }
       |  return null;
       |}
       |
       |/// Finds a `.packages` or `.dart_tool/package_config.json` file in [directory].
       |///
       |/// Loads the file, if it is there, and returns the resulting [PackageConfig].
       |/// Returns `null` if the file isn't there.
       |/// Reports a [FormatException] if a file is there but the content is not valid.
       |/// If the file exists, but fails to be read, the file system error is reported.
       |///
       |/// If [onError] is supplied, parsing errors are reported using that, and
       |/// a best-effort attempt is made to return a package configuration.
       |/// This may be the empty package configuration.
      0|Future<PackageConfig /*?*/ > findPackagConfigInDirectory(
       |    Directory directory, void onError(Object error)) async {
      0|  var packageConfigFile = await checkForPackageConfigJsonFile(directory);
       |  if (packageConfigFile != null) {
      0|    return await readPackageConfigJsonFile(packageConfigFile, onError);
       |  }
      0|  packageConfigFile = await checkForDotPackagesFile(directory);
       |  if (packageConfigFile != null) {
      0|    return await readDotPackagesFile(packageConfigFile, onError);
       |  }
       |  return null;
       |}
       |
      0|Future<File> /*?*/ checkForPackageConfigJsonFile(Directory directory) async {
       |  assert(directory.isAbsolute);
       |  var file =
      0|      File(pathJoin(directory.path, ".dart_tool", "package_config.json"));
      0|  if (await file.exists()) return file;
       |  return null;
       |}
       |
      0|Future<File /*?*/ > checkForDotPackagesFile(Directory directory) async {
      0|  var file = File(pathJoin(directory.path, ".packages"));
      0|  if (await file.exists()) return file;
       |  return null;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/errors.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// General superclass of most errors and exceptions thrown by this package.
       |///
       |/// Only covers errors thrown while parsing package configuration files.
       |/// Programming errors and I/O exceptions are not covered.
       |abstract class PackageConfigError {
      0|  PackageConfigError._();
       |}
       |
       |class PackageConfigArgumentError extends ArgumentError
       |    implements PackageConfigError {
      0|  PackageConfigArgumentError(Object /*?*/ value, String name, String message)
      0|      : super.value(value, name, message);
       |
      0|  PackageConfigArgumentError.from(ArgumentError error)
      0|      : super.value(error.invalidValue, error.name, error.message);
       |}
       |
       |class PackageConfigFormatException extends FormatException
       |    implements PackageConfigError {
      0|  PackageConfigFormatException(String message, Object /*?*/ source,
       |      [int /*?*/ offset])
      0|      : super(message, source, offset);
       |
      0|  PackageConfigFormatException.from(FormatException exception)
      0|      : super(exception.message, exception.source, exception.offset);
       |}
       |
       |/// The default `onError` handler.
      0|void /*Never*/ throwError(Object error) => throw error;
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/package_config.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:typed_data';
       |
       |import 'errors.dart';
       |import "package_config_impl.dart";
       |import 'package_config_json.dart';
       |
       |/// A package configuration.
       |///
       |/// Associates configuration data to packages and files in packages.
       |///
       |/// More members may be added to this class in the future,
       |/// so classes outside of this package must not implement [PackageConfig]
       |/// or any subclass of it.
       |abstract class PackageConfig {
       |  /// The largest configuration version currently recognized.
       |  static const int maxVersion = 2;
       |
       |  /// An empty package configuration.
       |  ///
       |  /// A package configuration with no available packages.
       |  /// Is used as a default value where a package configuration
       |  /// is expected, but none have been specified or found.
       |  static const PackageConfig empty = SimplePackageConfig.empty();
       |
       |  /// Creats a package configuration with the provided available [packages].
       |  ///
       |  /// The packages must be valid packages (valid package name, valid
       |  /// absolute directory URIs, valid language version, if any),
       |  /// and there must not be two packages with the same name.
       |  ///
       |  /// The package's root ([Package.rootUri]) and package-root
       |  /// ([Package.packageUriRoot]) paths must satisfy a number of constraints
       |  /// We say that one path (which we know ends with a `/` charater)
       |  /// is inside another path, if the latter path is a prefix of the former path,
       |  /// including the two paths being the same.
       |  ///
       |  /// * No package's root must be the same as another package's root.
       |  /// * The package-root of a package must be inside the pacakge's root.
       |  /// * If one package's package-root is inside another package's root,
       |  ///   then the latter package's package root must not be inside the former
       |  ///   package's root. (No getting between a package and its package root!)
       |  ///   This also disallows a package's root being the same as another
       |  ///   package's package root.
       |  ///
       |  /// If supplied, the [extraData] will be available as the
       |  /// [PackageConfig.extraData] of the created configuration.
       |  ///
       |  /// The version of the resulting configuration is always [maxVersion].
      0|  factory PackageConfig(Iterable<Package> packages, {dynamic extraData}) =>
      0|      SimplePackageConfig(maxVersion, packages, extraData);
       |
       |  /// Parses a package configuration file.
       |  ///
       |  /// The [bytes] must be an UTF-8 encoded JSON object
       |  /// containing a valid package configuration.
       |  ///
       |  /// The [baseUri] is used as the base for resolving relative
       |  /// URI references in the configuration file. If the configuration
       |  /// has been read from a file, the [baseUri] can be the URI of that
       |  /// file, or of the directory it occurs in.
       |  ///
       |  /// If [onError] is provided, errors found during parsing or building
       |  /// the configuration are reported by calling [onError] instead of
       |  /// throwing, and parser makes a *best effort* attempt to continue
       |  /// despite the error. The input must still be valid JSON.
       |  /// The result may be a [PackageConfig.empty] if there is no way to
       |  /// extract useful information from the bytes.
      0|  static PackageConfig parseBytes(Uint8List bytes, Uri baseUri,
       |          {void onError(Object error)}) =>
      0|      parsePackageConfigBytes(bytes, baseUri, onError ?? throwError);
       |
       |  /// Parses a package configuration file.
       |  ///
       |  /// The [configuration] must be a JSON object
       |  /// containing a valid package configuration.
       |  ///
       |  /// The [baseUri] is used as the base for resolving relative
       |  /// URI references in the configuration file. If the configuration
       |  /// has been read from a file, the [baseUri] can be the URI of that
       |  /// file, or of the directory it occurs in.
       |  ///
       |  /// If [onError] is provided, errors found during parsing or building
       |  /// the configuration are reported by calling [onError] instead of
       |  /// throwing, and parser makes a *best effort* attempt to continue
       |  /// despite the error. The input must still be valid JSON.
       |  /// The result may be a [PackageConfig.empty] if there is no way to
       |  /// extract useful information from the bytes.
      0|  static PackageConfig parseString(String configuration, Uri baseUri,
       |          {void onError(Object error)}) =>
      0|      parsePackageConfigString(configuration, baseUri, onError ?? throwError);
       |
       |  /// Parses the JSON data of a package configuration file.
       |  ///
       |  /// The [configuration] must be a JSON-like Dart data structure,
       |  /// like the one provided by parsing JSON text using `dart:convert`,
       |  /// containing a valid package configuration.
       |  ///
       |  /// The [baseUri] is used as the base for resolving relative
       |  /// URI references in the configuration file. If the configuration
       |  /// has been read from a file, the [baseUri] can be the URI of that
       |  /// file, or of the directory it occurs in.
       |  ///
       |  /// If [onError] is provided, errors found during parsing or building
       |  /// the configuration are reported by calling [onError] instead of
       |  /// throwing, and parser makes a *best effort* attempt to continue
       |  /// despite the error. The input must still be valid JSON.
       |  /// The result may be a [PackageConfig.empty] if there is no way to
       |  /// extract useful information from the bytes.
      0|  static PackageConfig parseJson(dynamic jsonData, Uri baseUri,
       |          {void onError(Object error)}) =>
      0|      parsePackageConfigJson(jsonData, baseUri, onError ?? throwError);
       |
       |  /// Writes a configuration file for this configuration on [output].
       |  ///
       |  /// If [baseUri] is provided, URI references in the generated file
       |  /// will be made relative to [baseUri] where possible.
      0|  static void writeBytes(PackageConfig configuration, Sink<Uint8List> output,
       |      [Uri /*?*/ baseUri]) {
      0|    writePackageConfigJsonUtf8(configuration, baseUri, output);
       |  }
       |
       |  /// Writes a configuration JSON text for this configuration on [output].
       |  ///
       |  /// If [baseUri] is provided, URI references in the generated file
       |  /// will be made relative to [baseUri] where possible.
      0|  static void writeString(PackageConfig configuration, StringSink output,
       |      [Uri /*?*/ baseUri]) {
      0|    writePackageConfigJsonString(configuration, baseUri, output);
       |  }
       |
       |  /// Converts a configuration to a JSON-like data structure.
       |  ///
       |  /// If [baseUri] is provided, URI references in the generated data
       |  /// will be made relative to [baseUri] where possible.
      0|  static Map<String, dynamic> toJson(PackageConfig configuration,
       |          [Uri /*?*/ baseUri]) =>
      0|      packageConfigToJson(configuration, baseUri);
       |
       |  /// The configuration version number.
       |  ///
       |  /// Currently this is 1 or 2, where
       |  /// * Version one is the `.packages` file format and
       |  /// * Version two is the first `package_config.json` format.
       |  ///
       |  /// Instances of this class supports both, and the version
       |  /// is only useful for detecting which kind of file the configuration
       |  /// was read from.
       |  int get version;
       |
       |  /// All the available packages of this configuration.
       |  ///
       |  /// No two of these packages have the same name,
       |  /// and no two [Package.root] directories overlap.
       |  Iterable<Package> get packages;
       |
       |  /// Look up a package by name.
       |  ///
       |  /// Returns the [Package] fron [packages] with [packageName] as
       |  /// [Package.name]. Returns `null` if the package is not available in the
       |  /// current configuration.
       |  Package /*?*/ operator [](String packageName);
       |
       |  /// Provides the associated package for a specific [file] (or directory).
       |  ///
       |  /// Returns a [Package] which contains the [file]'s path, if any.
       |  /// That is, the [Package.rootUri] directory is a parent directory
       |  /// of the [file]'s location.
       |  ///
       |  /// Returns `null` if the file does not belong to any package.
       |  Package /*?*/ packageOf(Uri file);
       |
       |  /// Resolves a `package:` URI to a non-package URI
       |  ///
       |  /// The [packageUri] must be a valid package URI. That means:
       |  /// * A URI with `package` as scheme,
       |  /// * with no authority part (`package://...`),
       |  /// * with a path starting with a valid package name followed by a slash, and
       |  /// * with no query or fragment part.
       |  ///
       |  /// Throws an [ArgumentError] (which also implements [PackageConfigError])
       |  /// if the package URI is not valid.
       |  ///
       |  /// Returns `null` if the package name of [packageUri] is not available
       |  /// in this package configuration.
       |  /// Returns the remaining path of the package URI resolved relative to the
       |  /// [Package.packageUriRoot] of the corresponding package.
       |  Uri /*?*/ resolve(Uri packageUri);
       |
       |  /// The package URI which resolves to [nonPackageUri].
       |  ///
       |  /// The [nonPackageUri] must not have any query or fragment part,
       |  /// and it must not have `package` as scheme.
       |  /// Throws an [ArgumentError] (which also implements [PackageConfigError])
       |  /// if the non-package URI is not valid.
       |  ///
       |  /// Returns a package URI which [resolve] will convert to [nonPackageUri],
       |  /// if any such URI exists. Returns `null` if no such package URI exists.
       |  Uri /*?*/ toPackageUri(Uri nonPackageUri);
       |
       |  /// Extra data associated with the package configuration.
       |  ///
       |  /// The data may be in any format, depending on who introduced it.
       |  /// The standard `packjage_config.json` file storage will only store
       |  /// JSON-like list/map data structures.
       |  dynamic get extraData;
       |}
       |
       |/// Configuration data for a single package.
       |abstract class Package {
       |  /// Creates a package with the provided properties.
       |  ///
       |  /// The [name] must be a valid package name.
       |  /// The [root] must be an absolute directory URI, meaning an absolute URI
       |  /// with no query or fragment path and a path starting and ending with `/`.
       |  /// The [packageUriRoot], if provided, must be either an absolute
       |  /// directory URI or a relative URI reference which is then resolved
       |  /// relative to [root]. It must then also be a subdirectory of [root],
       |  /// or the same directory, and must end with `/`.
       |  /// If [languageVersion] is supplied, it must be a valid Dart language
       |  /// version, which means two decimal integer literals separated by a `.`,
       |  /// where the integer literals have no leading zeros unless they are
       |  /// a single zero digit.
       |  /// If [extraData] is supplied, it will be available as the
       |  /// [Package.extraData] of the created package.
      0|  factory Package(String name, Uri root,
       |          {Uri /*?*/ packageUriRoot,
       |          LanguageVersion /*?*/ languageVersion,
       |          dynamic extraData}) =>
      0|      SimplePackage.validate(
       |          name, root, packageUriRoot, languageVersion, extraData, throwError);
       |
       |  /// The package-name of the package.
       |  String get name;
       |
       |  /// The location of the root of the package.
       |  ///
       |  /// Is always an absolute URI with no query or fragment parts,
       |  /// and with a path ending in `/`.
       |  ///
       |  /// All files in the [rootUri] directory are considered
       |  /// part of the package for purposes where that that matters.
       |  Uri get root;
       |
       |  /// The root of the files available through `package:` URIs.
       |  ///
       |  /// A `package:` URI with [name] as the package name is
       |  /// resolved relative to this location.
       |  ///
       |  /// Is always an absolute URI with no query or fragment part
       |  /// with a path ending in `/`,
       |  /// and with a location which is a subdirectory
       |  /// of the [root], or the same as the [root].
       |  Uri get packageUriRoot;
       |
       |  /// The default language version associated with this package.
       |  ///
       |  /// Each package may have a default language version associated,
       |  /// which is the language version used to parse and compile
       |  /// Dart files in the package.
       |  /// A package version is defined by two non-negative numbers,
       |  /// the *major* and *minor* version numbers.
       |  LanguageVersion /*?*/ get languageVersion;
       |
       |  /// Extra data associated with the specific package.
       |  ///
       |  /// The data may be in any format, depending on who introduced it.
       |  /// The standard `packjage_config.json` file storage will only store
       |  /// JSON-like list/map data structures.
       |  dynamic get extraData;
       |}
       |
       |/// A language version.
       |///
       |/// A language version is represented by two non-negative integers,
       |/// the [major] and [minor] version numbers.
       |///
       |/// If errors during parsing are handled using an `onError` handler,
       |/// then an *invalid* language version may be represented by an
       |/// [InvalidLanguageVersion] object.
       |abstract class LanguageVersion implements Comparable<LanguageVersion> {
       |  /// The maximal value allowed by [major] and [minor] values;
       |  static const int maxValue = 0x7FFFFFFF;
      0|  factory LanguageVersion(int major, int minor) {
      0|    RangeError.checkValueInInterval(major, 0, maxValue, "major");
      0|    RangeError.checkValueInInterval(minor, 0, maxValue, "major");
      0|    return SimpleLanguageVersion(major, minor, null);
       |  }
       |
       |  /// Parses a language version string.
       |  ///
       |  /// A valid language version string has the form
       |  ///
       |  /// > *decimalNumber* `.` *decimalNumber*
       |  ///
       |  /// where a *decimalNumber* is a non-empty sequence of decimal digits
       |  /// with no unnecessary leading zeros (the decimal number only starts
       |  /// with a zero digit if that digit is the entire number).
       |  /// No spaces are allowed in the string.
       |  ///
       |  /// If the [source] is valid then it is parsed into a valid
       |  /// [LanguageVersion] object.
       |  /// If not, then the [onError] is called with a [FormatException].
       |  /// If [onError] is not supplied, it defaults to throwing the exception.
       |  /// If the call does not throw, then an [InvalidLanguageVersion] is returned
       |  /// containing the original [source].
      0|  static LanguageVersion parse(String source, {void onError(Object error)}) =>
      0|      parseLanguageVersion(source, onError ?? throwError);
       |
       |  /// The major language version.
       |  ///
       |  /// A non-negative integer less than 2<sup>31</sup>.
       |  ///
       |  /// The value is negative for objects representing *invalid* language
       |  /// versions ([InvalidLanguageVersion]).
       |  int get major;
       |
       |  /// The minor language version.
       |  ///
       |  /// A non-negative integer less than 2<sup>31</sup>.
       |  ///
       |  /// The value is negative for objects representing *invalid* language
       |  /// versions ([InvalidLanguageVersion]).
       |  int get minor;
       |
       |  /// Compares language versions.
       |  ///
       |  /// Two language versions are considered equal if they have the
       |  /// same major and minor version numbers.
       |  ///
       |  /// A language version is greater then another if the former's major version
       |  /// is greater than the latter's major version, or if they have
       |  /// the same major version and the former's minor version is greater than
       |  /// the latter's.
       |  int compareTo(LanguageVersion other);
       |
       |  /// Valid language versions with the same [major] and [minor] values are
       |  /// equal.
       |  ///
       |  /// Invalid language versions ([InvalidLanguageVersion]) are not equal to
       |  /// any other object.
       |  bool operator ==(Object other);
       |
       |  int get hashCode;
       |
       |  /// A string representation of the language version.
       |  ///
       |  /// A valid language version is represented as
       |  /// `"${version.major}.${version.minor}"`.
       |  String toString();
       |}
       |
       |/// An *invalid* language version.
       |///
       |/// Stored in a [Package] when the orginal language version string
       |/// was invalid and a `onError` handler was passed to the parser
       |/// which did not throw on an error.
       |abstract class InvalidLanguageVersion implements LanguageVersion {
       |  /// The value -1 for an invalid language version.
       |  int get major;
       |
       |  /// The value -1 for an invalid language version.
       |  int get minor;
       |
       |  /// An invalid language version is only equal to itself.
       |  bool operator ==(Object other);
       |
       |  int get hashCode;
       |
       |  /// The original invalid version string.
       |  String toString();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/package_config_io.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// dart:io dependent functionality for reading and writing configuration files.
       |
       |import "dart:convert";
       |import "dart:io";
       |import "dart:typed_data";
       |
       |import "discovery.dart" show packageConfigJsonPath;
       |import "errors.dart";
       |import "package_config_impl.dart";
       |import "package_config_json.dart";
       |import "packages_file.dart" as packages_file;
       |import "util.dart";
       |import "util_io.dart";
       |
       |/// Reads a package configuration file.
       |///
       |/// Detects whether the [file] is a version one `.packages` file or
       |/// a version two `package_config.json` file.
       |///
       |/// If the [file] is a `.packages` file and [preferNewest] is true,
       |/// first checks whether there is an adjacent `.dart_tool/package_config.json`
       |/// file, and if so, reads that instead.
       |/// If [preferNewset] is false, the specified file is loaded even if it is
       |/// a `.packages` file and there is an available `package_config.json` file.
       |///
       |/// The file must exist and be a normal file.
      0|Future<PackageConfig> readAnyConfigFile(
       |    File file, bool preferNewest, void onError(Object error)) async {
      0|  if (preferNewest && fileName(file.path) == ".packages") {
       |    var alternateFile =
      0|        File(pathJoin(dirName(file.path), ".dart_tool", "package_config.json"));
      0|    if (alternateFile.existsSync()) {
      0|      return await readPackageConfigJsonFile(alternateFile, onError);
       |    }
       |  }
       |  Uint8List bytes;
       |  try {
      0|    bytes = await file.readAsBytes();
       |  } catch (e) {
      0|    onError(e);
       |    return const SimplePackageConfig.empty();
       |  }
      0|  return parseAnyConfigFile(bytes, file.uri, onError);
       |}
       |
       |/// Like [readAnyConfigFile] but uses a URI and an optional loader.
      0|Future<PackageConfig> readAnyConfigFileUri(
       |    Uri file,
       |    Future<Uint8List /*?*/ > loader(Uri uri) /*?*/,
       |    void onError(Object error),
       |    bool preferNewest) async {
      0|  if (file.isScheme("package")) {
      0|    throw PackageConfigArgumentError(
       |        file, "file", "Must not be a package: URI");
       |  }
       |  if (loader == null) {
      0|    if (file.isScheme("file")) {
      0|      return await readAnyConfigFile(File.fromUri(file), preferNewest, onError);
       |    }
       |    loader = defaultLoader;
       |  }
      0|  if (preferNewest && file.pathSegments.last == ".packages") {
      0|    var alternateFile = file.resolve(".dart_tool/package_config.json");
       |    Uint8List /*?*/ bytes;
       |    try {
      0|      bytes = await loader(alternateFile);
       |    } catch (e) {
      0|      onError(e);
       |      return const SimplePackageConfig.empty();
       |    }
       |    if (bytes != null) {
      0|      return parsePackageConfigBytes(bytes, alternateFile, onError);
       |    }
       |  }
       |  Uint8List /*?*/ bytes;
       |  try {
      0|    bytes = await loader(file);
       |  } catch (e) {
      0|    onError(e);
       |    return const SimplePackageConfig.empty();
       |  }
       |  if (bytes == null) {
      0|    onError(PackageConfigArgumentError(
      0|        file.toString(), "file", "File cannot be read"));
       |    return const SimplePackageConfig.empty();
       |  }
      0|  return parseAnyConfigFile(bytes, file, onError);
       |}
       |
       |/// Parses a `.packages` or `package_config.json` file's contents.
       |///
       |/// Assumes it's a JSON file if the first non-whitespace character
       |/// is `{`, otherwise assumes it's a `.packages` file.
      0|PackageConfig parseAnyConfigFile(
       |    Uint8List bytes, Uri file, void onError(Object error)) {
      0|  var firstChar = firstNonWhitespaceChar(bytes);
      0|  if (firstChar != $lbrace) {
       |    // Definitely not a JSON object, probably a .packages.
      0|    return packages_file.parse(bytes, file, onError);
       |  }
      0|  return parsePackageConfigBytes(bytes, file, onError);
       |}
       |
      0|Future<PackageConfig> readPackageConfigJsonFile(
       |    File file, void onError(Object error)) async {
       |  Uint8List bytes;
       |  try {
      0|    bytes = await file.readAsBytes();
       |  } catch (error) {
      0|    onError(error);
       |    return const SimplePackageConfig.empty();
       |  }
      0|  return parsePackageConfigBytes(bytes, file.uri, onError);
       |}
       |
      0|Future<PackageConfig> readDotPackagesFile(
       |    File file, void onError(Object error)) async {
       |  Uint8List bytes;
       |  try {
      0|    bytes = await file.readAsBytes();
       |  } catch (error) {
      0|    onError(error);
       |    return const SimplePackageConfig.empty();
       |  }
      0|  return packages_file.parse(bytes, file.uri, onError);
       |}
       |
      0|Future<void> writePackageConfigJsonFile(
       |    PackageConfig config, Directory targetDirectory) async {
       |  // Write .dart_tool/package_config.json first.
       |  var file =
      0|      File(pathJoin(targetDirectory.path, ".dart_tool", "package_config.json"));
      0|  var baseUri = file.uri;
      0|  var sink = file.openWrite(encoding: utf8);
      0|  writePackageConfigJsonUtf8(config, baseUri, sink);
      0|  var doneJson = sink.close();
       |
       |  // Write .packages too.
      0|  file = File(pathJoin(targetDirectory.path, ".packages"));
      0|  baseUri = file.uri;
      0|  sink = file.openWrite(encoding: utf8);
      0|  writeDotPackages(config, baseUri, sink);
      0|  var donePackages = sink.close();
       |
      0|  await Future.wait([doneJson, donePackages]);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/package_config_impl.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'errors.dart';
       |import "package_config.dart";
       |import "util.dart";
       |
       |export "package_config.dart";
       |
       |// Implementations of the main data types exposed by the API of this package.
       |
       |class SimplePackageConfig implements PackageConfig {
       |  final int version;
       |  final Map<String, Package> _packages;
       |  final PackageTree _packageTree;
       |  final dynamic extraData;
       |
      0|  factory SimplePackageConfig(int version, Iterable<Package> packages,
       |      [dynamic extraData, void onError(Object error)]) {
       |    onError ??= throwError;
      0|    var validVersion = _validateVersion(version, onError);
      0|    var sortedPackages = [...packages]..sort(_compareRoot);
      0|    var packageTree = _validatePackages(packages, sortedPackages, onError);
      0|    return SimplePackageConfig._(validVersion, packageTree,
      0|        {for (var p in packageTree.allPackages) p.name: p}, extraData);
       |  }
       |
      0|  SimplePackageConfig._(
       |      this.version, this._packageTree, this._packages, this.extraData);
       |
       |  /// Creates empty configuration.
       |  ///
       |  /// The empty configuration can be used in cases where no configuration is
       |  /// found, but code expects a non-null configuration.
      0|  const SimplePackageConfig.empty()
       |      : version = 1,
       |        _packageTree = const EmptyPackageTree(),
       |        _packages = const <String, Package>{},
       |        extraData = null;
       |
      0|  static int _validateVersion(int version, void onError(Object error)) {
      0|    if (version < 0 || version > PackageConfig.maxVersion) {
      0|      onError(PackageConfigArgumentError(version, "version",
      0|          "Must be in the range 1 to ${PackageConfig.maxVersion}"));
       |      return 2; // The minimal version supporting a SimplePackageConfig.
       |    }
       |    return version;
       |  }
       |
      0|  static PackageTree _validatePackages(Iterable<Package> originalPackages,
       |      List<Package> packages, void onError(Object error)) {
       |    var packageNames = <String>{};
      0|    var tree = MutablePackageTree();
      0|    for (var originalPackage in packages) {
       |      if (originalPackage == null) {
      0|        onError(ArgumentError.notNull("element of packages"));
       |        continue;
       |      }
       |      SimplePackage package;
      0|      if (originalPackage is! SimplePackage) {
       |        // SimplePackage validates these properties.
      0|        package = SimplePackage.validate(
      0|            originalPackage.name,
      0|            originalPackage.root,
      0|            originalPackage.packageUriRoot,
      0|            originalPackage.languageVersion,
      0|            originalPackage.extraData, (error) {
      0|          if (error is PackageConfigArgumentError) {
      0|            onError(PackageConfigArgumentError(packages, "packages",
      0|                "Package ${package.name}: ${error.message}"));
       |          } else {
      0|            onError(error);
       |          }
       |        });
       |        if (package == null) continue;
       |      } else {
       |        package = originalPackage;
       |      }
      0|      var name = package.name;
      0|      if (packageNames.contains(name)) {
      0|        onError(PackageConfigArgumentError(
       |            name, "packages", "Duplicate package name"));
       |        continue;
       |      }
      0|      packageNames.add(name);
      0|      tree.add(0, package, (error) {
      0|        if (error is ConflictException) {
       |          // There is a conflict with an existing package.
      0|          var existingPackage = error.existingPackage;
      0|          if (error.isRootConflict) {
      0|            onError(PackageConfigArgumentError(
       |                originalPackages,
      0|                "packages",
      0|                "Packages ${package.name} and ${existingPackage.name} "
      0|                    "have the same root directory: ${package.root}.\n"));
       |          } else {
       |            assert(error.isPackageRootConflict);
       |            // Package is inside the package URI root of the existing package.
      0|            onError(PackageConfigArgumentError(
       |                originalPackages,
      0|                "packages",
      0|                "Package ${package.name} is inside the package URI root of "
      0|                    "package ${existingPackage.name}.\n"
      0|                    "${existingPackage.name} URI root: "
      0|                    "${existingPackage.packageUriRoot}\n"
      0|                    "${package.name} root: ${package.root}\n"));
       |          }
       |        } else {
       |          // Any other error.
      0|          onError(error);
       |        }
       |      });
       |    }
       |    return tree;
       |  }
       |
      0|  Iterable<Package> get packages => _packages.values;
       |
      0|  Package /*?*/ operator [](String packageName) => _packages[packageName];
       |
       |  /// Provides the associated package for a specific [file] (or directory).
       |  ///
       |  /// Returns a [Package] which contains the [file]'s path.
       |  /// That is, the [Package.rootUri] directory is a parent directory
       |  /// of the [file]'s location.
       |  /// Returns `null` if the file does not belong to any package.
      0|  Package /*?*/ packageOf(Uri file) => _packageTree.packageOf(file);
       |
      0|  Uri /*?*/ resolve(Uri packageUri) {
      0|    var packageName = checkValidPackageUri(packageUri, "packageUri");
      0|    return _packages[packageName]?.packageUriRoot?.resolveUri(
      0|        Uri(path: packageUri.path.substring(packageName.length + 1)));
       |  }
       |
      0|  Uri /*?*/ toPackageUri(Uri nonPackageUri) {
      0|    if (nonPackageUri.isScheme("package")) {
      0|      throw PackageConfigArgumentError(
       |          nonPackageUri, "nonPackageUri", "Must not be a package URI");
       |    }
      0|    if (nonPackageUri.hasQuery || nonPackageUri.hasFragment) {
      0|      throw PackageConfigArgumentError(nonPackageUri, "nonPackageUri",
       |          "Must not have query or fragment part");
       |    }
       |    // Find package that file belongs to.
      0|    var package = _packageTree.packageOf(nonPackageUri);
       |    if (package == null) return null;
       |    // Check if it is inside the package URI root.
      0|    var path = nonPackageUri.toString();
      0|    var root = package.packageUriRoot.toString();
      0|    if (_beginsWith(package.root.toString().length, root, path)) {
      0|      var rest = path.substring(root.length);
      0|      return Uri(scheme: "package", path: "${package.name}/$rest");
       |    }
       |    return null;
       |  }
       |}
       |
       |/// Configuration data for a single package.
       |class SimplePackage implements Package {
       |  final String name;
       |  final Uri root;
       |  final Uri packageUriRoot;
       |  final LanguageVersion /*?*/ languageVersion;
       |  final dynamic extraData;
       |
      0|  SimplePackage._(this.name, this.root, this.packageUriRoot,
       |      this.languageVersion, this.extraData);
       |
       |  /// Creates a [SimplePackage] with the provided content.
       |  ///
       |  /// The provided arguments must be valid.
       |  ///
       |  /// If the arguments are invalid then the error is reported by
       |  /// calling [onError], then the erroneous entry is ignored.
       |  ///
       |  /// If [onError] is provided, the user is expected to be able to handle
       |  /// errors themselves. An invalid [languageVersion] string
       |  /// will be replaced with the string `"invalid"`. This allows
       |  /// users to detect the difference between an absent version and
       |  /// an invalid one.
       |  ///
       |  /// Returns `null` if the input is invalid and an approximately valid package
       |  /// cannot be salvaged from the input.
      0|  static SimplePackage /*?*/ validate(
       |      String name,
       |      Uri root,
       |      Uri packageUriRoot,
       |      LanguageVersion /*?*/ languageVersion,
       |      dynamic extraData,
       |      void onError(Object error)) {
       |    var fatalError = false;
      0|    var invalidIndex = checkPackageName(name);
      0|    if (invalidIndex >= 0) {
      0|      onError(PackageConfigFormatException(
       |          "Not a valid package name", name, invalidIndex));
       |      fatalError = true;
       |    }
      0|    if (root.isScheme("package")) {
      0|      onError(PackageConfigArgumentError(
      0|          "$root", "root", "Must not be a package URI"));
       |      fatalError = true;
      0|    } else if (!isAbsoluteDirectoryUri(root)) {
      0|      onError(PackageConfigArgumentError(
      0|          "$root",
      0|          "root",
       |          "In package $name: Not an absolute URI with no query or fragment "
       |              "with a path ending in /"));
       |      // Try to recover. If the URI has a scheme,
       |      // then ensure that the path ends with `/`.
      0|      if (!root.hasScheme) {
       |        fatalError = true;
      0|      } else if (!root.path.endsWith("/")) {
      0|        root = root.replace(path: root.path + "/");
       |      }
       |    }
       |    if (packageUriRoot == null) {
       |      packageUriRoot = root;
       |    } else if (!fatalError) {
      0|      packageUriRoot = root.resolveUri(packageUriRoot);
      0|      if (!isAbsoluteDirectoryUri(packageUriRoot)) {
      0|        onError(PackageConfigArgumentError(
       |            packageUriRoot,
      0|            "packageUriRoot",
       |            "In package $name: Not an absolute URI with no query or fragment "
       |                "with a path ending in /"));
       |        packageUriRoot = root;
      0|      } else if (!isUriPrefix(root, packageUriRoot)) {
      0|        onError(PackageConfigArgumentError(packageUriRoot, "packageUriRoot",
       |            "The package URI root is not below the package root"));
       |        packageUriRoot = root;
       |      }
       |    }
       |    if (fatalError) return null;
      0|    return SimplePackage._(
       |        name, root, packageUriRoot, languageVersion, extraData);
       |  }
       |}
       |
       |/// Checks whether [version] is a valid Dart language version string.
       |///
       |/// The format is (as RegExp) `^(0|[1-9]\d+)\.(0|[1-9]\d+)$`.
       |///
       |/// Reports a format exception on [onError] if not, or if the numbers
       |/// are too large (at most 32-bit signed integers).
      0|LanguageVersion parseLanguageVersion(
       |    String source, void onError(Object error)) {
       |  var index = 0;
       |  // Reads a positive decimal numeral. Returns the value of the numeral,
       |  // or a negative number in case of an error.
       |  // Starts at [index] and increments the index to the position after
       |  // the numeral.
       |  // It is an error if the numeral value is greater than 0x7FFFFFFFF.
       |  // It is a recoverable error if the numeral starts with leading zeros.
      0|  int readNumeral() {
       |    const maxValue = 0x7FFFFFFF;
      0|    if (index == source.length) {
      0|      onError(PackageConfigFormatException("Missing number", source, index));
      0|      return -1;
       |    }
       |    var start = index;
       |
      0|    var char = source.codeUnitAt(index);
      0|    var digit = char ^ 0x30;
      0|    if (digit > 9) {
      0|      onError(PackageConfigFormatException("Missing number", source, index));
      0|      return -1;
       |    }
       |    var firstDigit = digit;
       |    var value = 0;
       |    do {
      0|      value = value * 10 + digit;
      0|      if (value > maxValue) {
      0|        onError(
      0|            PackageConfigFormatException("Number too large", source, start));
      0|        return -1;
       |      }
      0|      index++;
      0|      if (index == source.length) break;
      0|      char = source.codeUnitAt(index);
      0|      digit = char ^ 0x30;
      0|    } while (digit <= 9);
      0|    if (firstDigit == 0 && index > start + 1) {
      0|      onError(PackageConfigFormatException(
       |          "Leading zero not allowed", source, start));
       |    }
       |    return value;
       |  }
       |
      0|  var major = readNumeral();
      0|  if (major < 0) {
      0|    return SimpleInvalidLanguageVersion(source);
       |  }
      0|  if (index == source.length || source.codeUnitAt(index) != $dot) {
      0|    onError(PackageConfigFormatException("Missing '.'", source, index));
      0|    return SimpleInvalidLanguageVersion(source);
       |  }
      0|  index++;
      0|  var minor = readNumeral();
      0|  if (minor < 0) {
      0|    return SimpleInvalidLanguageVersion(source);
       |  }
      0|  if (index != source.length) {
      0|    onError(PackageConfigFormatException(
       |        "Unexpected trailing character", source, index));
      0|    return SimpleInvalidLanguageVersion(source);
       |  }
      0|  return SimpleLanguageVersion(major, minor, source);
       |}
       |
       |abstract class _SimpleLanguageVersionBase implements LanguageVersion {
      0|  int compareTo(LanguageVersion other) {
      0|    var result = major.compareTo(other.major);
      0|    if (result != 0) return result;
      0|    return minor.compareTo(other.minor);
       |  }
       |}
       |
       |class SimpleLanguageVersion extends _SimpleLanguageVersionBase {
       |  final int major;
       |  final int minor;
       |  String /*?*/ _source;
      0|  SimpleLanguageVersion(this.major, this.minor, this._source);
       |
      0|  bool operator ==(Object other) =>
      0|      other is LanguageVersion && major == other.major && minor == other.minor;
       |
      0|  int get hashCode => (major * 17 ^ minor * 37) & 0x3FFFFFFF;
       |
      0|  String toString() => _source ??= "$major.$minor";
       |}
       |
       |class SimpleInvalidLanguageVersion extends _SimpleLanguageVersionBase
       |    implements InvalidLanguageVersion {
       |  final String _source;
      0|  SimpleInvalidLanguageVersion(this._source);
      0|  int get major => -1;
      0|  int get minor => -1;
       |
      0|  String toString() => _source;
       |}
       |
       |abstract class PackageTree {
       |  Iterable<Package> get allPackages;
       |  SimplePackage /*?*/ packageOf(Uri file);
       |}
       |
       |/// Packages of a package configuration ordered by root path.
       |///
       |/// A package has a root path and a package root path, where the latter
       |/// contains the files exposed by `package:` URIs.
       |///
       |/// A package is said to be inside another package if the root path URI of
       |/// the latter is a prefix of the root path URI of the former.
       |///
       |/// No two packages of a package may have the same root path, so this
       |/// path prefix ordering defines a tree-like partial ordering on packages
       |/// of a configuration.
       |///
       |/// The package root path of a package must not be inside another package's
       |/// root path.
       |/// Entire other packages are allowed inside a package's root or
       |/// package root path.
       |///
       |/// The package tree contains an ordered mapping of unrelated packages
       |/// (represented by their name) to their immediately nested packages' names.
       |class MutablePackageTree implements PackageTree {
       |  /// A list of packages that are not nested inside each other.
       |  final List<SimplePackage> packages = [];
       |
       |  /// The tree of the immediately nested packages inside each package.
       |  ///
       |  /// Indexed by [Package.name].
       |  /// If a package has no nested packages (which is most often the case),
       |  /// there is no tree object associated with it.
       |  Map<String, MutablePackageTree /*?*/ > /*?*/ _packageChildren;
       |
       |  Iterable<Package> get allPackages sync* {
       |    for (var package in packages) yield package;
       |    if (_packageChildren != null) {
       |      for (var tree in _packageChildren.values) yield* tree.allPackages;
       |    }
       |  }
       |
       |  /// Tries to (add) `package` to the tree.
       |  ///
       |  /// Reports a [ConflictException] if the added package conflicts with an
       |  /// existing package.
       |  /// It conflicts if its root or package root is the same as another
       |  /// package's root or package root, or is between the two.
       |  ///
       |  /// If a conflict is detected between [package] and a previous package,
       |  /// then [onError] is called with a [ConflictException] object
       |  /// and the [package] is not added to the tree.
       |  ///
       |  /// The packages are added in order of their root path.
       |  /// It is never necessary to insert a node between two existing levels.
      0|  void add(int start, SimplePackage package, void onError(Object error)) {
      0|    var path = package.root.toString();
      0|    for (var treePackage in packages) {
       |      // Check is package is inside treePackage.
      0|      var treePackagePath = treePackage.root.toString();
       |      assert(treePackagePath.length > start);
       |      assert(path.startsWith(treePackagePath.substring(0, start)));
      0|      if (_beginsWith(start, treePackagePath, path)) {
       |        // Package *is* inside treePackage.
      0|        var treePackagePathLength = treePackagePath.length;
      0|        if (path.length == treePackagePathLength) {
       |          // Has same root. Do not add package.
      0|          onError(ConflictException.root(package, treePackage));
       |          return;
       |        }
      0|        var treePackageUriRoot = treePackage.packageUriRoot.toString();
      0|        if (_beginsWith(treePackagePathLength, path, treePackageUriRoot)) {
       |          // The treePackage's package root is inside package, which is inside
       |          // the treePackage. This is not allowed.
      0|          onError(ConflictException.packageRoot(package, treePackage));
       |          return;
       |        }
      0|        _treeOf(treePackage).add(treePackagePathLength, package, onError);
       |        return;
       |      }
       |    }
      0|    packages.add(package);
       |  }
       |
      0|  SimplePackage /*?*/ packageOf(Uri file) {
      0|    return findPackageOf(0, file.toString());
       |  }
       |
       |  /// Finds package containing [path] in this tree.
       |  ///
       |  /// Returns `null` if no such package is found.
       |  ///
       |  /// Assumes the first [start] characters of path agrees with all
       |  /// the packages at this level of the tree.
      0|  SimplePackage /*?*/ findPackageOf(int start, String path) {
      0|    for (var childPackage in packages) {
      0|      var childPath = childPackage.root.toString();
      0|      if (_beginsWith(start, childPath, path)) {
       |        // The [package] is inside [childPackage].
      0|        var childPathLength = childPath.length;
      0|        if (path.length == childPathLength) return childPackage;
      0|        var uriRoot = childPackage.packageUriRoot.toString();
       |        // Is [package] is inside the URI root of [childPackage].
      0|        if (uriRoot.length == childPathLength ||
      0|            _beginsWith(childPathLength, uriRoot, path)) {
       |          return childPackage;
       |        }
       |        // Otherwise add [package] as child of [childPackage].
       |        // TODO(lrn): When NNBD comes, convert to:
       |        // return _packageChildren?[childPackage.name]
       |        //     ?.packageOf(childPathLength, path) ?? childPackage;
      0|        if (_packageChildren == null) return childPackage;
      0|        var childTree = _packageChildren[childPackage.name];
       |        if (childTree == null) return childPackage;
      0|        return childTree.findPackageOf(childPathLength, path) ?? childPackage;
       |      }
       |    }
       |    return null;
       |  }
       |
       |  /// Returns the [PackageTree] of the children of [package].
       |  ///
       |  /// Ensures that the object is allocated if necessary.
      0|  MutablePackageTree _treeOf(SimplePackage package) {
      0|    var children = _packageChildren ??= {};
      0|    return children[package.name] ??= MutablePackageTree();
       |  }
       |}
       |
       |class EmptyPackageTree implements PackageTree {
      0|  const EmptyPackageTree();
       |
      0|  Iterable<Package> get allPackages => const Iterable<Package>.empty();
       |
      0|  SimplePackage packageOf(Uri file) => null;
       |}
       |
       |/// Checks whether [longerPath] begins with [parentPath].
       |///
       |/// Skips checking the [start] first characters which are assumed to
       |/// already have been matched.
      0|bool _beginsWith(int start, String parentPath, String longerPath) {
      0|  if (longerPath.length < parentPath.length) return false;
      0|  for (var i = start; i < parentPath.length; i++) {
      0|    if (longerPath.codeUnitAt(i) != parentPath.codeUnitAt(i)) return false;
       |  }
       |  return true;
       |}
       |
       |/// Conflict between packages added to the same configuration.
       |///
       |/// The [package] conflicts with [existingPackage] if it has
       |/// the same root path ([isRootConflict]) or the package URI root path
       |/// of [existingPackage] is inside the root path of [package]
       |/// ([isPackageRootConflict]).
       |class ConflictException {
       |  /// The existing package that [package] conflicts with.
       |  final SimplePackage existingPackage;
       |
       |  /// The package that could not be added without a conflict.
       |  final SimplePackage package;
       |
       |  /// Whether the conflict is with the package URI root of [existingPackage].
       |  final bool isPackageRootConflict;
       |
       |  /// Creates a root conflict between [package] and [existingPackage].
      0|  ConflictException.root(this.package, this.existingPackage)
       |      : isPackageRootConflict = false;
       |
       |  /// Creates a package root conflict between [package] and [existingPackage].
      0|  ConflictException.packageRoot(this.package, this.existingPackage)
       |      : isPackageRootConflict = true;
       |
       |  /// WHether the conflict is with the root URI of [existingPackage].
      0|  bool get isRootConflict => !isPackageRootConflict;
       |}
       |
       |/// Used for sorting packages by root path.
      0|int _compareRoot(Package p1, Package p2) =>
      0|    p1.root.toString().compareTo(p2.root.toString());
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/package_config_json.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |// Parsing and serialization of package configurations.
       |
       |import "dart:convert";
       |import "dart:typed_data";
       |
       |import "errors.dart";
       |import "package_config_impl.dart";
       |import "packages_file.dart" as packages_file;
       |import "util.dart";
       |
       |const String _configVersionKey = "configVersion";
       |const String _packagesKey = "packages";
       |const List<String> _topNames = [_configVersionKey, _packagesKey];
       |const String _nameKey = "name";
       |const String _rootUriKey = "rootUri";
       |const String _packageUriKey = "packageUri";
       |const String _languageVersionKey = "languageVersion";
       |const List<String> _packageNames = [
       |  _nameKey,
       |  _rootUriKey,
       |  _packageUriKey,
       |  _languageVersionKey
       |];
       |
       |const String _generatedKey = "generated";
       |const String _generatorKey = "generator";
       |const String _generatorVersionKey = "generatorVersion";
       |
      0|final _jsonUtf8Decoder = json.fuse(utf8).decoder;
       |
      0|PackageConfig parsePackageConfigBytes(
       |    Uint8List bytes, Uri file, void onError(Object error)) {
       |  // TODO(lrn): Make this simpler. Maybe parse directly from bytes.
       |  var jsonObject;
       |  try {
      0|    jsonObject = _jsonUtf8Decoder.convert(bytes);
      0|  } on FormatException catch (e) {
      0|    onError(PackageConfigFormatException.from(e));
       |    return const SimplePackageConfig.empty();
       |  }
      0|  return parsePackageConfigJson(jsonObject, file, onError);
       |}
       |
      0|PackageConfig parsePackageConfigString(
       |    String source, Uri file, void onError(Object error)) {
       |  var jsonObject;
       |  try {
      0|    jsonObject = jsonDecode(source);
      0|  } on FormatException catch (e) {
      0|    onError(PackageConfigFormatException.from(e));
       |    return const SimplePackageConfig.empty();
       |  }
      0|  return parsePackageConfigJson(jsonObject, file, onError);
       |}
       |
       |/// Creates a [PackageConfig] from a parsed JSON-like object structure.
       |///
       |/// The [json] argument must be a JSON object (`Map<String, dynamic>`)
       |/// containing a `"configVersion"` entry with an integer value in the range
       |/// 1 to [PackageConfig.maxVersion],
       |/// and with a `"packages"` entry which is a JSON array (`List<dynamic>`)
       |/// containing JSON objects which each has the following properties:
       |///
       |/// * `"name"`: The package name as a string.
       |/// * `"rootUri"`: The root of the package as a URI stored as a string.
       |/// * `"packageUri"`: Optionally the root of for `package:` URI resolution
       |///     for the package, as a relative URI below the root URI
       |///     stored as a string.
       |/// * `"languageVersion"`: Optionally a language version string which is a
       |///     an integer numeral, a decimal point (`.`) and another integer numeral,
       |///     where the integer numeral cannot have a sign, and can only have a
       |///     leading zero if the entire numeral is a single zero.
       |///
       |/// All other properties are stored in [extraData].
       |///
       |/// The [baseLocation] is used as base URI to resolve the "rootUri"
       |/// URI referencestring.
      0|PackageConfig parsePackageConfigJson(
       |    dynamic json, Uri baseLocation, void onError(Object error)) {
      0|  if (!baseLocation.hasScheme || baseLocation.isScheme("package")) {
      0|    throw PackageConfigArgumentError(baseLocation.toString(), "baseLocation",
       |        "Must be an absolute non-package: URI");
       |  }
       |
      0|  if (!baseLocation.path.endsWith("/")) {
      0|    baseLocation = baseLocation.resolveUri(Uri(path: "."));
       |  }
       |
      0|  String typeName<T>() {
      0|    if (0 is T) return "int";
      0|    if ("" is T) return "string";
      0|    if (const [] is T) return "array";
       |    return "object";
       |  }
       |
      0|  T checkType<T>(dynamic value, String name, [String /*?*/ packageName]) {
      0|    if (value is T) return value;
       |    // The only types we are called with are [int], [String], [List<dynamic>]
       |    // and Map<String, dynamic>. Recognize which to give a better error message.
      0|    var message =
      0|        "$name${packageName != null ? " of package $packageName" : ""}"
      0|        " is not a JSON ${typeName<T>()}";
      0|    onError(PackageConfigFormatException(message, value));
       |    return null;
       |  }
       |
      0|  Package /*?*/ parsePackage(Map<String, dynamic> entry) {
       |    String /*?*/ name;
       |    String /*?*/ rootUri;
       |    String /*?*/ packageUri;
       |    String /*?*/ languageVersion;
       |    Map<String, dynamic> /*?*/ extraData;
       |    var hasName = false;
       |    var hasRoot = false;
       |    var hasVersion = false;
      0|    entry.forEach((key, value) {
       |      switch (key) {
      0|        case _nameKey:
       |          hasName = true;
      0|          name = checkType<String>(value, _nameKey);
       |          break;
      0|        case _rootUriKey:
       |          hasRoot = true;
      0|          rootUri = checkType<String>(value, _rootUriKey, name);
       |          break;
      0|        case _packageUriKey:
      0|          packageUri = checkType<String>(value, _packageUriKey, name);
       |          break;
      0|        case _languageVersionKey:
       |          hasVersion = true;
      0|          languageVersion = checkType<String>(value, _languageVersionKey, name);
       |          break;
       |        default:
      0|          (extraData ??= {})[key] = value;
       |          break;
       |      }
       |    });
       |    if (!hasName) {
      0|      onError(PackageConfigFormatException("Missing name entry", entry));
       |    }
       |    if (!hasRoot) {
      0|      onError(PackageConfigFormatException("Missing rootUri entry", entry));
       |    }
       |    if (name == null || rootUri == null) return null;
      0|    var root = baseLocation.resolve(rootUri);
      0|    if (!root.path.endsWith("/")) root = root.replace(path: root.path + "/");
       |    var packageRoot = root;
      0|    if (packageUri != null) packageRoot = root.resolve(packageUri);
      0|    if (!packageRoot.path.endsWith("/")) {
      0|      packageRoot = packageRoot.replace(path: packageRoot.path + "/");
       |    }
       |
       |    LanguageVersion /*?*/ version;
       |    if (languageVersion != null) {
      0|      version = parseLanguageVersion(languageVersion, onError);
       |    } else if (hasVersion) {
      0|      version = SimpleInvalidLanguageVersion("invalid");
       |    }
       |
      0|    return SimplePackage.validate(name, root, packageRoot, version, extraData,
      0|        (error) {
      0|      if (error is ArgumentError) {
      0|        onError(
      0|            PackageConfigFormatException(error.message, error.invalidValue));
       |      } else {
      0|        onError(error);
       |      }
       |    });
       |  }
       |
      0|  var map = checkType<Map<String, dynamic>>(json, "value");
       |  if (map == null) return const SimplePackageConfig.empty();
       |  Map<String, dynamic> /*?*/ extraData;
       |  List<Package> /*?*/ packageList;
       |  int /*?*/ configVersion;
      0|  map.forEach((key, value) {
       |    switch (key) {
      0|      case _configVersionKey:
      0|        configVersion = checkType<int>(value, _configVersionKey) ?? 2;
       |        break;
      0|      case _packagesKey:
      0|        var packageArray = checkType<List<dynamic>>(value, _packagesKey) ?? [];
      0|        var packages = <Package>[];
      0|        for (var package in packageArray) {
       |          var packageMap =
      0|              checkType<Map<String, dynamic>>(package, "package entry");
       |          if (packageMap != null) {
      0|            var entry = parsePackage(packageMap);
       |            if (entry != null) {
      0|              packages.add(entry);
       |            }
       |          }
       |        }
       |        packageList = packages;
       |        break;
       |      default:
      0|        (extraData ??= {})[key] = value;
       |        break;
       |    }
       |  });
       |  if (configVersion == null) {
      0|    onError(PackageConfigFormatException("Missing configVersion entry", json));
       |    configVersion = 2;
       |  }
       |  if (packageList == null) {
      0|    onError(PackageConfigFormatException("Missing packages list", json));
      0|    packageList = [];
       |  }
      0|  return SimplePackageConfig(configVersion, packageList, extraData, (error) {
      0|    if (error is ArgumentError) {
      0|      onError(PackageConfigFormatException(error.message, error.invalidValue));
       |    } else {
      0|      onError(error);
       |    }
       |  });
       |}
       |
      0|final _jsonUtf8Encoder = JsonUtf8Encoder("  ");
       |
      0|void writePackageConfigJsonUtf8(
       |    PackageConfig config, Uri baseUri, Sink<List<int>> output) {
       |  // Can be optimized.
      0|  var data = packageConfigToJson(config, baseUri);
      0|  output.add(_jsonUtf8Encoder.convert(data) as Uint8List);
       |}
       |
      0|void writePackageConfigJsonString(
       |    PackageConfig config, Uri baseUri, StringSink output) {
       |  // Can be optimized.
      0|  var data = packageConfigToJson(config, baseUri);
      0|  output.write(JsonEncoder.withIndent("  ").convert(data) as Uint8List);
       |}
       |
      0|Map<String, dynamic> packageConfigToJson(PackageConfig config, Uri baseUri) =>
      0|    <String, dynamic>{
      0|      ...?_extractExtraData(config.extraData, _topNames),
      0|      _configVersionKey: PackageConfig.maxVersion,
      0|      _packagesKey: [
      0|        for (var package in config.packages)
      0|          <String, dynamic>{
      0|            _nameKey: package.name,
      0|            _rootUriKey: relativizeUri(package.root, baseUri).toString(),
      0|            if (package.root != package.packageUriRoot)
      0|              _packageUriKey:
      0|                  relativizeUri(package.packageUriRoot, package.root)
      0|                      .toString(),
      0|            if (package.languageVersion != null &&
      0|                package.languageVersion is! InvalidLanguageVersion)
      0|              _languageVersionKey: package.languageVersion.toString(),
      0|            ...?_extractExtraData(package.extraData, _packageNames),
       |          }
       |      ],
       |    };
       |
      0|void writeDotPackages(PackageConfig config, Uri baseUri, StringSink output) {
      0|  var extraData = config.extraData;
       |  // Write .packages too.
       |  String /*?*/ comment;
       |  if (extraData != null) {
      0|    String /*?*/ generator = extraData[_generatorKey];
       |    if (generator != null) {
      0|      String /*?*/ generated = extraData[_generatedKey];
      0|      String /*?*/ generatorVersion = extraData[_generatorVersionKey];
      0|      comment = "Generated by $generator"
      0|          "${generatorVersion != null ? " $generatorVersion" : ""}"
      0|          "${generated != null ? " on $generated" : ""}.";
       |    }
       |  }
      0|  packages_file.write(output, config, baseUri: baseUri, comment: comment);
       |}
       |
       |/// If "extraData" is a JSON map, then return it, otherwise return null.
       |///
       |/// If the value contains any of the [reservedNames] for the current context,
       |/// entries with that name in the extra data are dropped.
      0|Map<String, dynamic> /*?*/ _extractExtraData(
       |    dynamic data, Iterable<String> reservedNames) {
      0|  if (data is Map<String, dynamic>) {
      0|    if (data.isEmpty) return null;
      0|    for (var name in reservedNames) {
      0|      if (data.containsKey(name)) {
      0|        data = {
      0|          for (var key in data.keys)
      0|            if (!reservedNames.contains(key)) key: data[key]
       |        };
      0|        if (data.isEmpty) return null;
      0|        for (var value in data.values) {
      0|          if (!_validateJson(value)) return null;
       |        }
       |      }
       |    }
       |    return data;
       |  }
       |  return null;
       |}
       |
       |/// Checks that the object is a valid JSON-like data structure.
      0|bool _validateJson(dynamic object) {
      0|  if (object == null || true == object || false == object) return true;
      0|  if (object is num || object is String) return true;
      0|  if (object is List<dynamic>) {
      0|    return object.every(_validateJson);
       |  }
      0|  if (object is Map<String, dynamic>) {
      0|    return object.values.every(_validateJson);
       |  }
       |  return false;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/packages_file.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "package_config_impl.dart";
       |
       |import "util.dart";
       |import "errors.dart";
       |
       |/// The language version prior to the release of language versioning.
       |///
       |/// This is the default language version used by all packages from a
       |/// `.packages` file.
      0|final LanguageVersion _languageVersion = LanguageVersion(2, 7);
       |
       |/// Parses a `.packages` file into a [PackageConfig].
       |///
       |/// The [source] is the byte content of a `.packages` file, assumed to be
       |/// UTF-8 encoded. In practice, all significant parts of the file must be ASCII,
       |/// so Latin-1 or Windows-1252 encoding will also work fine.
       |///
       |/// If the file content is available as a string, its [String.codeUnits] can
       |/// be used as the `source` argument of this function.
       |///
       |/// The [baseLocation] is used as a base URI to resolve all relative
       |/// URI references against.
       |/// If the content was read from a file, `baseLocation` should be the
       |/// location of that file.
       |///
       |/// Returns a simple package configuration where each package's
       |/// [Package.packageUriRoot] is the same as its [Package.root]
       |/// and it has no [Package.languageVersion].
      0|PackageConfig parse(
       |    List<int> source, Uri baseLocation, void onError(Object error)) {
      0|  if (baseLocation.isScheme("package")) {
      0|    onError(PackageConfigArgumentError(
       |        baseLocation, "baseLocation", "Must not be a package: URI"));
       |    return PackageConfig.empty;
       |  }
       |  var index = 0;
      0|  var packages = <Package>[];
       |  var packageNames = <String>{};
      0|  while (index < source.length) {
       |    var ignoreLine = false;
       |    var start = index;
      0|    var separatorIndex = -1;
      0|    var end = source.length;
      0|    var char = source[index++];
      0|    if (char == $cr || char == $lf) {
       |      continue;
       |    }
      0|    if (char == $colon) {
      0|      onError(PackageConfigFormatException(
      0|          "Missing package name", source, index - 1));
       |      ignoreLine = true; // Ignore if package name is invalid.
       |    } else {
      0|      ignoreLine = char == $hash; // Ignore if comment.
       |    }
      0|    var queryStart = -1;
      0|    var fragmentStart = -1;
      0|    while (index < source.length) {
      0|      char = source[index++];
      0|      if (char == $colon && separatorIndex < 0) {
      0|        separatorIndex = index - 1;
      0|      } else if (char == $cr || char == $lf) {
      0|        end = index - 1;
       |        break;
      0|      } else if (char == $question && queryStart < 0 && fragmentStart < 0) {
      0|        queryStart = index - 1;
      0|      } else if (char == $hash && fragmentStart < 0) {
      0|        fragmentStart = index - 1;
       |      }
       |    }
       |    if (ignoreLine) continue;
      0|    if (separatorIndex < 0) {
      0|      onError(
      0|          PackageConfigFormatException("No ':' on line", source, index - 1));
       |      continue;
       |    }
      0|    var packageName = String.fromCharCodes(source, start, separatorIndex);
      0|    var invalidIndex = checkPackageName(packageName);
      0|    if (invalidIndex >= 0) {
      0|      onError(PackageConfigFormatException(
      0|          "Not a valid package name", source, start + invalidIndex));
       |      continue;
       |    }
      0|    if (queryStart >= 0) {
      0|      onError(PackageConfigFormatException(
       |          "Location URI must not have query", source, queryStart));
       |      end = queryStart;
      0|    } else if (fragmentStart >= 0) {
      0|      onError(PackageConfigFormatException(
       |          "Location URI must not have fragment", source, fragmentStart));
       |      end = fragmentStart;
       |    }
      0|    var packageValue = String.fromCharCodes(source, separatorIndex + 1, end);
       |    Uri packageLocation;
       |    try {
      0|      packageLocation = baseLocation.resolve(packageValue);
      0|    } on FormatException catch (e) {
      0|      onError(PackageConfigFormatException.from(e));
       |      continue;
       |    }
      0|    if (packageLocation.isScheme("package")) {
      0|      onError(PackageConfigFormatException(
      0|          "Package URI as location for package", source, separatorIndex + 1));
       |      continue;
       |    }
      0|    var path = packageLocation.path;
      0|    if (!path.endsWith('/')) {
      0|      path += "/";
      0|      packageLocation = packageLocation.replace(path: path);
       |    }
      0|    if (packageNames.contains(packageName)) {
      0|      onError(PackageConfigFormatException(
       |          "Same package name occured more than once", source, start));
       |      continue;
       |    }
       |    var rootUri = packageLocation;
      0|    if (path.endsWith("/lib/")) {
       |      // Assume default Pub package layout. Include package itself in root.
       |      rootUri =
      0|          packageLocation.replace(path: path.substring(0, path.length - 4));
       |    }
      0|    var package = SimplePackage.validate(
      0|        packageName, rootUri, packageLocation, _languageVersion, null, (error) {
      0|      if (error is ArgumentError) {
      0|        onError(PackageConfigFormatException(error.message, source));
       |      } else {
      0|        onError(error);
       |      }
       |    });
       |    if (package != null) {
      0|      packages.add(package);
      0|      packageNames.add(packageName);
       |    }
       |  }
      0|  return SimplePackageConfig(1, packages, null, onError);
       |}
       |
       |/// Writes the configuration to a [StringSink].
       |///
       |/// If [comment] is provided, the output will contain this comment
       |/// with `# ` in front of each line.
       |/// Lines are defined as ending in line feed (`'\n'`). If the final
       |/// line of the comment doesn't end in a line feed, one will be added.
       |///
       |/// If [baseUri] is provided, package locations will be made relative
       |/// to the base URI, if possible, before writing.
       |///
       |/// If [allowDefaultPackage] is `true`, the [packageMapping] may contain an
       |/// empty string mapping to the _default package name_.
       |///
       |/// All the keys of [packageMapping] must be valid package names,
       |/// and the values must be URIs that do not have the `package:` scheme.
      0|void write(StringSink output, PackageConfig config,
       |    {Uri baseUri, String comment}) {
      0|  if (baseUri != null && !baseUri.isAbsolute) {
      0|    throw PackageConfigArgumentError(baseUri, "baseUri", "Must be absolute");
       |  }
       |
       |  if (comment != null) {
      0|    var lines = comment.split('\n');
      0|    if (lines.last.isEmpty) lines.removeLast();
      0|    for (var commentLine in lines) {
      0|      output.write('# ');
      0|      output.writeln(commentLine);
       |    }
       |  } else {
      0|    output.write("# generated by package:package_config at ");
      0|    output.write(DateTime.now());
      0|    output.writeln();
       |  }
      0|  for (var package in config.packages) {
      0|    var packageName = package.name;
      0|    var uri = package.packageUriRoot;
       |    // Validate packageName.
      0|    if (!isValidPackageName(packageName)) {
      0|      throw PackageConfigArgumentError(
      0|          config, "config", '"$packageName" is not a valid package name');
       |    }
      0|    if (uri.scheme == "package") {
      0|      throw PackageConfigArgumentError(
      0|          config, "config", "Package location must not be a package URI: $uri");
       |    }
      0|    output.write(packageName);
      0|    output.write(':');
       |    // If baseUri is provided, make the URI relative to baseUri.
       |    if (baseUri != null) {
      0|      uri = relativizeUri(uri, baseUri);
       |    }
      0|    if (!uri.path.endsWith('/')) {
      0|      uri = uri.replace(path: uri.path + '/');
       |    }
      0|    output.write(uri);
      0|    output.writeln();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/util.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Utility methods used by more than one library in the package.
       |library package_config.util;
       |
       |import "errors.dart";
       |
       |// All ASCII characters that are valid in a package name, with space
       |// for all the invalid ones (including space).
       |const String _validPackageNameCharacters =
       |    r"                                 !  $ &'()*+,-. 0123456789 ; =  "
       |    r"@ABCDEFGHIJKLMNOPQRSTUVWXYZ    _ abcdefghijklmnopqrstuvwxyz   ~ ";
       |
       |/// Tests whether something is a valid Dart package name.
      0|bool isValidPackageName(String string) {
      0|  return checkPackageName(string) < 0;
       |}
       |
       |/// Check if a string is a valid package name.
       |///
       |/// Valid package names contain only characters in [_validPackageNameCharacters]
       |/// and must contain at least one non-'.' character.
       |///
       |/// Returns `-1` if the string is valid.
       |/// Otherwise returns the index of the first invalid character,
       |/// or `string.length` if the string contains no non-'.' character.
      0|int checkPackageName(String string) {
       |  // Becomes non-zero if any non-'.' character is encountered.
       |  var nonDot = 0;
      0|  for (var i = 0; i < string.length; i++) {
      0|    var c = string.codeUnitAt(i);
      0|    if (c > 0x7f || _validPackageNameCharacters.codeUnitAt(c) <= $space) {
       |      return i;
       |    }
      0|    nonDot += c ^ $dot;
       |  }
      0|  if (nonDot == 0) return string.length;
      0|  return -1;
       |}
       |
       |/// Validate that a [Uri] is a valid `package:` URI.
       |///
       |/// Used to validate user input.
       |///
       |/// Returns the package name extracted from the package URI,
       |/// which is the path segment between `package:` and the first `/`.
      0|String checkValidPackageUri(Uri packageUri, String name) {
      0|  if (packageUri.scheme != "package") {
      0|    throw PackageConfigArgumentError(packageUri, name, "Not a package: URI");
       |  }
      0|  if (packageUri.hasAuthority) {
      0|    throw PackageConfigArgumentError(
       |        packageUri, name, "Package URIs must not have a host part");
       |  }
      0|  if (packageUri.hasQuery) {
       |    // A query makes no sense if resolved to a file: URI.
      0|    throw PackageConfigArgumentError(
       |        packageUri, name, "Package URIs must not have a query part");
       |  }
      0|  if (packageUri.hasFragment) {
       |    // We could leave the fragment after the URL when resolving,
       |    // but it would be odd if "package:foo/foo.dart#1" and
       |    // "package:foo/foo.dart#2" were considered different libraries.
       |    // Keep the syntax open in case we ever get multiple libraries in one file.
      0|    throw PackageConfigArgumentError(
       |        packageUri, name, "Package URIs must not have a fragment part");
       |  }
      0|  if (packageUri.path.startsWith('/')) {
      0|    throw PackageConfigArgumentError(
       |        packageUri, name, "Package URIs must not start with a '/'");
       |  }
      0|  var firstSlash = packageUri.path.indexOf('/');
      0|  if (firstSlash == -1) {
      0|    throw PackageConfigArgumentError(packageUri, name,
       |        "Package URIs must start with the package name followed by a '/'");
       |  }
      0|  var packageName = packageUri.path.substring(0, firstSlash);
      0|  var badIndex = checkPackageName(packageName);
      0|  if (badIndex >= 0) {
      0|    if (packageName.isEmpty) {
      0|      throw PackageConfigArgumentError(
       |          packageUri, name, "Package names mus be non-empty");
       |    }
      0|    if (badIndex == packageName.length) {
      0|      throw PackageConfigArgumentError(packageUri, name,
       |          "Package names must contain at least one non-'.' character");
       |    }
       |    assert(badIndex < packageName.length);
      0|    var badCharCode = packageName.codeUnitAt(badIndex);
      0|    var badChar = "U+" + badCharCode.toRadixString(16).padLeft(4, '0');
      0|    if (badCharCode >= 0x20 && badCharCode <= 0x7e) {
       |      // Printable character.
      0|      badChar = "'${packageName[badIndex]}' ($badChar)";
       |    }
      0|    throw PackageConfigArgumentError(
      0|        packageUri, name, "Package names must not contain $badChar");
       |  }
       |  return packageName;
       |}
       |
       |/// Checks whether URI is just an absolute directory.
       |///
       |/// * It must have a scheme.
       |/// * It must not have a query or fragment.
       |/// * The path must end with `/`.
      0|bool isAbsoluteDirectoryUri(Uri uri) {
      0|  if (uri.hasQuery) return false;
      0|  if (uri.hasFragment) return false;
      0|  if (!uri.hasScheme) return false;
      0|  var path = uri.path;
      0|  if (!path.endsWith("/")) return false;
       |  return true;
       |}
       |
       |/// Whether the former URI is a prefix of the latter.
      0|bool isUriPrefix(Uri prefix, Uri path) {
       |  assert(!prefix.hasFragment);
       |  assert(!prefix.hasQuery);
       |  assert(!path.hasQuery);
       |  assert(!path.hasFragment);
       |  assert(prefix.path.endsWith('/'));
      0|  return path.toString().startsWith(prefix.toString());
       |}
       |
       |/// Finds the first non-JSON-whitespace character in a file.
       |///
       |/// Used to heuristically detect whether a file is a JSON file or an .ini file.
      0|int firstNonWhitespaceChar(List<int> bytes) {
      0|  for (var i = 0; i < bytes.length; i++) {
      0|    var char = bytes[i];
      0|    if (char != 0x20 && char != 0x09 && char != 0x0a && char != 0x0d) {
       |      return char;
       |    }
       |  }
      0|  return -1;
       |}
       |
       |/// Attempts to return a relative path-only URI for [uri].
       |///
       |/// First removes any query or fragment part from [uri].
       |///
       |/// If [uri] is already relative (has no scheme), it's returned as-is.
       |/// If that is not desired, the caller can pass `baseUri.resolveUri(uri)`
       |/// as the [uri] instead.
       |///
       |/// If the [uri] has a scheme or authority part which differs from
       |/// the [baseUri], or if there is no overlap in the paths of the
       |/// two URIs at all, the [uri] is returned as-is.
       |///
       |/// Otherwise the result is a path-only URI which satsifies
       |/// `baseUri.resolveUri(result) == uri`,
       |///
       |/// The `baseUri` must be absolute.
      0|Uri relativizeUri(Uri uri, Uri /*?*/ baseUri) {
       |  if (baseUri == null) return uri;
       |  assert(baseUri.isAbsolute);
      0|  if (uri.hasQuery || uri.hasFragment) {
      0|    uri = Uri(
      0|        scheme: uri.scheme,
      0|        userInfo: uri.hasAuthority ? uri.userInfo : null,
      0|        host: uri.hasAuthority ? uri.host : null,
      0|        port: uri.hasAuthority ? uri.port : null,
      0|        path: uri.path);
       |  }
       |
       |  // Already relative. We assume the caller knows what they are doing.
      0|  if (!uri.isAbsolute) return uri;
       |
      0|  if (baseUri.scheme != uri.scheme) {
       |    return uri;
       |  }
       |
       |  // If authority differs, we could remove the scheme, but it's not worth it.
      0|  if (uri.hasAuthority != baseUri.hasAuthority) return uri;
      0|  if (uri.hasAuthority) {
      0|    if (uri.userInfo != baseUri.userInfo ||
      0|        uri.host.toLowerCase() != baseUri.host.toLowerCase() ||
      0|        uri.port != baseUri.port) {
       |      return uri;
       |    }
       |  }
       |
      0|  baseUri = baseUri.normalizePath();
      0|  var base = [...baseUri.pathSegments];
      0|  if (base.isNotEmpty) base.removeLast();
      0|  uri = uri.normalizePath();
      0|  var target = [...uri.pathSegments];
      0|  if (target.isNotEmpty && target.last.isEmpty) target.removeLast();
       |  var index = 0;
      0|  while (index < base.length && index < target.length) {
      0|    if (base[index] != target[index]) {
       |      break;
       |    }
      0|    index++;
       |  }
      0|  if (index == base.length) {
      0|    if (index == target.length) {
      0|      return Uri(path: "./");
       |    }
      0|    return Uri(path: target.skip(index).join('/'));
      0|  } else if (index > 0) {
      0|    var buffer = StringBuffer();
      0|    for (var n = base.length - index; n > 0; --n) {
      0|      buffer.write("../");
       |    }
      0|    buffer.writeAll(target.skip(index), "/");
      0|    return Uri(path: buffer.toString());
       |  } else {
       |    return uri;
       |  }
       |}
       |
       |// Character constants used by this package.
       |/// "Line feed" control character.
       |const int $lf = 0x0a;
       |
       |/// "Carriage return" control character.
       |const int $cr = 0x0d;
       |
       |/// Space character.
       |const int $space = 0x20;
       |
       |/// Character `#`.
       |const int $hash = 0x23;
       |
       |/// Character `.`.
       |const int $dot = 0x2e;
       |
       |/// Character `:`.
       |const int $colon = 0x3a;
       |
       |/// Character `?`.
       |const int $question = 0x3f;
       |
       |/// Character `{`.
       |const int $lbrace = 0x7b;
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/package_config-1.9.3/lib/src/util_io.dart
       |// Copyright (c) 2020, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Utility methods requiring dart:io and used by more than one library in the
       |/// package.
       |library package_config.util_io;
       |
       |import 'dart:io';
       |import 'dart:typed_data';
       |
      0|Future<Uint8List> defaultLoader(Uri uri) async {
      0|  if (uri.isScheme("file")) {
      0|    var file = File.fromUri(uri);
       |    try {
      0|      return await file.readAsBytes();
       |    } catch (_) {
       |      return null;
       |    }
       |  }
      0|  if (uri.isScheme("http") || uri.isScheme("https")) {
      0|    return _httpGet(uri);
       |  }
      0|  throw UnsupportedError("Default URI unsupported scheme: $uri");
       |}
       |
      0|Future<Uint8List /*?*/ > _httpGet(Uri uri) async {
       |  assert(uri.isScheme("http") || uri.isScheme("https"));
      0|  var client = HttpClient();
      0|  var request = await client.getUrl(uri);
      0|  var response = await request.close();
      0|  if (response.statusCode != HttpStatus.ok) {
       |    return null;
       |  }
      0|  var splitContent = await response.toList();
       |  var totalLength = 0;
      0|  if (splitContent.length == 1) {
      0|    var part = splitContent[0];
      0|    if (part is Uint8List) {
       |      return part;
       |    }
       |  }
      0|  for (var list in splitContent) {
      0|    totalLength += list.length;
       |  }
      0|  var result = Uint8List(totalLength);
       |  var offset = 0;
      0|  for (Uint8List contentPart in splitContent) {
      0|    result.setRange(offset, offset + contentPart.length, contentPart);
      0|    offset += contentPart.length;
       |  }
       |  return result;
       |}
       |
       |/// The file name of a path.
       |///
       |/// The file name is everything after the last occurrence of
       |/// [Platform.pathSeparator], or the entire string if no
       |/// path separator occurs in the string.
      0|String fileName(String path) {
      0|  var separator = Platform.pathSeparator;
      0|  var lastSeparator = path.lastIndexOf(separator);
      0|  if (lastSeparator < 0) return path;
      0|  return path.substring(lastSeparator + separator.length);
       |}
       |
       |/// The directory name of a path.
       |///
       |/// The directory name is everything before the last occurrence of
       |/// [Platform.pathSeparator], or the empty string if no
       |/// path separator occurs in the string.
      0|String dirName(String path) {
      0|  var separator = Platform.pathSeparator;
      0|  var lastSeparator = path.lastIndexOf(separator);
      0|  if (lastSeparator < 0) return "";
      0|  return path.substring(0, lastSeparator);
       |}
       |
       |/// Join path parts with the [Platform.pathSeparator].
       |///
       |/// If a part ends with a path separator, then no extra separator is
       |/// inserted.
      0|String pathJoin(String part1, String part2, [String part3]) {
      0|  var separator = Platform.pathSeparator;
      0|  var separator1 = part1.endsWith(separator) ? "" : separator;
       |  if (part3 == null) {
      0|    return "$part1$separator1$part2";
       |  }
      0|  var separator2 = part2.endsWith(separator) ? "" : separator;
      0|  return "$part1$separator1$part2$separator2$part3";
       |}
       |
       |/// Join an unknown number of path parts with [Platform.pathSeparator].
       |///
       |/// If a part ends with a path separator, then no extra separator is
       |/// inserted.
      0|String pathJoinAll(Iterable<String> parts) {
      0|  var buffer = StringBuffer();
       |  var separator = "";
      0|  for (var part in parts) {
      0|    buffer..write(separator)..write(part);
       |    separator =
      0|        part.endsWith(Platform.pathSeparator) ? "" : Platform.pathSeparator;
       |  }
      0|  return buffer.toString();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pedantic-1.9.2/lib/pedantic.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async' show Future;
       |
       |/// Indicates to tools that [future] is intentionally not `await`-ed.
       |///
       |/// In an `async` context, it is normally expected that all [Future]s are
       |/// awaited, and that is the basis of the lint `unawaited_futures`. However,
       |/// there are times where one or more futures are intentionally not awaited.
       |/// This function may be used to ignore a particular future. It silences the
       |/// `unawaited_futures` lint.
       |///
       |/// ```
       |/// Future<void> saveUserPreferences() async {
       |///   await _writePreferences();
       |///
       |///   // While 'log' returns a Future, the consumer of 'saveUserPreferences'
       |///   // is unlikely to want to wait for that future to complete; they only
       |///   // care about the preferences being written).
       |///   unawaited(log('Preferences saved!'));
       |/// }
       |/// ```
      0|void unawaited(Future<void> future) {}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pool-1.4.0/lib/pool.dart
       |// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |import 'dart:collection';
       |
       |import 'package:async/async.dart';
       |import 'package:stack_trace/stack_trace.dart';
       |
       |/// Manages an abstract pool of resources with a limit on how many may be in use
       |/// at once.
       |///
       |/// When a resource is needed, the user should call [request]. When the returned
       |/// future completes with a [PoolResource], the resource may be allocated. Once
       |/// the resource has been released, the user should call [PoolResource.release].
       |/// The pool will ensure that only a certain number of [PoolResource]s may be
       |/// allocated at once.
       |class Pool {
       |  /// Completers for requests beyond the first [_maxAllocatedResources].
       |  ///
       |  /// When an item is released, the next element of [_requestedResources] will
       |  /// be completed.
       |  final _requestedResources = Queue<Completer<PoolResource>>();
       |
       |  /// Callbacks that must be called before additional resources can be
       |  /// allocated.
       |  ///
       |  /// See [PoolResource.allowRelease].
       |  final _onReleaseCallbacks = Queue<void Function()>();
       |
       |  /// Completers that will be completed once `onRelease` callbacks are done
       |  /// running.
       |  ///
       |  /// These are kept in a queue to ensure that the earliest request completes
       |  /// first regardless of what order the `onRelease` callbacks complete in.
       |  final _onReleaseCompleters = Queue<Completer<PoolResource>>();
       |
       |  /// The maximum number of resources that may be allocated at once.
       |  final int _maxAllocatedResources;
       |
       |  /// The number of resources that are currently allocated.
       |  int _allocatedResources = 0;
       |
       |  /// The timeout timer.
       |  ///
       |  /// This timer is canceled as long as the pool is below the resource limit.
       |  /// It's reset once the resource limit is reached and again every time an
       |  /// resource is released or a new resource is requested. If it fires, that
       |  /// indicates that the caller became deadlocked, likely due to files waiting
       |  /// for additional files to be read before they could be closed.
       |  ///
       |  /// This is `null` if this pool shouldn't time out.
       |  RestartableTimer _timer;
       |
       |  /// The amount of time to wait before timing out the pending resources.
       |  final Duration _timeout;
       |
       |  /// A [FutureGroup] that tracks all the `onRelease` callbacks for resources
       |  /// that have been marked releasable.
       |  ///
       |  /// This is `null` until [close] is called.
       |  FutureGroup _closeGroup;
       |
       |  /// Whether [close] has been called.
      3|  bool get isClosed => _closeMemo.hasRun;
       |
       |  /// A future that completes once the pool is closed and all its outstanding
       |  /// resources have been released.
       |  ///
       |  /// If any [PoolResource.allowRelease] callback throws an exception after the
       |  /// pool is closed, this completes with that exception.
      3|  Future get done => _closeMemo.future;
       |
       |  /// Creates a new pool with the given limit on how many resources may be
       |  /// allocated at once.
       |  ///
       |  /// If [timeout] is passed, then if that much time passes without any activity
       |  /// all pending [request] futures will throw a [TimeoutException]. This is
       |  /// intended to avoid deadlocks.
      1|  Pool(this._maxAllocatedResources, {Duration timeout}) : _timeout = timeout {
      2|    if (_maxAllocatedResources <= 0) {
      0|      throw ArgumentError.value(_maxAllocatedResources, 'maxAllocatedResources',
       |          'Must be greater than zero.');
       |    }
       |
       |    if (timeout != null) {
       |      // Start the timer canceled since we only want to start counting down once
       |      // we've run out of available resources.
      0|      _timer = RestartableTimer(timeout, _onTimeout)..cancel();
       |    }
       |  }
       |
       |  /// Request a [PoolResource].
       |  ///
       |  /// If the maximum number of resources is already allocated, this will delay
       |  /// until one of them is released.
      1|  Future<PoolResource> request() {
      1|    if (isClosed) {
      0|      throw StateError("request() may not be called on a closed Pool.");
       |    }
       |
      3|    if (_allocatedResources < _maxAllocatedResources) {
      2|      _allocatedResources++;
      2|      return Future.value(PoolResource._(this));
      0|    } else if (_onReleaseCallbacks.isNotEmpty) {
      0|      return _runOnRelease(_onReleaseCallbacks.removeFirst());
       |    } else {
      0|      var completer = Completer<PoolResource>();
      0|      _requestedResources.add(completer);
      0|      _resetTimer();
      0|      return completer.future;
       |    }
       |  }
       |
       |  /// Requests a resource for the duration of [callback], which may return a
       |  /// Future.
       |  ///
       |  /// The return value of [callback] is piped to the returned Future.
      0|  Future<T> withResource<T>(FutureOr<T> Function() callback) async {
      0|    if (isClosed) {
      0|      throw StateError("withResource() may not be called on a closed Pool.");
       |    }
       |
      0|    var resource = await request();
       |    try {
      0|      return await callback();
       |    } finally {
      0|      resource.release();
       |    }
       |  }
       |
       |  /// Returns a [Stream] containing the result of [action] applied to each
       |  /// element of [elements].
       |  ///
       |  /// While [action] is invoked on each element of [elements] in order,
       |  /// it's possible the return [Stream] may have items out-of-order  especially
       |  /// if the completion time of [action] varies.
       |  ///
       |  /// If [action] throws an error the source item along with the error object
       |  /// and [StackTrace] are passed to [onError], if it is provided. If [onError]
       |  /// returns `true`, the error is added to the returned [Stream], otherwise
       |  /// it is ignored.
       |  ///
       |  /// Errors thrown from iterating [elements] will not be passed to
       |  /// [onError]. They will always be added to the returned stream as an error.
       |  ///
       |  /// Note: all of the resources of the this [Pool] will be used when the
       |  /// returned [Stream] is listened to until it is completed or canceled.
       |  ///
       |  /// Note: if this [Pool] is closed before the returned [Stream] is listened
       |  /// to, a [StateError] is thrown.
      0|  Stream<T> forEach<S, T>(
       |      Iterable<S> elements, FutureOr<T> Function(S source) action,
       |      {bool Function(S item, Object error, StackTrace stack) onError}) {
      0|    onError ??= (item, e, s) => true;
       |
       |    var cancelPending = false;
       |
       |    Completer resumeCompleter;
       |    StreamController<T> controller;
       |
       |    Iterator<S> iterator;
       |
      0|    Future<void> run(int i) async {
      0|      while (iterator.moveNext()) {
       |        // caching `current` is necessary because there are async breaks
       |        // in this code and `iterator` is shared across many workers
      0|        final current = iterator.current;
       |
      0|        _resetTimer();
       |
      0|        await resumeCompleter?.future;
       |
       |        if (cancelPending) {
       |          break;
       |        }
       |
       |        T value;
       |        try {
      0|          value = await action(current);
       |        } catch (e, stack) {
      0|          if (onError(current, e, stack)) {
      0|            controller.addError(e, stack);
       |          }
       |          continue;
       |        }
      0|        controller.add(value);
       |      }
       |    }
       |
       |    Future doneFuture;
       |
      0|    void onListen() {
       |      assert(iterator == null);
      0|      iterator = elements.iterator;
       |
       |      assert(doneFuture == null);
      0|      doneFuture = Future.wait(
      0|              Iterable<int>.generate(_maxAllocatedResources)
      0|                  .map((i) => withResource(() => run(i))),
       |              eagerError: true)
      0|          .catchError(controller.addError);
       |
      0|      doneFuture.whenComplete(controller.close);
       |    }
       |
      0|    controller = StreamController<T>(
       |      sync: true,
       |      onListen: onListen,
      0|      onCancel: () async {
       |        assert(!cancelPending);
       |        cancelPending = true;
      0|        await doneFuture;
       |      },
      0|      onPause: () {
       |        assert(resumeCompleter == null);
      0|        resumeCompleter = Completer();
       |      },
      0|      onResume: () {
       |        assert(resumeCompleter != null);
      0|        resumeCompleter.complete();
       |        resumeCompleter = null;
       |      },
       |    );
       |
      0|    return controller.stream;
       |  }
       |
       |  /// Closes the pool so that no more resources are requested.
       |  ///
       |  /// Existing resource requests remain unchanged.
       |  ///
       |  /// Any resources that are marked as releasable using
       |  /// [PoolResource.allowRelease] are released immediately. Once all resources
       |  /// have been released and any `onRelease` callbacks have completed, the
       |  /// returned future completes successfully. If any `onRelease` callback throws
       |  /// an error, the returned future completes with that error.
       |  ///
       |  /// This may be called more than once; it returns the same [Future] each time.
      4|  Future close() => _closeMemo.runOnce(() {
      1|        if (_closeGroup != null) return _closeGroup.future;
       |
      1|        _resetTimer();
       |
      2|        _closeGroup = FutureGroup();
      1|        for (var callback in _onReleaseCallbacks) {
      0|          _closeGroup.add(Future.sync(callback));
       |        }
       |
      4|        _allocatedResources -= _onReleaseCallbacks.length;
      2|        _onReleaseCallbacks.clear();
       |
      2|        if (_allocatedResources == 0) _closeGroup.close();
      2|        return _closeGroup.future;
       |      });
       |  final _closeMemo = AsyncMemoizer();
       |
       |  /// If there are any pending requests, this will fire the oldest one.
      0|  void _onResourceReleased() {
      0|    _resetTimer();
       |
      0|    if (_requestedResources.isNotEmpty) {
      0|      var pending = _requestedResources.removeFirst();
      0|      pending.complete(PoolResource._(this));
       |    } else {
      0|      _allocatedResources--;
      0|      if (isClosed && _allocatedResources == 0) _closeGroup.close();
       |    }
       |  }
       |
       |  /// If there are any pending requests, this will fire the oldest one after
       |  /// running [onRelease].
      1|  void _onResourceReleaseAllowed(Function() onRelease) {
      1|    _resetTimer();
       |
      2|    if (_requestedResources.isNotEmpty) {
      0|      var pending = _requestedResources.removeFirst();
      0|      pending.complete(_runOnRelease(onRelease));
      1|    } else if (isClosed) {
      3|      _closeGroup.add(Future.sync(onRelease));
      2|      _allocatedResources--;
      4|      if (_allocatedResources == 0) _closeGroup.close();
       |    } else {
      0|      var zone = Zone.current;
      0|      var registered = zone.registerCallback(onRelease);
      0|      _onReleaseCallbacks.add(() => zone.run(registered));
       |    }
       |  }
       |
       |  /// Runs [onRelease] and returns a Future that completes to a resource once an
       |  /// [onRelease] callback completes.
       |  ///
       |  /// Futures returned by [_runOnRelease] always complete in the order they were
       |  /// created, even if earlier [onRelease] callbacks take longer to run.
      0|  Future<PoolResource> _runOnRelease(Function() onRelease) {
      0|    Future.sync(onRelease).then((value) {
      0|      _onReleaseCompleters.removeFirst().complete(PoolResource._(this));
      0|    }).catchError((error, StackTrace stackTrace) {
      0|      _onReleaseCompleters.removeFirst().completeError(error, stackTrace);
       |    });
       |
      0|    var completer = Completer<PoolResource>.sync();
      0|    _onReleaseCompleters.add(completer);
      0|    return completer.future;
       |  }
       |
       |  /// A resource has been requested, allocated, or released.
      1|  void _resetTimer() {
      1|    if (_timer == null) return;
       |
      0|    if (_requestedResources.isEmpty) {
      0|      _timer.cancel();
       |    } else {
      0|      _timer.reset();
       |    }
       |  }
       |
       |  /// Handles [_timer] timing out by causing all pending resource completers to
       |  /// emit exceptions.
      0|  void _onTimeout() {
      0|    for (var completer in _requestedResources) {
      0|      completer.completeError(
      0|          TimeoutException(
       |              "Pool deadlock: all resources have been "
       |              "allocated for too long.",
      0|              _timeout),
      0|          Chain.current());
       |    }
      0|    _requestedResources.clear();
      0|    _timer = null;
       |  }
       |}
       |
       |/// A member of a [Pool].
       |///
       |/// A [PoolResource] is a token that indicates that a resource is allocated.
       |/// When the associated resource is released, the user should call [release].
       |class PoolResource {
       |  final Pool _pool;
       |
       |  /// Whether `this` has been released yet.
       |  bool _released = false;
       |
      1|  PoolResource._(this._pool);
       |
       |  /// Tells the parent [Pool] that the resource associated with this resource is
       |  /// no longer allocated, and that a new [PoolResource] may be allocated.
      0|  void release() {
      0|    if (_released) {
      0|      throw StateError("A PoolResource may only be released once.");
       |    }
      0|    _released = true;
      0|    _pool._onResourceReleased();
       |  }
       |
       |  /// Tells the parent [Pool] that the resource associated with this resource is
       |  /// no longer necessary, but should remain allocated until more resources are
       |  /// needed.
       |  ///
       |  /// When [Pool.request] is called and there are no remaining available
       |  /// resources, the [onRelease] callback is called. It should free the
       |  /// resource, and it may return a Future or `null`. Once that completes, the
       |  /// [Pool.request] call will complete to a new [PoolResource].
       |  ///
       |  /// This is useful when a resource's main function is complete, but it may
       |  /// produce additional information later on. For example, an isolate's task
       |  /// may be complete, but it could still emit asynchronous errors.
      1|  void allowRelease(Function() onRelease) {
      1|    if (_released) {
      0|      throw StateError("A PoolResource may only be released once.");
       |    }
      1|    _released = true;
      2|    _pool._onResourceReleaseAllowed(onRelease);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_api-0.2.18/lib/src/util/iterable_set.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |import 'package:collection/collection.dart';
       |
       |/// An unmodifiable [Set] view backed by an arbitrary [Iterable].
       |///
       |/// Note that contrary to most APIs that take iterables, this does not convert
       |/// its argument to another collection before use. This means that if it's
       |/// lazily-generated, that generation will happen for every operation.
       |///
       |/// Note also that set operations that are usually expected to be `O(1)` or
       |/// `O(log(n))`, such as [contains], may be `O(n)` for many underlying iterable
       |/// types. As such, this should only be used for small iterables.
       |class IterableSet<E> extends SetMixin<E> with UnmodifiableSetMixin<E> {
       |  /// The base iterable that set operations forward to.
       |  final Iterable<E> _base;
       |
      1|  @override
      2|  int get length => _base.length;
       |
      1|  @override
      2|  Iterator<E> get iterator => _base.iterator;
       |
       |  /// Creates a [Set] view of [base].
      1|  IterableSet(this._base);
       |
      0|  @override
      0|  bool contains(Object element) => _base.contains(element);
       |
      0|  @override
       |  E lookup(Object needle) =>
      0|      _base.firstWhere((element) => element == needle, orElse: () => null);
       |
      0|  @override
      0|  Set<E> toSet() => _base.toSet();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/live_suite.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:collection/collection.dart';
       |
       |import 'package:test_api/src/backend/live_test.dart'; // ignore: implementation_imports
       |
       |import 'runner_suite.dart';
       |
       |/// A view of the execution of a test suite.
       |///
       |/// This is distinct from [Suite] because it represents the progress of running
       |/// a suite rather than the suite's contents. It provides events and collections
       |/// that give the caller a view into the suite's current state.
       |abstract class LiveSuite {
       |  /// The suite that's being run.
       |  RunnerSuite get suite;
       |
       |  /// Whether the suite has completed.
       |  ///
       |  /// Note that even if this returns `true`, the suite may still be running code
       |  /// asynchronously. A suite is considered complete once all of its tests are
       |  /// complete, but it's possible for a test to continue running even after it's
       |  /// been marked completesee [LiveTest.isComplete] for details.
       |  ///
       |  /// The [isClosed] getter can be used to determine whether the suite and its
       |  /// tests are guaranteed to emit no more events.
       |  bool get isComplete;
       |
       |  /// A [Future] that completes once the suite is complete.
       |  ///
       |  /// Note that even once this completes, the suite may still be running code
       |  /// asynchronously. A suite is considered complete once all of its tests are
       |  /// complete, but it's possible for a test to continue running even after it's
       |  /// been marked completesee [LiveTest.isComplete] for details.
       |  ///
       |  /// The [onClose] future can be used to determine when the suite and its tests
       |  /// are guaranteed to emit no more events.
       |  Future get onComplete;
       |
       |  /// Whether the suite has been closed.
       |  ///
       |  /// If this is `true`, no code is running for the suite or any of its tests.
       |  /// At this point, the caller can be sure that the suites' tests are all in
       |  /// fixed states that will not change in the future.
       |  bool get isClosed;
       |
       |  /// A [Future] that completes when the suite has been closed.
       |  ///
       |  /// Once this completes, no code is running for the suite or any of its tests.
       |  /// At this point, the caller can be sure that the suites' tests are all in
       |  /// fixed states that will not change in the future.
       |  Future get onClose;
       |
       |  /// All the currently-known tests in this suite that have run or are running.
       |  ///
       |  /// This is guaranteed to contain the same tests as the union of [passed],
       |  /// [skipped], [failed], and [active].
      0|  Set<LiveTest> get liveTests => UnionSet.from([
      0|        passed,
      0|        skipped,
      0|        failed,
      0|        if (active != null) {active}
       |      ]);
       |
       |  /// A stream that emits each [LiveTest] in this suite as it's about to start
       |  /// running.
       |  ///
       |  /// This is guaranteed to fire before [LiveTest.onStateChange] first fires. It
       |  /// will close once all tests the user has selected are run.
       |  Stream<LiveTest> get onTestStarted;
       |
       |  /// The set of tests in this suite that have completed and been marked as
       |  /// passing.
       |  Set<LiveTest> get passed;
       |
       |  /// The set of tests in this suite that have completed and been marked as
       |  /// skipped.
       |  Set<LiveTest> get skipped;
       |
       |  /// The set of tests in this suite that have completed and been marked as
       |  /// failing or error.
       |  Set<LiveTest> get failed;
       |
       |  /// The currently running test in this suite, or `null` if no test is running.
       |  LiveTest get active;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/live_suite_controller.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:async';
       |
       |import 'package:async/async.dart' hide Result;
       |import 'package:collection/collection.dart';
       |
       |import 'package:test_api/src/backend/live_test.dart'; // ignore: implementation_imports
       |import 'package:test_api/src/backend/state.dart'; // ignore: implementation_imports
       |
       |import 'runner_suite.dart';
       |import 'live_suite.dart';
       |
       |/// An implementation of [LiveSuite] that's controlled by a
       |/// [LiveSuiteController].
       |class _LiveSuite extends LiveSuite {
       |  final LiveSuiteController _controller;
       |
      1|  @override
      2|  RunnerSuite get suite => _controller._suite;
       |
      0|  @override
      0|  bool get isComplete => _controller._isComplete;
       |
      0|  @override
      0|  Future get onComplete => _controller._onCompleteGroup.future;
       |
      0|  @override
      0|  bool get isClosed => _controller._onCloseCompleter.isCompleted;
       |
      0|  @override
      0|  Future get onClose => _controller._onCloseCompleter.future;
       |
      1|  @override
       |  Stream<LiveTest> get onTestStarted =>
      3|      _controller._onTestStartedController.stream;
       |
      1|  @override
      3|  Set<LiveTest> get passed => UnmodifiableSetView(_controller._passed);
       |
      1|  @override
      3|  Set<LiveTest> get skipped => UnmodifiableSetView(_controller._skipped);
       |
      1|  @override
      3|  Set<LiveTest> get failed => UnmodifiableSetView(_controller._failed);
       |
      0|  @override
      0|  LiveTest get active => _controller._active;
       |
      1|  _LiveSuite(this._controller);
       |}
       |
       |/// A controller that drives a [LiveSuite].
       |///
       |/// This is a utility class to make it easier for [Engine] to create the
       |/// [LiveSuite]s exposed by various APIs. The [LiveSuite] is accessible through
       |/// [LiveSuiteController.liveSuite]. When a live test is run, it should be
       |/// passed to [reportLiveTest], and once tests are finished being run for this
       |/// suite, [noMoreLiveTests] should be called. Once the suite should be torn
       |/// down, [close] should be called.
       |class LiveSuiteController {
       |  /// The [LiveSuite] being controlled.
      2|  LiveSuite get liveSuite => _liveSuite;
       |  LiveSuite _liveSuite;
       |
       |  /// The suite that's being run.
       |  final RunnerSuite _suite;
       |
       |  /// The future group that backs [LiveSuite.onComplete].
       |  ///
       |  /// This contains all the futures from tests that are run in this suite.
       |  final _onCompleteGroup = FutureGroup();
       |
       |  /// Whether [_onCompleteGroup]'s future has fired.
       |  var _isComplete = false;
       |
       |  /// The completer that backs [LiveSuite.onClose].
       |  ///
       |  /// This is completed when the live suite is closed.
       |  final _onCloseCompleter = Completer();
       |
       |  /// The controller for [LiveSuite.onTestStarted].
       |  final _onTestStartedController =
       |      StreamController<LiveTest>.broadcast(sync: true);
       |
       |  /// The set that backs [LiveTest.passed].
       |  final _passed = <LiveTest>{};
       |
       |  /// The set that backs [LiveTest.skipped].
       |  final _skipped = <LiveTest>{};
       |
       |  /// The set that backs [LiveTest.failed].
       |  final _failed = <LiveTest>{};
       |
       |  /// The test exposed through [LiveTest.active].
       |  LiveTest _active;
       |
       |  /// Creates a controller for a live suite representing running the tests in
       |  /// [suite].
       |  ///
       |  /// Once this is called, the controller assumes responsibility for closing the
       |  /// suite. The caller should call [LiveSuiteController.close] rather than
       |  /// calling [RunnerSuite.close] directly.
      1|  LiveSuiteController(this._suite) {
      2|    _liveSuite = _LiveSuite(this);
       |
      4|    _onCompleteGroup.future.then((_) {
      1|      _isComplete = true;
      0|    }, onError: (_) {});
       |  }
       |
       |  /// Reports the status of [liveTest] through [liveSuite].
       |  ///
       |  /// The live test is assumed to be a member of this suite. If [countSuccess]
       |  /// is `true` (the default), the test is put into [passed] if it succeeds.
       |  /// Otherwise, it's removed from [liveTests] entirely.
       |  ///
       |  /// Throws a [StateError] if called after [noMoreLiveTests].
      1|  void reportLiveTest(LiveTest liveTest, {bool countSuccess = true}) {
      2|    if (_onTestStartedController.isClosed) {
      0|      throw StateError("Can't call reportLiveTest() after noMoreTests().");
       |    }
       |
       |    assert(liveTest.suite == _suite);
       |    assert(_active == null);
       |
      1|    _active = liveTest;
       |
      3|    liveTest.onStateChange.listen((state) {
      2|      if (state.status != Status.complete) return;
      1|      _active = null;
       |
      2|      if (state.result == Result.skipped) {
      0|        _skipped.add(liveTest);
      2|      } else if (state.result != Result.success) {
      0|        _passed.remove(liveTest);
      0|        _failed.add(liveTest);
       |      } else if (countSuccess) {
      2|        _passed.add(liveTest);
       |        // A passing test that was once failing was retried
      2|        _failed.remove(liveTest);
       |      }
       |    });
       |
      2|    _onTestStartedController.add(liveTest);
       |
      3|    _onCompleteGroup.add(liveTest.onComplete);
       |  }
       |
       |  /// Indicates that all the live tests that are going to be provided for this
       |  /// suite have already been provided.
      1|  void noMoreLiveTests() {
      2|    _onTestStartedController.close();
      2|    _onCompleteGroup.close();
       |  }
       |
       |  /// Closes the underlying suite.
      4|  Future close() => _closeMemo.runOnce(() async {
       |        try {
      3|          await _suite.close();
       |        } finally {
      2|          _onCloseCompleter.complete();
       |        }
       |      });
       |  final _closeMemo = AsyncMemoizer();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/parameters_with_iv.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |//TODO rename
       |/// [CipherParameters] consisting of an underlying [CipherParameters] (of type [UnderlyingParameters]) and an initialization
       |/// vector of arbitrary length.
       |class ParametersWithIV<UnderlyingParameters extends CipherParameters>
       |    implements CipherParameters {
       |  final Uint8List iv;
       |  final UnderlyingParameters parameters;
       |
      1|  ParametersWithIV(this.parameters, this.iv);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/aead_cipher.dart
       |part of '../../api.dart';
       |
       |abstract class AEADCipher extends Algorithm {
       |  void init(bool forEncryption, CipherParameters params);
       |
      0|  factory AEADCipher(String algorithmName) =>
      0|      registry.create<AEADCipher>(algorithmName);
       |
       |  @override
       |  String get algorithmName;
       |
       |  void processAADByte(int inp);
       |
       |  void processAADBytes(Uint8List inp, int inpOff, int len);
       |
       |  int processByte(int inp, Uint8List out, int outOff);
       |
       |  int processBytes(
       |      Uint8List inp, int inOff, int len, Uint8List out, int outOff);
       |
       |  int doFinal(Uint8List out, int outOff);
       |
       |  Uint8List get mac;
       |
       |  int getUpdateOutputSize(int len);
       |
       |  int getOutputSize(int len);
       |
       |  void reset();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/parameters_with_salt_configuration.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// [CipherParameters] consisting of an underlying [CipherParameters] (of type
       |/// [UnderlyingParameters]), an acompanying [SecureRandom], and salt length.
       |class ParametersWithSaltConfiguration<
       |    UnderlyingParameters extends CipherParameters> implements CipherParameters {
       |  final UnderlyingParameters parameters;
       |  final SecureRandom random;
       |  final int saltLength;
       |
      0|  ParametersWithSaltConfiguration(
       |      this.parameters, this.random, this.saltLength);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/signer.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// An interface for DSAs (digital signature algorithms)
       |abstract class Signer extends Algorithm {
       |  /// Create the signer specified by the standard [algorithmName].
      0|  factory Signer(String algorithmName) =>
      0|      registry.create<Signer>(algorithmName);
       |
       |  /// Reset the signer to its original state.
       |  void reset();
       |
       |  /// Init the signer with its initialization [params]. The type of [CipherParameters] depends on the algorithm being used (see
       |  /// the documentation of each implementation to find out more).
       |  ///
       |  /// Use the argument [forSigning] to tell the signer if you want to generate or verify signatures.
       |  void init(bool forSigning, CipherParameters params);
       |
       |  /// Sign the passed in [message] (usually the output of a hash function)
       |  Signature generateSignature(Uint8List message);
       |
       |  /// Verify the [message] against the [signature].
       |  bool verifySignature(Uint8List message, Signature signature);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/stream_cipher.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// The interface stream ciphers conform to.
       |abstract class StreamCipher extends Algorithm {
       |  /// Create the cipher specified by the standard [algorithmName].
      0|  factory StreamCipher(String algorithmName) =>
      0|      registry.create<StreamCipher>(algorithmName);
       |
       |  /// Reset the cipher to its original state.
       |  void reset();
       |
       |  /// Init the cipher with its initialization [params]. The type of
       |  /// [CipherParameters] depends on the algorithm being used (see the
       |  /// documentation of each implementation to find out more).
       |  ///
       |  /// Use the argument [forEncryption] to tell the cipher if you want to encrypt
       |  /// or decrypt data.
       |  void init(bool forEncryption, CipherParameters params);
       |
       |  /// Process a whole block of [data] at once, returning the result in a byte array.
       |  Uint8List process(Uint8List data);
       |
       |  /// Process one byte of data given by [inp] and return its encrypted value.
       |  int returnByte(int inp);
       |
       |  /// Process [len] bytes of data given by [inp] and starting at offset [inpOff].
       |  /// The resulting cipher text is put in [out] beginning at position [outOff].
       |  void processBytes(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/aead_block_cipher.dart
       |part of '../../api.dart';
       |
       |/// A block cipher mode that includes authenticated encryption
       |abstract class AEADBlockCipher extends BlockCipher {
      0|  factory AEADBlockCipher(String algorithmName) =>
      0|      registry.create<AEADBlockCipher>(algorithmName);
       |
       |  /// Process [len] bytes from [inp] starting at offset [inpOff] and output the
       |  /// result to [out] at offset [outOff].
       |  ///
       |  /// Returns the number of bytes written to the output.
       |  int processBytes(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff);
       |
       |  /// Finish the operation either appending or verifying the MAC at the end of
       |  /// the data.
       |  ///
       |  /// Returns the number of bytes written to the output.
       |  int doFinal(Uint8List out, int outOff);
       |}
       |
       |class InvalidCipherTextException implements Exception {
       |  final String message;
       |
      0|  InvalidCipherTextException(this.message);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/key_generator.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// The interface that asymmetric key generators conform to.
       |///
       |/// A [KeyGenerator] is used to create a pair of public and private keys.
       |abstract class KeyGenerator extends Algorithm {
       |  /// Create the key generator specified by the standard [algorithmName].
      0|  factory KeyGenerator(String algorithmName) =>
      0|      registry.create<KeyGenerator>(algorithmName);
       |
       |  /// Init the generator with its initialization [params]. The type of [CipherParameters] depends on the algorithm being used
       |  /// (see the documentation of each implementation to find out more).
       |  void init(CipherParameters params);
       |
       |  /// Generate a key pair.
       |  AsymmetricKeyPair generateKeyPair();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/asymmetric_key_pair.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// A pair of public and private asymmetric keys.
       |class AsymmetricKeyPair<B extends PublicKey, V extends PrivateKey> {
       |  final B publicKey;
       |  final V privateKey;
       |
      1|  AsymmetricKeyPair(this.publicKey, this.privateKey);
       |
      0|  @override
       |  bool operator ==(Object other) =>
       |      identical(this, other) ||
      0|      other is AsymmetricKeyPair &&
      0|          runtimeType == other.runtimeType &&
      0|          publicKey == other.publicKey &&
      0|          privateKey == other.privateKey;
       |
      0|  @override
      0|  int get hashCode => publicKey.hashCode ^ privateKey.hashCode;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/key_parameter.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// [CipherParameters] consisting of just a key of arbitrary length.
       |class KeyParameter extends CipherParameters {
       |  Uint8List key;
       |
      1|  KeyParameter(this.key);
       |
      0|  KeyParameter.offset(Uint8List key, int keyOff, int keyLen) {
      0|    this.key = Uint8List(keyLen);
      0|    arrayCopy(key, keyOff, this.key, 0, keyLen);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/parameters_with_salt.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// [CipherParameters] consisting of an underlying [CipherParameters] (of type
       |/// [UnderlyingParameters]) and an acompanying salt of type [Uint8List].
       |class ParametersWithSalt<UnderlyingParameters extends CipherParameters>
       |    implements CipherParameters {
       |  final UnderlyingParameters parameters;
       |  final Uint8List salt;
       |
      0|  ParametersWithSalt(this.parameters, this.salt);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/key_derivator.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// The interface that a symmetric key derivator conforms to.
       |///
       |/// A [KeyDerivator] is normally used to convert some master data (like a password, for instance) to a symmetric key.
       |abstract class KeyDerivator extends Algorithm {
       |  /// Create the key derivator specified by the standard [algorithmName].
      0|  factory KeyDerivator(String algorithmName) =>
      0|      registry.create<KeyDerivator>(algorithmName);
       |
       |  /// Get this derivator key's output size.
       |  int get keySize;
       |
       |  /// Init the derivator with its initialization [params]. The type of [CipherParameters] depends on the algorithm being used
       |  /// (see the documentation of each implementation to find out more).
       |  void init(CipherParameters params);
       |
       |  /// Process a whole block of [data] at once, returning the result in a byte array.
       |  Uint8List process(Uint8List data);
       |
       |  /// Derive key from given input and put it in [out] at offset [outOff].
       |  int deriveKey(Uint8List inp, int inpOff, Uint8List out, int outOff);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/padded_block_cipher_parameters.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// [CipherParameters] for [PaddedBlockCipher]s consisting of two underlying [CipherParameters], one for the [BlockCipher] (of
       |/// type [UnderlyingCipherParameters]) and the other for the [Padding] (of type [PaddingCipherParameters]).
       |class PaddedBlockCipherParameters<
       |        UnderlyingCipherParameters extends CipherParameters,
       |        PaddingCipherParameters extends CipherParameters>
       |    implements CipherParameters {
       |  final UnderlyingCipherParameters underlyingCipherParameters;
       |  final PaddingCipherParameters paddingCipherParameters;
       |
      0|  PaddedBlockCipherParameters(
       |      this.underlyingCipherParameters, this.paddingCipherParameters);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/secure_random.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// A synchronous secure random number generator (RNG).
       |///
       |/// Being synchronous, this RNG cannot return direct results from sources of randomness like
       |/// '/dev/random' or similar. For that, use an **EntropySource** which allows to be called
       |/// asynchronously. Usually an **EntropySource** should be seen like a random generation device while
       |/// a [SecureRandom] should be seen like a cryptographic PRNG. Thus, data from an **EntropySource**
       |/// should be seen as 'more random' than that returned from a [SecureRandom].
       |abstract class SecureRandom extends Algorithm {
       |  /// Create the secure random specified by the standard [algorithmName].
      0|  factory SecureRandom([String algorithmName = '']) =>
      0|      registry.create<SecureRandom>(algorithmName);
       |
       |  /// Seed the RNG with some entropy (look at package cipher_entropy providing entropy sources).
       |  void seed(CipherParameters params);
       |
       |  /// Get one byte long random int.
       |  int nextUint8();
       |
       |  /// Get two bytes long random int.
       |  int nextUint16();
       |
       |  /// Get four bytes long random int.
       |  int nextUint32();
       |
       |  /// Get a random BigInteger of [bitLength] bits.
       |  BigInt nextBigInteger(int bitLength);
       |
       |  /// Get a list of bytes of arbitrary length.
       |  Uint8List nextBytes(int count);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/key_generator_parameters.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// Abstract [CipherParameters] to init an asymmetric key generator.
       |abstract class KeyGeneratorParameters implements CipherParameters {
       |  final int bitStrength;
       |
      1|  KeyGeneratorParameters(this.bitStrength);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/mac.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// The interface that a MAC (message authentication code) conforms to.
       |abstract class Mac extends Algorithm {
       |  /// Create the MAC specified by the standard [algorithmName].
      0|  factory Mac(String algorithmName) => registry.create<Mac>(algorithmName);
       |
       |  /// Get this MAC's output size.
       |  int get macSize;
       |
       |  /// Reset the MAC to its original state.
       |  void reset();
       |
       |  /// Init the MAC with its initialization [params]. The type of
       |  /// [CipherParameters] depends on the algorithm being used (see
       |  /// the documentation of each implementation to find out more).
       |  void init(CipherParameters params);
       |
       |  /// Process a whole block of [data] at once, returning the result in a new
       |  /// byte array.
       |  Uint8List process(Uint8List data);
       |
       |  /// Add one byte of data to the MAC input.
       |  void updateByte(int inp);
       |
       |  /// Add [len] bytes of data contained in [inp], starting at position [inpOff]
       |  /// to the MAC'ed input.
       |  void update(Uint8List inp, int inpOff, int len);
       |
       |  /// Store the MAC of previously given data in buffer [out] starting at
       |  /// offset [outOff]. This method returns the size of the digest.
       |  int doFinal(Uint8List out, int outOff);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/xof.dart
       |part of api;
       |
       |abstract class Xof extends Digest {
       |  /// Create the Xof specified by the standard [algorithmName].
      0|  factory Xof(String algorithmName) => registry.create<Xof>(algorithmName);
       |
       |  ///
       |  int doFinalRange(Uint8List out, int outOff, int outLen);
       |
       |  int doOutput(Uint8List out, int outOff, int outLen);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/registry_factory_exception.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// This kind of exception is thrown when a user tries to create an algorithm
       |/// or domain parameters that were not correctly registered. This can be
       |/// because the corresponding class was not imported, or because the algorithm
       |/// does not exist.
       |class RegistryFactoryException implements Exception {
       |  final String message;
       |
      0|  RegistryFactoryException(this.message);
       |
      0|  RegistryFactoryException.unknown(String algorithm, [Type type])
      0|      : this('No algorithm registered' +
      0|            (type != null ? ' of type $type' : '') +
      0|            ' with name: $algorithm');
       |
      0|  RegistryFactoryException.invalid(String algorithm, [Type type])
      0|      : this('Algorithm name $algorithm is invalid' +
      0|            (type != null ? ' of type $type' : ''));
       |
      0|  @override
      0|  String toString() => 'RegistryFactoryException: $message';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/digest.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// The interface that a message digest conforms to.
       |abstract class Digest extends Algorithm {
       |  /// Create the digest specified by the standard [algorithmName].
      0|  factory Digest(String algorithmName) =>
      0|      registry.create<Digest>(algorithmName);
       |
       |  /// Get this digest's output size in bytes
       |  int get digestSize;
       |
       |  /// Return the size in bytes of the internal buffer the digest applies
       |  /// it's compression function to.
       |  int get byteLength;
       |
       |  /// Reset the digest to its original state.
       |  void reset();
       |
       |  /// Process a whole block of [data] at once, returning the result in a new byte array.
       |  Uint8List process(Uint8List data);
       |
       |  /// Add one byte of data to the digested input.
       |  void updateByte(int inp);
       |
       |  /// Add [len] bytes of data contained in [inp], starting at position [inpOff]
       |  /// ti the digested input.
       |  void update(Uint8List inp, int inpOff, int len);
       |
       |  /// Store the digest of previously given data in buffer [out] starting at
       |  /// offset [outOff]. This method returns the size of the digest.
       |  int doFinal(Uint8List out, int outOff);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/padded_block_cipher.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// All padded block ciphers conform to this interface.
       |///
       |/// A padded block cipher is a wrapper around a [BlockCipher] that allows padding the last procesed
       |/// block (when encrypting) in the following way:
       |///
       |/// *If it is smaller than the [blockSize] it will be padded to [blockSize] bytes.
       |/// *If it is equal to the [blockSize] a pad block will be added.
       |///
       |/// When decrypting, a [PaddedBlockCipher] also removes the padding from the last cipher text block.
       |///
       |/// It is advised to use method [process] as it is much easier than making the correct calls to
       |/// [processBlock] and [doFinal] which are different depending on whether you are encrypting or
       |/// decrypting and also depending on the data length being a multiple of the cipher's block size.
       |abstract class PaddedBlockCipher implements BlockCipher {
       |  /// Create the padded block cipher specified by the standard [algorithmName].
      0|  factory PaddedBlockCipher(String algorithmName) =>
      0|      registry.create<PaddedBlockCipher>(algorithmName);
       |
       |  /// Get the underlying [Padding] used by this cipher.
       |  Padding get padding;
       |
       |  /// Get the underlying [BlockCipher] used by this cipher.
       |  BlockCipher get cipher;
       |
       |  /// Process a whole block of [data] at once, returning the result in a byte array.
       |  ///
       |  /// This call does as many calls to [processBlock] as needed to process all the given data and a
       |  /// final one to [doFinal] so that the padding can do its job.
       |  @override
       |  Uint8List process(Uint8List data);
       |
       |  /// Process the last block of data given by [inp] and starting at offset [inpOff] and pad it as
       |  /// explained in this interface's description.
       |  ///
       |  /// For encryption, the resulting cipher text is put in [out] beginning at position [outOff] and
       |  /// the method returns the total bytes put in [out], including the padding. Note that, if [inp]
       |  /// length is equal to the cipher's block size, [out] will need to be twice the cipher's block size
       |  /// to allow place for the padding.
       |  ///
       |  /// For decryption, the resulting plain text is put in [out] beginning at position [outOff] and the
       |  /// method returns the total bytes put in [out], excluding the padding. Note that the method may
       |  /// return 0 if the last block was all padding.
       |  int doFinal(Uint8List inp, int inpOff, Uint8List out, int outOff);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/block_cipher.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// Block cipher engines are expected to conform to this interface.
       |abstract class BlockCipher extends Algorithm {
       |  /// Create the cipher specified by the standard [algorithmName].
      0|  factory BlockCipher(String algorithmName) =>
      0|      registry.create<BlockCipher>(algorithmName);
       |
       |  /// Get this ciphers's block size.
       |  int get blockSize;
       |
       |  /// Reset the cipher to its original state.
       |  void reset();
       |
       |  /// Init the cipher with its initialization [params]. The type of
       |  /// [CipherParameters] depends on the algorithm being used (see the
       |  /// documentation of each implementation to find out more).
       |  ///
       |  /// Use the argument [forEncryption] to tell the cipher if you want to encrypt
       |  /// or decrypt data.
       |  void init(bool forEncryption, CipherParameters params);
       |
       |  /// Process a whole block of [blockSize] bytes stored in [data] at once, returning the result in a
       |  /// byte array.
       |  ///
       |  /// This call is equivalent to [processBlock] but it allocates the array under the hood.
       |  Uint8List process(Uint8List data);
       |
       |  /// Process a whole block of data given by [inp] and starting at offset
       |  /// [inpOff].
       |  ///
       |  /// The resulting cipher text is put in [out] beginning at position [outOff].
       |  ///
       |  /// This method returns the total bytes processed (which is the same as the
       |  /// block size of the algorithm).
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/public_key_parameter.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// A [CipherParameters] to hold an asymmetric public key
       |class PublicKeyParameter<T extends PublicKey>
       |    extends AsymmetricKeyParameter<T> {
      2|  PublicKeyParameter(PublicKey key) : super(key as T);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/aead_parameters.dart
       |part of '../../api.dart';
       |
       |// ignore_for_file: omit_local_variable_types, prefer_single_quotes, non_constant_identifier_names, directives_ordering, prefer_typing_uninitialized_variables
       |
       |class AEADParameters<UnderlyingCipherParameters extends CipherParameters>
       |    implements CipherParameters {
       |  final UnderlyingCipherParameters parameters;
       |
       |  final Uint8List associatedData;
       |
       |  final Uint8List nonce;
       |
       |  final int macSize;
       |
      0|  AEADParameters(
       |      this.parameters, this.macSize, this.nonce, this.associatedData);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/asymmetric_key_parameter.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// Abstract [CipherParameters] to hold an asymmetric (public or private) key
       |abstract class AsymmetricKeyParameter<T extends AsymmetricKey>
       |    implements CipherParameters {
       |  final T key;
       |
      1|  AsymmetricKeyParameter(this.key);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/padding.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// The interface that a padding conforms to.
       |abstract class Padding extends Algorithm {
       |  /// Create the digest specified by the standard [algorithmName].
      0|  factory Padding(String algorithmName) =>
      0|      registry.create<Padding>(algorithmName);
       |
       |  /// Initialise the padder. Normally, paddings don't need any init params.
       |  void init([CipherParameters params]);
       |
       |  /// Process a whole block of [data] at once, returning the result in a byte array. If [pad] is
       |  /// true adds padding to the given block, otherwise, padding is removed.
       |  ///
       |  /// Note: this assumes that the last block of plain text is always passed to it inside [data]. The
       |  /// reason for this is that some modes such as 'trailing bit compliment' base the padding on the
       |  /// last byte of plain text.
       |  Uint8List process(bool pad, Uint8List data);
       |
       |  /// Add the pad bytes to the passed in block, returning the number of bytes added.
       |  ///
       |  /// Note: this assumes that the last block of plain text is always passed to it inside [data]. i.e.
       |  /// if [offset] is zero, indicating the entire block is to be overwritten with padding the value of
       |  /// [data] should be the same as the last block of plain text. The reason for this is that some
       |  /// modes such as 'trailing bit compliment' base the padding on the last byte of plain text.
       |  int addPadding(Uint8List data, int offset);
       |
       |  /// Get the number of pad bytes present in the block.
       |  int padCount(Uint8List data);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/parameters_with_random.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |//TODO consider mixin
       |/// [CipherParameters] consisting of an underlying [CipherParameters] (of type
       |/// [UnderlyingParameters]) and an acompanying [SecureRandom].
       |class ParametersWithRandom<UnderlyingParameters extends CipherParameters>
       |    implements CipherParameters {
       |  final UnderlyingParameters parameters;
       |  final SecureRandom random;
       |
      1|  ParametersWithRandom(this.parameters, this.random);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/private_key_parameter.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// A [CipherParameters] to hold an asymmetric private key
       |class PrivateKeyParameter<T extends PrivateKey>
       |    extends AsymmetricKeyParameter<T> {
      2|  PrivateKeyParameter(PrivateKey key) : super(key as T);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/api/asymmetric_block_cipher.dart
       |// See file LICENSE for more information.
       |
       |part of api;
       |
       |/// Asymmetric block cipher engines are expected to conform to this interface.
       |abstract class AsymmetricBlockCipher extends Algorithm {
       |  /// Create the cipher specified by the standard [algorithmName].
      0|  factory AsymmetricBlockCipher(String algorithmName) =>
      0|      registry.create<AsymmetricBlockCipher>(algorithmName);
       |
       |  /// Get this ciphers's maximum input block size.
       |  int get inputBlockSize;
       |
       |  /// Get this ciphers's maximum output block size.
       |  int get outputBlockSize;
       |
       |  /// Reset the cipher to its original state.
       |  void reset();
       |
       |  /// Init the cipher with its initialization [params]. The type of [CipherParameters] depends on the algorithm being used (see
       |  /// the documentation of each implementation to find out more).
       |  ///
       |  /// Use the argument [forEncryption] to tell the cipher if you want to encrypt or decrypt data.
       |  void init(bool forEncryption, CipherParameters params);
       |
       |  /// Process a whole block of [data] at once, returning the result in a byte array.
       |  Uint8List process(Uint8List data);
       |
       |  /// Process a block of [len]bytes given by [inp] and starting at offset [inpOff] and put the resulting cipher text in [out]
       |  /// beginning at position [outOff].
       |  ///
       |  /// This method returns the total bytes put in the output buffer.
       |  int processBlock(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/asn1_encoding_rule.dart
      1|enum ASN1EncodingRule {
       |  /// Normal DER encoding rules
      1|  ENCODING_DER,
       |
       |  /// BER encoding where the length is described in a long form
      1|  ENCODING_BER_LONG_LENGTH_FORM,
       |
       |  /// BER Constructed encoding with definite length
      1|  ENCODING_BER_CONSTRUCTED,
       |
       |  /// BER encoding with padded bits to make the length of the value bytes a multiple of eight. Only used for ASN1BitString
      1|  ENCODING_BER_PADDED,
       |
       |  /// BER Constructed encoding with indefinite length
      1|  ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/asn1_object.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_utils.dart';
       |
       |///
       |/// Base model for all ASN1Objects
       |///
       |class ASN1Object {
       |  ///
       |  /// The BER tag representing this object.
       |  ///
       |  /// For a list of all supported BER tags take a look in the **Asn1Tags** class.
       |  ///
       |  int tag;
       |
       |  ///
       |  /// The encoded bytes.
       |  ///
       |  Uint8List encodedBytes;
       |
       |  ///
       |  /// The value bytes.
       |  ///
       |  Uint8List valueBytes;
       |
       |  ///
       |  /// The index where the value bytes start. This is the position after the tag + length bytes.
       |  ///
       |  /// The default value for this field is 2. If the length byte is larger than **127**, the value of this field will increase depending on the length bytes.
       |  ///
       |  int valueStartPosition = 2;
       |
       |  ///
       |  /// Length of the encoded value bytes.
       |  ///
       |  int valueByteLength;
       |
       |  ///
       |  /// Describes if this ASN1 Object is constructed.
       |  ///
       |  /// The object is marked as constructed if bit 6 of the [tag] field has value **1**
       |  ///
       |  bool isConstructed;
       |
       |  int dumpIndent = 2;
       |
      0|  ASN1Object({this.tag}) {
      0|    if (tag != null) {
      0|      isConstructed = ASN1Utils.isConstructed(tag);
       |    }
       |  }
       |
       |  ///
       |  /// Creates a new ASN1Object from the given [encodedBytes].
       |  ///
       |  /// The first byte will be used as the [tag].The field [valueStartPosition] and [valueByteLength] will be calculated on the given [encodedBytes].
       |  ///
      0|  ASN1Object.fromBytes(this.encodedBytes) {
      0|    tag = encodedBytes[0];
      0|    isConstructed = ASN1Utils.isConstructed(tag);
      0|    valueByteLength = ASN1Utils.decodeLength(encodedBytes);
      0|    valueStartPosition = ASN1Utils.calculateValueStartPosition(encodedBytes);
      0|    if (valueByteLength == -1) {
       |      // Indefinite length, check the last to bytes
      0|      if (ASN1Utils.hasIndefiniteLengthEnding(encodedBytes)) {
      0|        valueByteLength = encodedBytes.length - 4;
       |      }
       |    }
      0|    valueBytes = Uint8List.view(encodedBytes.buffer,
      0|        valueStartPosition + encodedBytes.offsetInBytes, valueByteLength);
       |  }
       |
       |  ///
       |  /// Encode the object to their byte representation.
       |  ///
       |  /// [encodingRule] defines if the [valueByteLength] should be encoded as indefinite length (0x80) or fixed length with short/long form.
       |  /// The default is [ASN1EncodingRule.ENCODING_DER] which will automatically decode in definite length with short form.
       |  ///
       |  /// **Important note**: Subclasses need to override this method and may call this method. If this method is called by a subclass, the subclass has to set the [valueBytes] before calling super.encode().
       |  ///
      0|  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
      0|    if (encodedBytes == null) {
       |      // Encode the length
       |      Uint8List lengthAsBytes;
      0|      valueByteLength ??= valueBytes.length;
       |      // Check if we have indefinite length or fixed length (short or longform)
      0|      if (encodingRule ==
       |          ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH) {
       |        // Set length to 0x80
      0|        lengthAsBytes = Uint8List.fromList([0x80]);
       |        // Add 2 to the valueByteLength to handle the 0x00, 0x00 at the end
       |        //valueByteLength = valueByteLength + 2;
       |      } else {
      0|        lengthAsBytes = ASN1Utils.encodeLength(valueByteLength,
       |            longform:
      0|                encodingRule == ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM);
       |      }
       |      // Create the Uint8List with the calculated length
      0|      encodedBytes = Uint8List(1 + lengthAsBytes.length + valueByteLength);
       |      // Set the tag
      0|      encodedBytes[0] = tag;
       |      // Set the length bytes
      0|      encodedBytes.setRange(1, 1 + lengthAsBytes.length, lengthAsBytes, 0);
       |      // Set the value bytes
      0|      encodedBytes.setRange(
      0|          1 + lengthAsBytes.length, encodedBytes.length, valueBytes, 0);
       |    }
      0|    return encodedBytes;
       |  }
       |
       |  ///
       |  /// The total length of this object, including its value bytes, the encoded tag and length bytes.
       |  ///
      0|  int get totalEncodedByteLength => valueStartPosition + valueByteLength;
       |
       |  ///
       |  /// Creates a readable dump from the current ASN1Object.
       |  ///
       |  /// **Important note**: Subclasses need to override this method. If the ASN1Object is constructed and has child elements, dump() has to be called for each child element.
       |  ///
      0|  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    if (tag == 0xA0 || tag == 0xA3) {
      0|      sb.write('[$tag]');
      0|      var parser = ASN1Parser(valueBytes);
      0|      var next = parser.nextObject();
      0|      var dump = next.dump(spaces: spaces + dumpIndent);
      0|      sb.write('\n$dump');
       |    }
      0|    sb.write('UNKNOWN');
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/asn1_parser.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/asn1_utils.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_bit_string.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_boolean.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_generalized_time.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_ia5_string.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_integer.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_null.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_object_identifier.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_octet_string.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_printable_string.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_sequence.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_set.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_teletext_string.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_utc_time.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_utf8_string.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_tag_exception.dart';
       |
       |///
       |/// The ASN1Parser to parse bytes into ASN1 Objects
       |///
       |class ASN1Parser {
       |  ///
       |  /// The bytes to parse
       |  ///
       |  final Uint8List bytes;
       |
       |  ///
       |  /// The current position in the byte array.
       |  ///
       |  /// The inital value is 0.
       |  ///
       |  int _position = 0;
       |
      0|  ASN1Parser(this.bytes);
       |
       |  ///
       |  /// Returns true if there is still an object to parse. Otherwise false.
       |  ///
      0|  bool hasNext() {
      0|    return _position < bytes.length;
       |  }
       |
       |  ///
       |  /// Parses the next object in the [bytes].
       |  ///
      0|  ASN1Object nextObject() {
       |    // Get the current tag in the list bytes
      0|    var tag = bytes[_position];
       |
       |    // Get the length of the value bytes for the current object
      0|    var length = ASN1Utils.decodeLength(bytes.sublist(_position));
       |
       |    var valueStartPosition =
      0|        ASN1Utils.calculateValueStartPosition(bytes.sublist(_position));
      0|    if (_position < length + valueStartPosition) {
      0|      length = length + valueStartPosition;
       |    } else {
      0|      length = bytes.length - _position;
       |    }
       |
       |    // Create new view from the bytes
      0|    var offset = _position + bytes.offsetInBytes;
      0|    var subBytes = Uint8List.view(bytes.buffer, offset, length);
       |
       |    // Parse the view and the tag to an ASN1Object
      0|    var isConstructed = ASN1Utils.isConstructed(tag);
      0|    var isPrimitive = (0xC0 & tag) == 0;
       |    //var isApplication = (0x40 & tag) != 0;
       |
       |    ASN1Object obj;
       |    if (isConstructed) {
      0|      obj = _createConstructed(tag, subBytes);
       |    } else if (isPrimitive) {
      0|      obj = _createPrimitive(tag, subBytes);
       |    } else {
       |      // create a vanilla object
      0|      obj = ASN1Object.fromBytes(subBytes);
       |    }
       |
       |    // Update the position
      0|    _position = _position + obj.totalEncodedByteLength;
       |    return obj;
       |  }
       |
       |  ///
       |  /// Creates a constructed ASN1Object depending on the given [tag] and [bytes]
       |  ///
      0|  ASN1Object _createConstructed(int tag, Uint8List bytes) {
       |    switch (tag) {
      0|      case ASN1Tags.SEQUENCE: // sequence
      0|        return ASN1Sequence.fromBytes(bytes);
      0|      case ASN1Tags.SET:
      0|        return ASN1Set.fromBytes(bytes);
      0|      case ASN1Tags.IA5_STRING_CONSTRUCTED:
      0|        return ASN1IA5String.fromBytes(bytes);
      0|      case ASN1Tags.BIT_STRING_CONSTRUCTED:
      0|        return ASN1BitString.fromBytes(bytes);
      0|      case ASN1Tags.OCTET_STRING_CONSTRUCTED:
      0|        return ASN1OctetString.fromBytes(bytes);
      0|      case ASN1Tags.PRINTABLE_STRING_CONSTRUCTED:
      0|        return ASN1PrintableString.fromBytes(bytes);
      0|      case ASN1Tags.T61_STRING_CONSTRUCTED:
      0|        return ASN1TeletextString.fromBytes(bytes);
      0|      case 0xA0:
      0|      case 0xA1:
      0|      case 0xA2:
      0|      case 0xA3:
      0|        return ASN1Object.fromBytes(bytes);
       |      default:
      0|        throw UnsupportedASN1TagException(tag);
       |    }
       |  }
       |
       |  ///
       |  /// Creates a primitive ASN1Object depending on the given [tag] and [bytes]
       |  ///
      0|  ASN1Object _createPrimitive(int tag, Uint8List bytes) {
       |    switch (tag) {
      0|      case ASN1Tags.OCTET_STRING:
      0|        return ASN1OctetString.fromBytes(bytes);
      0|      case ASN1Tags.UTF8_STRING:
      0|        return ASN1UTF8String.fromBytes(bytes);
      0|      case ASN1Tags.IA5_STRING:
      0|        return ASN1IA5String.fromBytes(bytes);
      0|      case ASN1Tags.INTEGER:
      0|      case ASN1Tags.ENUMERATED:
      0|        return ASN1Integer.fromBytes(bytes);
      0|      case ASN1Tags.BOOLEAN:
      0|        return ASN1Boolean.fromBytes(bytes);
      0|      case ASN1Tags.OBJECT_IDENTIFIER:
      0|        return ASN1ObjectIdentifier.fromBytes(bytes);
      0|      case ASN1Tags.BIT_STRING:
      0|        return ASN1BitString.fromBytes(bytes);
      0|      case ASN1Tags.NULL:
      0|        return ASN1Null.fromBytes(bytes);
      0|      case ASN1Tags.PRINTABLE_STRING:
      0|        return ASN1PrintableString.fromBytes(bytes);
      0|      case ASN1Tags.UTC_TIME:
      0|        return ASN1UtcTime.fromBytes(bytes);
      0|      case ASN1Tags.T61_STRING:
      0|        return ASN1TeletextString.fromBytes(bytes);
      0|      case ASN1Tags.GENERALIZED_TIME:
      0|        return ASN1GeneralizedTime.fromBytes(bytes);
       |      default:
      0|        throw UnsupportedASN1TagException(tag);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/asn1_utils.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |
       |///
       |/// Utils class holding different methods to ease the handling of ANS1Objects and their byte representation.
       |///
       |class ASN1Utils {
       |  ///
       |  /// Calculates the start position of the value bytes for the given [encodedBytes].
       |  ///
       |  /// It will return 2 if the **length byte** is less than 127 or the length calculate on the **length byte** value.
       |  /// This will throw a [RangeError] if the given [encodedBytes] has length < 2.
       |  ///
      0|  static int calculateValueStartPosition(Uint8List encodedBytes) {
      0|    var length = encodedBytes[1];
      0|    if (length < 0x7F) {
       |      return 2;
       |    } else {
      0|      return 2 + (length & 0x7F);
       |    }
       |  }
       |
       |  ///
       |  /// Calculates the length of the **value bytes** for the given [encodedBytes].
       |  ///
       |  /// Will return **-1** if the length byte equals **0x80**. Throws an [ArgumentError] if the length could not be calculated for the given [encodedBytes].
       |  ///
      0|  static int decodeLength(Uint8List encodedBytes) {
       |    var valueStartPosition = 2;
      0|    var length = encodedBytes[1];
      0|    if (length < 0x7F) {
       |      return length;
       |    }
      0|    if (length == 0x80) {
      0|      return -1;
       |    }
      0|    if (length > 127) {
      0|      var length = encodedBytes[1] & 0x7F;
       |
       |      var numLengthBytes = length;
       |
       |      length = 0;
      0|      for (var i = 0; i < numLengthBytes; i++) {
      0|        length <<= 8;
      0|        length |= (encodedBytes[valueStartPosition++] & 0xFF);
       |      }
       |      return length;
       |    }
      0|    throw ArgumentError('Could not calculate the length from the given bytes.');
       |  }
       |
       |  ///
       |  /// Encode the given [length] to byte representation.
       |  ///
      0|  static Uint8List encodeLength(int length, {bool longform = false}) {
       |    Uint8List e;
      0|    if (length <= 127 && longform == false) {
      0|      e = Uint8List(1);
      0|      e[0] = length;
       |    } else {
      0|      var x = Uint32List(1);
      0|      x[0] = length;
      0|      var y = Uint8List.view(x.buffer);
       |      // Skip null bytes
       |      var num = 3;
      0|      while (y[num] == 0) {
      0|        --num;
       |      }
      0|      e = Uint8List(num + 2);
      0|      e[0] = 0x80 + num + 1;
      0|      for (var i = 1; i < e.length; ++i) {
      0|        e[i] = y[num--];
       |      }
       |    }
       |    return e;
       |  }
       |
       |  ///
       |  /// Checks if the given int [i] is constructed according to <https://www.bouncycastle.org/asn1_layman_93.txt> section 3.2.
       |  ///
       |  /// The Identifier octets (represented by the given [i]) is marked as constructed if bit 6 has the value **1**.
       |  ///
       |  /// Example with the IA5 String tag:
       |  ///
       |  /// 0x36 = 0 0 1 1 0 1 1 0
       |  ///
       |  /// 0x16 = 0 0 0 1 0 1 1 0
       |  /// ```
       |  /// ASN1Utils.isConstructed(0x36);  // true
       |  /// ASN1Utils.isConstructed(0x16);  // false
       |  /// ```
       |  ///
       |  ///
      0|  static bool isConstructed(int i) {
       |    // Shift bits
      0|    var newNum = i >> (6 - 1);
       |    // Check if bit is set to 1
      0|    return (newNum & 1) == 1;
       |  }
       |
      0|  static bool isASN1Tag(int i) {
      0|    return ASN1Tags.TAGS.contains(i);
       |  }
       |
       |  ///
       |  /// Checks if the given [bytes] ends with 0x00, 0x00
       |  ///
      0|  static bool hasIndefiniteLengthEnding(Uint8List bytes) {
      0|    var last = bytes.elementAt(bytes.length - 1);
      0|    var lastMinus1 = bytes.elementAt(bytes.length - 2);
      0|    if (last == 0 && lastMinus1 == 0) {
       |      return true;
       |    }
       |    return false;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_bit_string.dart
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/asn1_utils.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 Bit String object
       |///
       |class ASN1BitString extends ASN1Object {
       |  ///
       |  /// The decoded string value
       |  ///
       |  List<int> stringValues;
       |
       |  ///
       |  /// The unused bits
       |  ///
       |  int unusedbits;
       |
       |  ///
       |  /// A list of elements. Only set if this ASN1IA5String is constructed, otherwhise null.
       |  ///
       |  ///
       |  List<ASN1Object> elements;
       |
       |  ///
       |  /// Create an [ASN1BitString] entity with the given [stringValues].
       |  ///
      0|  ASN1BitString(
       |      {this.stringValues, this.elements, int tag = ASN1Tags.BIT_STRING})
      0|      : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1BitString] entity from the given [encodedBytes].
       |  ///
      0|  ASN1BitString.fromBytes(Uint8List bytes) : super.fromBytes(bytes) {
      0|    if (ASN1Utils.isConstructed(encodedBytes.elementAt(0))) {
      0|      elements = [];
      0|      var parser = ASN1Parser(valueBytes);
      0|      stringValues = [];
      0|      while (parser.hasNext()) {
      0|        var bitString = parser.nextObject() as ASN1BitString;
      0|        stringValues.addAll(bitString.stringValues);
      0|        elements.add(bitString);
       |      }
       |    } else {
      0|      unusedbits = valueBytes[0];
      0|      stringValues = valueBytes.sublist(1);
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  /// * [ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH]
       |  /// * [ASN1EncodingRule.ENCODING_BER_PADDED]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
       |    switch (encodingRule) {
      0|      case ASN1EncodingRule.ENCODING_BER_PADDED:
      0|      case ASN1EncodingRule.ENCODING_DER:
      0|      case ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM:
      0|        var b = <int>[];
      0|        if (unusedbits != null) {
      0|          b.add(unusedbits);
       |        }
      0|        b.addAll(stringValues);
      0|        valueBytes = Uint8List.fromList(b);
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH:
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED:
      0|        valueByteLength = 0;
      0|        if (elements == null) {
      0|          elements.add(ASN1BitString(stringValues: stringValues));
       |        }
      0|        valueByteLength = _childLength(
      0|            isIndefinite: encodingRule ==
       |                ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH);
      0|        valueBytes = Uint8List(valueByteLength);
       |        var i = 0;
      0|        elements.forEach((obj) {
      0|          var b = obj.encode();
      0|          valueBytes.setRange(i, i + b.length, b);
      0|          i += b.length;
       |        });
       |        break;
       |    }
       |
      0|    return super.encode(encodingRule: encodingRule);
       |  }
       |
       |  ///
       |  /// Calculate encoded length of all children
       |  ///
      0|  int _childLength({bool isIndefinite = false}) {
       |    var l = 0;
      0|    elements.forEach((ASN1Object obj) {
      0|      l += obj.encode().length;
       |    });
       |    if (isIndefinite) {
      0|      return l + 2;
       |    }
       |    return l;
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    if (isConstructed) {
      0|      sb.write('BIT STRING (${elements.length} elem)');
      0|      for (var e in elements) {
      0|        var dump = e.dump(spaces: spaces + dumpIndent);
      0|        sb.write('\n$dump');
       |      }
       |    } else {
      0|      if (ASN1Utils.isASN1Tag(stringValues.elementAt(0))) {
      0|        var parser = ASN1Parser(stringValues);
      0|        var next = parser.nextObject();
      0|        var dump = next.dump(spaces: spaces + dumpIndent);
      0|        sb.write('BIT STRING\n$dump');
       |      } else {
      0|        sb.write(
      0|            'BIT STRING ${ascii.decode(stringValues, allowInvalid: true)}');
       |      }
       |    }
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_boolean.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 Boolean object
       |///
       |class ASN1Boolean extends ASN1Object {
       |  bool boolValue;
       |
       |  ///
       |  /// The byte to use for the TRUE value
       |  ///
       |  static const int BOOLEAN_TRUE_VALUE = 0xff;
       |
       |  ///
       |  /// The byte to use for the FALSE value
       |  ///
       |  static const int BOOLEAN_FALSE_VALUE = 0x00;
       |
       |  ///
       |  /// Creates an [ASN1Boolean] entity with the given [boolValue].
       |  ///
      0|  ASN1Boolean(this.boolValue, {int tag = ASN1Tags.BOOLEAN}) : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1Boolean] entity from the given [encodedBytes].
       |  ///
      0|  ASN1Boolean.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    boolValue = (valueBytes[0] == BOOLEAN_TRUE_VALUE);
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
      0|    if (encodingRule != ASN1EncodingRule.ENCODING_DER) {
      0|      throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
      0|    valueByteLength = 1;
      0|    valueBytes = (boolValue == true)
      0|        ? Uint8List.fromList([BOOLEAN_TRUE_VALUE])
      0|        : Uint8List.fromList([BOOLEAN_FALSE_VALUE]);
      0|    return super.encode();
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    sb.write('Boolean $boolValue');
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_enumerated.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/primitives/asn1_integer.dart';
       |
       |///
       |/// An ASN1Enumerated object
       |///
       |class ASN1Enumerated extends ASN1Integer {
       |  ///
       |  /// Create an [ASN1Enumerated] entity with the given integer [i].
       |  ///
      0|  ASN1Enumerated(int i, {int tag = ASN1Tags.ENUMERATED})
      0|      : super(BigInt.from(i), tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1Enumerated] entity from the given [encodedBytes].
       |  ///
      0|  ASN1Enumerated.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_generalized_time.dart
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |class ASN1GeneralizedTime extends ASN1Object {
       |  // The decoded date value
       |  DateTime dateTimeValue;
       |
       |  ///
       |  /// Create an [ASN1GeneralizedTime] entity with the given BigInt [dateTimeValue].
       |  ///
      0|  ASN1GeneralizedTime(this.dateTimeValue, {int tag = ASN1Tags.GENERALIZED_TIME})
      0|      : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1GeneralizedTime] entity from the given [encodedBytes].
       |  ///
      0|  ASN1GeneralizedTime.fromBytes(Uint8List bytes) : super.fromBytes(bytes) {
      0|    var octets = valueBytes;
      0|    var stringValue = ascii.decode(octets);
      0|    var year = stringValue.substring(0, 4);
      0|    var month = stringValue.substring(4, 6);
      0|    var day = stringValue.substring(6, 8);
      0|    var hour = stringValue.substring(8, 10);
      0|    var minute = stringValue.substring(10, 12);
      0|    var second = stringValue.substring(12, 14);
      0|    if (stringValue.length > 14) {
      0|      var timeZone = stringValue.substring(14, stringValue.length);
      0|      dateTimeValue =
      0|          DateTime.parse('$year-$month-$day $hour:$minute:$second$timeZone');
       |    } else {
      0|      dateTimeValue = DateTime.parse('$year-$month-$day $hour:$minute:$second');
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
      0|    if (encodingRule != ASN1EncodingRule.ENCODING_DER) {
      0|      throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
      0|    var utc = dateTimeValue.toUtc();
      0|    var year = utc.year.toString();
      0|    var month = utc.month.toString();
      0|    var day = utc.day.toString();
      0|    var hour = utc.hour.toString();
      0|    var minute = utc.minute.toString();
      0|    var second = utc.second.toString();
       |    // Encode string to YYMMDDhhmm[ss]Z
      0|    var utcString = '$year$month$day$hour$minute${second}Z';
      0|    valueBytes = ascii.encode(utcString);
      0|    valueByteLength = valueBytes.length;
      0|    return super.encode();
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    sb.write('UTCTime ${dateTimeValue.toIso8601String()}');
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_ia5_string.dart
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/asn1_utils.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 IA5 String object
       |///
       |class ASN1IA5String extends ASN1Object {
       |  ///
       |  /// The ascii decoded string value
       |  ///
       |  String stringValue;
       |
       |  ///
       |  /// A list of elements. Only set if this ASN1IA5String is constructed, otherwhise null.
       |  ///
       |  List<ASN1Object> elements;
       |
       |  ///
       |  /// Create an [ASN1IA5String] entity with the given [stringValue].
       |  ///
      0|  ASN1IA5String(
       |      {this.stringValue, this.elements, int tag = ASN1Tags.IA5_STRING})
      0|      : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1IA5String] entity from the given [encodedBytes].
       |  ///
      0|  ASN1IA5String.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    if (ASN1Utils.isConstructed(encodedBytes.elementAt(0))) {
      0|      elements = [];
      0|      var parser = ASN1Parser(valueBytes);
      0|      var sb = StringBuffer();
      0|      while (parser.hasNext()) {
      0|        var ia5String = parser.nextObject() as ASN1IA5String;
      0|        sb.write(ia5String.stringValue);
      0|        elements.add(ia5String);
       |      }
      0|      stringValue = sb.toString();
       |    } else {
      0|      stringValue = ascii.decode(valueBytes);
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  /// * [ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
       |    switch (encodingRule) {
      0|      case ASN1EncodingRule.ENCODING_DER:
      0|      case ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM:
      0|        var octets = ascii.encode(stringValue);
      0|        valueByteLength = octets.length;
      0|        valueBytes = Uint8List.fromList(octets);
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH:
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED:
      0|        valueByteLength = 0;
      0|        if (elements == null) {
      0|          elements.add(ASN1IA5String(stringValue: stringValue));
       |        }
      0|        valueByteLength = _childLength(
      0|            isIndefinite: encodingRule ==
       |                ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH);
      0|        valueBytes = Uint8List(valueByteLength);
       |        var i = 0;
      0|        elements.forEach((obj) {
      0|          var b = obj.encode();
      0|          valueBytes.setRange(i, i + b.length, b);
      0|          i += b.length;
       |        });
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_PADDED:
      0|        throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
       |
      0|    return super.encode(encodingRule: encodingRule);
       |  }
       |
       |  ///
       |  /// Calculate encoded length of all children
       |  ///
      0|  int _childLength({bool isIndefinite = false}) {
       |    var l = 0;
      0|    elements.forEach((ASN1Object obj) {
      0|      l += obj.encode().length;
       |    });
       |    if (isIndefinite) {
      0|      return l + 2;
       |    }
       |    return l;
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    if (isConstructed) {
      0|      sb.write('IA5String (${elements.length} elem)');
      0|      for (var e in elements) {
      0|        var dump = e.dump(spaces: spaces + dumpIndent);
      0|        sb.write('\n $dump');
       |      }
       |    } else {
      0|      sb.write('IA5String $stringValue');
       |    }
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_integer.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |import 'package:pointycastle/src/utils.dart';
       |
       |class ASN1Integer extends ASN1Object {
       |  ///
       |  /// The integer value
       |  ///
       |  BigInt integer;
       |
       |  ///
       |  /// Create an [ASN1Integer] entity with the given BigInt [integer].
       |  ///
      0|  ASN1Integer(this.integer, {int tag = ASN1Tags.INTEGER}) : super(tag: tag);
       |
       |  ///
       |  /// Create an [ASN1Integer] entity with the given int [i].
       |  ///
      0|  ASN1Integer.fromtInt(int i, {int tag = ASN1Tags.INTEGER}) : super(tag: tag) {
      0|    integer = BigInt.from(i);
       |  }
       |
       |  ///
       |  /// Creates an [ASN1Integer] entity from the given [encodedBytes].
       |  ///
      0|  ASN1Integer.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    integer = decodeBigInt(valueBytes);
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
      0|    if (encodingRule != ASN1EncodingRule.ENCODING_DER) {
      0|      throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
      0|    if (integer.bitLength == 0) {
      0|      if (integer == BigInt.from(-1)) {
      0|        valueBytes = Uint8List.fromList([0xff]);
       |      } else {
      0|        valueBytes = Uint8List.fromList([0]);
       |      }
       |    } else {
      0|      valueBytes = encodeBigInt(integer);
       |    }
      0|    valueByteLength = valueBytes.length;
      0|    return super.encode();
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    sb.write('INTEGER ${integer.toString().toUpperCase()}');
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_null.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 Null object
       |///
       |class ASN1Null extends ASN1Object {
       |  ///
       |  /// Creates an empty [ASN1Null] entity with only the [tag] set.
       |  ///
      0|  ASN1Null({int tag = ASN1Tags.NULL}) : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1Null] entity from the given [encodedBytes].
       |  ///
      0|  ASN1Null.fromBytes(Uint8List encodedBytes) : super.fromBytes(encodedBytes);
       |
       |  ///
       |  /// Encode the [ASN1Null] to the byte representation.
       |  ///
       |  /// This basically returns **[0x05, 0x00]** or **[0x05, 0x81, 0x00]** depending on the [encodingRule] and will not call the *super.encode()* method.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  /// * [ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM]
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
       |    switch (encodingRule) {
      0|      case ASN1EncodingRule.ENCODING_DER:
      0|        return Uint8List.fromList([tag, 0x00]);
      0|      case ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM:
      0|        return Uint8List.fromList([tag, 0x81, 0x00]);
       |      default:
      0|        throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    sb.write('NULL');
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_object_identifier.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/object_identifiers.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |import 'package:pointycastle/asn1/unsupported_object_identifier_exception.dart';
       |
       |class ASN1ObjectIdentifier extends ASN1Object {
       |  ///
       |  /// The object identifier integer values
       |  ///
       |  List<int> objectIdentifier;
       |
       |  ///
       |  /// The String representation of the [objectIdentifier]
       |  ///
       |  String objectIdentifierAsString;
       |
       |  ///
       |  /// The readable representation of the [objectIdentifier]
       |  ///
       |  String readableName;
       |
       |  ///
       |  /// Create an [ASN1ObjectIdentifier] entity with the given [objectIdentifier].
       |  ///
      0|  ASN1ObjectIdentifier(this.objectIdentifier,
       |      {int tag = ASN1Tags.OBJECT_IDENTIFIER})
      0|      : super(tag: tag) {
      0|    objectIdentifierAsString = objectIdentifier.join('.');
       |  }
       |
       |  ///
       |  /// Creates an [ASN1ObjectIdentifier] entity from the given [encodedBytes].
       |  ///
      0|  ASN1ObjectIdentifier.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
       |    var value = 0;
       |    var first = true;
       |    BigInt bigValue;
      0|    var list = <int>[];
      0|    var sb = StringBuffer();
      0|    valueBytes.forEach((element) {
      0|      var b = element & 0xff;
      0|      if (value < 0x80000000000000) {
      0|        value = value * 128 + (b & 0x7f);
      0|        if ((b & 0x80) == 0) {
       |          if (first) {
      0|            var truncated = value ~/ 40;
      0|            if (truncated < 2) {
      0|              list.add(truncated);
      0|              sb.write(truncated);
      0|              value -= truncated * 40;
       |            } else {
      0|              list.add(2);
      0|              sb.write('2');
      0|              value -= 80;
       |            }
       |            first = false;
       |          }
      0|          list.add(value);
      0|          sb.write('.$value');
       |          value = 0;
       |        }
       |      } else {
      0|        bigValue ??= BigInt.from(value);
      0|        bigValue = bigValue << (7);
      0|        bigValue = bigValue | BigInt.from(b & 0x7f);
      0|        if ((b & 0x80) == 0) {
      0|          sb.write('.$bigValue');
       |          bigValue = null;
       |          value = 0;
       |        }
       |      }
       |    });
      0|    objectIdentifierAsString = sb.toString();
      0|    objectIdentifier = Uint8List.fromList(list);
       |    var identifier =
      0|        ObjectIdentifiers.getIdentifierByIdentifier(objectIdentifierAsString);
       |    if (identifier != null) {
      0|      readableName = identifier['readableName'] as String;
       |    }
       |  }
       |
       |  ///
       |  /// Creates an [ASN1ObjectIdentifier] entity from the given [name].
       |  ///
       |  /// Example:
       |  /// ```
       |  /// var oi = ASN1ObjectIdentifier.fromName('ecdsaWithSHA256');
       |  /// ```
       |  ///
       |  /// Throws an [UnsupportedObjectIdentifierException] if the given [name] is not supported
       |  ///
      0|  ASN1ObjectIdentifier.fromName(String name) {
      0|    tag = ASN1Tags.OBJECT_IDENTIFIER;
      0|    var identifier = ObjectIdentifiers.getIdentifierByName(name);
       |    if (identifier == null) {
      0|      throw UnsupportedObjectIdentifierException(name);
       |    }
      0|    objectIdentifierAsString = identifier['identifierString'] as String;
      0|    readableName = identifier['readableName'] as String;
      0|    objectIdentifier = identifier['identifier'] as List<int>;
       |  }
       |
       |  ///
       |  /// Creates an [ASN1ObjectIdentifier] entity from the given [objectIdentifierAsString].
       |  ///
       |  /// Example:
       |  /// ```
       |  /// var oi = ASN1ObjectIdentifier.fromName('2.5.4.3');
       |  /// ```
       |  ///
       |  /// Throws an [UnsupportedObjectIdentifierException] if the given [objectIdentifierAsString] is not supported
       |  ///
      0|  ASN1ObjectIdentifier.fromIdentifierString(this.objectIdentifierAsString,
       |      {int tag = ASN1Tags.OBJECT_IDENTIFIER})
      0|      : super(tag: tag) {
       |    var identifier =
      0|        ObjectIdentifiers.getIdentifierByIdentifier(objectIdentifierAsString);
       |    if (identifier == null) {
      0|      throw UnsupportedObjectIdentifierException(objectIdentifierAsString);
       |    }
      0|    objectIdentifierAsString = identifier['identifierString'] as String;
      0|    readableName = identifier['readableName'] as String;
      0|    objectIdentifier = identifier['identifier'] as List<int>;
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
      0|    if (encodingRule != ASN1EncodingRule.ENCODING_DER) {
      0|      throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
      0|    var oi = <int>[];
      0|    oi.add(objectIdentifier[0] * 40 + objectIdentifier[1]);
       |
      0|    for (var ci = 2; ci < objectIdentifier.length; ci++) {
      0|      var position = oi.length;
      0|      var v = objectIdentifier[ci];
       |      assert(v > 0);
       |
       |      var first = true;
       |      do {
      0|        var remainder = v & 127;
      0|        v = v >> 7;
       |        if (first) {
       |          first = false;
       |        } else {
      0|          remainder |= 0x80;
       |        }
       |
      0|        oi.insert(position, remainder);
      0|      } while (v > 0);
       |    }
       |
      0|    valueBytes = Uint8List.fromList(oi);
      0|    valueByteLength = oi.length;
       |
      0|    return super.encode();
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    sb.write('OBJECT IDENTIFIER $objectIdentifierAsString $readableName');
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_octet_string.dart
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/asn1_utils.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 Octed String object
       |///
       |class ASN1OctetString extends ASN1Object {
       |  ///
       |  /// The decoded string value
       |  ///
       |  Uint8List octets;
       |
       |  ///
       |  /// A list of elements. Only set if this ASN1OctetString is constructed, otherwhise null.
       |  ///
       |  List<ASN1Object> elements;
       |
       |  ///
       |  /// Create an [ASN1OctetString] entity with the given [octets].
       |  ///
      0|  ASN1OctetString({this.octets, this.elements, int tag = ASN1Tags.OCTET_STRING})
      0|      : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1OctetString] entity from the given [encodedBytes].
       |  ///
      0|  ASN1OctetString.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    if (ASN1Utils.isConstructed(encodedBytes.elementAt(0))) {
      0|      elements = [];
      0|      var parser = ASN1Parser(valueBytes);
      0|      var bytes = <int>[];
      0|      while (parser.hasNext()) {
      0|        var octetString = parser.nextObject() as ASN1OctetString;
      0|        bytes.addAll(octetString.octets);
      0|        elements.add(octetString);
       |      }
      0|      octets = Uint8List.fromList(bytes);
       |    } else {
      0|      octets = valueBytes;
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  /// * [ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
       |    switch (encodingRule) {
      0|      case ASN1EncodingRule.ENCODING_DER:
      0|      case ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM:
      0|        valueByteLength = octets.length;
      0|        valueBytes = octets;
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED:
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH:
      0|        valueByteLength = 0;
      0|        if (elements == null) {
      0|          elements.add(ASN1OctetString(octets: octets));
       |        }
      0|        valueByteLength = _childLength(
      0|            isIndefinite: encodingRule ==
       |                ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH);
      0|        valueBytes = Uint8List(valueByteLength);
       |        var i = 0;
      0|        elements.forEach((obj) {
      0|          var b = obj.encode();
      0|          valueBytes.setRange(i, i + b.length, b);
      0|          i += b.length;
       |        });
       |        break;
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_PADDED:
      0|        throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
      0|    return super.encode(encodingRule: encodingRule);
       |  }
       |
       |  ///
       |  /// Calculate encoded length of all children
       |  ///
      0|  int _childLength({bool isIndefinite = false}) {
       |    var l = 0;
      0|    elements.forEach((ASN1Object obj) {
      0|      l += obj.encode().length;
       |    });
       |    if (isIndefinite) {
      0|      return l + 2;
       |    }
       |    return l;
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    if (isConstructed) {
      0|      sb.write('OCTET STRING (${elements.length} elem)');
      0|      for (var e in elements) {
      0|        var dump = e.dump(spaces: spaces + dumpIndent);
      0|        sb.write('\n $dump');
       |      }
       |    } else {
      0|      if (ASN1Utils.isASN1Tag(octets.elementAt(0))) {
      0|        var parser = ASN1Parser(octets);
      0|        var next = parser.nextObject();
      0|        var dump = next.dump(spaces: spaces + dumpIndent);
      0|        sb.write('OCTET STRING\n$dump');
       |      } else {
      0|        sb.write('OCTET STRING ${ascii.decode(octets, allowInvalid: true)}');
       |      }
       |    }
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_printable_string.dart
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/asn1_utils.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 Printable String object
       |///
       |class ASN1PrintableString extends ASN1Object {
       |  ///
       |  /// The ascii decoded string value
       |  ///
       |  String stringValue;
       |
       |  ///
       |  /// A list of elements. Only set if this ASN1PrintableString is constructed, otherwhise null.
       |  ///
       |  List<ASN1Object> elements;
       |
       |  ///
       |  /// Create an [ASN1PrintableString] entity with the given [stringValue].
       |  ///
      0|  ASN1PrintableString(
       |      {this.stringValue, this.elements, int tag = ASN1Tags.PRINTABLE_STRING})
      0|      : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1PrintableString] entity from the given [encodedBytes].
       |  ///
      0|  ASN1PrintableString.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    if (ASN1Utils.isConstructed(encodedBytes.elementAt(0))) {
      0|      elements = [];
      0|      var parser = ASN1Parser(valueBytes);
      0|      var sb = StringBuffer();
      0|      while (parser.hasNext()) {
      0|        var printableString = parser.nextObject() as ASN1PrintableString;
      0|        sb.write(printableString.stringValue);
      0|        elements.add(printableString);
       |      }
      0|      stringValue = sb.toString();
       |    } else {
      0|      stringValue = ascii.decode(valueBytes);
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  /// * [ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
       |    switch (encodingRule) {
      0|      case ASN1EncodingRule.ENCODING_DER:
      0|      case ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM:
      0|        var octets = ascii.encode(stringValue);
      0|        valueByteLength = octets.length;
      0|        valueBytes = Uint8List.fromList(octets);
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH:
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED:
      0|        valueByteLength = 0;
      0|        if (elements == null) {
      0|          elements.add(ASN1PrintableString(stringValue: stringValue));
       |        }
      0|        valueByteLength = _childLength(
      0|            isIndefinite: encodingRule ==
       |                ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH);
      0|        valueBytes = Uint8List(valueByteLength);
       |        var i = 0;
      0|        elements.forEach((obj) {
      0|          var b = obj.encode();
      0|          valueBytes.setRange(i, i + b.length, b);
      0|          i += b.length;
       |        });
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_PADDED:
      0|        throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
       |
      0|    return super.encode(encodingRule: encodingRule);
       |  }
       |
       |  ///
       |  /// Calculate encoded length of all children
       |  ///
      0|  int _childLength({bool isIndefinite = false}) {
       |    var l = 0;
      0|    elements.forEach((ASN1Object obj) {
      0|      l += obj.encode().length;
       |    });
       |    if (isIndefinite) {
      0|      return l + 2;
       |    }
       |    return l;
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    if (isConstructed) {
      0|      sb.write('PrintableString (${elements.length} elem)');
      0|      for (var e in elements) {
      0|        var dump = e.dump(spaces: spaces + dumpIndent);
      0|        sb.write('\n$dump');
       |      }
       |    } else {
      0|      sb.write('PrintableString $stringValue');
       |    }
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_sequence.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |class ASN1Sequence extends ASN1Object {
       |  ///
       |  /// The decoded string value
       |  ///
       |  List<ASN1Object> elements = [];
       |
       |  ///
       |  /// Create an [ASN1Sequence] entity with the given [elements].
       |  ///
      0|  ASN1Sequence({this.elements, int tag = ASN1Tags.SEQUENCE}) : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1Sequence] entity from the given [encodedBytes].
       |  ///
      0|  ASN1Sequence.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    elements = [];
      0|    var parser = ASN1Parser(valueBytes);
      0|    while (parser.hasNext()) {
      0|      elements.add(parser.nextObject());
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
      0|    if (encodingRule != ASN1EncodingRule.ENCODING_DER) {
      0|      throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
      0|    valueBytes = Uint8List(0);
      0|    valueByteLength = 0;
      0|    if (elements != null) {
      0|      valueByteLength = _childLength();
      0|      valueBytes = Uint8List(valueByteLength);
       |      var i = 0;
      0|      elements.forEach((obj) {
      0|        var b = obj.encode();
      0|        valueBytes.setRange(i, i + b.length, b);
      0|        i += b.length;
       |      });
       |    }
      0|    return super.encode();
       |  }
       |
       |  ///
       |  /// Calculate encoded length of all children
       |  ///
      0|  int _childLength() {
       |    var l = 0;
      0|    elements.forEach((ASN1Object obj) {
      0|      l += obj.encode().length;
       |    });
       |    return l;
       |  }
       |
       |  ///
       |  /// Adds the given [obj] to the [elements] list.
       |  ///
      0|  void add(ASN1Object obj) {
      0|    elements ??= [];
      0|    elements.add(obj);
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    sb.write('SEQUENCE (${elements.length} elem)');
      0|    for (var e in elements) {
      0|      var dump = e.dump(spaces: spaces + dumpIndent);
      0|      sb.write('\n$dump');
       |    }
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_set.dart
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |class ASN1Set extends ASN1Object {
       |  ///
       |  /// The decoded string value
       |  ///
       |  List<ASN1Object> elements;
       |
       |  ///
       |  /// Create an [ASN1Set] entity with the given [elements].
       |  ///
      0|  ASN1Set({this.elements, int tag = ASN1Tags.SET}) : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1Set] entity from the given [encodedBytes].
       |  ///
      0|  ASN1Set.fromBytes(Uint8List encodedBytes) : super.fromBytes(encodedBytes) {
      0|    elements = [];
      0|    var parser = ASN1Parser(valueBytes);
      0|    while (parser.hasNext()) {
      0|      elements.add(parser.nextObject());
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
      0|    if (encodingRule != ASN1EncodingRule.ENCODING_DER) {
      0|      throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
      0|    valueBytes = Uint8List(0);
      0|    valueByteLength = 0;
      0|    if (elements != null) {
      0|      valueByteLength = _childLength();
      0|      valueBytes = Uint8List(valueByteLength);
       |      var i = 0;
      0|      elements.forEach((obj) {
      0|        var b = obj.encode();
      0|        valueBytes.setRange(i, i + b.length, b);
      0|        i += b.length;
       |      });
       |    }
      0|    return super.encode();
       |  }
       |
       |  ///
       |  /// Calculate encoded length of all children
       |  ///
      0|  int _childLength() {
       |    var l = 0;
      0|    elements.forEach((ASN1Object obj) {
      0|      l += obj.encode().length;
       |    });
       |    return l;
       |  }
       |
       |  ///
       |  /// Adds the given [obj] to the [elements] list.
       |  ///
      0|  void add(ASN1Object obj) {
      0|    elements ??= [];
      0|    elements.add(obj);
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    sb.write('SEQUENCE (${elements.length} elem)');
      0|    for (var e in elements) {
      0|      var dump = e.dump(spaces: spaces + dumpIndent);
      0|      sb.write('\n$dump');
       |    }
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_teletext_string.dart
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/asn1_utils.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 Octed String object
       |///
       |class ASN1TeletextString extends ASN1Object {
       |  ///
       |  /// The ascii decoded string value
       |  ///
       |  String stringValue;
       |
       |  ///
       |  /// A list of elements. Only set if this ASN1TeletextString is constructed, otherwhise null.
       |  ///
       |  List<ASN1Object> elements;
       |
       |  ///
       |  /// Create an [ASN1TeletextString] entity with the given [stringValue].
       |  ///
      0|  ASN1TeletextString(
       |      {this.stringValue, this.elements, int tag = ASN1Tags.T61_STRING})
      0|      : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1TeletextString] entity from the given [encodedBytes].
       |  ///
      0|  ASN1TeletextString.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    if (ASN1Utils.isConstructed(encodedBytes.elementAt(0))) {
      0|      elements = [];
      0|      var parser = ASN1Parser(valueBytes);
      0|      var sb = StringBuffer();
      0|      while (parser.hasNext()) {
      0|        var printableString = parser.nextObject() as ASN1TeletextString;
      0|        sb.write(printableString.stringValue);
      0|        elements.add(printableString);
       |      }
      0|      stringValue = sb.toString();
       |    } else {
      0|      stringValue = ascii.decode(valueBytes);
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  /// * [ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
       |    switch (encodingRule) {
      0|      case ASN1EncodingRule.ENCODING_DER:
      0|      case ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM:
      0|        var octets = ascii.encode(stringValue);
      0|        valueByteLength = octets.length;
      0|        valueBytes = Uint8List.fromList(octets);
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH:
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED:
      0|        valueByteLength = 0;
      0|        if (elements == null) {
      0|          elements.add(ASN1TeletextString(stringValue: stringValue));
       |        }
      0|        valueByteLength = _childLength(
      0|            isIndefinite: encodingRule ==
       |                ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH);
      0|        valueBytes = Uint8List(valueByteLength);
       |        var i = 0;
      0|        elements.forEach((obj) {
      0|          var b = obj.encode();
      0|          valueBytes.setRange(i, i + b.length, b);
      0|          i += b.length;
       |        });
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_PADDED:
      0|        throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
       |
      0|    return super.encode(encodingRule: encodingRule);
       |  }
       |
       |  ///
       |  /// Calculate encoded length of all children
       |  ///
      0|  int _childLength({bool isIndefinite = false}) {
       |    var l = 0;
      0|    elements.forEach((ASN1Object obj) {
      0|      l += obj.encode().length;
       |    });
       |    if (isIndefinite) {
      0|      return l + 2;
       |    }
       |    return l;
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    if (isConstructed) {
      0|      sb.write('T61String (${elements.length} elem)');
      0|      for (var e in elements) {
      0|        var dump = e.dump(spaces: spaces + dumpIndent);
      0|        sb.write('\n $dump');
       |      }
       |    } else {
      0|      sb.write('T61String $stringValue');
       |    }
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_utc_time.dart
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 Utc Time object
       |///
       |/// **Note**: It is not recommended to use the UTC Time in the far future because this will not work anymore after the year 2075,
       |/// due to the fact that the UTC Time only uses 2 digits to represent the year.!
       |///
       |/// Use the **GeneralizedTime** instead!
       |///
       |class ASN1UtcTime extends ASN1Object {
       |  ///
       |  /// The decoded DateTime value
       |  ///
       |  DateTime time;
       |
       |  ///
       |  /// Creates an [ASN1UtcTime] entity with the given [time].
       |  ///
      0|  ASN1UtcTime(this.time, {int tag = ASN1Tags.UTC_TIME}) : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1UtcTime] entity from the given [encodedBytes].
       |  ///
      0|  ASN1UtcTime.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    var stringValue = ascii.decode(valueBytes);
      0|    var formatedStringValue = _format(stringValue);
      0|    time = DateTime.parse(formatedStringValue);
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
      0|    if (encodingRule != ASN1EncodingRule.ENCODING_DER) {
      0|      throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
      0|    var utc = time.toUtc();
      0|    var year = utc.year.toString().substring(2).padLeft(2, '0');
      0|    var month = utc.month.toString().padLeft(2, '0');
      0|    var day = utc.day.toString().padLeft(2, '0');
      0|    var hour = utc.hour.toString().padLeft(2, '0');
      0|    var minute = utc.minute.toString().padLeft(2, '0');
      0|    var second = utc.second.toString().padLeft(2, '0');
       |    // Encode string to YYMMDDhhmm[ss]Z
      0|    var utcString = '$year$month$day$hour$minute${second}Z';
      0|    valueBytes = ascii.encode(utcString);
      0|    valueByteLength = valueBytes.length;
      0|    return super.encode();
       |  }
       |
       |  ///
       |  /// Formats the given [stringValue].
       |  ///
       |  /// This needs to be done, due to the fact that the UTC Time only uses 2 digits to represent the year.
       |  /// To use the DateTime.parse() method we have to add the century.
       |  ///
       |  /// **Note**: It is not recommended to use the UTC Time in the future because this will not work anymore after the year 2075! Use the GeneralizedTime instead.
       |  ///
      0|  String _format(String stringValue) {
      0|    var y2 = int.parse(stringValue.substring(0, 2));
      0|    if (y2 > 75) {
      0|      stringValue = '19' + stringValue;
       |    } else {
      0|      stringValue = '20' + stringValue;
       |    }
      0|    return stringValue.substring(0, 8) + 'T' + stringValue.substring(8);
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    sb.write('UTCTime ${time.toIso8601String()}');
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/primitives/asn1_utf8_string.dart
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |import 'package:pointycastle/asn1/asn1_object.dart';
       |import 'package:pointycastle/asn1/asn1_parser.dart';
       |import 'package:pointycastle/asn1/asn1_tags.dart';
       |import 'package:pointycastle/asn1/asn1_utils.dart';
       |import 'package:pointycastle/asn1/unsupported_asn1_encoding_rule_exception.dart';
       |
       |///
       |/// An ASN1 UTF8 String object
       |///
       |class ASN1UTF8String extends ASN1Object {
       |  ///
       |  /// The decoded string value
       |  ///
       |  String utf8StringValue;
       |
       |  ///
       |  /// A list of elements. Only set if this ASN1UTF8String is constructed, otherwhise null.
       |  ///
       |  List<ASN1Object> elements;
       |
       |  ///
       |  /// Creates an empty [ASN1UTF8String] entity with only the [tag] set.
       |  ///
      0|  ASN1UTF8String(
       |      {this.utf8StringValue, this.elements, int tag = ASN1Tags.UTF8_STRING})
      0|      : super(tag: tag);
       |
       |  ///
       |  /// Creates an [ASN1UTF8String] entity from the given [encodedBytes].
       |  ///
      0|  ASN1UTF8String.fromBytes(Uint8List encodedBytes)
      0|      : super.fromBytes(encodedBytes) {
      0|    if (ASN1Utils.isConstructed(encodedBytes.elementAt(0))) {
      0|      elements = [];
      0|      var parser = ASN1Parser(valueBytes);
      0|      var sb = StringBuffer();
      0|      while (parser.hasNext()) {
      0|        var utf8String = parser.nextObject() as ASN1UTF8String;
      0|        sb.write(utf8String.utf8StringValue);
      0|        elements.add(utf8String);
       |      }
      0|      utf8StringValue = sb.toString();
       |    } else {
      0|      utf8StringValue = utf8.decode(valueBytes);
       |    }
       |  }
       |
       |  ///
       |  /// Encodes this ASN1Object depending on the given [encodingRule]
       |  ///
       |  /// If no [ASN1EncodingRule] is given, ENCODING_DER will be used.
       |  ///
       |  /// Supported encoding rules are :
       |  /// * [ASN1EncodingRule.ENCODING_DER]
       |  /// * [ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED]
       |  /// * [ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH]
       |  ///
       |  /// Throws an [UnsupportedAsn1EncodingRuleException] if the given [encodingRule] is not supported.
       |  ///
      0|  @override
       |  Uint8List encode(
       |      {ASN1EncodingRule encodingRule = ASN1EncodingRule.ENCODING_DER}) {
       |    switch (encodingRule) {
      0|      case ASN1EncodingRule.ENCODING_DER:
      0|      case ASN1EncodingRule.ENCODING_BER_LONG_LENGTH_FORM:
      0|        var octets = utf8.encode(utf8StringValue);
      0|        valueByteLength = octets.length;
      0|        valueBytes = Uint8List.fromList(octets);
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH:
      0|      case ASN1EncodingRule.ENCODING_BER_CONSTRUCTED:
      0|        valueByteLength = 0;
      0|        if (elements == null) {
      0|          elements.add(ASN1UTF8String(utf8StringValue: utf8StringValue));
       |        }
      0|        valueByteLength = _childLength(
      0|            isIndefinite: encodingRule ==
       |                ASN1EncodingRule.ENCODING_BER_CONSTRUCTED_INDEFINITE_LENGTH);
      0|        valueBytes = Uint8List(valueByteLength);
       |        var i = 0;
      0|        elements.forEach((obj) {
      0|          var b = obj.encode();
      0|          valueBytes.setRange(i, i + b.length, b);
      0|          i += b.length;
       |        });
       |        break;
      0|      case ASN1EncodingRule.ENCODING_BER_PADDED:
      0|        throw UnsupportedAsn1EncodingRuleException(encodingRule);
       |    }
       |
      0|    return super.encode(encodingRule: encodingRule);
       |  }
       |
       |  ///
       |  /// Calculate encoded length of all children
       |  ///
      0|  int _childLength({bool isIndefinite = false}) {
       |    var l = 0;
      0|    elements.forEach((ASN1Object obj) {
      0|      l += obj.encode().length;
       |    });
       |    if (isIndefinite) {
      0|      return l + 2;
       |    }
       |    return l;
       |  }
       |
      0|  @override
       |  String dump({int spaces = 0}) {
      0|    var sb = StringBuffer();
      0|    for (var i = 0; i < spaces; i++) {
      0|      sb.write(' ');
       |    }
      0|    if (isConstructed) {
      0|      sb.write('UTF8String (${elements.length} elem)');
      0|      for (var e in elements) {
      0|        var dump = e.dump(spaces: spaces + dumpIndent);
      0|        sb.write('\n$dump');
       |      }
       |    } else {
      0|      sb.write('UTF8String $utf8StringValue');
       |    }
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/unsupported_asn1_encoding_rule_exception.dart
       |import 'package:pointycastle/asn1/asn1_encoding_rule.dart';
       |
       |///
       |/// Exception that indicates that the given [ASN1EncodingRule] is not supported
       |///
       |class UnsupportedAsn1EncodingRuleException implements Exception {
       |  ASN1EncodingRule rule;
       |
      0|  UnsupportedAsn1EncodingRuleException(this.rule);
       |
      0|  @override
       |  String toString() =>
      0|      'UnsupportedAsn1EncodingRuleException: Encoding $rule is not supported by this ASN1Object.';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/unsupported_asn1_tag_exception.dart
       |///
       |/// Exception that indicates that the given tag is not supported
       |///
       |class UnsupportedASN1TagException implements Exception {
       |  int tag;
       |
      0|  UnsupportedASN1TagException(this.tag);
       |
      0|  @override
       |  String toString() =>
      0|      'UnsupportedASN1TagException: Tag $tag is not supported yet';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/object_identifiers.dart
       |///
       |/// Class holding a list of object identifiers
       |///
       |class ObjectIdentifiers {
       |  ///
       |  /// A list of object identifiers, holding the identifier and a readable name.
       |  ///
       |  static const oi = [
       |    {
       |      'identifierString': '2.5.4.3',
       |      'readableName': 'commonName',
       |      'identifier': [2, 5, 4, 3]
       |    },
       |    {
       |      'identifierString': '2.5.4.6',
       |      'readableName': 'countryName',
       |      'identifier': [2, 5, 4, 6]
       |    },
       |    {
       |      'identifierString': '2.5.4.10',
       |      'readableName': 'organizationName',
       |      'identifier': [2, 5, 4, 10]
       |    },
       |    {
       |      'identifierString': '2.5.4.11',
       |      'readableName': 'organizationalUnitName',
       |      'identifier': [2, 5, 4, 11]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.4.1.311.60.2.1.3',
       |      'readableName': 'jurisdictionOfIncorporationC',
       |      'identifier': [1, 3, 6, 1, 4, 1, 311, 60, 2, 1, 3]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.4.1.311.60.2.1.2',
       |      'readableName': 'jurisdictionOfIncorporationSP',
       |      'identifier': [1, 3, 6, 1, 4, 1, 311, 60, 2, 1, 2]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.4.1.311.60.2.1.1',
       |      'readableName': 'jurisdictionOfIncorporationL',
       |      'identifier': [1, 3, 6, 1, 4, 1, 311, 60, 2, 1, 1]
       |    },
       |    {
       |      'identifierString': '2.5.4.15',
       |      'readableName': 'businessCategory',
       |      'identifier': [2, 5, 4, 15]
       |    },
       |    {
       |      'identifierString': '2.5.4.5',
       |      'readableName': 'serialNumber',
       |      'identifier': [2, 5, 4, 5]
       |    },
       |    {
       |      'identifierString': '2.5.4.8',
       |      'readableName': 'stateOrProvinceName',
       |      'identifier': [2, 5, 4, 8]
       |    },
       |    {
       |      'identifierString': '2.5.4.7',
       |      'readableName': 'localityName',
       |      'identifier': [2, 5, 4, 7]
       |    },
       |    {
       |      'identifierString': '1.2.840.113549.1.1.1',
       |      'readableName': 'rsaEncryption',
       |      'identifier': [1, 2, 840, 113549, 1, 1, 1]
       |    },
       |    {
       |      'identifierString': '2.5.29.17',
       |      'readableName': 'subjectAltName',
       |      'identifier': [2, 5, 29, 17]
       |    },
       |    {
       |      'identifierString': '2.5.29.32',
       |      'readableName': 'certificatePolicies',
       |      'identifier': [2, 5, 29, 32]
       |    },
       |    {
       |      'identifierString': '2.16.840.1.113733.1.7.23.6',
       |      'readableName': 'VeriSign EV policy',
       |      'identifier': [2, 16, 840, 1, 113733, 1, 7, 23, 6]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.5.5.7.2.1',
       |      'readableName': 'cps',
       |      'identifier': [1, 3, 6, 1, 5, 5, 7, 2, 1]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.5.5.7.2.2',
       |      'readableName': 'unotice',
       |      'identifier': [1, 3, 6, 1, 5, 5, 7, 2, 2]
       |    },
       |    {
       |      'identifierString': '2.5.29.31',
       |      'readableName': 'cRLDistributionPoints',
       |      'identifier': [2, 5, 29, 31]
       |    },
       |    {
       |      'identifierString': '2.5.29.37',
       |      'readableName': 'extKeyUsage',
       |      'identifier': [2, 5, 29, 37]
       |    },
       |    {
       |      'identifierString': '2.5.29.35',
       |      'readableName': 'authorityKeyIdentifier',
       |      'identifier': [2, 5, 29, 35]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.5.5.7.3.1',
       |      'readableName': 'serverAuth',
       |      'identifier': [1, 3, 6, 1, 5, 5, 7, 3, 1]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.5.5.7.3.2',
       |      'readableName': 'clientAuth',
       |      'identifier': [1, 3, 6, 1, 5, 5, 7, 3, 2]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.5.5.7.1.1',
       |      'readableName': 'authorityInfoAccess',
       |      'identifier': [1, 3, 6, 1, 5, 5, 7, 1, 1]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.5.5.7.48.1',
       |      'readableName': 'ocsp',
       |      'identifier': [1, 3, 6, 1, 5, 5, 7, 48, 1]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.5.5.7.48.2',
       |      'readableName': 'caIssuers',
       |      'identifier': [1, 3, 6, 1, 5, 5, 7, 48, 2]
       |    },
       |    {
       |      'identifierString': '1.2.840.113549.1.1.11',
       |      'readableName': 'sha256WithRSAEncryption',
       |      'identifier': [1, 2, 840, 113549, 1, 1, 11]
       |    },
       |    {
       |      'identifierString': '1.2.840.113549.1.1.4',
       |      'readableName': 'md5WithRSAEncryption',
       |      'identifier': [1, 2, 840, 113549, 1, 1, 4]
       |    },
       |    {
       |      'identifierString': '1.3.6.1.4.1.11129.2.4.2',
       |      'readableName': '2',
       |      'identifier': [1, 3, 6, 1, 4, 1, 11129, 2, 4, 2]
       |    },
       |    {
       |      'identifierString': '2.23.140.1.1',
       |      'readableName': 'ev-guidelines',
       |      'identifier': [2, 23, 140, 1, 1]
       |    },
       |    {
       |      'identifierString': '1.2.840.113549.1.1.5',
       |      'readableName': 'sha1WithRSAEncryption',
       |      'identifier': [1, 2, 840, 113549, 1, 1, 5]
       |    },
       |    {
       |      'identifierString': '1.2.840.10045.2.1',
       |      'readableName': 'ecPublicKey',
       |      'identifier': [1, 2, 840, 10045, 2, 1]
       |    },
       |    {
       |      'identifierString': '1.2.840.10045.3.1.7',
       |      'readableName': 'prime256v1',
       |      'identifier': [1, 2, 840, 10045, 3, 1, 7]
       |    },
       |    {
       |      'identifierString': '1.2.840.10045.4.3.2',
       |      'readableName': 'ecdsaWithSHA256',
       |      'identifier': [1, 2, 840, 10045, 4, 3, 2]
       |    },
       |    {
       |      'identifierString': '2.5.4.3',
       |      'readableName': 'CN',
       |      'identifier': [2, 5, 4, 3]
       |    },
       |    {
       |      'identifierString': '2.5.4.4',
       |      'readableName': 'SN',
       |      'identifier': [2, 5, 4, 4]
       |    },
       |    {
       |      'identifierString': '2.5.4.5',
       |      'readableName': 'SERIALNUMBER',
       |      'identifier': [2, 5, 4, 5]
       |    },
       |    {
       |      'identifierString': '2.5.4.6',
       |      'readableName': 'C',
       |      'identifier': [2, 5, 4, 6]
       |    },
       |    {
       |      'identifierString': '2.5.4.7',
       |      'readableName': 'L',
       |      'identifier': [2, 5, 4, 7]
       |    },
       |    {
       |      'identifierString': '2.5.4.8',
       |      'readableName': 'ST',
       |      'identifier': [2, 5, 4, 8]
       |    },
       |    {
       |      'identifierString': '2.5.4.8',
       |      'readableName': 'S',
       |      'identifier': [2, 5, 4, 8]
       |    },
       |    {
       |      'identifierString': '2.5.4.9',
       |      'readableName': 'streetAddress',
       |      'identifier': [2, 5, 4, 9]
       |    },
       |    {
       |      'identifierString': '2.5.4.9',
       |      'readableName': 'STREET',
       |      'identifier': [2, 5, 4, 9]
       |    },
       |    {
       |      'identifierString': '2.5.4.10',
       |      'readableName': 'O',
       |      'identifier': [2, 5, 4, 10]
       |    },
       |    {
       |      'identifierString': '2.5.4.11',
       |      'readableName': 'OU',
       |      'identifier': [2, 5, 4, 11]
       |    },
       |    {
       |      'identifierString': '2.5.4.12',
       |      'readableName': 'title',
       |      'identifier': [2, 5, 4, 12]
       |    },
       |    {
       |      'identifierString': '2.5.4.12',
       |      'readableName': 'T',
       |      'identifier': [2, 5, 4, 12]
       |    },
       |    {
       |      'identifierString': '2.5.4.12',
       |      'readableName': 'TITLE',
       |      'identifier': [2, 5, 4, 12]
       |    },
       |    {
       |      'identifierString': '2.5.4.42',
       |      'readableName': 'givenName',
       |      'identifier': [2, 5, 4, 42]
       |    },
       |    {
       |      'identifierString': '2.5.4.42',
       |      'readableName': 'G',
       |      'identifier': [2, 5, 4, 42]
       |    },
       |    {
       |      'identifierString': '2.5.4.42',
       |      'readableName': 'GN',
       |      'identifier': [2, 5, 4, 42]
       |    },
       |  ];
       |
       |  ///
       |  /// Returns the object identifier corresponding to the given [readableName].
       |  ///
       |  /// Returns null if none object identifier can be found for the given [readableName].
       |  ///
      0|  static Map<String, dynamic> getIdentifierByName(String readableName) {
      0|    for (var element in oi) {
      0|      if (element['readableName'] == readableName) {
       |        return element;
       |      }
       |    }
       |    return null;
       |  }
       |
       |  ///
       |  /// Returns the object identifier corresponding to the given [identifier].
       |  ///
       |  /// Returns null if none object identifier can be found for the given [identifier].
       |  ///
      0|  static Map<String, dynamic> getIdentifierByIdentifier(String identifier) {
      0|    for (var element in oi) {
      0|      if (element['identifierString'] == identifier) {
       |        return element;
       |      }
       |    }
       |    return null;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asn1/unsupported_object_identifier_exception.dart
       |///
       |/// Exception that indicates that the given object identifier is not supported
       |///
       |class UnsupportedObjectIdentifierException implements Exception {
       |  String oiString;
       |
      0|  UnsupportedObjectIdentifierException(this.oiString);
       |
      0|  @override
       |  String toString() =>
      0|      'UnsupportedObjectIdentifierException: ObjectIdentifier $oiString is not supported yet';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/utils.dart
       |// See file LICENSE for more information.
       |
       |library src.utils;
       |
       |import 'dart:typed_data';
       |
      0|void arrayCopy(
       |    Uint8List sourceArr, int sourcePos, Uint8List outArr, int outPos, int len) {
      0|  for (var i = 0; i < len; i++) {
      0|    outArr[outPos + i] = sourceArr[sourcePos + i];
       |  }
       |}
       |
      0|Uint8List concatUint8List(Iterable<Uint8List> list) =>
      0|    Uint8List.fromList(list.expand((element) => element).toList());
       |
       |/// Decode a BigInt from bytes in big-endian encoding.
      1|BigInt decodeBigInt(List<int> bytes) {
      1|  var result = BigInt.from(0);
      3|  for (var i = 0; i < bytes.length; i++) {
      8|    result += BigInt.from(bytes[bytes.length - i - 1]) << (8 * i);
       |  }
       |  return result;
       |}
       |
      3|var _byteMask = BigInt.from(0xff);
       |
       |/// Encode a BigInt into bytes using big-endian encoding.
      1|Uint8List encodeBigInt(BigInt number) {
       |  // Not handling negative numbers. Decide how you want to do that.
      3|  var size = (number.bitLength + 7) >> 3;
      1|  var result = Uint8List(size);
      2|  for (var i = 0; i < size; i++) {
      6|    result[size - i - 1] = (number & _byteMask).toInt();
      1|    number = number >> 8;
       |  }
       |  return result;
       |}
       |
      0|bool constantTimeAreEqual(Uint8List expected, Uint8List supplied) {
       |  if (expected == null || supplied == null) {
       |    return false;
       |  }
       |
      0|  if (expected == supplied) {
       |    return true;
       |  }
       |
       |  var len =
      0|      (expected.length < supplied.length) ? expected.length : supplied.length;
       |
      0|  var nonEqual = expected.length ^ supplied.length;
       |
      0|  for (var i = 0; i != len; i++) {
      0|    nonEqual |= (expected[i] ^ supplied[i]);
       |  }
      0|  for (var i = len; i < supplied.length; i++) {
      0|    nonEqual |= (supplied[i] ^ ~supplied[i]);
       |  }
       |
      0|  return nonEqual == 0;
       |}
       |
      0|bool constantTimeAreEqualOffset(
       |    int len, Uint8List a, int aOff, Uint8List b, int bOff) {
       |  if (null == a) {
      0|    throw ArgumentError('"a" cannot be null');
       |  }
       |  if (null == b) {
      0|    throw ArgumentError('"b" cannot be null');
       |  }
      0|  if (len < 0) {
      0|    throw ArgumentError('"len" cannot be negative');
       |  }
      0|  if (aOff > (a.length - len)) {
      0|    throw ArgumentError('"aOff" value invalid for specified length');
       |  }
      0|  if (bOff > (b.length - len)) {
      0|    throw ArgumentError('"bOff" value invalid for specified length');
       |  }
       |
       |  var d = 0;
      0|  for (var i = 0; i < len; ++i) {
      0|    d |= (a[aOff + i] ^ b[bOff + i]);
       |  }
      0|  return 0 == d;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asymmetric/api.dart
       |// See file LICENSE for more information.
       |
       |library api.asymmetric;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// Base class for asymmetric keys in RSA
       |abstract class RSAAsymmetricKey implements AsymmetricKey {
       |  // The parameters of this key
       |  final BigInt modulus;
       |  final BigInt exponent;
       |
       |  /// Create an asymmetric key for the given domain parameters
      1|  RSAAsymmetricKey(this.modulus, this.exponent);
       |
       |  /// Get modulus [n] = pq
      0|  BigInt get n => modulus;
       |}
       |
       |/// Private keys in RSA
       |class RSAPrivateKey extends RSAAsymmetricKey implements PrivateKey {
       |  // The secret prime factors of n
       |  final BigInt p;
       |  final BigInt q;
       |  final BigInt pubExponent;
       |
       |  /// Create an RSA private key for the given parameters.
      1|  RSAPrivateKey(BigInt modulus, BigInt privateExponent, this.p, this.q,
       |      [this.pubExponent])
      1|      : super(modulus, privateExponent);
       |
       |  /// Get private exponent [d] = e^-1
      0|  @Deprecated('Use privateExponent.')
      0|  BigInt get d => exponent;
       |
       |  /// Get the private exponent (d)
      2|  BigInt get privateExponent => exponent;
       |
       |  /// Get the public exponent (e)
      0|  BigInt get publicExponent => pubExponent;
       |
      0|  @override
       |  bool operator ==(other) {
      0|    if (other is RSAPrivateKey) {
      0|      return other.privateExponent == privateExponent &&
      0|          other.modulus == modulus;
       |    }
       |    return false;
       |  }
       |
      0|  @override
      0|  int get hashCode => modulus.hashCode + privateExponent.hashCode;
       |}
       |
       |/// Public keys in RSA
       |class RSAPublicKey extends RSAAsymmetricKey implements PublicKey {
       |  /// Create an RSA public key for the given parameters.
      2|  RSAPublicKey(BigInt modulus, BigInt exponent) : super(modulus, exponent);
       |
       |  /// Get public exponent [e]
      0|  @Deprecated('Use get publicExponent')
      0|  BigInt get e => exponent;
       |
       |  /// Get the public exponent.
      2|  BigInt get publicExponent => exponent;
       |
      0|  @override
       |  bool operator ==(other) {
      0|    if (other is RSAPublicKey) {
      0|      return (other.modulus == modulus) &&
      0|          (other.publicExponent == publicExponent);
       |    }
       |    return false;
       |  }
       |
      0|  @override
      0|  int get hashCode => modulus.hashCode + publicExponent.hashCode;
       |}
       |
       |/// A [Signature] created with RSA.
       |class RSASignature implements Signature {
       |  final Uint8List bytes;
       |
      1|  RSASignature(this.bytes);
       |
      0|  @override
      0|  String toString() => bytes.toString();
      0|  @override
       |  bool operator ==(other) {
       |    if (other == null) return false;
      0|    if (other is! RSASignature) return false;
      0|    if (other.bytes.length != bytes.length) return false;
       |
      0|    for (var i = 0; i < bytes.length; i++) {
      0|      if (bytes[i] != other.bytes[i]) {
       |        return false;
       |      }
       |    }
       |    return true;
       |  }
       |
      0|  @override
      0|  int get hashCode => bytes.hashCode;
       |}
       |
       |/// A [Signature] created with PSS.
       |class PSSSignature implements Signature {
       |  final Uint8List bytes;
       |
      0|  PSSSignature(this.bytes);
       |
      0|  @override
      0|  String toString() => bytes.toString();
       |
      0|  @override
       |  bool operator ==(other) {
      0|    if (other is! PSSSignature) return false;
      0|    if (other.bytes.length != bytes.length) return false;
       |
      0|    for (var i = 0; i < bytes.length; i++) {
      0|      if (bytes[i] != other.bytes[i]) {
       |        return false;
       |      }
       |    }
       |    return true;
       |  }
       |
      0|  @override
      0|  int get hashCode => bytes.hashCode;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/api.dart
       |// See file LICENSE for more information.
       |
       |library api.ecc;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Standard ECC curve description
       |abstract class ECDomainParameters {
       |  /// Get this domain's standard name.
       |  String get domainName;
       |
       |  ECCurve get curve;
       |
       |  List<int> get seed;
       |
       |  ECPoint get G;
       |
       |  BigInt get n;
       |
       |  /// Create a curve description from its standard name
      0|  factory ECDomainParameters(String domainName) =>
      0|      registry.create<ECDomainParameters>(domainName);
       |}
       |
       |/// Type for coordinates of an [ECPoint]
       |abstract class ECFieldElement {
       |  BigInt toBigInteger();
       |
       |  String get fieldName;
       |
       |  int get fieldSize;
       |
       |  int get byteLength;
       |
       |  ECFieldElement operator +(ECFieldElement b);
       |
       |  ECFieldElement operator -(ECFieldElement b);
       |
       |  ECFieldElement operator *(ECFieldElement b);
       |
       |  ECFieldElement operator /(ECFieldElement b);
       |
       |  ECFieldElement operator -();
       |
       |  ECFieldElement invert();
       |
       |  ECFieldElement square();
       |
       |  ECFieldElement sqrt();
       |}
       |
       |/// An elliptic curve point
       |abstract class ECPoint {
       |  ECCurve get curve;
       |
       |  ECFieldElement get x;
       |
       |  ECFieldElement get y;
       |
       |  bool get isCompressed;
       |
       |  bool get isInfinity;
       |
       |  @override
       |  bool operator ==(other);
       |
       |  Uint8List getEncoded([bool compressed = true]);
       |
       |  ECPoint operator +(ECPoint b);
       |
       |  ECPoint operator -(ECPoint b);
       |
       |  ECPoint operator -();
       |
       |  ECPoint twice();
       |
       |  /// Multiply this point by the given number [k].
       |  ECPoint operator *(BigInt k);
       |
      0|  @override
      0|  int get hashCode => super.hashCode;
       |}
       |
       |/// An elliptic curve
       |abstract class ECCurve {
       |  ECFieldElement get a;
       |
       |  ECFieldElement get b;
       |
       |  int get fieldSize;
       |
       |  ECPoint get infinity;
       |
       |  /// Create an [ECFieldElement]on this curve from its big integer value.
       |  ECFieldElement fromBigInteger(BigInt x);
       |
       |  /// Create an [ECPoint]on its curve from its coordinates
       |  ECPoint createPoint(BigInt x, BigInt y, [bool withCompression = false]);
       |
       |  ECPoint decompressPoint(int yTilde, BigInt x1);
       |
       |  /// Decode a point on this curve from its ASN.1 encoding. The different encodings are taken account of, including point
       |  /// compression for Fp (X9.62 s 4.2.1 pg 17).
       |  ECPoint decodePoint(List<int> encoded);
       |}
       |
       |/// Base class for asymmetric keys in ECC
       |abstract class ECAsymmetricKey implements AsymmetricKey {
       |  /// The domain parameters of this key
       |  final ECDomainParameters parameters;
       |
       |  /// Create an asymmetric key for the given domain parameters
      0|  ECAsymmetricKey(this.parameters);
       |}
       |
       |/// Private keys in ECC
       |class ECPrivateKey extends ECAsymmetricKey implements PrivateKey {
       |  /// ECC's d private parameter
       |  final BigInt d;
       |
       |  /// Create an ECC private key for the given d and domain parameters.
      0|  ECPrivateKey(this.d, ECDomainParameters parameters) : super(parameters);
      0|  @override
       |  bool operator ==(other) {
       |    if (other == null) return false;
      0|    if (other is! ECPrivateKey) return false;
      0|    return (other.parameters == parameters) && (other.d == d);
       |  }
       |
      0|  @override
       |  int get hashCode {
      0|    return parameters.hashCode + d.hashCode;
       |  }
       |}
       |
       |/// Public keys in ECC
       |class ECPublicKey extends ECAsymmetricKey implements PublicKey {
       |  /// ECC's Q public parameter
       |  final ECPoint Q;
       |
       |  /// Create an ECC public key for the given Q and domain parameters.
      0|  ECPublicKey(this.Q, ECDomainParameters parameters) : super(parameters);
      0|  @override
       |  bool operator ==(other) {
       |    if (other == null) return false;
      0|    if (other is! ECPublicKey) return false;
      0|    return (other.parameters == parameters) && (other.Q == Q);
       |  }
       |
      0|  @override
       |  int get hashCode {
      0|    return parameters.hashCode + Q.hashCode;
       |  }
       |}
       |
       |/// A [Signature] created with ECC.
       |class ECSignature implements Signature {
       |  final BigInt r;
       |  final BigInt s;
       |
      0|  ECSignature(this.r, this.s);
       |
       |  /// Returns true if s is in lower-s form, false otherwise.
      0|  bool isNormalized(ECDomainParameters curveParams) {
      0|    return !(s.compareTo(curveParams.n >> 1) > 0);
       |  }
       |
       |  ///
       |  /// 'normalize' this signature by converting its s to lower-s form if necessary
       |  /// This is required to validate this signature with some libraries such as libsecp256k1
       |  /// which enforce lower-s form for all signatures to combat ecdsa signature malleability
       |  ///
       |  /// Returns this if the signature was already normalized, or a copy if it is changed.
       |  ///
      0|  ECSignature normalize(ECDomainParameters curveParams) {
      0|    if (isNormalized(curveParams)) {
       |      return this;
       |    }
      0|    return ECSignature(r, curveParams.n - s);
       |  }
       |
      0|  @override
      0|  String toString() => '(${r.toString()},${s.toString()})';
      0|  @override
       |  bool operator ==(other) {
       |    if (other == null) return false;
      0|    if (other is! ECSignature) return false;
      0|    return (other.r == r) && (other.s == s);
       |  }
       |
      0|  @override
       |  int get hashCode {
      0|    return r.hashCode + s.hashCode;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/key_derivators/api.dart
       |// See file LICENSE for more information.
       |
       |library api.key_derivators;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// [CipherParameters] used by PBKDF2.
       |class Pbkdf2Parameters extends CipherParameters {
       |  final Uint8List salt;
       |  final int iterationCount;
       |  final int desiredKeyLength;
       |
      0|  Pbkdf2Parameters(this.salt, this.iterationCount, this.desiredKeyLength);
       |}
       |
       |/// [CipherParameters] for the scrypt password based key derivation function.
       |class ScryptParameters implements CipherParameters {
       |  final int N;
       |  final int r;
       |  final int p;
       |  final int desiredKeyLength;
       |  final Uint8List salt;
       |
      0|  ScryptParameters(this.N, this.r, this.p, this.desiredKeyLength, this.salt);
       |}
       |
       |/// Generates [CipherParameters] for HKDF key derivation function.
       |class HkdfParameters extends CipherParameters {
       |  final Uint8List ikm; // the input keying material or seed
       |  final int desiredKeyLength;
       |  final Uint8List
       |      salt; // the salt to use, may be null for a salt for hashLen zeros
       |  final Uint8List
       |      info; // the info to use, may be null for an info field of zero bytes
       |  final bool skipExtract;
       |
      0|  HkdfParameters._(this.ikm, this.desiredKeyLength,
       |      [this.salt, this.info, this.skipExtract = false]);
       |
      0|  factory HkdfParameters(ikm, desiredKeyLength,
       |      [salt, info, skipExtract = false]) {
       |    if (ikm == null) {
      0|      throw ArgumentError('IKM (input keying material) should not be null');
       |    }
       |
      0|    if (salt == null || salt.length == 0) {
       |      salt = null;
       |    }
       |
      0|    return HkdfParameters._(
      0|        ikm, desiredKeyLength, salt, info ?? Uint8List(0), skipExtract);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/key_generators/api.dart
       |// See file LICENSE for more information.
       |
       |library api.key_generators;
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/ecc/api.dart';
       |
       |/// Abstract [CipherParameters] to init an ECC key generator.
       |class ECKeyGeneratorParameters extends KeyGeneratorParameters {
       |  ECDomainParameters _domainParameters;
       |
      0|  ECKeyGeneratorParameters(ECDomainParameters domainParameters)
      0|      : super(domainParameters.n.bitLength) {
      0|    _domainParameters = domainParameters;
       |  }
       |
      0|  ECDomainParameters get domainParameters => _domainParameters;
       |}
       |
       |/// Abstract [CipherParameters] to init an RSA key generator.
       |class RSAKeyGeneratorParameters extends KeyGeneratorParameters {
       |  final BigInt publicExponent;
       |  final int certainty;
       |
      1|  RSAKeyGeneratorParameters(
       |      this.publicExponent, int bitStrength, this.certainty)
      1|      : super(bitStrength);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/registry/registry.dart
       |// See file LICENSE for more information.
       |
       |library src.registry;
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registration.dart';
       |
      0|final FactoryRegistry registry = _RegistryImpl();
       |
       |abstract class FactoryRegistry {
       |  T create<T>(String registrableName);
       |
       |  void register<T>(FactoryConfig config);
       |}
       |
       |typedef /*Registrable*/ RegistrableConstructor = Function();
       |typedef DynamicConstructorFactory = RegistrableConstructor Function(
       |    String registrableName, Match match);
       |
       |abstract class FactoryConfig {
       |  final Type type;
       |
      0|  FactoryConfig(this.type);
       |}
       |
       |class StaticFactoryConfig extends FactoryConfig {
       |  final String algorithmName;
       |  final RegistrableConstructor factory;
       |
      0|  StaticFactoryConfig(Type type, this.algorithmName, this.factory)
      0|      : super(type);
       |}
       |
       |// From the PatternCharacter rule here:
       |// http://ecma-international.org/ecma-262/5.1/#sec-15.10
      0|final _specialRegExpChars = RegExp(r'([\\\^\$\.\|\+\[\]\(\)\{\}])');
       |
       |/// Escapes special regular expression characters in [str] so that it can be
       |/// used as a literal match inside of a [RegExp].
       |///
       |/// The special characters are: \ ^ $ . | + [ ] ( ) { }
       |/// as defined here: http://ecma-international.org/ecma-262/5.1/#sec-15.10
      0|String _escapeRegExp(String str) => str.splitMapJoin(_specialRegExpChars,
      0|    onMatch: (Match m) => '\\${m.group(0)}', onNonMatch: (s) => s);
       |
       |class DynamicFactoryConfig extends FactoryConfig {
       |  final RegExp regExp;
       |  final DynamicConstructorFactory factory;
       |
      0|  DynamicFactoryConfig(Type type, this.regExp, this.factory) : super(type);
       |
      0|  DynamicFactoryConfig.regex(
       |      Type type, String regexString, DynamicConstructorFactory factory)
      0|      : this(type, RegExp(regexString), factory);
       |
       |  /// A dynamic registry that matches by prefix.
       |  /// The part after the prefix will be in `match.group(1)`.
      0|  DynamicFactoryConfig.prefix(
       |      Type type, String prefix, DynamicConstructorFactory factory)
      0|      : this.regex(type, '^${_escapeRegExp(prefix)}(.+)\$', factory);
       |
       |  /// A dynamic registry that matches by suffix.
       |  /// The part before the suffix will be in `match.group(1)`.
      0|  DynamicFactoryConfig.suffix(
       |      Type type, String suffix, DynamicConstructorFactory factory)
      0|      : this.regex(type, '^(.+)${_escapeRegExp(suffix)}\$', factory);
       |
       |  /// Invokes the factory when it matches. Else returns null.
      0|  RegistrableConstructor tryFactory(String algorithmName) {
      0|    Match match = regExp.firstMatch(algorithmName);
       |    if (match == null) {
       |      return null;
       |    }
      0|    return factory(algorithmName, match);
       |  }
       |}
       |
       |class _RegistryImpl implements FactoryRegistry {
       |  static const int _CONSTRUCTOR_CACHE_SIZE = 25;
       |
       |  final Map<Type, Map<String, RegistrableConstructor>> _staticFactories;
       |  final Map<Type, Set<DynamicFactoryConfig>> _dynamicFactories;
       |
       |  final Map<String, RegistrableConstructor> _constructorCache =
       |      <String, RegistrableConstructor>{};
       |
       |  bool _initialized = false;
       |
      0|  _RegistryImpl()
      0|      : _staticFactories = <Type, Map<String, RegistrableConstructor>>{},
      0|        _dynamicFactories = <Type, Set<DynamicFactoryConfig>>{};
       |
      0|  @override
       |  T create<T>(String registrableName) {
       |    var type = T;
      0|    var constructor = getConstructor(type, registrableName);
      0|    var result = constructor() as T;
       |    return result;
       |  }
       |
      0|  RegistrableConstructor getConstructor(Type type, String registrableName) {
      0|    var constructor = _constructorCache['$type.$registrableName'];
       |
       |    if (constructor == null) {
      0|      constructor = _createConstructor(type, registrableName);
      0|      if (_constructorCache.length > _CONSTRUCTOR_CACHE_SIZE) {
      0|        _constructorCache.clear();
       |      }
      0|      _constructorCache['$type.$registrableName'] = constructor;
       |    }
       |    return constructor;
       |  }
       |
      0|  RegistrableConstructor _createConstructor(Type type, String registrableName) {
       |    // Init lazily
      0|    _checkInit();
       |
      0|    if (_staticFactories.containsKey(type) &&
      0|        _staticFactories[type].containsKey(registrableName)) {
      0|      return _staticFactories[type][registrableName];
       |    }
       |
      0|    if (_dynamicFactories.containsKey(type)) {
      0|      for (var factory in _dynamicFactories[type]) {
      0|        var constructor = factory.tryFactory(registrableName);
       |        if (constructor != null) {
       |          return constructor;
       |        }
       |      }
       |    }
       |
       |    // No factory found
      0|    throw RegistryFactoryException.unknown(registrableName, type);
       |  }
       |
      0|  void _checkInit() {
      0|    if (!_initialized) {
      0|      _initialize();
       |    }
       |  }
       |
      0|  @override
       |  void register<T>(FactoryConfig config) {
      0|    if (config is StaticFactoryConfig) {
      0|      _addStaticFactoryConfig(config);
      0|    } else if (config is DynamicFactoryConfig) {
      0|      _addDynamicFactoryConfig(config);
       |    }
       |  }
       |
      0|  void _addStaticFactoryConfig(StaticFactoryConfig config) {
      0|    Map factories = _staticFactories.putIfAbsent(
      0|        config.type, () => <String, RegistrableConstructor>{});
      0|    factories[config.algorithmName] = config.factory;
       |  }
       |
      0|  void _addDynamicFactoryConfig(DynamicFactoryConfig config) {
      0|    Set factories = _dynamicFactories.putIfAbsent(
      0|        config.type,
      0|        () => Set<DynamicFactoryConfig>.of(
      0|            [])); // ignore: prefer_collection_literals
      0|    factories.add(config);
       |  }
       |
      0|  void _initialize() {
      0|    registerFactories(this);
      0|    _initialized = true;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/registry/registration.dart
       |library src.registry.impl;
       |
       |import 'package:pointycastle/asymmetric/oaep.dart';
       |import 'package:pointycastle/asymmetric/pkcs1.dart';
       |import 'package:pointycastle/asymmetric/rsa.dart';
       |import 'package:pointycastle/block/aes_fast.dart';
       |import 'package:pointycastle/block/modes/cbc.dart';
       |import 'package:pointycastle/block/modes/cfb.dart';
       |import 'package:pointycastle/block/modes/ctr.dart';
       |import 'package:pointycastle/block/modes/ecb.dart';
       |import 'package:pointycastle/block/modes/gcm.dart';
       |import 'package:pointycastle/block/modes/gctr.dart';
       |import 'package:pointycastle/block/modes/ofb.dart';
       |import 'package:pointycastle/block/modes/sic.dart';
       |import 'package:pointycastle/digests/blake2b.dart';
       |import 'package:pointycastle/digests/keccak.dart';
       |import 'package:pointycastle/digests/md2.dart';
       |import 'package:pointycastle/digests/md4.dart';
       |import 'package:pointycastle/digests/md5.dart';
       |import 'package:pointycastle/digests/ripemd128.dart';
       |import 'package:pointycastle/digests/ripemd160.dart';
       |import 'package:pointycastle/digests/ripemd256.dart';
       |import 'package:pointycastle/digests/ripemd320.dart';
       |import 'package:pointycastle/digests/sha1.dart';
       |import 'package:pointycastle/digests/sha224.dart';
       |import 'package:pointycastle/digests/sha256.dart';
       |import 'package:pointycastle/digests/sha3.dart';
       |import 'package:pointycastle/digests/sha384.dart';
       |import 'package:pointycastle/digests/sha512.dart';
       |import 'package:pointycastle/digests/sha512t.dart';
       |import 'package:pointycastle/digests/shake.dart';
       |import 'package:pointycastle/digests/cshake.dart';
       |import 'package:pointycastle/digests/tiger.dart';
       |import 'package:pointycastle/digests/whirlpool.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp160r1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp160t1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp192r1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp192t1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp224r1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp224t1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp256r1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp256t1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp320r1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp320t1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp384r1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp384t1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp512r1.dart';
       |import 'package:pointycastle/ecc/curves/brainpoolp512t1.dart';
       |import 'package:pointycastle/ecc/curves/gostr3410_2001_cryptopro_a.dart';
       |import 'package:pointycastle/ecc/curves/gostr3410_2001_cryptopro_b.dart';
       |import 'package:pointycastle/ecc/curves/gostr3410_2001_cryptopro_c.dart';
       |import 'package:pointycastle/ecc/curves/gostr3410_2001_cryptopro_xcha.dart';
       |import 'package:pointycastle/ecc/curves/gostr3410_2001_cryptopro_xchb.dart';
       |import 'package:pointycastle/ecc/curves/prime192v1.dart';
       |import 'package:pointycastle/ecc/curves/prime192v2.dart';
       |import 'package:pointycastle/ecc/curves/prime192v3.dart';
       |import 'package:pointycastle/ecc/curves/prime239v1.dart';
       |import 'package:pointycastle/ecc/curves/prime239v2.dart';
       |import 'package:pointycastle/ecc/curves/prime239v3.dart';
       |import 'package:pointycastle/ecc/curves/prime256v1.dart';
       |import 'package:pointycastle/ecc/curves/secp112r1.dart';
       |import 'package:pointycastle/ecc/curves/secp112r2.dart';
       |import 'package:pointycastle/ecc/curves/secp128r1.dart';
       |import 'package:pointycastle/ecc/curves/secp128r2.dart';
       |import 'package:pointycastle/ecc/curves/secp160k1.dart';
       |import 'package:pointycastle/ecc/curves/secp160r1.dart';
       |import 'package:pointycastle/ecc/curves/secp160r2.dart';
       |import 'package:pointycastle/ecc/curves/secp192k1.dart';
       |import 'package:pointycastle/ecc/curves/secp192r1.dart';
       |import 'package:pointycastle/ecc/curves/secp224k1.dart';
       |import 'package:pointycastle/ecc/curves/secp224r1.dart';
       |import 'package:pointycastle/ecc/curves/secp256k1.dart';
       |import 'package:pointycastle/ecc/curves/secp256r1.dart';
       |import 'package:pointycastle/ecc/curves/secp384r1.dart';
       |import 'package:pointycastle/ecc/curves/secp521r1.dart';
       |import 'package:pointycastle/export.dart';
       |import 'package:pointycastle/key_derivators/hkdf.dart';
       |import 'package:pointycastle/key_derivators/pbkdf2.dart';
       |import 'package:pointycastle/key_derivators/scrypt.dart';
       |import 'package:pointycastle/key_generators/ec_key_generator.dart';
       |import 'package:pointycastle/key_generators/rsa_key_generator.dart';
       |import 'package:pointycastle/macs/cbc_block_cipher_mac.dart';
       |import 'package:pointycastle/macs/cmac.dart';
       |import 'package:pointycastle/macs/hmac.dart';
       |import 'package:pointycastle/macs/poly1305.dart';
       |import 'package:pointycastle/padded_block_cipher/padded_block_cipher_impl.dart';
       |import 'package:pointycastle/paddings/iso7816d4.dart';
       |import 'package:pointycastle/paddings/pkcs7.dart';
       |import 'package:pointycastle/random/auto_seed_block_ctr_random.dart';
       |import 'package:pointycastle/random/block_ctr_random.dart';
       |import 'package:pointycastle/random/fortuna_random.dart';
       |import 'package:pointycastle/signers/ecdsa_signer.dart';
       |import 'package:pointycastle/signers/rsa_signer.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/stream/chacha20poly1305.dart';
       |import 'package:pointycastle/stream/chacha7539.dart';
       |import 'package:pointycastle/stream/ctr.dart';
       |import 'package:pointycastle/stream/salsa20.dart';
       |import 'package:pointycastle/stream/sic.dart';
       |
      0|void registerFactories(FactoryRegistry registry) {
      0|  _registerAsymmetricCiphers(registry);
      0|  _registerBlockCiphers(registry);
      0|  _registerDigests(registry);
      0|  _registerECCurves(registry);
      0|  _registerKeyDerivators(registry);
      0|  _registerKeyGenerators(registry);
      0|  _registerMacs(registry);
      0|  _registerPaddedBlockCiphers(registry);
      0|  _registerPaddings(registry);
      0|  _registerRandoms(registry);
      0|  _registerSigners(registry);
      0|  _registerStreamCiphers(registry);
       |}
       |
      0|void _registerAsymmetricCiphers(FactoryRegistry registry) {
      0|  registry.register(OAEPEncoding.factoryConfig);
      0|  registry.register(PKCS1Encoding.factoryConfig);
      0|  registry.register(RSAEngine.factoryConfig);
       |}
       |
      0|void _registerBlockCiphers(FactoryRegistry registry) {
      0|  registry.register(AESFastEngine.factoryConfig);
       |
       |  // modes
      0|  registry.register(CBCBlockCipher.factoryConfig);
      0|  registry.register(CFBBlockCipher.factoryConfig);
      0|  registry.register(CTRBlockCipher.factoryConfig);
      0|  registry.register(ECBBlockCipher.factoryConfig);
      0|  registry.register(GCTRBlockCipher.factoryConfig);
      0|  registry.register(OFBBlockCipher.factoryConfig);
      0|  registry.register(SICBlockCipher.factoryConfig);
      0|  registry.register(GCMBlockCipher.factoryConfig);
       |}
       |
      0|void _registerDigests(FactoryRegistry registry) {
      0|  registry.register(Blake2bDigest.factoryConfig);
      0|  registry.register(MD2Digest.factoryConfig);
      0|  registry.register(MD4Digest.factoryConfig);
      0|  registry.register(MD5Digest.factoryConfig);
      0|  registry.register(RIPEMD128Digest.factoryConfig);
      0|  registry.register(RIPEMD160Digest.factoryConfig);
      0|  registry.register(RIPEMD256Digest.factoryConfig);
      0|  registry.register(RIPEMD320Digest.factoryConfig);
      0|  registry.register(SHA1Digest.factoryConfig);
      0|  registry.register(SHA3Digest.factoryConfig);
      0|  registry.register(KeccakDigest.factoryConfig);
      0|  registry.register(SHA224Digest.factoryConfig);
      0|  registry.register(SHA256Digest.factoryConfig);
      0|  registry.register(SHA384Digest.factoryConfig);
      0|  registry.register(SHA512Digest.factoryConfig);
      0|  registry.register(SHA512tDigest.factoryConfig);
      0|  registry.register(TigerDigest.factoryConfig);
      0|  registry.register(WhirlpoolDigest.factoryConfig);
      0|  registry.register(SHAKEDigest.factoryConfig);
      0|  registry.register(CSHAKEDigest.factoryConfig);
       |}
       |
      0|void _registerECCurves(FactoryRegistry registry) {
      0|  registry.register(ECCurve_brainpoolp160r1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp160t1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp192r1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp192t1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp224r1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp224t1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp256r1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp256t1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp320r1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp320t1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp384r1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp384t1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp512r1.factoryConfig);
      0|  registry.register(ECCurve_brainpoolp512t1.factoryConfig);
      0|  registry.register(ECCurve_gostr3410_2001_cryptopro_a.factoryConfig);
      0|  registry.register(ECCurve_gostr3410_2001_cryptopro_b.factoryConfig);
      0|  registry.register(ECCurve_gostr3410_2001_cryptopro_c.factoryConfig);
      0|  registry.register(ECCurve_gostr3410_2001_cryptopro_xcha.factoryConfig);
      0|  registry.register(ECCurve_gostr3410_2001_cryptopro_xchb.factoryConfig);
      0|  registry.register(ECCurve_prime192v1.factoryConfig);
      0|  registry.register(ECCurve_prime192v2.factoryConfig);
      0|  registry.register(ECCurve_prime192v3.factoryConfig);
      0|  registry.register(ECCurve_prime239v1.factoryConfig);
      0|  registry.register(ECCurve_prime239v2.factoryConfig);
      0|  registry.register(ECCurve_prime239v3.factoryConfig);
      0|  registry.register(ECCurve_prime256v1.factoryConfig);
      0|  registry.register(ECCurve_secp112r1.factoryConfig);
      0|  registry.register(ECCurve_secp112r2.factoryConfig);
      0|  registry.register(ECCurve_secp128r1.factoryConfig);
      0|  registry.register(ECCurve_secp128r2.factoryConfig);
      0|  registry.register(ECCurve_secp160k1.factoryConfig);
      0|  registry.register(ECCurve_secp160r1.factoryConfig);
      0|  registry.register(ECCurve_secp160r2.factoryConfig);
      0|  registry.register(ECCurve_secp192k1.factoryConfig);
      0|  registry.register(ECCurve_secp192r1.factoryConfig);
      0|  registry.register(ECCurve_secp224k1.factoryConfig);
      0|  registry.register(ECCurve_secp224r1.factoryConfig);
      0|  registry.register(ECCurve_secp256k1.factoryConfig);
      0|  registry.register(ECCurve_secp256r1.factoryConfig);
      0|  registry.register(ECCurve_secp384r1.factoryConfig);
      0|  registry.register(ECCurve_secp521r1.factoryConfig);
       |}
       |
      0|void _registerKeyDerivators(FactoryRegistry registry) {
      0|  registry.register(PBKDF2KeyDerivator.factoryConfig);
      0|  registry.register(Scrypt.factoryConfig);
      0|  registry.register(HKDFKeyDerivator.factoryConfig);
       |}
       |
      0|void _registerKeyGenerators(FactoryRegistry registry) {
      0|  registry.register(ECKeyGenerator.factoryConfig);
      0|  registry.register(RSAKeyGenerator.factoryConfig);
       |}
       |
      0|void _registerMacs(FactoryRegistry registry) {
      0|  registry.register(HMac.factoryConfig);
      0|  registry.register(CMac.factoryConfig);
      0|  registry.register(CBCBlockCipherMac.factoryConfig);
      0|  registry.register(Poly1305.factoryConfig);
       |}
       |
      0|void _registerPaddedBlockCiphers(FactoryRegistry registry) {
      0|  registry.register(PaddedBlockCipherImpl.factoryConfig);
       |}
       |
      0|void _registerPaddings(FactoryRegistry registry) {
      0|  registry.register(PKCS7Padding.factoryConfig);
      0|  registry.register(ISO7816d4Padding.factoryConfig);
       |}
       |
      0|void _registerRandoms(FactoryRegistry registry) {
      0|  registry.register(AutoSeedBlockCtrRandom.factoryConfig);
      0|  registry.register(BlockCtrRandom.factoryConfig);
      0|  registry.register(FortunaRandom.factoryConfig);
       |}
       |
      0|void _registerSigners(FactoryRegistry registry) {
      0|  registry.register(ECDSASigner.factoryConfig);
      0|  registry.register(PSSSigner.factoryConfig);
      0|  registry.register(RSASigner.factoryConfig);
       |}
       |
      0|void _registerStreamCiphers(FactoryRegistry registry) {
      0|  registry.register(CTRStreamCipher.factoryConfig);
      0|  registry.register(Salsa20Engine.factoryConfig);
      0|  registry.register(ChaCha20Engine.factoryConfig);
      0|  registry.register(ChaCha7539Engine.factoryConfig);
      0|  registry.register(ChaCha20Poly1305.factoryConfig);
      0|  registry.register(SICStreamCipher.factoryConfig);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asymmetric/oaep.dart
       |// See file LICENSE for more information.
       |
       |library impl.asymmetric_block_cipher.oeap;
       |
       |import 'dart:math';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_asymmetric_block_cipher.dart';
       |import 'package:pointycastle/random/fortuna_random.dart';
       |import 'package:pointycastle/digests/sha1.dart';
       |
       |/// RSAES-OAEP v2.0
       |///
       |/// This implementation is based on the RSAES-OAEP (RSA Encryption Scheme -
       |/// Optimal Asymmetric Encryption Padding) as specified in section 7.1 of
       |/// [RFC 2437](https://tools.ietf.org/html/rfc2437#section-7.1)
       |/// _PKCS #1: RSA Cryptography Specifications Version 2.0_.
       |///
       |/// **Important:** this is **not** compatible with RSAES-OAEP v2.1 or later (as
       |/// specified in RFC 3447, RFC 8017, etc.) Those newer versions have an extra
       |/// 0x00 byte at the beginning of the encoded message (EM) that is passed
       |/// to the RSA encryption primitive. Therefore, this implementation is
       |/// incompatible with it, since this is an implementation of v2.0 which does
       |/// not have that 0x00 byte. A breaking change in the standard!
       |///
       |/// Currently, this implementation has the following restrictions:
       |///
       |/// - the hash function is hard-coded to be SHA-1;
       |/// - the mask generation function is hard-coded to MGF1; and
       |/// - it cannot accept any _encoding parameters_ (that is, _P_ is always empty)
       |
       |class OAEPEncoding extends BaseAsymmetricBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      AsymmetricBlockCipher,
       |      '/OAEP',
       |      (_, final Match match) => () {
       |            var underlyingCipher = AsymmetricBlockCipher(match.group(1));
       |            return OAEPEncoding(underlyingCipher);
       |          });
       |
       |  /// Hash function used by the EME-OAEP (Encoding Method for Encryption OAEP).
       |  Digest hash = SHA1Digest();
       |
       |  /// Hash function used by the MGF1 Mask Generation Function.
       |  Digest mgf1Hash;
       |
       |  /// Hash of the encoding parameters.
       |  ///
       |  /// Note: in this implementation the encoding parameters is always zero
       |  /// octets. There is no mechanism to provide encoding parameters.
       |  Uint8List defHash = Uint8List(SHA1Digest().digestSize);
       |
       |  final AsymmetricBlockCipher _engine;
       |  SecureRandom _random;
       |  bool _forEncryption;
       |
      0|  OAEPEncoding(this._engine) {
      0|    SHA1Digest().doFinal(defHash, 0);
       |  }
       |
      0|  @override
      0|  String get algorithmName => '${_engine.algorithmName}/OAEP';
       |
      0|  @override
       |  void reset() {}
       |
      0|  Uint8List _seed() {
      0|    var random = Random.secure();
      0|    var seeds = <int>[];
      0|    for (var i = 0; i < 32; i++) {
      0|      seeds.add(random.nextInt(255));
       |    }
      0|    return Uint8List.fromList(seeds);
       |  }
       |
       |  // for compat cleaner translation from java source
      0|  Uint8List _arraycopy(
       |      Uint8List src, int srcPos, Uint8List dest, int destPos, int length) {
      0|    dest.setRange(
      0|        destPos, destPos + length, src.sublist(srcPos, srcPos + length));
       |    return dest;
       |  }
       |
      0|  @override
       |  void init(bool forEncryption, CipherParameters params) {
       |    AsymmetricKeyParameter akparams;
      0|    mgf1Hash = hash;
      0|    if (params is ParametersWithRandom) {
       |      var paramswr = params;
      0|      _random = paramswr.random;
      0|      akparams = paramswr.parameters;
       |    } else {
      0|      _random = FortunaRandom();
      0|      _random.seed(KeyParameter(_seed()));
       |      akparams = params;
       |    }
      0|    _engine.init(forEncryption, akparams);
      0|    _forEncryption = forEncryption;
       |
       |    // Check type of key provided is suitable
       |    // Note: the _engine can't do this check, because the engine could be used
       |    // for both encryption/decryption and signature/verification (which reverses
       |    // the keys), so its `init` method accepts both types of keys. For example,
       |    // [RSAEngine.init].
       |
       |    if (forEncryption) {
      0|      if (akparams.key is! PublicKey) {
      0|        throw ArgumentError.value(
      0|            'OAEP encryption needs PublicKey: not ${akparams.key.runtimeType}');
       |      }
       |    } else {
      0|      if (akparams.key is! PrivateKey) {
      0|        throw ArgumentError.value(
      0|            'OAEP decryption needs PrivateKey: not ${akparams.key.runtimeType}');
       |      }
       |    }
       |  }
       |
      0|  @override
       |  int get inputBlockSize {
      0|    var baseBlockSize = _engine.inputBlockSize;
      0|    if (_forEncryption) {
      0|      return baseBlockSize - 1 - 2 * defHash.length;
       |    } else {
       |      return baseBlockSize;
       |    }
       |  }
       |
      0|  @override
       |  int get outputBlockSize {
      0|    var baseBlockSize = _engine.outputBlockSize;
      0|    if (_forEncryption) {
       |      return baseBlockSize;
       |    } else {
      0|      return baseBlockSize - 1 - (2 * defHash.length);
       |    }
       |  }
       |
      0|  @override
       |  int processBlock(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      0|    if (_forEncryption) {
      0|      return _encodeBlock(inp, inpOff, len, out, outOff);
       |    } else {
      0|      return _decodeBlock(inp, inpOff, len, out, outOff);
       |    }
       |  }
       |
       |  /// RSAES-OAEP encryption operation
       |  ///
       |  /// Implements the _RSA Encryption Scheme with Optimal Asymmetric Encryption
       |  /// Padding_ (RSAES-OAEP) **encryption operation**. This encryption operation
       |  /// combines the _Encoding Method for Encryption OAEP_ (EME-OAEP)
       |  /// **encoding operation** with the _RSA Encryption Primitive_ (RSAEP).
       |  ///
       |  /// This method performs the EME-OAEP encoding operation, and then invokes its
       |  /// [AsymmetricBlockCipher] engine to perform RSAEP to encrypt it.
       |  ///
       |  /// The RSAES-OAEP encryption operation is specified in section 7.1.1 of
       |  /// [RFC 2437](https://tools.ietf.org/html/rfc2437#section-7.1.1) and the
       |  /// EME-OAEP encoding operation it uses is specified in section 9.1.1.1 of
       |  /// [RFC 2437](https://tools.ietf.org/html/rfc2437#section-9.1.1.1).
       |  ///
       |  /// The message to be encoded and encrypted is the octet string consisting of
       |  /// [inpLen] bytes from [inp], starting at the [inpOff] offset.
       |  ///
       |  /// It returns the ciphertext.
       |
      0|  int _encodeBlock(
       |      Uint8List inp, int inpOff, int inpLen, Uint8List out, int outOff) {
      0|    if (inpLen > inputBlockSize) {
      0|      throw ArgumentError('message too long');
       |    }
       |
       |    // The numbered steps below correspond to the steps in RFC 2437.
       |    // Names in _italics_ refers to names in the RFC 2437 and names in square
       |    // brackets refers to variables in this code.
       |
       |    // 3. Generate PS (padding string containing just zero octets)
       |    //
       |    // In this implementation, the length of PS is always zero. That is, there
       |    // is no bytes in _PS_.
       |
       |    // 4. Calculate _pHash_ = Hash(P)
       |    //
       |    // The result _pHash_ is stored into [pHash].
       |    //
       |    // defHash = hash.process(encodingParams);
       |
       |    // Note: This implementation currently does not support encodingParams
       |    // so the [defHash] is used as is (which was initialized to be a hash of no
       |    // bytes). (Not sure why it is a member variable instead of a variable
       |    // local to this method.)
       |
       |    // 5. Calculate _DB_ = pHash || PS || 01 || M
       |    //
       |    // It is the concatenation of _pHash_, _PS_, 0x01 and the message.
       |    // Note: RFC 2437 also includes 'other padding', but that is an error that
       |    // does not appear in subsequent versions of PKCS #1 (e.g. RFC 3447).
       |    //
       |    // The result _DB_ is stored into [block] starting at offset _hLen_ to the
       |    // end.
       |
      0|    var block = Uint8List(inputBlockSize + 1 + 2 * defHash.length);
       |
       |    // M: copy the message into the end of the block.
       |    //
       |    // block.setRange(inpOff, block.length - inpLen, inp.sublist(inpLen));
      0|    block = _arraycopy(inp, inpOff, block, block.length - inpLen, inpLen);
       |
       |    // 01: add the sentinel byte
       |    //
      0|    block[block.length - inpLen - 1] = 0x01;
       |
       |    // PS: since a Uint8List is initialized with 0x00, PS is already zeroed
       |
       |    // pHash: add the hash of the encoding params.
       |    //
      0|    block = _arraycopy(defHash, 0, block, defHash.length, defHash.length);
       |
       |    // 6. Generate a random octet string _seed_ of length _hLen_.
       |    //
       |    // The _seed_ is stored in [seed].
       |
      0|    var seed = _random.nextBytes(defHash.length);
       |
       |    // 7. Calculate _dbMask_ = MGF(seed, emLen - hLen)
       |    //
       |    // The _seed_ comes from [seed]. The result _dbMask_ is stored into [mask].
       |
      0|    var mask = _maskGeneratorFunction1(
      0|        seed, 0, seed.length, block.length - defHash.length);
       |
       |    // 8. Calculate _maskedDB_ = DB XOR dbMask
       |    //
       |    // The _DB_ comes from [block], starting at offset _hLen_ to the end. The
       |    // _dbMask_ comes from [mask]. The result _maskedDB_ is stored into [block]
       |    // starting at offset _hLen_ to the end (overwriting the _DB_).
       |
      0|    for (var i = defHash.length; i != block.length; i++) {
      0|      block[i] ^= mask[i - defHash.length];
       |    }
       |
       |    // Temporally store the _seed_ in the first _hLen_ bytes of the [block]
       |    // so it can be used later.
       |
      0|    block = _arraycopy(seed, 0, block, 0, defHash.length);
       |
       |    // 9. Calculate _seedMask_ = MGF(maskedDB, hLen)
       |    //
       |    // The _maskedDB_ comes from [block], starting at offset _hLen_ to the end.
       |    // The result _seedMask_ is stored into [mask] (replacing the _dbMask_ which
       |    // is no longer needed).
       |
      0|    mask = _maskGeneratorFunction1(
      0|        block, defHash.length, block.length - defHash.length, defHash.length);
       |
       |    // 10. Calculate _maskedSeed_ = seed XOR seedMask
       |    //
       |    // The _seed_ comes from [block], the first _hLen_ bytes (where it was
       |    // temporally stored). The _seedMask_ comes from [mask]. The result
       |    // _maskedSeed_ is stored into [block], the first _hLen_ bytes (overwriting
       |    // the temporary _seed_).
       |
      0|    for (var i = 0; i != defHash.length; i++) {
      0|      block[i] ^= mask[i];
       |    }
       |
       |    // 11. Calculate _EM_ = maskedSeed || maskedDB
       |    //
       |    // The [block] already contains the concatenated value, since they were both
       |    // calculated in the first.
       |
       |    // EME-OAEP-ENCODE completed.
       |
       |    // Use the [_engine] to finish the RSAES-OAEP. That is, it will convert the
       |    // _EM_ into an integer, apply the RSA Encryption Primitive (RSAEP) to the
       |    // public key, and convert the resulting integer ciphertext representation
       |    // into octets. The octets will be written into [out] starting at [outOff].
       |    //
       |    // Returns the number of bytes in the output ciphertext.
       |
      0|    return _engine.processBlock(block, 0, block.length, out, outOff);
       |  }
       |
       |  /// RSAES-OAEP decryption operation
       |  ///
       |  /// Implements the _RSA Encryption Scheme with Optimal Asymmetric Encryption
       |  /// Padding_ (RSAES-OAEP) **decryption operation**. This decryption operation
       |  /// combines the _RSA Decryption Primitive_ (RSADP) with the _Encoding Method
       |  /// for Encryption OAEP_ (EME-OAEP) **decoding operation**.
       |  ///
       |  /// This method invokes its [AsymmetricBlockCipher] engine to perform RSADP,
       |  /// and then performs the EME-OAEP decoding operation on the decrypted data.
       |  ///
       |  /// The RSAES-OAEP decryption operation is specified in section 7.1.2 of
       |  /// [RFC 2437](https://tools.ietf.org/html/rfc2437#section-7.1.2) and the
       |  /// EME-OAEP decoding operation it uses is specified in section 9.1.1.2 of
       |  /// [RFC 2437](https://tools.ietf.org/html/rfc2437#section-9.1.1.2).
       |  ///
       |  /// The ciphertext to be decrypted and decoded is the octet string consisting
       |  /// of [inpLen] bytes from [inp], starting at the [inpOff] offset.
       |  ///
       |  /// It returns the message in [out] starting at offset [outOff].
       |
      0|  int _decodeBlock(
       |      Uint8List inp, int inpOff, int inpLen, Uint8List out, int outOff) {
       |    // The numbered steps below correspond to the steps from section 7.1.2 of
       |    // [RFC 2437](https://tools.ietf.org/html/rfc2437#section-7.1.2).
       |    //
       |    // Names in _italics_ refers to names in the RFC 2437 and names in square
       |    // brackets refers to variables in this code.
       |
       |    // 1. Length checking
       |
      0|    if (inpLen != _engine.inputBlockSize) {
      0|      throw ArgumentError.value(inpLen, 'inpLen', 'decryption error');
       |    }
       |
       |    // 2, 3. RSA decryption
       |
      0|    var block = Uint8List(_engine.outputBlockSize);
       |
       |    var decryptFailed = false;
       |    try {
      0|      var len = _engine.processBlock(inp, inpOff, inpLen, block, 0);
       |
       |      // 4. EM = I2OSP(m, k-1)
       |
      0|      if (len < block.length) {
       |        // Decrypted bytes is shorter than expected. Add 0x00 bytes at the
       |        // beginning of the block (i.e. ensure it is k-1 long). This is needed
       |        // when there were 0x00 in the leading bytes of the block that was
       |        // originally encrypted.
       |
       |        // Note: do not use [_arrayCopy] or [SetRange], since the source and
       |        // destination may overlap. Those methods will corrupt the data.
       |
       |        // Copy [len] data bytes from beginning of block to its end. I.e. from
       |        // block[block.length - 1] <- block[len - 1] through to
       |        // block[block.len - len] <- block[0]
      0|        for (var x = 0; x < len; x++) {
      0|          block[block.length - 1 - x] = block[len - 1 - x];
       |        }
       |        // Put 0x00 in those beginning bytes. Important: do this AFTER copying
      0|        block.fillRange(0, block.length - len, 0x00);
       |      }
      0|    } on ArgumentError {
       |      decryptFailed = true;
       |    }
       |
       |    // 5. EME-OAEP decoding
       |    //
       |    // In these 5.x numbered steps, the x refers to steps from section 9.1.1.2
       |    // of [RFC 2437](https://tools.ietf.org/html/rfc2437#section-9.1.1.2)
       |
       |    // 5.2 Check length
       |
      0|    var wrongData = (block.length < (2 * defHash.length) + 1);
       |
       |    // 5.4 Calculate _seedMask_ = MGF(maskedDB, hLen)
       |    //
       |    // The _maskedDB_ comes from [block] starting at _hLen_ to the end.
       |    // The result _seedMask_ is stored in [mask].
       |
      0|    var mask = _maskGeneratorFunction1(
      0|        block, defHash.length, block.length - defHash.length, defHash.length);
       |
       |    // 5.5 Calculate _seed_ = maskedSeed XOR seedMask
       |    //
       |    // THe _maskedSeed_ comes from the first _hLen_ bytes of [block] and the
       |    // _seedMask_ comes from [mask].
       |    // The result _seed_ is stored in the first _hLen_ bytes of [block]
       |    // (overwriting the maskedSeed_ that was previously there).
       |
      0|    for (var i = 0; i != defHash.length; i++) {
      0|      block[i] ^= mask[i];
       |    }
       |
       |    // 5.6 Calculate _dbMask_ = MGF(seed, length of EM - hLen)
       |
      0|    mask = _maskGeneratorFunction1(
      0|        block, 0, defHash.length, block.length - defHash.length);
       |
       |    // 5.7 Calculate _DB_ = maskedDB XOR dbMask
       |    //
       |    // The _maskedDB_ comes from [block], from _hLen_ to the end, and the
       |    // _dbMask_ comes from [mask]. The result _DB_ is stored in [block] from
       |    // _hLen_ to the end (overwriting the _maskedDB_ that was previously there).
       |
      0|    for (var i = defHash.length; i != block.length; i++) {
      0|      block[i] ^= mask[i - defHash.length];
       |    }
       |
       |    // 5.8 pHash = Hash(P)
       |    //
       |    // Since in this implementation P is always an empty octet string, _pHash_
       |    // is already the value in _defHash_.
       |
       |    // 5.10 Check _pHash'_ to _pHash_
       |    //
       |    // check the hash of the encoding params.
       |    // long check to try to avoid this been a source of a timing attack.
       |    //
       |    // The _pHash'_ comes from the first _hLen_ bytes of [block]
       |
       |    var defHashWrong = false;
       |
      0|    for (var i = 0; i != defHash.length; i++) {
      0|      if (defHash[i] != block[defHash.length + i]) {
       |        defHashWrong = true;
       |      }
       |    }
       |
       |    // 5.9 Split _DB_ into pHash1 || PS || 0x01 || M
       |    //
       |    // Skip over the _PS_ (which are all 0x00 bytes). Finding the first non-zero
       |    // byte from hash.digestLength * 2 to the end of [block]. Setting [start]
       |    // to that first non-zero byte (or will be block.length if none found).
       |
      0|    var start = block.length;
      0|    for (var index = 2 * defHash.length; index != block.length; index++) {
      0|      if ((block[index] != 0) & (start == block.length)) {
       |        start = index;
       |      }
       |    }
       |
       |    // The data-start-is-wrong if the rest of the [block] contains all 0x00
       |    // bytes or that first non-zero byte is not 0x01.
       |
      0|    var dataStartWrong = (start > (block.length - 1)) | (block[start] != 0x01);
      0|    start++;
       |
       |    if (decryptFailed || defHashWrong || wrongData || dataStartWrong) {
      0|      block.fillRange(0, block.length, 0);
      0|      throw ArgumentError('decoding error');
       |    }
       |
       |    // 5.11 Output M
       |    //
       |    // The _M_ are all the bytes from after the 0x01 byte (i.e. offset [start])
       |    // to the end of [block]. Copy those bytes into [out] starting at [outOff].
       |
      0|    final mLen = block.length - start;
      0|    _arraycopy(block, start, out, outOff, mLen);
       |    return mLen;
       |  }
       |
       |  // ignore: slash_for_doc_comments
       |  /**
       |  * int to octet string.
       |  */
      0|  Uint8List _itoOSP(int i, Uint8List sp) {
      0|    sp[0] = i >> 24;
      0|    sp[1] = i >> 16;
      0|    sp[2] = i >> 8;
      0|    sp[3] = i >> 0;
       |    return sp;
       |  }
       |
       |  /// Implementation of MGF1 (the Mask Generation Function from PKCS #1 v2.0).
       |  ///
       |  /// See section 10.2.1 of
       |  /// [RFC 2437](https://tools.ietf.org/html/rfc2437#section-10.2.1).
       |  ///
       |  /// MGF1 is defined to take a hash function as an option. This implementation
       |  /// uses [mgf1Hash] for that hash function.
       |  ///
       |  /// MGF1 hsa two inputs: a seed and an intended length. The seed is the
       |  /// sequence of bytes in [Z], starting at [zOff] for [zLen] bytes.
       |  /// The intended length is in [length].
       |  ///
       |  /// Returns the calculated mask. A Uint8List that contains [length] bytes.
       |
      0|  Uint8List _maskGeneratorFunction1(
       |      Uint8List Z, int zOff, int zLen, int length) {
      0|    var mask = Uint8List(length);
      0|    var hashBuf = Uint8List(mgf1Hash.digestSize);
      0|    var C = Uint8List(4);
       |    var counter = 0;
      0|    mgf1Hash.reset();
       |
      0|    while (counter < (length / hashBuf.length).floor()) {
      0|      _itoOSP(counter, C);
      0|      mgf1Hash.update(Z, zOff, zLen);
      0|      mgf1Hash.update(C, 0, C.length);
      0|      mgf1Hash.doFinal(hashBuf, 0);
      0|      mask = _arraycopy(
      0|          hashBuf, 0, mask, counter * hashBuf.length, hashBuf.length);
      0|      counter++;
       |    }
       |
      0|    if ((counter * hashBuf.length) < length) {
      0|      _itoOSP(counter, C);
      0|      mgf1Hash.update(Z, zOff, zLen);
      0|      mgf1Hash.update(C, 0, C.length);
      0|      mgf1Hash.doFinal(hashBuf, 0);
      0|      mask = _arraycopy(hashBuf, 0, mask, counter * hashBuf.length,
      0|          mask.length - (counter * hashBuf.length));
       |    }
       |    return mask;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asymmetric/pkcs1.dart
       |// See file LICENSE for more information.
       |
       |library impl.asymmetric_block_cipher.pkcs1;
       |
       |import 'dart:math';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_asymmetric_block_cipher.dart';
       |import 'package:pointycastle/random/fortuna_random.dart';
       |
       |class PKCS1Encoding extends BaseAsymmetricBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      AsymmetricBlockCipher,
       |      '/PKCS1',
       |      (_, final Match match) => () {
       |            var underlyingCipher = AsymmetricBlockCipher(match.group(1));
       |            return PKCS1Encoding(underlyingCipher);
       |          });
       |
       |  static const _HEADER_LENGTH = 10;
       |
       |  final AsymmetricBlockCipher _engine;
       |
       |  SecureRandom _random;
       |  bool _forEncryption;
       |  bool _forPrivateKey;
       |
      1|  PKCS1Encoding(this._engine);
       |
      0|  @override
      0|  String get algorithmName => '${_engine.algorithmName}/PKCS1';
      1|  @override
       |  void reset() {}
       |
      1|  Uint8List _seed() {
      1|    var random = Random.secure();
      1|    var seeds = <int>[];
      2|    for (var i = 0; i < 32; i++) {
      2|      seeds.add(random.nextInt(255));
       |    }
      1|    return Uint8List.fromList(seeds);
       |  }
       |
      1|  @override
       |  void init(bool forEncryption, CipherParameters params) {
       |    AsymmetricKeyParameter akparams;
       |
      1|    if (params is ParametersWithRandom) {
       |      var paramswr = params;
       |
      0|      _random = paramswr.random;
      0|      akparams = paramswr.parameters;
       |    } else {
      2|      _random = FortunaRandom();
      4|      _random.seed(KeyParameter(_seed()));
       |      akparams = params;
       |    }
       |
      2|    _engine.init(forEncryption, akparams);
       |
      3|    _forPrivateKey = (akparams.key is PrivateKey);
      1|    _forEncryption = forEncryption;
       |  }
       |
      1|  @override
       |  int get inputBlockSize {
      2|    var baseBlockSize = _engine.inputBlockSize;
       |
      1|    if (_forEncryption) {
      1|      return baseBlockSize - _HEADER_LENGTH;
       |    } else {
       |      return baseBlockSize;
       |    }
       |  }
       |
      1|  @override
       |  int get outputBlockSize {
      2|    var baseBlockSize = _engine.outputBlockSize;
       |
      1|    if (_forEncryption) {
       |      return baseBlockSize;
       |    } else {
      1|      return baseBlockSize - _HEADER_LENGTH;
       |    }
       |  }
       |
      1|  @override
       |  int processBlock(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      1|    if (_forEncryption) {
      1|      return _encodeBlock(inp, inpOff, len, out, outOff);
       |    } else {
      1|      return _decodeBlock(inp, inpOff, len, out, outOff);
       |    }
       |  }
       |
      1|  int _encodeBlock(
       |      Uint8List inp, int inpOff, int inpLen, Uint8List out, int outOff) {
      2|    if (inpLen > inputBlockSize) {
      0|      throw ArgumentError('Input data too large');
       |    }
       |
      3|    var block = Uint8List(_engine.inputBlockSize);
      3|    var padLength = (block.length - inpLen - 1);
       |
      1|    if (_forPrivateKey) {
      1|      block[0] = 0x01; // type code 1
      1|      block.fillRange(1, padLength, 0xFF);
       |    } else {
      0|      block[0] = 0x02; // type code 2
      0|      block.setRange(1, padLength, _random.nextBytes(padLength - 1));
       |
       |      // a zero byte marks the end of the padding, so all
       |      // the pad bytes must be non-zero.
      0|      for (var i = 1; i < padLength; i++) {
      0|        while (block[i] == 0) {
      0|          block[i] = _random.nextUint8();
       |        }
       |      }
       |    }
       |
      1|    block[padLength] = 0x00; // mark the end of the padding
      4|    block.setRange(padLength + 1, block.length, inp.sublist(inpOff));
       |
      3|    return _engine.processBlock(block, 0, block.length, out, outOff);
       |  }
       |
      1|  int _decodeBlock(
       |      Uint8List inp, int inpOff, int inpLen, Uint8List out, int outOff) {
      3|    var block = Uint8List(_engine.inputBlockSize);
      2|    var len = _engine.processBlock(inp, inpOff, inpLen, block, 0);
      1|    block = block.sublist(0, len);
       |
      3|    if (block.length < outputBlockSize) {
      0|      throw ArgumentError('Block truncated');
       |    }
       |
      1|    var type = block[0];
       |
      1|    if (_forPrivateKey && (type != 2)) {
      0|      throw ArgumentError('Unsupported block type for private key: $type');
       |    }
      2|    if (!_forPrivateKey && (type != 1)) {
      0|      throw ArgumentError('Unsupported block type for public key: $type');
       |    }
      4|    if (block.length != _engine.outputBlockSize) {
      0|      throw ArgumentError('Block size is incorrect: ${block.length}');
       |    }
       |
       |    // find and extract the message block.
       |    int start;
       |
      3|    for (start = 1; start < block.length; start++) {
      1|      var pad = block[start];
       |
      1|      if (pad == 0) {
       |        break;
       |      }
      2|      if (type == 1 && (pad != 0xFF)) {
      0|        throw ArgumentError('Incorrect block padding');
       |      }
       |    }
       |
      1|    start++; // data should start at the next byte
       |
      3|    if ((start > block.length) || (start < _HEADER_LENGTH)) {
      0|      throw ArgumentError('No data found in block, only padding');
       |    }
       |
      2|    var rlen = (block.length - start);
      1|    var result = Uint8List(rlen);
      3|    out.setRange(outOff, outOff + rlen, block.sublist(start));
       |    return rlen;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/asymmetric/rsa.dart
       |// See file LICENSE for more information.
       |
       |library impl.asymmetric_block_cipher.rsa;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/asymmetric/api.dart';
       |import 'package:pointycastle/src/impl/base_asymmetric_block_cipher.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/utils.dart' as utils;
       |
       |class RSAEngine extends BaseAsymmetricBlockCipher {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(AsymmetricBlockCipher, 'RSA', () => RSAEngine());
       |
       |  bool _forEncryption;
       |  RSAAsymmetricKey _key;
       |  BigInt _dP;
       |  BigInt _dQ;
       |  BigInt _qInv;
       |
      0|  @override
       |  String get algorithmName => 'RSA';
       |
      1|  @override
       |  int get inputBlockSize {
      1|    if (_key == null) {
      0|      throw StateError(
       |          'Input block size cannot be calculated until init() called');
       |    }
       |
      3|    var bitSize = _key.modulus.bitLength;
      1|    if (_forEncryption) {
      3|      return ((bitSize + 7) ~/ 8) - 1;
       |    } else {
      2|      return (bitSize + 7) ~/ 8;
       |    }
       |  }
       |
      1|  @override
       |  int get outputBlockSize {
      1|    if (_key == null) {
      0|      throw StateError(
       |          'Output block size cannot be calculated until init() called');
       |    }
       |
      3|    var bitSize = _key.modulus.bitLength;
      1|    if (_forEncryption) {
      2|      return (bitSize + 7) ~/ 8;
       |    } else {
      3|      return ((bitSize + 7) ~/ 8) - 1;
       |    }
       |  }
       |
      0|  @override
       |  void reset() {}
       |
      1|  @override
       |  void init(bool forEncryption,
       |      covariant AsymmetricKeyParameter<RSAAsymmetricKey> params) {
      1|    _forEncryption = forEncryption;
      2|    _key = params.key;
       |
      2|    if (_key is RSAPrivateKey) {
      1|      var privKey = (_key as RSAPrivateKey);
      3|      var pSub1 = (privKey.p - BigInt.one);
      3|      var qSub1 = (privKey.q - BigInt.one);
      3|      _dP = privKey.privateExponent.remainder(pSub1);
      3|      _dQ = privKey.privateExponent.remainder(qSub1);
      4|      _qInv = privKey.q.modInverse(privKey.p);
       |    }
       |  }
       |
      0|  @override
       |  Uint8List process(Uint8List data) {
       |    // Expand the output block size by an extra byte to handle cases where
       |    // the output is larger than expected.
      0|    var out = Uint8List(outputBlockSize + 1);
      0|    var len = processBlock(data, 0, data.length, out, 0);
      0|    return out.sublist(0, len);
       |  }
       |
      1|  @override
       |  int processBlock(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      1|    var input = _convertInput(inp, inpOff, len);
      1|    var output = _processBigInteger(input);
      1|    return _convertOutput(output, out, outOff);
       |  }
       |
      1|  BigInt _convertInput(Uint8List inp, int inpOff, int len) {
      1|    var inpLen = inp.length;
       |
      2|    if (inpLen < inpOff + len) {
      0|      throw ArgumentError.value(inpOff, 'inpOff',
      0|          'Not enough data for RSA cipher (length=$len, available=$inpLen)');
       |    }
       |
      3|    if (inputBlockSize + 1 < len) {
      0|      throw ArgumentError.value(len, 'len',
      0|          'Too large for maximum RSA cipher input block size ($inputBlockSize)');
       |    }
       |
      3|    var res = utils.decodeBigInt(inp.sublist(inpOff, inpOff + len));
      3|    if (res >= _key.modulus) {
      0|      throw ArgumentError('Input block too large for RSA key size');
       |    }
       |
       |    return res;
       |  }
       |
      1|  int _convertOutput(BigInt result, Uint8List out, int outOff) {
      1|    final output = utils.encodeBigInt(result);
       |
      1|    if (_forEncryption) {
      2|      if ((output[0] == 0) && (output.length > outputBlockSize)) {
       |        // have ended up with an extra zero byte, copy down.
      0|        var len = (output.length - 1);
      0|        out.setRange(outOff, outOff + len, output.sublist(1));
       |        return len;
       |      }
      3|      if (output.length < outputBlockSize) {
       |        // have ended up with less bytes than normal, lengthen
      0|        var len = outputBlockSize;
      0|        out.setRange((outOff + len - output.length), (outOff + len), output);
       |        return len;
       |      }
       |    } else {
      2|      if (output[0] == 0) {
       |        // have ended up with an extra zero byte, copy down.
      0|        var len = (output.length - 1);
      0|        out.setRange(outOff, outOff + len, output.sublist(1));
       |        return len;
       |      }
       |    }
       |
      1|    out.setAll(outOff, output);
      1|    return output.length;
       |  }
       |
      1|  BigInt _processBigInteger(BigInt input) {
      2|    if (_key is RSAPrivateKey) {
      1|      var privKey = (_key as RSAPrivateKey);
       |      BigInt mP, mQ, h, m;
       |
      5|      mP = (input.remainder(privKey.p)).modPow(_dP, privKey.p);
       |
      5|      mQ = (input.remainder(privKey.q)).modPow(_dQ, privKey.q);
       |
      1|      h = mP - mQ;
      2|      h = h * _qInv;
      2|      h = h % privKey.p;
       |
      2|      m = h * privKey.q;
      1|      m = m + mQ;
       |
       |      return m;
       |    } else {
      5|      return input.modPow(_key.exponent, _key.modulus);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/aes_fast.dart
       |// See file LICENSE for more information.
       |
       |library impl.block_cipher.aes_fast;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_block_cipher.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// An implementation of the AES (Rijndael), from FIPS-197.
       |///
       |/// For further details see: [http://csrc.nist.gov/encryption/aes/]
       |///
       |/// This implementation is based on optimizations from Dr. Brian Gladman's paper
       |/// and C code at [http://fp.gladman.plus.com/cryptography_technology/rijndael/]
       |///
       |/// There are three levels of tradeoff of speed vs memory and they are written
       |/// as three separate classes from which to choose.
       |///
       |/// The fastest uses 8Kbytes of static tables to precompute round calculations,
       |/// 4 256 word tables for encryption and 4 for decryption.
       |///
       |/// The middle performance version uses only one 256 word table for each, for a
       |/// total of 2Kbytes, adding 12 rotate operations per round to compute the values
       |/// contained in the other tables from the contents of the first.
       |///
       |/// The slowest version uses no static tables at all and computes the values in
       |/// each round.
       |/// This file contains the fast version with 8Kbytes of static tables for round
       |/// precomputation.
       |class AESFastEngine extends BaseBlockCipher {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(BlockCipher, 'AES', () => AESFastEngine());
       |
       |  static const _BLOCK_SIZE = 16;
       |
       |  bool _forEncryption;
       |  List<List<int>> _workingKey;
       |  int _rounds;
       |  int _c0, _c1, _c2, _c3;
       |
      0|  @override
       |  String get algorithmName => 'AES';
       |
      1|  @override
       |  int get blockSize => _BLOCK_SIZE;
       |
      0|  @override
       |  void reset() {
      0|    _rounds = 0;
      0|    _c0 = _c1 = _c2 = _c3 = 0;
      0|    _forEncryption = false;
      0|    _workingKey = null;
       |  }
       |
      1|  @override
       |  void init(bool forEncryption, covariant KeyParameter params) {
      1|    var key = params.key;
       |
      3|    var kc = (key.lengthInBytes / 4).floor(); // key length in words
      3|    if (((kc != 4) && (kc != 6) && (kc != 8)) ||
      3|        ((kc * 4) != key.lengthInBytes)) {
      0|      throw ArgumentError('Key length must be 128/192/256 bits');
       |    }
       |
      1|    _forEncryption = forEncryption;
      2|    _rounds = kc +
       |        6; // This is not always true for the generalized Rijndael that allows larger block sizes
      2|    _workingKey = List.generate(
      4|        _rounds + 1, (int i) => List<int>(4)); // 4 words in a block
       |
       |    // Copy the key into the round key array.
      1|    var keyView = ByteData.view(
      6|        params.key.buffer, params.key.offsetInBytes, params.key.length);
      4|    for (var i = 0, t = 0; i < key.lengthInBytes; i += 4, t++) {
      1|      var value = unpack32(keyView, i, Endian.little);
      5|      _workingKey[t >> 2][t & 3] = value;
       |    }
       |
       |    // While not enough round key material calculated calculate values.
      3|    var k = (_rounds + 1) << 2;
      2|    for (var i = kc; i < k; i++) {
      8|      var temp = _workingKey[(i - 1) >> 2][(i - 1) & 3].toInt();
      2|      if ((i % kc) == 0) {
      8|        temp = _subWord(_shift(temp, 8)) ^ _rcon[((i / kc) - 1).floor()];
      3|      } else if ((kc > 6) && ((i % kc) == 4)) {
      1|        temp = _subWord(temp);
       |      }
       |
      8|      var value = _workingKey[(i - kc) >> 2][(i - kc) & 3] ^ temp;
      5|      _workingKey[i >> 2][i & 3] = value;
       |    }
       |
       |    if (!forEncryption) {
      0|      for (var j = 1; j < _rounds; j++) {
      0|        for (var i = 0; i < 4; i++) {
      0|          var value = _invMcol(_workingKey[j][i].toInt());
      0|          _workingKey[j][i] = value;
       |        }
       |      }
       |    }
       |  }
       |
      1|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      1|    if (_workingKey == null) {
      0|      throw StateError('AES engine not initialised');
       |    }
       |
      4|    if ((inpOff + (32 / 2)) > inp.lengthInBytes) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
       |
      4|    if ((outOff + (32 / 2)) > out.lengthInBytes) {
      0|      throw ArgumentError('Output buffer too short');
       |    }
       |
      4|    var inpView = ByteData.view(inp.buffer, inp.offsetInBytes, inp.length);
      4|    var outView = ByteData.view(out.buffer, out.offsetInBytes, out.length);
      1|    if (_forEncryption) {
      1|      _unpackBlock(inpView, inpOff);
      2|      _encryptBlock(_workingKey);
      1|      _packBlock(outView, outOff);
       |    } else {
      0|      _unpackBlock(inpView, inpOff);
      0|      _decryptBlock(_workingKey);
      0|      _packBlock(outView, outOff);
       |    }
       |
       |    return _BLOCK_SIZE;
       |  }
       |
      1|  void _encryptBlock(List<List<int>> kw) {
       |    int r, r0, r1, r2, r3;
       |
      5|    _c0 ^= kw[0][0].toInt();
      5|    _c1 ^= kw[0][1].toInt();
      5|    _c2 ^= kw[0][2].toInt();
      5|    _c3 ^= kw[0][3].toInt();
       |
       |    r = 1;
      3|    while (r < _rounds - 1) {
      5|      r0 = _t0[_c0 & 255] ^
      6|          _t1[(_c1 >> 8) & 255] ^
      6|          _t2[(_c2 >> 16) & 255] ^
      6|          _t3[(_c3 >> 24) & 255] ^
      3|          kw[r][0].toInt();
      5|      r1 = _t0[_c1 & 255] ^
      6|          _t1[(_c2 >> 8) & 255] ^
      6|          _t2[(_c3 >> 16) & 255] ^
      6|          _t3[(_c0 >> 24) & 255] ^
      3|          kw[r][1].toInt();
      5|      r2 = _t0[_c2 & 255] ^
      6|          _t1[(_c3 >> 8) & 255] ^
      6|          _t2[(_c0 >> 16) & 255] ^
      6|          _t3[(_c1 >> 24) & 255] ^
      3|          kw[r][2].toInt();
      5|      r3 = _t0[_c3 & 255] ^
      6|          _t1[(_c0 >> 8) & 255] ^
      6|          _t2[(_c1 >> 16) & 255] ^
      6|          _t3[(_c2 >> 24) & 255] ^
      3|          kw[r][3].toInt();
      1|      r++;
      5|      _c0 = _t0[r0 & 255] ^
      5|          _t1[(r1 >> 8) & 255] ^
      5|          _t2[(r2 >> 16) & 255] ^
      5|          _t3[(r3 >> 24) & 255] ^
      3|          kw[r][0].toInt();
      5|      _c1 = _t0[r1 & 255] ^
      5|          _t1[(r2 >> 8) & 255] ^
      5|          _t2[(r3 >> 16) & 255] ^
      5|          _t3[(r0 >> 24) & 255] ^
      3|          kw[r][1].toInt();
      5|      _c2 = _t0[r2 & 255] ^
      5|          _t1[(r3 >> 8) & 255] ^
      5|          _t2[(r0 >> 16) & 255] ^
      5|          _t3[(r1 >> 24) & 255] ^
      3|          kw[r][2].toInt();
      5|      _c3 = _t0[r3 & 255] ^
      5|          _t1[(r0 >> 8) & 255] ^
      5|          _t2[(r1 >> 16) & 255] ^
      5|          _t3[(r2 >> 24) & 255] ^
      3|          kw[r][3].toInt();
      1|      r++;
       |    }
       |
      5|    r0 = _t0[_c0 & 255] ^
      6|        _t1[(_c1 >> 8) & 255] ^
      6|        _t2[(_c2 >> 16) & 255] ^
      6|        _t3[(_c3 >> 24) & 255] ^
      3|        kw[r][0].toInt();
      5|    r1 = _t0[_c1 & 255] ^
      6|        _t1[(_c2 >> 8) & 255] ^
      6|        _t2[(_c3 >> 16) & 255] ^
      6|        _t3[(_c0 >> 24) & 255] ^
      3|        kw[r][1].toInt();
      5|    r2 = _t0[_c2 & 255] ^
      6|        _t1[(_c3 >> 8) & 255] ^
      6|        _t2[(_c0 >> 16) & 255] ^
      6|        _t3[(_c1 >> 24) & 255] ^
      3|        kw[r][2].toInt();
      5|    r3 = _t0[_c3 & 255] ^
      6|        _t1[(_c0 >> 8) & 255] ^
      6|        _t2[(_c1 >> 16) & 255] ^
      6|        _t3[(_c2 >> 24) & 255] ^
      3|        kw[r][3].toInt();
      1|    r++;
       |
       |    // the final round's table is a simple function of S so we don't use a whole other four tables for it
      6|    _c0 = (_s[r0 & 255] & 255) ^
      7|        ((_s[(r1 >> 8) & 255] & 255) << 8) ^
      7|        ((_s[(r2 >> 16) & 255] & 255) << 16) ^
      6|        (_s[(r3 >> 24) & 255] << 24) ^
      3|        kw[r][0].toInt();
      6|    _c1 = (_s[r1 & 255] & 255) ^
      7|        ((_s[(r2 >> 8) & 255] & 255) << 8) ^
      7|        ((_s[(r3 >> 16) & 255] & 255) << 16) ^
      6|        (_s[(r0 >> 24) & 255] << 24) ^
      3|        kw[r][1].toInt();
      6|    _c2 = (_s[r2 & 255] & 255) ^
      7|        ((_s[(r3 >> 8) & 255] & 255) << 8) ^
      7|        ((_s[(r0 >> 16) & 255] & 255) << 16) ^
      6|        (_s[(r1 >> 24) & 255] << 24) ^
      3|        kw[r][2].toInt();
      6|    _c3 = (_s[r3 & 255] & 255) ^
      7|        ((_s[(r0 >> 8) & 255] & 255) << 8) ^
      7|        ((_s[(r1 >> 16) & 255] & 255) << 16) ^
      6|        (_s[(r2 >> 24) & 255] << 24) ^
      3|        kw[r][3].toInt();
       |  }
       |
      0|  void _decryptBlock(List<List<int>> kw) {
       |    int r, r0, r1, r2, r3;
       |
      0|    _c0 ^= kw[_rounds][0].toInt();
      0|    _c1 ^= kw[_rounds][1].toInt();
      0|    _c2 ^= kw[_rounds][2].toInt();
      0|    _c3 ^= kw[_rounds][3].toInt();
       |
      0|    r = _rounds - 1;
      0|    while (r > 1) {
      0|      r0 = _tinv0[_c0 & 255] ^
      0|          _tinv1[(_c3 >> 8) & 255] ^
      0|          _tinv2[(_c2 >> 16) & 255] ^
      0|          _tinv3[(_c1 >> 24) & 255] ^
      0|          kw[r][0].toInt();
      0|      r1 = _tinv0[_c1 & 255] ^
      0|          _tinv1[(_c0 >> 8) & 255] ^
      0|          _tinv2[(_c3 >> 16) & 255] ^
      0|          _tinv3[(_c2 >> 24) & 255] ^
      0|          kw[r][1].toInt();
      0|      r2 = _tinv0[_c2 & 255] ^
      0|          _tinv1[(_c1 >> 8) & 255] ^
      0|          _tinv2[(_c0 >> 16) & 255] ^
      0|          _tinv3[(_c3 >> 24) & 255] ^
      0|          kw[r][2].toInt();
      0|      r3 = _tinv0[_c3 & 255] ^
      0|          _tinv1[(_c2 >> 8) & 255] ^
      0|          _tinv2[(_c1 >> 16) & 255] ^
      0|          _tinv3[(_c0 >> 24) & 255] ^
      0|          kw[r][3].toInt();
      0|      r--;
      0|      _c0 = _tinv0[r0 & 255] ^
      0|          _tinv1[(r3 >> 8) & 255] ^
      0|          _tinv2[(r2 >> 16) & 255] ^
      0|          _tinv3[(r1 >> 24) & 255] ^
      0|          kw[r][0].toInt();
      0|      _c1 = _tinv0[r1 & 255] ^
      0|          _tinv1[(r0 >> 8) & 255] ^
      0|          _tinv2[(r3 >> 16) & 255] ^
      0|          _tinv3[(r2 >> 24) & 255] ^
      0|          kw[r][1].toInt();
      0|      _c2 = _tinv0[r2 & 255] ^
      0|          _tinv1[(r1 >> 8) & 255] ^
      0|          _tinv2[(r0 >> 16) & 255] ^
      0|          _tinv3[(r3 >> 24) & 255] ^
      0|          kw[r][2].toInt();
      0|      _c3 = _tinv0[r3 & 255] ^
      0|          _tinv1[(r2 >> 8) & 255] ^
      0|          _tinv2[(r1 >> 16) & 255] ^
      0|          _tinv3[(r0 >> 24) & 255] ^
      0|          kw[r][3].toInt();
      0|      r--;
       |    }
       |
      0|    r0 = _tinv0[_c0 & 255] ^
      0|        _tinv1[(_c3 >> 8) & 255] ^
      0|        _tinv2[(_c2 >> 16) & 255] ^
      0|        _tinv3[(_c1 >> 24) & 255] ^
      0|        kw[r][0].toInt();
      0|    r1 = _tinv0[_c1 & 255] ^
      0|        _tinv1[(_c0 >> 8) & 255] ^
      0|        _tinv2[(_c3 >> 16) & 255] ^
      0|        _tinv3[(_c2 >> 24) & 255] ^
      0|        kw[r][1].toInt();
      0|    r2 = _tinv0[_c2 & 255] ^
      0|        _tinv1[(_c1 >> 8) & 255] ^
      0|        _tinv2[(_c0 >> 16) & 255] ^
      0|        _tinv3[(_c3 >> 24) & 255] ^
      0|        kw[r][2].toInt();
      0|    r3 = _tinv0[_c3 & 255] ^
      0|        _tinv1[(_c2 >> 8) & 255] ^
      0|        _tinv2[(_c1 >> 16) & 255] ^
      0|        _tinv3[(_c0 >> 24) & 255] ^
      0|        kw[r][3].toInt();
       |
       |    // the final round's table is a simple function of Si so we don't use a whole other four tables for it
      0|    _c0 = (_si[r0 & 255] & 255) ^
      0|        ((_si[(r3 >> 8) & 255] & 255) << 8) ^
      0|        ((_si[(r2 >> 16) & 255] & 255) << 16) ^
      0|        (_si[(r1 >> 24) & 255] << 24) ^
      0|        kw[0][0].toInt();
      0|    _c1 = (_si[r1 & 255] & 255) ^
      0|        ((_si[(r0 >> 8) & 255] & 255) << 8) ^
      0|        ((_si[(r3 >> 16) & 255] & 255) << 16) ^
      0|        (_si[(r2 >> 24) & 255] << 24) ^
      0|        kw[0][1].toInt();
      0|    _c2 = (_si[r2 & 255] & 255) ^
      0|        ((_si[(r1 >> 8) & 255] & 255) << 8) ^
      0|        ((_si[(r0 >> 16) & 255] & 255) << 16) ^
      0|        (_si[(r3 >> 24) & 255] << 24) ^
      0|        kw[0][2].toInt();
      0|    _c3 = (_si[r3 & 255] & 255) ^
      0|        ((_si[(r2 >> 8) & 255] & 255) << 8) ^
      0|        ((_si[(r1 >> 16) & 255] & 255) << 16) ^
      0|        (_si[(r0 >> 24) & 255] << 24) ^
      0|        kw[0][3].toInt();
       |  }
       |
      1|  void _unpackBlock(ByteData view, int off) {
      2|    _c0 = unpack32(view, off, Endian.little);
      3|    _c1 = unpack32(view, off + 4, Endian.little);
      3|    _c2 = unpack32(view, off + 8, Endian.little);
      3|    _c3 = unpack32(view, off + 12, Endian.little);
       |  }
       |
      1|  void _packBlock(ByteData view, int off) {
      2|    pack32(_c0, view, off, Endian.little);
      3|    pack32(_c1, view, off + 4, Endian.little);
      3|    pack32(_c2, view, off + 8, Endian.little);
      3|    pack32(_c3, view, off + 12, Endian.little);
       |  }
       |}
       |
      2|int _shift(int r, int shift) => rotr32(r, shift);
       |
       |/* multiply four bytes in GF(2^8) by 'x' {02} in parallel */
       |
       |const int _m1 = 0x80808080;
       |const int _m2 = 0x7f7f7f7f;
       |const int _m3 = 0x0000001b;
       |
      0|int _fFmulX(int x) {
      0|  var lsr = shiftr32((x & _m1), 7);
      0|  return (((x & _m2) << 1) ^ lsr * _m3);
       |}
       |
       |///
       |/// The following defines provide alternative definitions of FFmulX that might
       |/// give improved performance if a fast 32-bit multiply is not available.
       |/// private int FFmulX(int x) { int u = x & m1; u |= (u >> 1); return ((x & m2) << 1) ^ ((u >>> 3) | (u >>> 6)); }
       |/// private static final int  m4 = 0x1b1b1b1b;
       |/// private int FFmulX(int x) { int u = x & m1; return ((x & m2) << 1) ^ ((u - (u >>> 7)) & m4); }
       |///
      0|int _invMcol(int x) {
      0|  var f2 = _fFmulX(x);
      0|  var f4 = _fFmulX(f2);
      0|  var f8 = _fFmulX(f4);
      0|  var f9 = x ^ f8;
       |
      0|  return f2 ^
      0|      f4 ^
      0|      f8 ^
      0|      _shift(f2 ^ f9, 8) ^
      0|      _shift(f4 ^ f9, 16) ^
      0|      _shift(f9, 24);
       |}
       |
      1|int _subWord(int x) {
      5|  return (_s[x & 255] & 255 |
      7|      ((_s[(x >> 8) & 255] & 255) << 8) |
      7|      ((_s[(x >> 16) & 255] & 255) << 16) |
      5|      _s[(x >> 24) & 255] << 24);
       |}
       |
       |// The S box
      3|final _s = [
       |  99,
       |  124,
       |  119,
       |  123,
       |  242,
       |  107,
       |  111,
       |  197,
       |  48,
       |  1,
       |  103,
       |  43,
       |  254,
       |  215,
       |  171,
       |  118,
       |  202,
       |  130,
       |  201,
       |  125,
       |  250,
       |  89,
       |  71,
       |  240,
       |  173,
       |  212,
       |  162,
       |  175,
       |  156,
       |  164,
       |  114,
       |  192,
       |  183,
       |  253,
       |  147,
       |  38,
       |  54,
       |  63,
       |  247,
       |  204,
       |  52,
       |  165,
       |  229,
       |  241,
       |  113,
       |  216,
       |  49,
       |  21,
       |  4,
       |  199,
       |  35,
       |  195,
       |  24,
       |  150,
       |  5,
       |  154,
       |  7,
       |  18,
       |  128,
       |  226,
       |  235,
       |  39,
       |  178,
       |  117,
       |  9,
       |  131,
       |  44,
       |  26,
       |  27,
       |  110,
       |  90,
       |  160,
       |  82,
       |  59,
       |  214,
       |  179,
       |  41,
       |  227,
       |  47,
       |  132,
       |  83,
       |  209,
       |  0,
       |  237,
       |  32,
       |  252,
       |  177,
       |  91,
       |  106,
       |  203,
       |  190,
       |  57,
       |  74,
       |  76,
       |  88,
       |  207,
       |  208,
       |  239,
       |  170,
       |  251,
       |  67,
       |  77,
       |  51,
       |  133,
       |  69,
       |  249,
       |  2,
       |  127,
       |  80,
       |  60,
       |  159,
       |  168,
       |  81,
       |  163,
       |  64,
       |  143,
       |  146,
       |  157,
       |  56,
       |  245,
       |  188,
       |  182,
       |  218,
       |  33,
       |  16,
       |  255,
       |  243,
       |  210,
       |  205,
       |  12,
       |  19,
       |  236,
       |  95,
       |  151,
       |  68,
       |  23,
       |  196,
       |  167,
       |  126,
       |  61,
       |  100,
       |  93,
       |  25,
       |  115,
       |  96,
       |  129,
       |  79,
       |  220,
       |  34,
       |  42,
       |  144,
       |  136,
       |  70,
       |  238,
       |  184,
       |  20,
       |  222,
       |  94,
       |  11,
       |  219,
       |  224,
       |  50,
       |  58,
       |  10,
       |  73,
       |  6,
       |  36,
       |  92,
       |  194,
       |  211,
       |  172,
       |  98,
       |  145,
       |  149,
       |  228,
       |  121,
       |  231,
       |  200,
       |  55,
       |  109,
       |  141,
       |  213,
       |  78,
       |  169,
       |  108,
       |  86,
       |  244,
       |  234,
       |  101,
       |  122,
       |  174,
       |  8,
       |  186,
       |  120,
       |  37,
       |  46,
       |  28,
       |  166,
       |  180,
       |  198,
       |  232,
       |  221,
       |  116,
       |  31,
       |  75,
       |  189,
       |  139,
       |  138,
       |  112,
       |  62,
       |  181,
       |  102,
       |  72,
       |  3,
       |  246,
       |  14,
       |  97,
       |  53,
       |  87,
       |  185,
       |  134,
       |  193,
       |  29,
       |  158,
       |  225,
       |  248,
       |  152,
       |  17,
       |  105,
       |  217,
       |  142,
       |  148,
       |  155,
       |  30,
       |  135,
       |  233,
       |  206,
       |  85,
       |  40,
       |  223,
       |  140,
       |  161,
       |  137,
       |  13,
       |  191,
       |  230,
       |  66,
       |  104,
       |  65,
       |  153,
       |  45,
       |  15,
       |  176,
       |  84,
       |  187,
       |  22
       |];
       |
       |// The inverse S-box
      0|final _si = [
       |  82,
       |  9,
       |  106,
       |  213,
       |  48,
       |  54,
       |  165,
       |  56,
       |  191,
       |  64,
       |  163,
       |  158,
       |  129,
       |  243,
       |  215,
       |  251,
       |  124,
       |  227,
       |  57,
       |  130,
       |  155,
       |  47,
       |  255,
       |  135,
       |  52,
       |  142,
       |  67,
       |  68,
       |  196,
       |  222,
       |  233,
       |  203,
       |  84,
       |  123,
       |  148,
       |  50,
       |  166,
       |  194,
       |  35,
       |  61,
       |  238,
       |  76,
       |  149,
       |  11,
       |  66,
       |  250,
       |  195,
       |  78,
       |  8,
       |  46,
       |  161,
       |  102,
       |  40,
       |  217,
       |  36,
       |  178,
       |  118,
       |  91,
       |  162,
       |  73,
       |  109,
       |  139,
       |  209,
       |  37,
       |  114,
       |  248,
       |  246,
       |  100,
       |  134,
       |  104,
       |  152,
       |  22,
       |  212,
       |  164,
       |  92,
       |  204,
       |  93,
       |  101,
       |  182,
       |  146,
       |  108,
       |  112,
       |  72,
       |  80,
       |  253,
       |  237,
       |  185,
       |  218,
       |  94,
       |  21,
       |  70,
       |  87,
       |  167,
       |  141,
       |  157,
       |  132,
       |  144,
       |  216,
       |  171,
       |  0,
       |  140,
       |  188,
       |  211,
       |  10,
       |  247,
       |  228,
       |  88,
       |  5,
       |  184,
       |  179,
       |  69,
       |  6,
       |  208,
       |  44,
       |  30,
       |  143,
       |  202,
       |  63,
       |  15,
       |  2,
       |  193,
       |  175,
       |  189,
       |  3,
       |  1,
       |  19,
       |  138,
       |  107,
       |  58,
       |  145,
       |  17,
       |  65,
       |  79,
       |  103,
       |  220,
       |  234,
       |  151,
       |  242,
       |  207,
       |  206,
       |  240,
       |  180,
       |  230,
       |  115,
       |  150,
       |  172,
       |  116,
       |  34,
       |  231,
       |  173,
       |  53,
       |  133,
       |  226,
       |  249,
       |  55,
       |  232,
       |  28,
       |  117,
       |  223,
       |  110,
       |  71,
       |  241,
       |  26,
       |  113,
       |  29,
       |  41,
       |  197,
       |  137,
       |  111,
       |  183,
       |  98,
       |  14,
       |  170,
       |  24,
       |  190,
       |  27,
       |  252,
       |  86,
       |  62,
       |  75,
       |  198,
       |  210,
       |  121,
       |  32,
       |  154,
       |  219,
       |  192,
       |  254,
       |  120,
       |  205,
       |  90,
       |  244,
       |  31,
       |  221,
       |  168,
       |  51,
       |  136,
       |  7,
       |  199,
       |  49,
       |  177,
       |  18,
       |  16,
       |  89,
       |  39,
       |  128,
       |  236,
       |  95,
       |  96,
       |  81,
       |  127,
       |  169,
       |  25,
       |  181,
       |  74,
       |  13,
       |  45,
       |  229,
       |  122,
       |  159,
       |  147,
       |  201,
       |  156,
       |  239,
       |  160,
       |  224,
       |  59,
       |  77,
       |  174,
       |  42,
       |  245,
       |  176,
       |  200,
       |  235,
       |  187,
       |  60,
       |  131,
       |  83,
       |  153,
       |  97,
       |  23,
       |  43,
       |  4,
       |  126,
       |  186,
       |  119,
       |  214,
       |  38,
       |  225,
       |  105,
       |  20,
       |  99,
       |  85,
       |  33,
       |  12,
       |  125,
       |];
       |
       |// vector used in calculating key schedule (powers of x in GF(256))
      3|final _rcon = [
       |  0x01,
       |  0x02,
       |  0x04,
       |  0x08,
       |  0x10,
       |  0x20,
       |  0x40,
       |  0x80,
       |  0x1b,
       |  0x36,
       |  0x6c,
       |  0xd8,
       |  0xab,
       |  0x4d,
       |  0x9a,
       |  0x2f,
       |  0x5e,
       |  0xbc,
       |  0x63,
       |  0xc6,
       |  0x97,
       |  0x35,
       |  0x6a,
       |  0xd4,
       |  0xb3,
       |  0x7d,
       |  0xfa,
       |  0xef,
       |  0xc5,
       |  0x91
       |];
       |
       |// precomputation tables of calculations for rounds
      3|final _t0 = [
       |  0xa56363c6,
       |  0x847c7cf8,
       |  0x997777ee,
       |  0x8d7b7bf6,
       |  0x0df2f2ff,
       |  0xbd6b6bd6,
       |  0xb16f6fde,
       |  0x54c5c591,
       |  0x50303060,
       |  0x03010102,
       |  0xa96767ce,
       |  0x7d2b2b56,
       |  0x19fefee7,
       |  0x62d7d7b5,
       |  0xe6abab4d,
       |  0x9a7676ec,
       |  0x45caca8f,
       |  0x9d82821f,
       |  0x40c9c989,
       |  0x877d7dfa,
       |  0x15fafaef,
       |  0xeb5959b2,
       |  0xc947478e,
       |  0x0bf0f0fb,
       |  0xecadad41,
       |  0x67d4d4b3,
       |  0xfda2a25f,
       |  0xeaafaf45,
       |  0xbf9c9c23,
       |  0xf7a4a453,
       |  0x967272e4,
       |  0x5bc0c09b,
       |  0xc2b7b775,
       |  0x1cfdfde1,
       |  0xae93933d,
       |  0x6a26264c,
       |  0x5a36366c,
       |  0x413f3f7e,
       |  0x02f7f7f5,
       |  0x4fcccc83,
       |  0x5c343468,
       |  0xf4a5a551,
       |  0x34e5e5d1,
       |  0x08f1f1f9,
       |  0x937171e2,
       |  0x73d8d8ab,
       |  0x53313162,
       |  0x3f15152a,
       |  0x0c040408,
       |  0x52c7c795,
       |  0x65232346,
       |  0x5ec3c39d,
       |  0x28181830,
       |  0xa1969637,
       |  0x0f05050a,
       |  0xb59a9a2f,
       |  0x0907070e,
       |  0x36121224,
       |  0x9b80801b,
       |  0x3de2e2df,
       |  0x26ebebcd,
       |  0x6927274e,
       |  0xcdb2b27f,
       |  0x9f7575ea,
       |  0x1b090912,
       |  0x9e83831d,
       |  0x742c2c58,
       |  0x2e1a1a34,
       |  0x2d1b1b36,
       |  0xb26e6edc,
       |  0xee5a5ab4,
       |  0xfba0a05b,
       |  0xf65252a4,
       |  0x4d3b3b76,
       |  0x61d6d6b7,
       |  0xceb3b37d,
       |  0x7b292952,
       |  0x3ee3e3dd,
       |  0x712f2f5e,
       |  0x97848413,
       |  0xf55353a6,
       |  0x68d1d1b9,
       |  0x00000000,
       |  0x2cededc1,
       |  0x60202040,
       |  0x1ffcfce3,
       |  0xc8b1b179,
       |  0xed5b5bb6,
       |  0xbe6a6ad4,
       |  0x46cbcb8d,
       |  0xd9bebe67,
       |  0x4b393972,
       |  0xde4a4a94,
       |  0xd44c4c98,
       |  0xe85858b0,
       |  0x4acfcf85,
       |  0x6bd0d0bb,
       |  0x2aefefc5,
       |  0xe5aaaa4f,
       |  0x16fbfbed,
       |  0xc5434386,
       |  0xd74d4d9a,
       |  0x55333366,
       |  0x94858511,
       |  0xcf45458a,
       |  0x10f9f9e9,
       |  0x06020204,
       |  0x817f7ffe,
       |  0xf05050a0,
       |  0x443c3c78,
       |  0xba9f9f25,
       |  0xe3a8a84b,
       |  0xf35151a2,
       |  0xfea3a35d,
       |  0xc0404080,
       |  0x8a8f8f05,
       |  0xad92923f,
       |  0xbc9d9d21,
       |  0x48383870,
       |  0x04f5f5f1,
       |  0xdfbcbc63,
       |  0xc1b6b677,
       |  0x75dadaaf,
       |  0x63212142,
       |  0x30101020,
       |  0x1affffe5,
       |  0x0ef3f3fd,
       |  0x6dd2d2bf,
       |  0x4ccdcd81,
       |  0x140c0c18,
       |  0x35131326,
       |  0x2fececc3,
       |  0xe15f5fbe,
       |  0xa2979735,
       |  0xcc444488,
       |  0x3917172e,
       |  0x57c4c493,
       |  0xf2a7a755,
       |  0x827e7efc,
       |  0x473d3d7a,
       |  0xac6464c8,
       |  0xe75d5dba,
       |  0x2b191932,
       |  0x957373e6,
       |  0xa06060c0,
       |  0x98818119,
       |  0xd14f4f9e,
       |  0x7fdcdca3,
       |  0x66222244,
       |  0x7e2a2a54,
       |  0xab90903b,
       |  0x8388880b,
       |  0xca46468c,
       |  0x29eeeec7,
       |  0xd3b8b86b,
       |  0x3c141428,
       |  0x79dedea7,
       |  0xe25e5ebc,
       |  0x1d0b0b16,
       |  0x76dbdbad,
       |  0x3be0e0db,
       |  0x56323264,
       |  0x4e3a3a74,
       |  0x1e0a0a14,
       |  0xdb494992,
       |  0x0a06060c,
       |  0x6c242448,
       |  0xe45c5cb8,
       |  0x5dc2c29f,
       |  0x6ed3d3bd,
       |  0xefacac43,
       |  0xa66262c4,
       |  0xa8919139,
       |  0xa4959531,
       |  0x37e4e4d3,
       |  0x8b7979f2,
       |  0x32e7e7d5,
       |  0x43c8c88b,
       |  0x5937376e,
       |  0xb76d6dda,
       |  0x8c8d8d01,
       |  0x64d5d5b1,
       |  0xd24e4e9c,
       |  0xe0a9a949,
       |  0xb46c6cd8,
       |  0xfa5656ac,
       |  0x07f4f4f3,
       |  0x25eaeacf,
       |  0xaf6565ca,
       |  0x8e7a7af4,
       |  0xe9aeae47,
       |  0x18080810,
       |  0xd5baba6f,
       |  0x887878f0,
       |  0x6f25254a,
       |  0x722e2e5c,
       |  0x241c1c38,
       |  0xf1a6a657,
       |  0xc7b4b473,
       |  0x51c6c697,
       |  0x23e8e8cb,
       |  0x7cdddda1,
       |  0x9c7474e8,
       |  0x211f1f3e,
       |  0xdd4b4b96,
       |  0xdcbdbd61,
       |  0x868b8b0d,
       |  0x858a8a0f,
       |  0x907070e0,
       |  0x423e3e7c,
       |  0xc4b5b571,
       |  0xaa6666cc,
       |  0xd8484890,
       |  0x05030306,
       |  0x01f6f6f7,
       |  0x120e0e1c,
       |  0xa36161c2,
       |  0x5f35356a,
       |  0xf95757ae,
       |  0xd0b9b969,
       |  0x91868617,
       |  0x58c1c199,
       |  0x271d1d3a,
       |  0xb99e9e27,
       |  0x38e1e1d9,
       |  0x13f8f8eb,
       |  0xb398982b,
       |  0x33111122,
       |  0xbb6969d2,
       |  0x70d9d9a9,
       |  0x898e8e07,
       |  0xa7949433,
       |  0xb69b9b2d,
       |  0x221e1e3c,
       |  0x92878715,
       |  0x20e9e9c9,
       |  0x49cece87,
       |  0xff5555aa,
       |  0x78282850,
       |  0x7adfdfa5,
       |  0x8f8c8c03,
       |  0xf8a1a159,
       |  0x80898909,
       |  0x170d0d1a,
       |  0xdabfbf65,
       |  0x31e6e6d7,
       |  0xc6424284,
       |  0xb86868d0,
       |  0xc3414182,
       |  0xb0999929,
       |  0x772d2d5a,
       |  0x110f0f1e,
       |  0xcbb0b07b,
       |  0xfc5454a8,
       |  0xd6bbbb6d,
       |  0x3a16162c
       |];
       |
      3|final _t1 = [
       |  0x6363c6a5,
       |  0x7c7cf884,
       |  0x7777ee99,
       |  0x7b7bf68d,
       |  0xf2f2ff0d,
       |  0x6b6bd6bd,
       |  0x6f6fdeb1,
       |  0xc5c59154,
       |  0x30306050,
       |  0x01010203,
       |  0x6767cea9,
       |  0x2b2b567d,
       |  0xfefee719,
       |  0xd7d7b562,
       |  0xabab4de6,
       |  0x7676ec9a,
       |  0xcaca8f45,
       |  0x82821f9d,
       |  0xc9c98940,
       |  0x7d7dfa87,
       |  0xfafaef15,
       |  0x5959b2eb,
       |  0x47478ec9,
       |  0xf0f0fb0b,
       |  0xadad41ec,
       |  0xd4d4b367,
       |  0xa2a25ffd,
       |  0xafaf45ea,
       |  0x9c9c23bf,
       |  0xa4a453f7,
       |  0x7272e496,
       |  0xc0c09b5b,
       |  0xb7b775c2,
       |  0xfdfde11c,
       |  0x93933dae,
       |  0x26264c6a,
       |  0x36366c5a,
       |  0x3f3f7e41,
       |  0xf7f7f502,
       |  0xcccc834f,
       |  0x3434685c,
       |  0xa5a551f4,
       |  0xe5e5d134,
       |  0xf1f1f908,
       |  0x7171e293,
       |  0xd8d8ab73,
       |  0x31316253,
       |  0x15152a3f,
       |  0x0404080c,
       |  0xc7c79552,
       |  0x23234665,
       |  0xc3c39d5e,
       |  0x18183028,
       |  0x969637a1,
       |  0x05050a0f,
       |  0x9a9a2fb5,
       |  0x07070e09,
       |  0x12122436,
       |  0x80801b9b,
       |  0xe2e2df3d,
       |  0xebebcd26,
       |  0x27274e69,
       |  0xb2b27fcd,
       |  0x7575ea9f,
       |  0x0909121b,
       |  0x83831d9e,
       |  0x2c2c5874,
       |  0x1a1a342e,
       |  0x1b1b362d,
       |  0x6e6edcb2,
       |  0x5a5ab4ee,
       |  0xa0a05bfb,
       |  0x5252a4f6,
       |  0x3b3b764d,
       |  0xd6d6b761,
       |  0xb3b37dce,
       |  0x2929527b,
       |  0xe3e3dd3e,
       |  0x2f2f5e71,
       |  0x84841397,
       |  0x5353a6f5,
       |  0xd1d1b968,
       |  0x00000000,
       |  0xededc12c,
       |  0x20204060,
       |  0xfcfce31f,
       |  0xb1b179c8,
       |  0x5b5bb6ed,
       |  0x6a6ad4be,
       |  0xcbcb8d46,
       |  0xbebe67d9,
       |  0x3939724b,
       |  0x4a4a94de,
       |  0x4c4c98d4,
       |  0x5858b0e8,
       |  0xcfcf854a,
       |  0xd0d0bb6b,
       |  0xefefc52a,
       |  0xaaaa4fe5,
       |  0xfbfbed16,
       |  0x434386c5,
       |  0x4d4d9ad7,
       |  0x33336655,
       |  0x85851194,
       |  0x45458acf,
       |  0xf9f9e910,
       |  0x02020406,
       |  0x7f7ffe81,
       |  0x5050a0f0,
       |  0x3c3c7844,
       |  0x9f9f25ba,
       |  0xa8a84be3,
       |  0x5151a2f3,
       |  0xa3a35dfe,
       |  0x404080c0,
       |  0x8f8f058a,
       |  0x92923fad,
       |  0x9d9d21bc,
       |  0x38387048,
       |  0xf5f5f104,
       |  0xbcbc63df,
       |  0xb6b677c1,
       |  0xdadaaf75,
       |  0x21214263,
       |  0x10102030,
       |  0xffffe51a,
       |  0xf3f3fd0e,
       |  0xd2d2bf6d,
       |  0xcdcd814c,
       |  0x0c0c1814,
       |  0x13132635,
       |  0xececc32f,
       |  0x5f5fbee1,
       |  0x979735a2,
       |  0x444488cc,
       |  0x17172e39,
       |  0xc4c49357,
       |  0xa7a755f2,
       |  0x7e7efc82,
       |  0x3d3d7a47,
       |  0x6464c8ac,
       |  0x5d5dbae7,
       |  0x1919322b,
       |  0x7373e695,
       |  0x6060c0a0,
       |  0x81811998,
       |  0x4f4f9ed1,
       |  0xdcdca37f,
       |  0x22224466,
       |  0x2a2a547e,
       |  0x90903bab,
       |  0x88880b83,
       |  0x46468cca,
       |  0xeeeec729,
       |  0xb8b86bd3,
       |  0x1414283c,
       |  0xdedea779,
       |  0x5e5ebce2,
       |  0x0b0b161d,
       |  0xdbdbad76,
       |  0xe0e0db3b,
       |  0x32326456,
       |  0x3a3a744e,
       |  0x0a0a141e,
       |  0x494992db,
       |  0x06060c0a,
       |  0x2424486c,
       |  0x5c5cb8e4,
       |  0xc2c29f5d,
       |  0xd3d3bd6e,
       |  0xacac43ef,
       |  0x6262c4a6,
       |  0x919139a8,
       |  0x959531a4,
       |  0xe4e4d337,
       |  0x7979f28b,
       |  0xe7e7d532,
       |  0xc8c88b43,
       |  0x37376e59,
       |  0x6d6ddab7,
       |  0x8d8d018c,
       |  0xd5d5b164,
       |  0x4e4e9cd2,
       |  0xa9a949e0,
       |  0x6c6cd8b4,
       |  0x5656acfa,
       |  0xf4f4f307,
       |  0xeaeacf25,
       |  0x6565caaf,
       |  0x7a7af48e,
       |  0xaeae47e9,
       |  0x08081018,
       |  0xbaba6fd5,
       |  0x7878f088,
       |  0x25254a6f,
       |  0x2e2e5c72,
       |  0x1c1c3824,
       |  0xa6a657f1,
       |  0xb4b473c7,
       |  0xc6c69751,
       |  0xe8e8cb23,
       |  0xdddda17c,
       |  0x7474e89c,
       |  0x1f1f3e21,
       |  0x4b4b96dd,
       |  0xbdbd61dc,
       |  0x8b8b0d86,
       |  0x8a8a0f85,
       |  0x7070e090,
       |  0x3e3e7c42,
       |  0xb5b571c4,
       |  0x6666ccaa,
       |  0x484890d8,
       |  0x03030605,
       |  0xf6f6f701,
       |  0x0e0e1c12,
       |  0x6161c2a3,
       |  0x35356a5f,
       |  0x5757aef9,
       |  0xb9b969d0,
       |  0x86861791,
       |  0xc1c19958,
       |  0x1d1d3a27,
       |  0x9e9e27b9,
       |  0xe1e1d938,
       |  0xf8f8eb13,
       |  0x98982bb3,
       |  0x11112233,
       |  0x6969d2bb,
       |  0xd9d9a970,
       |  0x8e8e0789,
       |  0x949433a7,
       |  0x9b9b2db6,
       |  0x1e1e3c22,
       |  0x87871592,
       |  0xe9e9c920,
       |  0xcece8749,
       |  0x5555aaff,
       |  0x28285078,
       |  0xdfdfa57a,
       |  0x8c8c038f,
       |  0xa1a159f8,
       |  0x89890980,
       |  0x0d0d1a17,
       |  0xbfbf65da,
       |  0xe6e6d731,
       |  0x424284c6,
       |  0x6868d0b8,
       |  0x414182c3,
       |  0x999929b0,
       |  0x2d2d5a77,
       |  0x0f0f1e11,
       |  0xb0b07bcb,
       |  0x5454a8fc,
       |  0xbbbb6dd6,
       |  0x16162c3a
       |];
       |
      3|final _t2 = [
       |  0x63c6a563,
       |  0x7cf8847c,
       |  0x77ee9977,
       |  0x7bf68d7b,
       |  0xf2ff0df2,
       |  0x6bd6bd6b,
       |  0x6fdeb16f,
       |  0xc59154c5,
       |  0x30605030,
       |  0x01020301,
       |  0x67cea967,
       |  0x2b567d2b,
       |  0xfee719fe,
       |  0xd7b562d7,
       |  0xab4de6ab,
       |  0x76ec9a76,
       |  0xca8f45ca,
       |  0x821f9d82,
       |  0xc98940c9,
       |  0x7dfa877d,
       |  0xfaef15fa,
       |  0x59b2eb59,
       |  0x478ec947,
       |  0xf0fb0bf0,
       |  0xad41ecad,
       |  0xd4b367d4,
       |  0xa25ffda2,
       |  0xaf45eaaf,
       |  0x9c23bf9c,
       |  0xa453f7a4,
       |  0x72e49672,
       |  0xc09b5bc0,
       |  0xb775c2b7,
       |  0xfde11cfd,
       |  0x933dae93,
       |  0x264c6a26,
       |  0x366c5a36,
       |  0x3f7e413f,
       |  0xf7f502f7,
       |  0xcc834fcc,
       |  0x34685c34,
       |  0xa551f4a5,
       |  0xe5d134e5,
       |  0xf1f908f1,
       |  0x71e29371,
       |  0xd8ab73d8,
       |  0x31625331,
       |  0x152a3f15,
       |  0x04080c04,
       |  0xc79552c7,
       |  0x23466523,
       |  0xc39d5ec3,
       |  0x18302818,
       |  0x9637a196,
       |  0x050a0f05,
       |  0x9a2fb59a,
       |  0x070e0907,
       |  0x12243612,
       |  0x801b9b80,
       |  0xe2df3de2,
       |  0xebcd26eb,
       |  0x274e6927,
       |  0xb27fcdb2,
       |  0x75ea9f75,
       |  0x09121b09,
       |  0x831d9e83,
       |  0x2c58742c,
       |  0x1a342e1a,
       |  0x1b362d1b,
       |  0x6edcb26e,
       |  0x5ab4ee5a,
       |  0xa05bfba0,
       |  0x52a4f652,
       |  0x3b764d3b,
       |  0xd6b761d6,
       |  0xb37dceb3,
       |  0x29527b29,
       |  0xe3dd3ee3,
       |  0x2f5e712f,
       |  0x84139784,
       |  0x53a6f553,
       |  0xd1b968d1,
       |  0x00000000,
       |  0xedc12ced,
       |  0x20406020,
       |  0xfce31ffc,
       |  0xb179c8b1,
       |  0x5bb6ed5b,
       |  0x6ad4be6a,
       |  0xcb8d46cb,
       |  0xbe67d9be,
       |  0x39724b39,
       |  0x4a94de4a,
       |  0x4c98d44c,
       |  0x58b0e858,
       |  0xcf854acf,
       |  0xd0bb6bd0,
       |  0xefc52aef,
       |  0xaa4fe5aa,
       |  0xfbed16fb,
       |  0x4386c543,
       |  0x4d9ad74d,
       |  0x33665533,
       |  0x85119485,
       |  0x458acf45,
       |  0xf9e910f9,
       |  0x02040602,
       |  0x7ffe817f,
       |  0x50a0f050,
       |  0x3c78443c,
       |  0x9f25ba9f,
       |  0xa84be3a8,
       |  0x51a2f351,
       |  0xa35dfea3,
       |  0x4080c040,
       |  0x8f058a8f,
       |  0x923fad92,
       |  0x9d21bc9d,
       |  0x38704838,
       |  0xf5f104f5,
       |  0xbc63dfbc,
       |  0xb677c1b6,
       |  0xdaaf75da,
       |  0x21426321,
       |  0x10203010,
       |  0xffe51aff,
       |  0xf3fd0ef3,
       |  0xd2bf6dd2,
       |  0xcd814ccd,
       |  0x0c18140c,
       |  0x13263513,
       |  0xecc32fec,
       |  0x5fbee15f,
       |  0x9735a297,
       |  0x4488cc44,
       |  0x172e3917,
       |  0xc49357c4,
       |  0xa755f2a7,
       |  0x7efc827e,
       |  0x3d7a473d,
       |  0x64c8ac64,
       |  0x5dbae75d,
       |  0x19322b19,
       |  0x73e69573,
       |  0x60c0a060,
       |  0x81199881,
       |  0x4f9ed14f,
       |  0xdca37fdc,
       |  0x22446622,
       |  0x2a547e2a,
       |  0x903bab90,
       |  0x880b8388,
       |  0x468cca46,
       |  0xeec729ee,
       |  0xb86bd3b8,
       |  0x14283c14,
       |  0xdea779de,
       |  0x5ebce25e,
       |  0x0b161d0b,
       |  0xdbad76db,
       |  0xe0db3be0,
       |  0x32645632,
       |  0x3a744e3a,
       |  0x0a141e0a,
       |  0x4992db49,
       |  0x060c0a06,
       |  0x24486c24,
       |  0x5cb8e45c,
       |  0xc29f5dc2,
       |  0xd3bd6ed3,
       |  0xac43efac,
       |  0x62c4a662,
       |  0x9139a891,
       |  0x9531a495,
       |  0xe4d337e4,
       |  0x79f28b79,
       |  0xe7d532e7,
       |  0xc88b43c8,
       |  0x376e5937,
       |  0x6ddab76d,
       |  0x8d018c8d,
       |  0xd5b164d5,
       |  0x4e9cd24e,
       |  0xa949e0a9,
       |  0x6cd8b46c,
       |  0x56acfa56,
       |  0xf4f307f4,
       |  0xeacf25ea,
       |  0x65caaf65,
       |  0x7af48e7a,
       |  0xae47e9ae,
       |  0x08101808,
       |  0xba6fd5ba,
       |  0x78f08878,
       |  0x254a6f25,
       |  0x2e5c722e,
       |  0x1c38241c,
       |  0xa657f1a6,
       |  0xb473c7b4,
       |  0xc69751c6,
       |  0xe8cb23e8,
       |  0xdda17cdd,
       |  0x74e89c74,
       |  0x1f3e211f,
       |  0x4b96dd4b,
       |  0xbd61dcbd,
       |  0x8b0d868b,
       |  0x8a0f858a,
       |  0x70e09070,
       |  0x3e7c423e,
       |  0xb571c4b5,
       |  0x66ccaa66,
       |  0x4890d848,
       |  0x03060503,
       |  0xf6f701f6,
       |  0x0e1c120e,
       |  0x61c2a361,
       |  0x356a5f35,
       |  0x57aef957,
       |  0xb969d0b9,
       |  0x86179186,
       |  0xc19958c1,
       |  0x1d3a271d,
       |  0x9e27b99e,
       |  0xe1d938e1,
       |  0xf8eb13f8,
       |  0x982bb398,
       |  0x11223311,
       |  0x69d2bb69,
       |  0xd9a970d9,
       |  0x8e07898e,
       |  0x9433a794,
       |  0x9b2db69b,
       |  0x1e3c221e,
       |  0x87159287,
       |  0xe9c920e9,
       |  0xce8749ce,
       |  0x55aaff55,
       |  0x28507828,
       |  0xdfa57adf,
       |  0x8c038f8c,
       |  0xa159f8a1,
       |  0x89098089,
       |  0x0d1a170d,
       |  0xbf65dabf,
       |  0xe6d731e6,
       |  0x4284c642,
       |  0x68d0b868,
       |  0x4182c341,
       |  0x9929b099,
       |  0x2d5a772d,
       |  0x0f1e110f,
       |  0xb07bcbb0,
       |  0x54a8fc54,
       |  0xbb6dd6bb,
       |  0x162c3a16
       |];
       |
      3|final _t3 = [
       |  0xc6a56363,
       |  0xf8847c7c,
       |  0xee997777,
       |  0xf68d7b7b,
       |  0xff0df2f2,
       |  0xd6bd6b6b,
       |  0xdeb16f6f,
       |  0x9154c5c5,
       |  0x60503030,
       |  0x02030101,
       |  0xcea96767,
       |  0x567d2b2b,
       |  0xe719fefe,
       |  0xb562d7d7,
       |  0x4de6abab,
       |  0xec9a7676,
       |  0x8f45caca,
       |  0x1f9d8282,
       |  0x8940c9c9,
       |  0xfa877d7d,
       |  0xef15fafa,
       |  0xb2eb5959,
       |  0x8ec94747,
       |  0xfb0bf0f0,
       |  0x41ecadad,
       |  0xb367d4d4,
       |  0x5ffda2a2,
       |  0x45eaafaf,
       |  0x23bf9c9c,
       |  0x53f7a4a4,
       |  0xe4967272,
       |  0x9b5bc0c0,
       |  0x75c2b7b7,
       |  0xe11cfdfd,
       |  0x3dae9393,
       |  0x4c6a2626,
       |  0x6c5a3636,
       |  0x7e413f3f,
       |  0xf502f7f7,
       |  0x834fcccc,
       |  0x685c3434,
       |  0x51f4a5a5,
       |  0xd134e5e5,
       |  0xf908f1f1,
       |  0xe2937171,
       |  0xab73d8d8,
       |  0x62533131,
       |  0x2a3f1515,
       |  0x080c0404,
       |  0x9552c7c7,
       |  0x46652323,
       |  0x9d5ec3c3,
       |  0x30281818,
       |  0x37a19696,
       |  0x0a0f0505,
       |  0x2fb59a9a,
       |  0x0e090707,
       |  0x24361212,
       |  0x1b9b8080,
       |  0xdf3de2e2,
       |  0xcd26ebeb,
       |  0x4e692727,
       |  0x7fcdb2b2,
       |  0xea9f7575,
       |  0x121b0909,
       |  0x1d9e8383,
       |  0x58742c2c,
       |  0x342e1a1a,
       |  0x362d1b1b,
       |  0xdcb26e6e,
       |  0xb4ee5a5a,
       |  0x5bfba0a0,
       |  0xa4f65252,
       |  0x764d3b3b,
       |  0xb761d6d6,
       |  0x7dceb3b3,
       |  0x527b2929,
       |  0xdd3ee3e3,
       |  0x5e712f2f,
       |  0x13978484,
       |  0xa6f55353,
       |  0xb968d1d1,
       |  0x00000000,
       |  0xc12ceded,
       |  0x40602020,
       |  0xe31ffcfc,
       |  0x79c8b1b1,
       |  0xb6ed5b5b,
       |  0xd4be6a6a,
       |  0x8d46cbcb,
       |  0x67d9bebe,
       |  0x724b3939,
       |  0x94de4a4a,
       |  0x98d44c4c,
       |  0xb0e85858,
       |  0x854acfcf,
       |  0xbb6bd0d0,
       |  0xc52aefef,
       |  0x4fe5aaaa,
       |  0xed16fbfb,
       |  0x86c54343,
       |  0x9ad74d4d,
       |  0x66553333,
       |  0x11948585,
       |  0x8acf4545,
       |  0xe910f9f9,
       |  0x04060202,
       |  0xfe817f7f,
       |  0xa0f05050,
       |  0x78443c3c,
       |  0x25ba9f9f,
       |  0x4be3a8a8,
       |  0xa2f35151,
       |  0x5dfea3a3,
       |  0x80c04040,
       |  0x058a8f8f,
       |  0x3fad9292,
       |  0x21bc9d9d,
       |  0x70483838,
       |  0xf104f5f5,
       |  0x63dfbcbc,
       |  0x77c1b6b6,
       |  0xaf75dada,
       |  0x42632121,
       |  0x20301010,
       |  0xe51affff,
       |  0xfd0ef3f3,
       |  0xbf6dd2d2,
       |  0x814ccdcd,
       |  0x18140c0c,
       |  0x26351313,
       |  0xc32fecec,
       |  0xbee15f5f,
       |  0x35a29797,
       |  0x88cc4444,
       |  0x2e391717,
       |  0x9357c4c4,
       |  0x55f2a7a7,
       |  0xfc827e7e,
       |  0x7a473d3d,
       |  0xc8ac6464,
       |  0xbae75d5d,
       |  0x322b1919,
       |  0xe6957373,
       |  0xc0a06060,
       |  0x19988181,
       |  0x9ed14f4f,
       |  0xa37fdcdc,
       |  0x44662222,
       |  0x547e2a2a,
       |  0x3bab9090,
       |  0x0b838888,
       |  0x8cca4646,
       |  0xc729eeee,
       |  0x6bd3b8b8,
       |  0x283c1414,
       |  0xa779dede,
       |  0xbce25e5e,
       |  0x161d0b0b,
       |  0xad76dbdb,
       |  0xdb3be0e0,
       |  0x64563232,
       |  0x744e3a3a,
       |  0x141e0a0a,
       |  0x92db4949,
       |  0x0c0a0606,
       |  0x486c2424,
       |  0xb8e45c5c,
       |  0x9f5dc2c2,
       |  0xbd6ed3d3,
       |  0x43efacac,
       |  0xc4a66262,
       |  0x39a89191,
       |  0x31a49595,
       |  0xd337e4e4,
       |  0xf28b7979,
       |  0xd532e7e7,
       |  0x8b43c8c8,
       |  0x6e593737,
       |  0xdab76d6d,
       |  0x018c8d8d,
       |  0xb164d5d5,
       |  0x9cd24e4e,
       |  0x49e0a9a9,
       |  0xd8b46c6c,
       |  0xacfa5656,
       |  0xf307f4f4,
       |  0xcf25eaea,
       |  0xcaaf6565,
       |  0xf48e7a7a,
       |  0x47e9aeae,
       |  0x10180808,
       |  0x6fd5baba,
       |  0xf0887878,
       |  0x4a6f2525,
       |  0x5c722e2e,
       |  0x38241c1c,
       |  0x57f1a6a6,
       |  0x73c7b4b4,
       |  0x9751c6c6,
       |  0xcb23e8e8,
       |  0xa17cdddd,
       |  0xe89c7474,
       |  0x3e211f1f,
       |  0x96dd4b4b,
       |  0x61dcbdbd,
       |  0x0d868b8b,
       |  0x0f858a8a,
       |  0xe0907070,
       |  0x7c423e3e,
       |  0x71c4b5b5,
       |  0xccaa6666,
       |  0x90d84848,
       |  0x06050303,
       |  0xf701f6f6,
       |  0x1c120e0e,
       |  0xc2a36161,
       |  0x6a5f3535,
       |  0xaef95757,
       |  0x69d0b9b9,
       |  0x17918686,
       |  0x9958c1c1,
       |  0x3a271d1d,
       |  0x27b99e9e,
       |  0xd938e1e1,
       |  0xeb13f8f8,
       |  0x2bb39898,
       |  0x22331111,
       |  0xd2bb6969,
       |  0xa970d9d9,
       |  0x07898e8e,
       |  0x33a79494,
       |  0x2db69b9b,
       |  0x3c221e1e,
       |  0x15928787,
       |  0xc920e9e9,
       |  0x8749cece,
       |  0xaaff5555,
       |  0x50782828,
       |  0xa57adfdf,
       |  0x038f8c8c,
       |  0x59f8a1a1,
       |  0x09808989,
       |  0x1a170d0d,
       |  0x65dabfbf,
       |  0xd731e6e6,
       |  0x84c64242,
       |  0xd0b86868,
       |  0x82c34141,
       |  0x29b09999,
       |  0x5a772d2d,
       |  0x1e110f0f,
       |  0x7bcbb0b0,
       |  0xa8fc5454,
       |  0x6dd6bbbb,
       |  0x2c3a1616
       |];
       |
      0|final _tinv0 = [
       |  0x50a7f451,
       |  0x5365417e,
       |  0xc3a4171a,
       |  0x965e273a,
       |  0xcb6bab3b,
       |  0xf1459d1f,
       |  0xab58faac,
       |  0x9303e34b,
       |  0x55fa3020,
       |  0xf66d76ad,
       |  0x9176cc88,
       |  0x254c02f5,
       |  0xfcd7e54f,
       |  0xd7cb2ac5,
       |  0x80443526,
       |  0x8fa362b5,
       |  0x495ab1de,
       |  0x671bba25,
       |  0x980eea45,
       |  0xe1c0fe5d,
       |  0x02752fc3,
       |  0x12f04c81,
       |  0xa397468d,
       |  0xc6f9d36b,
       |  0xe75f8f03,
       |  0x959c9215,
       |  0xeb7a6dbf,
       |  0xda595295,
       |  0x2d83bed4,
       |  0xd3217458,
       |  0x2969e049,
       |  0x44c8c98e,
       |  0x6a89c275,
       |  0x78798ef4,
       |  0x6b3e5899,
       |  0xdd71b927,
       |  0xb64fe1be,
       |  0x17ad88f0,
       |  0x66ac20c9,
       |  0xb43ace7d,
       |  0x184adf63,
       |  0x82311ae5,
       |  0x60335197,
       |  0x457f5362,
       |  0xe07764b1,
       |  0x84ae6bbb,
       |  0x1ca081fe,
       |  0x942b08f9,
       |  0x58684870,
       |  0x19fd458f,
       |  0x876cde94,
       |  0xb7f87b52,
       |  0x23d373ab,
       |  0xe2024b72,
       |  0x578f1fe3,
       |  0x2aab5566,
       |  0x0728ebb2,
       |  0x03c2b52f,
       |  0x9a7bc586,
       |  0xa50837d3,
       |  0xf2872830,
       |  0xb2a5bf23,
       |  0xba6a0302,
       |  0x5c8216ed,
       |  0x2b1ccf8a,
       |  0x92b479a7,
       |  0xf0f207f3,
       |  0xa1e2694e,
       |  0xcdf4da65,
       |  0xd5be0506,
       |  0x1f6234d1,
       |  0x8afea6c4,
       |  0x9d532e34,
       |  0xa055f3a2,
       |  0x32e18a05,
       |  0x75ebf6a4,
       |  0x39ec830b,
       |  0xaaef6040,
       |  0x069f715e,
       |  0x51106ebd,
       |  0xf98a213e,
       |  0x3d06dd96,
       |  0xae053edd,
       |  0x46bde64d,
       |  0xb58d5491,
       |  0x055dc471,
       |  0x6fd40604,
       |  0xff155060,
       |  0x24fb9819,
       |  0x97e9bdd6,
       |  0xcc434089,
       |  0x779ed967,
       |  0xbd42e8b0,
       |  0x888b8907,
       |  0x385b19e7,
       |  0xdbeec879,
       |  0x470a7ca1,
       |  0xe90f427c,
       |  0xc91e84f8,
       |  0x00000000,
       |  0x83868009,
       |  0x48ed2b32,
       |  0xac70111e,
       |  0x4e725a6c,
       |  0xfbff0efd,
       |  0x5638850f,
       |  0x1ed5ae3d,
       |  0x27392d36,
       |  0x64d90f0a,
       |  0x21a65c68,
       |  0xd1545b9b,
       |  0x3a2e3624,
       |  0xb1670a0c,
       |  0x0fe75793,
       |  0xd296eeb4,
       |  0x9e919b1b,
       |  0x4fc5c080,
       |  0xa220dc61,
       |  0x694b775a,
       |  0x161a121c,
       |  0x0aba93e2,
       |  0xe52aa0c0,
       |  0x43e0223c,
       |  0x1d171b12,
       |  0x0b0d090e,
       |  0xadc78bf2,
       |  0xb9a8b62d,
       |  0xc8a91e14,
       |  0x8519f157,
       |  0x4c0775af,
       |  0xbbdd99ee,
       |  0xfd607fa3,
       |  0x9f2601f7,
       |  0xbcf5725c,
       |  0xc53b6644,
       |  0x347efb5b,
       |  0x7629438b,
       |  0xdcc623cb,
       |  0x68fcedb6,
       |  0x63f1e4b8,
       |  0xcadc31d7,
       |  0x10856342,
       |  0x40229713,
       |  0x2011c684,
       |  0x7d244a85,
       |  0xf83dbbd2,
       |  0x1132f9ae,
       |  0x6da129c7,
       |  0x4b2f9e1d,
       |  0xf330b2dc,
       |  0xec52860d,
       |  0xd0e3c177,
       |  0x6c16b32b,
       |  0x99b970a9,
       |  0xfa489411,
       |  0x2264e947,
       |  0xc48cfca8,
       |  0x1a3ff0a0,
       |  0xd82c7d56,
       |  0xef903322,
       |  0xc74e4987,
       |  0xc1d138d9,
       |  0xfea2ca8c,
       |  0x360bd498,
       |  0xcf81f5a6,
       |  0x28de7aa5,
       |  0x268eb7da,
       |  0xa4bfad3f,
       |  0xe49d3a2c,
       |  0x0d927850,
       |  0x9bcc5f6a,
       |  0x62467e54,
       |  0xc2138df6,
       |  0xe8b8d890,
       |  0x5ef7392e,
       |  0xf5afc382,
       |  0xbe805d9f,
       |  0x7c93d069,
       |  0xa92dd56f,
       |  0xb31225cf,
       |  0x3b99acc8,
       |  0xa77d1810,
       |  0x6e639ce8,
       |  0x7bbb3bdb,
       |  0x097826cd,
       |  0xf418596e,
       |  0x01b79aec,
       |  0xa89a4f83,
       |  0x656e95e6,
       |  0x7ee6ffaa,
       |  0x08cfbc21,
       |  0xe6e815ef,
       |  0xd99be7ba,
       |  0xce366f4a,
       |  0xd4099fea,
       |  0xd67cb029,
       |  0xafb2a431,
       |  0x31233f2a,
       |  0x3094a5c6,
       |  0xc066a235,
       |  0x37bc4e74,
       |  0xa6ca82fc,
       |  0xb0d090e0,
       |  0x15d8a733,
       |  0x4a9804f1,
       |  0xf7daec41,
       |  0x0e50cd7f,
       |  0x2ff69117,
       |  0x8dd64d76,
       |  0x4db0ef43,
       |  0x544daacc,
       |  0xdf0496e4,
       |  0xe3b5d19e,
       |  0x1b886a4c,
       |  0xb81f2cc1,
       |  0x7f516546,
       |  0x04ea5e9d,
       |  0x5d358c01,
       |  0x737487fa,
       |  0x2e410bfb,
       |  0x5a1d67b3,
       |  0x52d2db92,
       |  0x335610e9,
       |  0x1347d66d,
       |  0x8c61d79a,
       |  0x7a0ca137,
       |  0x8e14f859,
       |  0x893c13eb,
       |  0xee27a9ce,
       |  0x35c961b7,
       |  0xede51ce1,
       |  0x3cb1477a,
       |  0x59dfd29c,
       |  0x3f73f255,
       |  0x79ce1418,
       |  0xbf37c773,
       |  0xeacdf753,
       |  0x5baafd5f,
       |  0x146f3ddf,
       |  0x86db4478,
       |  0x81f3afca,
       |  0x3ec468b9,
       |  0x2c342438,
       |  0x5f40a3c2,
       |  0x72c31d16,
       |  0x0c25e2bc,
       |  0x8b493c28,
       |  0x41950dff,
       |  0x7101a839,
       |  0xdeb30c08,
       |  0x9ce4b4d8,
       |  0x90c15664,
       |  0x6184cb7b,
       |  0x70b632d5,
       |  0x745c6c48,
       |  0x4257b8d0
       |];
       |
      0|final _tinv1 = [
       |  0xa7f45150,
       |  0x65417e53,
       |  0xa4171ac3,
       |  0x5e273a96,
       |  0x6bab3bcb,
       |  0x459d1ff1,
       |  0x58faacab,
       |  0x03e34b93,
       |  0xfa302055,
       |  0x6d76adf6,
       |  0x76cc8891,
       |  0x4c02f525,
       |  0xd7e54ffc,
       |  0xcb2ac5d7,
       |  0x44352680,
       |  0xa362b58f,
       |  0x5ab1de49,
       |  0x1bba2567,
       |  0x0eea4598,
       |  0xc0fe5de1,
       |  0x752fc302,
       |  0xf04c8112,
       |  0x97468da3,
       |  0xf9d36bc6,
       |  0x5f8f03e7,
       |  0x9c921595,
       |  0x7a6dbfeb,
       |  0x595295da,
       |  0x83bed42d,
       |  0x217458d3,
       |  0x69e04929,
       |  0xc8c98e44,
       |  0x89c2756a,
       |  0x798ef478,
       |  0x3e58996b,
       |  0x71b927dd,
       |  0x4fe1beb6,
       |  0xad88f017,
       |  0xac20c966,
       |  0x3ace7db4,
       |  0x4adf6318,
       |  0x311ae582,
       |  0x33519760,
       |  0x7f536245,
       |  0x7764b1e0,
       |  0xae6bbb84,
       |  0xa081fe1c,
       |  0x2b08f994,
       |  0x68487058,
       |  0xfd458f19,
       |  0x6cde9487,
       |  0xf87b52b7,
       |  0xd373ab23,
       |  0x024b72e2,
       |  0x8f1fe357,
       |  0xab55662a,
       |  0x28ebb207,
       |  0xc2b52f03,
       |  0x7bc5869a,
       |  0x0837d3a5,
       |  0x872830f2,
       |  0xa5bf23b2,
       |  0x6a0302ba,
       |  0x8216ed5c,
       |  0x1ccf8a2b,
       |  0xb479a792,
       |  0xf207f3f0,
       |  0xe2694ea1,
       |  0xf4da65cd,
       |  0xbe0506d5,
       |  0x6234d11f,
       |  0xfea6c48a,
       |  0x532e349d,
       |  0x55f3a2a0,
       |  0xe18a0532,
       |  0xebf6a475,
       |  0xec830b39,
       |  0xef6040aa,
       |  0x9f715e06,
       |  0x106ebd51,
       |  0x8a213ef9,
       |  0x06dd963d,
       |  0x053eddae,
       |  0xbde64d46,
       |  0x8d5491b5,
       |  0x5dc47105,
       |  0xd406046f,
       |  0x155060ff,
       |  0xfb981924,
       |  0xe9bdd697,
       |  0x434089cc,
       |  0x9ed96777,
       |  0x42e8b0bd,
       |  0x8b890788,
       |  0x5b19e738,
       |  0xeec879db,
       |  0x0a7ca147,
       |  0x0f427ce9,
       |  0x1e84f8c9,
       |  0x00000000,
       |  0x86800983,
       |  0xed2b3248,
       |  0x70111eac,
       |  0x725a6c4e,
       |  0xff0efdfb,
       |  0x38850f56,
       |  0xd5ae3d1e,
       |  0x392d3627,
       |  0xd90f0a64,
       |  0xa65c6821,
       |  0x545b9bd1,
       |  0x2e36243a,
       |  0x670a0cb1,
       |  0xe757930f,
       |  0x96eeb4d2,
       |  0x919b1b9e,
       |  0xc5c0804f,
       |  0x20dc61a2,
       |  0x4b775a69,
       |  0x1a121c16,
       |  0xba93e20a,
       |  0x2aa0c0e5,
       |  0xe0223c43,
       |  0x171b121d,
       |  0x0d090e0b,
       |  0xc78bf2ad,
       |  0xa8b62db9,
       |  0xa91e14c8,
       |  0x19f15785,
       |  0x0775af4c,
       |  0xdd99eebb,
       |  0x607fa3fd,
       |  0x2601f79f,
       |  0xf5725cbc,
       |  0x3b6644c5,
       |  0x7efb5b34,
       |  0x29438b76,
       |  0xc623cbdc,
       |  0xfcedb668,
       |  0xf1e4b863,
       |  0xdc31d7ca,
       |  0x85634210,
       |  0x22971340,
       |  0x11c68420,
       |  0x244a857d,
       |  0x3dbbd2f8,
       |  0x32f9ae11,
       |  0xa129c76d,
       |  0x2f9e1d4b,
       |  0x30b2dcf3,
       |  0x52860dec,
       |  0xe3c177d0,
       |  0x16b32b6c,
       |  0xb970a999,
       |  0x489411fa,
       |  0x64e94722,
       |  0x8cfca8c4,
       |  0x3ff0a01a,
       |  0x2c7d56d8,
       |  0x903322ef,
       |  0x4e4987c7,
       |  0xd138d9c1,
       |  0xa2ca8cfe,
       |  0x0bd49836,
       |  0x81f5a6cf,
       |  0xde7aa528,
       |  0x8eb7da26,
       |  0xbfad3fa4,
       |  0x9d3a2ce4,
       |  0x9278500d,
       |  0xcc5f6a9b,
       |  0x467e5462,
       |  0x138df6c2,
       |  0xb8d890e8,
       |  0xf7392e5e,
       |  0xafc382f5,
       |  0x805d9fbe,
       |  0x93d0697c,
       |  0x2dd56fa9,
       |  0x1225cfb3,
       |  0x99acc83b,
       |  0x7d1810a7,
       |  0x639ce86e,
       |  0xbb3bdb7b,
       |  0x7826cd09,
       |  0x18596ef4,
       |  0xb79aec01,
       |  0x9a4f83a8,
       |  0x6e95e665,
       |  0xe6ffaa7e,
       |  0xcfbc2108,
       |  0xe815efe6,
       |  0x9be7bad9,
       |  0x366f4ace,
       |  0x099fead4,
       |  0x7cb029d6,
       |  0xb2a431af,
       |  0x233f2a31,
       |  0x94a5c630,
       |  0x66a235c0,
       |  0xbc4e7437,
       |  0xca82fca6,
       |  0xd090e0b0,
       |  0xd8a73315,
       |  0x9804f14a,
       |  0xdaec41f7,
       |  0x50cd7f0e,
       |  0xf691172f,
       |  0xd64d768d,
       |  0xb0ef434d,
       |  0x4daacc54,
       |  0x0496e4df,
       |  0xb5d19ee3,
       |  0x886a4c1b,
       |  0x1f2cc1b8,
       |  0x5165467f,
       |  0xea5e9d04,
       |  0x358c015d,
       |  0x7487fa73,
       |  0x410bfb2e,
       |  0x1d67b35a,
       |  0xd2db9252,
       |  0x5610e933,
       |  0x47d66d13,
       |  0x61d79a8c,
       |  0x0ca1377a,
       |  0x14f8598e,
       |  0x3c13eb89,
       |  0x27a9ceee,
       |  0xc961b735,
       |  0xe51ce1ed,
       |  0xb1477a3c,
       |  0xdfd29c59,
       |  0x73f2553f,
       |  0xce141879,
       |  0x37c773bf,
       |  0xcdf753ea,
       |  0xaafd5f5b,
       |  0x6f3ddf14,
       |  0xdb447886,
       |  0xf3afca81,
       |  0xc468b93e,
       |  0x3424382c,
       |  0x40a3c25f,
       |  0xc31d1672,
       |  0x25e2bc0c,
       |  0x493c288b,
       |  0x950dff41,
       |  0x01a83971,
       |  0xb30c08de,
       |  0xe4b4d89c,
       |  0xc1566490,
       |  0x84cb7b61,
       |  0xb632d570,
       |  0x5c6c4874,
       |  0x57b8d042
       |];
       |
      0|final _tinv2 = [
       |  0xf45150a7,
       |  0x417e5365,
       |  0x171ac3a4,
       |  0x273a965e,
       |  0xab3bcb6b,
       |  0x9d1ff145,
       |  0xfaacab58,
       |  0xe34b9303,
       |  0x302055fa,
       |  0x76adf66d,
       |  0xcc889176,
       |  0x02f5254c,
       |  0xe54ffcd7,
       |  0x2ac5d7cb,
       |  0x35268044,
       |  0x62b58fa3,
       |  0xb1de495a,
       |  0xba25671b,
       |  0xea45980e,
       |  0xfe5de1c0,
       |  0x2fc30275,
       |  0x4c8112f0,
       |  0x468da397,
       |  0xd36bc6f9,
       |  0x8f03e75f,
       |  0x9215959c,
       |  0x6dbfeb7a,
       |  0x5295da59,
       |  0xbed42d83,
       |  0x7458d321,
       |  0xe0492969,
       |  0xc98e44c8,
       |  0xc2756a89,
       |  0x8ef47879,
       |  0x58996b3e,
       |  0xb927dd71,
       |  0xe1beb64f,
       |  0x88f017ad,
       |  0x20c966ac,
       |  0xce7db43a,
       |  0xdf63184a,
       |  0x1ae58231,
       |  0x51976033,
       |  0x5362457f,
       |  0x64b1e077,
       |  0x6bbb84ae,
       |  0x81fe1ca0,
       |  0x08f9942b,
       |  0x48705868,
       |  0x458f19fd,
       |  0xde94876c,
       |  0x7b52b7f8,
       |  0x73ab23d3,
       |  0x4b72e202,
       |  0x1fe3578f,
       |  0x55662aab,
       |  0xebb20728,
       |  0xb52f03c2,
       |  0xc5869a7b,
       |  0x37d3a508,
       |  0x2830f287,
       |  0xbf23b2a5,
       |  0x0302ba6a,
       |  0x16ed5c82,
       |  0xcf8a2b1c,
       |  0x79a792b4,
       |  0x07f3f0f2,
       |  0x694ea1e2,
       |  0xda65cdf4,
       |  0x0506d5be,
       |  0x34d11f62,
       |  0xa6c48afe,
       |  0x2e349d53,
       |  0xf3a2a055,
       |  0x8a0532e1,
       |  0xf6a475eb,
       |  0x830b39ec,
       |  0x6040aaef,
       |  0x715e069f,
       |  0x6ebd5110,
       |  0x213ef98a,
       |  0xdd963d06,
       |  0x3eddae05,
       |  0xe64d46bd,
       |  0x5491b58d,
       |  0xc471055d,
       |  0x06046fd4,
       |  0x5060ff15,
       |  0x981924fb,
       |  0xbdd697e9,
       |  0x4089cc43,
       |  0xd967779e,
       |  0xe8b0bd42,
       |  0x8907888b,
       |  0x19e7385b,
       |  0xc879dbee,
       |  0x7ca1470a,
       |  0x427ce90f,
       |  0x84f8c91e,
       |  0x00000000,
       |  0x80098386,
       |  0x2b3248ed,
       |  0x111eac70,
       |  0x5a6c4e72,
       |  0x0efdfbff,
       |  0x850f5638,
       |  0xae3d1ed5,
       |  0x2d362739,
       |  0x0f0a64d9,
       |  0x5c6821a6,
       |  0x5b9bd154,
       |  0x36243a2e,
       |  0x0a0cb167,
       |  0x57930fe7,
       |  0xeeb4d296,
       |  0x9b1b9e91,
       |  0xc0804fc5,
       |  0xdc61a220,
       |  0x775a694b,
       |  0x121c161a,
       |  0x93e20aba,
       |  0xa0c0e52a,
       |  0x223c43e0,
       |  0x1b121d17,
       |  0x090e0b0d,
       |  0x8bf2adc7,
       |  0xb62db9a8,
       |  0x1e14c8a9,
       |  0xf1578519,
       |  0x75af4c07,
       |  0x99eebbdd,
       |  0x7fa3fd60,
       |  0x01f79f26,
       |  0x725cbcf5,
       |  0x6644c53b,
       |  0xfb5b347e,
       |  0x438b7629,
       |  0x23cbdcc6,
       |  0xedb668fc,
       |  0xe4b863f1,
       |  0x31d7cadc,
       |  0x63421085,
       |  0x97134022,
       |  0xc6842011,
       |  0x4a857d24,
       |  0xbbd2f83d,
       |  0xf9ae1132,
       |  0x29c76da1,
       |  0x9e1d4b2f,
       |  0xb2dcf330,
       |  0x860dec52,
       |  0xc177d0e3,
       |  0xb32b6c16,
       |  0x70a999b9,
       |  0x9411fa48,
       |  0xe9472264,
       |  0xfca8c48c,
       |  0xf0a01a3f,
       |  0x7d56d82c,
       |  0x3322ef90,
       |  0x4987c74e,
       |  0x38d9c1d1,
       |  0xca8cfea2,
       |  0xd498360b,
       |  0xf5a6cf81,
       |  0x7aa528de,
       |  0xb7da268e,
       |  0xad3fa4bf,
       |  0x3a2ce49d,
       |  0x78500d92,
       |  0x5f6a9bcc,
       |  0x7e546246,
       |  0x8df6c213,
       |  0xd890e8b8,
       |  0x392e5ef7,
       |  0xc382f5af,
       |  0x5d9fbe80,
       |  0xd0697c93,
       |  0xd56fa92d,
       |  0x25cfb312,
       |  0xacc83b99,
       |  0x1810a77d,
       |  0x9ce86e63,
       |  0x3bdb7bbb,
       |  0x26cd0978,
       |  0x596ef418,
       |  0x9aec01b7,
       |  0x4f83a89a,
       |  0x95e6656e,
       |  0xffaa7ee6,
       |  0xbc2108cf,
       |  0x15efe6e8,
       |  0xe7bad99b,
       |  0x6f4ace36,
       |  0x9fead409,
       |  0xb029d67c,
       |  0xa431afb2,
       |  0x3f2a3123,
       |  0xa5c63094,
       |  0xa235c066,
       |  0x4e7437bc,
       |  0x82fca6ca,
       |  0x90e0b0d0,
       |  0xa73315d8,
       |  0x04f14a98,
       |  0xec41f7da,
       |  0xcd7f0e50,
       |  0x91172ff6,
       |  0x4d768dd6,
       |  0xef434db0,
       |  0xaacc544d,
       |  0x96e4df04,
       |  0xd19ee3b5,
       |  0x6a4c1b88,
       |  0x2cc1b81f,
       |  0x65467f51,
       |  0x5e9d04ea,
       |  0x8c015d35,
       |  0x87fa7374,
       |  0x0bfb2e41,
       |  0x67b35a1d,
       |  0xdb9252d2,
       |  0x10e93356,
       |  0xd66d1347,
       |  0xd79a8c61,
       |  0xa1377a0c,
       |  0xf8598e14,
       |  0x13eb893c,
       |  0xa9ceee27,
       |  0x61b735c9,
       |  0x1ce1ede5,
       |  0x477a3cb1,
       |  0xd29c59df,
       |  0xf2553f73,
       |  0x141879ce,
       |  0xc773bf37,
       |  0xf753eacd,
       |  0xfd5f5baa,
       |  0x3ddf146f,
       |  0x447886db,
       |  0xafca81f3,
       |  0x68b93ec4,
       |  0x24382c34,
       |  0xa3c25f40,
       |  0x1d1672c3,
       |  0xe2bc0c25,
       |  0x3c288b49,
       |  0x0dff4195,
       |  0xa8397101,
       |  0x0c08deb3,
       |  0xb4d89ce4,
       |  0x566490c1,
       |  0xcb7b6184,
       |  0x32d570b6,
       |  0x6c48745c,
       |  0xb8d04257
       |];
       |
      0|final _tinv3 = [
       |  0x5150a7f4,
       |  0x7e536541,
       |  0x1ac3a417,
       |  0x3a965e27,
       |  0x3bcb6bab,
       |  0x1ff1459d,
       |  0xacab58fa,
       |  0x4b9303e3,
       |  0x2055fa30,
       |  0xadf66d76,
       |  0x889176cc,
       |  0xf5254c02,
       |  0x4ffcd7e5,
       |  0xc5d7cb2a,
       |  0x26804435,
       |  0xb58fa362,
       |  0xde495ab1,
       |  0x25671bba,
       |  0x45980eea,
       |  0x5de1c0fe,
       |  0xc302752f,
       |  0x8112f04c,
       |  0x8da39746,
       |  0x6bc6f9d3,
       |  0x03e75f8f,
       |  0x15959c92,
       |  0xbfeb7a6d,
       |  0x95da5952,
       |  0xd42d83be,
       |  0x58d32174,
       |  0x492969e0,
       |  0x8e44c8c9,
       |  0x756a89c2,
       |  0xf478798e,
       |  0x996b3e58,
       |  0x27dd71b9,
       |  0xbeb64fe1,
       |  0xf017ad88,
       |  0xc966ac20,
       |  0x7db43ace,
       |  0x63184adf,
       |  0xe582311a,
       |  0x97603351,
       |  0x62457f53,
       |  0xb1e07764,
       |  0xbb84ae6b,
       |  0xfe1ca081,
       |  0xf9942b08,
       |  0x70586848,
       |  0x8f19fd45,
       |  0x94876cde,
       |  0x52b7f87b,
       |  0xab23d373,
       |  0x72e2024b,
       |  0xe3578f1f,
       |  0x662aab55,
       |  0xb20728eb,
       |  0x2f03c2b5,
       |  0x869a7bc5,
       |  0xd3a50837,
       |  0x30f28728,
       |  0x23b2a5bf,
       |  0x02ba6a03,
       |  0xed5c8216,
       |  0x8a2b1ccf,
       |  0xa792b479,
       |  0xf3f0f207,
       |  0x4ea1e269,
       |  0x65cdf4da,
       |  0x06d5be05,
       |  0xd11f6234,
       |  0xc48afea6,
       |  0x349d532e,
       |  0xa2a055f3,
       |  0x0532e18a,
       |  0xa475ebf6,
       |  0x0b39ec83,
       |  0x40aaef60,
       |  0x5e069f71,
       |  0xbd51106e,
       |  0x3ef98a21,
       |  0x963d06dd,
       |  0xddae053e,
       |  0x4d46bde6,
       |  0x91b58d54,
       |  0x71055dc4,
       |  0x046fd406,
       |  0x60ff1550,
       |  0x1924fb98,
       |  0xd697e9bd,
       |  0x89cc4340,
       |  0x67779ed9,
       |  0xb0bd42e8,
       |  0x07888b89,
       |  0xe7385b19,
       |  0x79dbeec8,
       |  0xa1470a7c,
       |  0x7ce90f42,
       |  0xf8c91e84,
       |  0x00000000,
       |  0x09838680,
       |  0x3248ed2b,
       |  0x1eac7011,
       |  0x6c4e725a,
       |  0xfdfbff0e,
       |  0x0f563885,
       |  0x3d1ed5ae,
       |  0x3627392d,
       |  0x0a64d90f,
       |  0x6821a65c,
       |  0x9bd1545b,
       |  0x243a2e36,
       |  0x0cb1670a,
       |  0x930fe757,
       |  0xb4d296ee,
       |  0x1b9e919b,
       |  0x804fc5c0,
       |  0x61a220dc,
       |  0x5a694b77,
       |  0x1c161a12,
       |  0xe20aba93,
       |  0xc0e52aa0,
       |  0x3c43e022,
       |  0x121d171b,
       |  0x0e0b0d09,
       |  0xf2adc78b,
       |  0x2db9a8b6,
       |  0x14c8a91e,
       |  0x578519f1,
       |  0xaf4c0775,
       |  0xeebbdd99,
       |  0xa3fd607f,
       |  0xf79f2601,
       |  0x5cbcf572,
       |  0x44c53b66,
       |  0x5b347efb,
       |  0x8b762943,
       |  0xcbdcc623,
       |  0xb668fced,
       |  0xb863f1e4,
       |  0xd7cadc31,
       |  0x42108563,
       |  0x13402297,
       |  0x842011c6,
       |  0x857d244a,
       |  0xd2f83dbb,
       |  0xae1132f9,
       |  0xc76da129,
       |  0x1d4b2f9e,
       |  0xdcf330b2,
       |  0x0dec5286,
       |  0x77d0e3c1,
       |  0x2b6c16b3,
       |  0xa999b970,
       |  0x11fa4894,
       |  0x472264e9,
       |  0xa8c48cfc,
       |  0xa01a3ff0,
       |  0x56d82c7d,
       |  0x22ef9033,
       |  0x87c74e49,
       |  0xd9c1d138,
       |  0x8cfea2ca,
       |  0x98360bd4,
       |  0xa6cf81f5,
       |  0xa528de7a,
       |  0xda268eb7,
       |  0x3fa4bfad,
       |  0x2ce49d3a,
       |  0x500d9278,
       |  0x6a9bcc5f,
       |  0x5462467e,
       |  0xf6c2138d,
       |  0x90e8b8d8,
       |  0x2e5ef739,
       |  0x82f5afc3,
       |  0x9fbe805d,
       |  0x697c93d0,
       |  0x6fa92dd5,
       |  0xcfb31225,
       |  0xc83b99ac,
       |  0x10a77d18,
       |  0xe86e639c,
       |  0xdb7bbb3b,
       |  0xcd097826,
       |  0x6ef41859,
       |  0xec01b79a,
       |  0x83a89a4f,
       |  0xe6656e95,
       |  0xaa7ee6ff,
       |  0x2108cfbc,
       |  0xefe6e815,
       |  0xbad99be7,
       |  0x4ace366f,
       |  0xead4099f,
       |  0x29d67cb0,
       |  0x31afb2a4,
       |  0x2a31233f,
       |  0xc63094a5,
       |  0x35c066a2,
       |  0x7437bc4e,
       |  0xfca6ca82,
       |  0xe0b0d090,
       |  0x3315d8a7,
       |  0xf14a9804,
       |  0x41f7daec,
       |  0x7f0e50cd,
       |  0x172ff691,
       |  0x768dd64d,
       |  0x434db0ef,
       |  0xcc544daa,
       |  0xe4df0496,
       |  0x9ee3b5d1,
       |  0x4c1b886a,
       |  0xc1b81f2c,
       |  0x467f5165,
       |  0x9d04ea5e,
       |  0x015d358c,
       |  0xfa737487,
       |  0xfb2e410b,
       |  0xb35a1d67,
       |  0x9252d2db,
       |  0xe9335610,
       |  0x6d1347d6,
       |  0x9a8c61d7,
       |  0x377a0ca1,
       |  0x598e14f8,
       |  0xeb893c13,
       |  0xceee27a9,
       |  0xb735c961,
       |  0xe1ede51c,
       |  0x7a3cb147,
       |  0x9c59dfd2,
       |  0x553f73f2,
       |  0x1879ce14,
       |  0x73bf37c7,
       |  0x53eacdf7,
       |  0x5f5baafd,
       |  0xdf146f3d,
       |  0x7886db44,
       |  0xca81f3af,
       |  0xb93ec468,
       |  0x382c3424,
       |  0xc25f40a3,
       |  0x1672c31d,
       |  0xbc0c25e2,
       |  0x288b493c,
       |  0xff41950d,
       |  0x397101a8,
       |  0x08deb30c,
       |  0xd89ce4b4,
       |  0x6490c156,
       |  0x7b6184cb,
       |  0xd570b632,
       |  0x48745c6c,
       |  0xd04257b8
       |];
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/modes/cbc.dart
       |// See file LICENSE for more information.
       |library impl.block_cipher.modes.cbc;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_block_cipher.dart';
       |
       |/// Implementation of Cipher-Block-Chaining (CBC) mode on top of a [BlockCipher].
       |class CBCBlockCipher extends BaseBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      BlockCipher,
       |      '/CBC',
       |      (_, final Match match) => () {
       |            var underlying = BlockCipher(match.group(1));
       |            return CBCBlockCipher(underlying);
       |          });
       |
       |  final BlockCipher _underlyingCipher;
       |
       |  Uint8List _iv;
       |  Uint8List _cbcV;
       |  Uint8List _cbcNextV;
       |
       |  bool _encrypting;
       |
      0|  CBCBlockCipher(this._underlyingCipher) {
      0|    _iv = Uint8List(blockSize);
      0|    _cbcV = Uint8List(blockSize);
      0|    _cbcNextV = Uint8List(blockSize);
       |  }
       |
      0|  @override
      0|  String get algorithmName => '${_underlyingCipher.algorithmName}/CBC';
      0|  @override
      0|  int get blockSize => _underlyingCipher.blockSize;
       |
      0|  @override
       |  void reset() {
      0|    _cbcV.setAll(0, _iv);
      0|    _cbcNextV.fillRange(0, _cbcNextV.length, 0);
       |
      0|    _underlyingCipher.reset();
       |  }
       |
      0|  @override
       |  void init(bool forEncryption, covariant ParametersWithIV params) {
      0|    if (params.iv.length != blockSize) {
      0|      throw ArgumentError(
       |          'Initialization vector must be the same length as block size');
       |    }
       |
      0|    _encrypting = forEncryption;
      0|    _iv.setAll(0, params.iv);
       |
      0|    reset();
       |
      0|    _underlyingCipher.init(forEncryption, params.parameters);
       |  }
       |
      0|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) =>
      0|      _encrypting
      0|          ? _encryptBlock(inp, inpOff, out, outOff)
      0|          : _decryptBlock(inp, inpOff, out, outOff);
       |
      0|  int _encryptBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    if ((inpOff + blockSize) > inp.length) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
       |
       |    // XOR the cbcV and the input, then encrypt the cbcV
      0|    for (var i = 0; i < blockSize; i++) {
      0|      _cbcV[i] ^= inp[inpOff + i];
       |    }
       |
      0|    var length = _underlyingCipher.processBlock(_cbcV, 0, out, outOff);
       |
       |    // copy ciphertext to cbcV
      0|    _cbcV.setRange(0, blockSize,
      0|        Uint8List.view(out.buffer, out.offsetInBytes + outOff, blockSize));
       |
       |    return length;
       |  }
       |
      0|  int _decryptBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    if ((inpOff + blockSize) > inp.length) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
       |
      0|    _cbcNextV.setRange(0, blockSize,
      0|        Uint8List.view(inp.buffer, inp.offsetInBytes + inpOff, blockSize));
       |
      0|    var length = _underlyingCipher.processBlock(inp, inpOff, out, outOff);
       |
       |    // XOR the cbcV and the output
      0|    for (var i = 0; i < blockSize; i++) {
      0|      out[outOff + i] ^= _cbcV[i];
       |    }
       |
       |    // swap the back up buffer into next position
       |    Uint8List tmp;
       |
      0|    tmp = _cbcV;
      0|    _cbcV = _cbcNextV;
      0|    _cbcNextV = tmp;
       |
       |    return length;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/modes/cfb.dart
       |// See file LICENSE for more information.
       |
       |library impl.block_cipher.modes.cfb;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_block_cipher.dart';
       |
       |/// Implementation of Cipher Feedback Mode (CFB) on top of a [BlockCipher].
       |class CFBBlockCipher extends BaseBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.regex(
       |      BlockCipher,
       |      r'^(.+)/CFB-([0-9]+)$',
       |      (_, final Match match) => () {
       |            var underlying = BlockCipher(match.group(1));
       |            var blockSizeInBits = int.parse(match.group(2));
       |            if ((blockSizeInBits % 8) != 0) {
       |              throw RegistryFactoryException.invalid(
       |                  'Bad CFB block size: $blockSizeInBits (must be a multiple of 8)');
       |            }
       |            return CFBBlockCipher(underlying, blockSizeInBits ~/ 8);
       |          });
       |
       |  @override
       |  final int blockSize;
       |
       |  final BlockCipher _underlyingCipher;
       |
       |  Uint8List _iv;
       |  Uint8List _cfbV;
       |  Uint8List _cfbOutV;
       |  bool _encrypting;
       |
      0|  CFBBlockCipher(this._underlyingCipher, this.blockSize) {
      0|    _iv = Uint8List(_underlyingCipher.blockSize);
      0|    _cfbV = Uint8List(_underlyingCipher.blockSize);
      0|    _cfbOutV = Uint8List(_underlyingCipher.blockSize);
       |  }
       |
      0|  @override
       |  String get algorithmName =>
      0|      '${_underlyingCipher.algorithmName}/CFB-${blockSize * 8}';
       |
      0|  @override
       |  void reset() {
      0|    _cfbV.setRange(0, _iv.length, _iv);
      0|    _underlyingCipher.reset();
       |  }
       |
       |  /// Initialise the cipher and, possibly, the initialisation vector (IV).
       |  /// If an IV isn't passed as part of the parameter, the IV will be all zeros.
       |  /// An IV which is too short is handled in FIPS compliant fashion.
       |  ///
       |  /// @param encrypting if true the cipher is initialised for
       |  ///  encryption, if false for decryption.
       |  /// @param params the key and other data required by the cipher.
       |  /// @exception IllegalArgumentException if the params argument is
       |  /// inappropriate.
      0|  @override
       |  void init(bool encrypting, CipherParameters params) {
      0|    _encrypting = encrypting;
       |
      0|    if (params is ParametersWithIV) {
       |      var ivParam = params;
      0|      var iv = ivParam.iv;
       |
      0|      if (iv.length < _iv.length) {
       |        // prepend the supplied IV with zeros (per FIPS PUB 81)
      0|        var offset = _iv.length - iv.length;
      0|        _iv.fillRange(0, offset, 0);
      0|        _iv.setRange(offset, _iv.length, iv);
       |      } else {
      0|        _iv.setRange(0, _iv.length, iv);
       |      }
       |
      0|      reset();
       |
       |      // if null it's an IV changed only.
      0|      if (ivParam.parameters != null) {
      0|        _underlyingCipher.init(true, ivParam.parameters);
       |      }
       |    } else {
      0|      reset();
      0|      _underlyingCipher.init(true, params);
       |    }
       |  }
       |
       |  /// Process one block of input from the array in and write it to
       |  /// the out array.
       |  ///
       |  /// @param in the array containing the input data.
       |  /// @param inOff offset into the in array the data starts at.
       |  /// @param out the array the output data will be copied into.
       |  /// @param outOff the offset into the out array the output will start at.
       |  /// @exception DataLengthException if there isn't enough data in in, or
       |  /// space in out.
       |  /// @exception IllegalStateException if the cipher isn't initialised.
       |  /// @return the number of bytes processed and produced.
      0|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) =>
      0|      _encrypting
      0|          ? _encryptBlock(inp, inpOff, out, outOff)
      0|          : _decryptBlock(inp, inpOff, out, outOff);
       |
       |  /// Do the appropriate processing for CFB mode encryption.
       |  ///
       |  /// @param in the array containing the data to be encrypted.
       |  /// @param inOff offset into the in array the data starts at.
       |  /// @param out the array the encrypted data will be copied into.
       |  /// @param outOff the offset into the out array the output will start at.
       |  /// @exception DataLengthException if there isn't enough data in in, or
       |  /// space in out.
       |  /// @exception IllegalStateException if the cipher isn't initialised.
       |  /// @return the number of bytes processed and produced.
      0|  int _encryptBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    if ((inpOff + blockSize) > inp.length) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
       |
      0|    if ((outOff + blockSize) > out.length) {
      0|      throw ArgumentError('Output buffer too short');
       |    }
       |
      0|    _underlyingCipher.processBlock(_cfbV, 0, _cfbOutV, 0);
       |
       |    // XOR the cfbV with the plaintext producing the ciphertext
      0|    for (var i = 0; i < blockSize; i++) {
      0|      out[outOff + i] = _cfbOutV[i] ^ inp[inpOff + i];
       |    }
       |
       |    // change over the input block.
      0|    var offset = _cfbV.length - blockSize;
      0|    _cfbV.setRange(0, offset, _cfbV.sublist(blockSize));
      0|    _cfbV.setRange(offset, _cfbV.length, out.sublist(outOff));
       |
      0|    return blockSize;
       |  }
       |
       |  /// Do the appropriate processing for CFB mode decryption.
       |  ///
       |  /// @param in the array containing the data to be decrypted.
       |  /// @param inOff offset into the in array the data starts at.
       |  /// @param out the array the encrypted data will be copied into.
       |  /// @param outOff the offset into the out array the output will start at.
       |  /// @exception DataLengthException if there isn't enough data in in, or
       |  /// space in out.
       |  /// @exception IllegalStateException if the cipher isn't initialised.
       |  /// @return the number of bytes processed and produced.
      0|  int _decryptBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    if ((inpOff + blockSize) > inp.length) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
       |
      0|    if ((outOff + blockSize) > out.length) {
      0|      throw ArgumentError('Output buffer too short');
       |    }
       |
      0|    _underlyingCipher.processBlock(_cfbV, 0, _cfbOutV, 0);
       |
       |    // change over the input block.
      0|    var offset = _cfbV.length - blockSize;
      0|    _cfbV.setRange(0, offset, _cfbV.sublist(blockSize));
      0|    _cfbV.setRange(offset, _cfbV.length, inp.sublist(inpOff));
       |
       |    // XOR the cfbV with the ciphertext producing the plaintext
      0|    for (var i = 0; i < blockSize; i++) {
      0|      out[outOff + i] = _cfbOutV[i] ^ inp[inpOff + i];
       |    }
       |
      0|    return blockSize;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/modes/ctr.dart
       |// See file LICENSE for more information.
       |
       |library impl.block_cipher.modes.ctr;
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/adapters/stream_cipher_as_block_cipher.dart';
       |import 'package:pointycastle/stream/ctr.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |class CTRBlockCipher extends StreamCipherAsBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      BlockCipher,
       |      '/CTR',
       |      (_, final Match match) => () {
       |            var underlying = BlockCipher(match.group(1));
       |            return CTRBlockCipher(
       |                underlying.blockSize, CTRStreamCipher(underlying));
       |          });
       |
      0|  CTRBlockCipher(int blockSize, StreamCipher underlyingCipher)
      0|      : super(blockSize, underlyingCipher);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/modes/ecb.dart
       |// See file LICENSE for more information.
       |
       |library impl.block_cipher.modes.ecb;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_block_cipher.dart';
       |
       |/// Implementation of Electronic Code Book (ECB) mode on top of a [BlockCipher].
       |class ECBBlockCipher extends BaseBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      BlockCipher,
       |      '/ECB',
       |      (_, final Match match) => () {
       |            var underlying = BlockCipher(match.group(1));
       |            return ECBBlockCipher(underlying);
       |          });
       |
       |  final BlockCipher _underlyingCipher;
       |
      0|  ECBBlockCipher(this._underlyingCipher);
       |
      0|  @override
      0|  String get algorithmName => '${_underlyingCipher.algorithmName}/ECB';
      0|  @override
      0|  int get blockSize => _underlyingCipher.blockSize;
      0|  @override
       |  void reset() {
      0|    _underlyingCipher.reset();
       |  }
       |
      0|  @override
       |  void init(bool forEncryption, CipherParameters params) {
      0|    _underlyingCipher.init(forEncryption, params);
       |  }
       |
      0|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) =>
      0|      _underlyingCipher.processBlock(inp, inpOff, out, outOff);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/modes/gcm.dart
       |library impl.block_cipher.modes.gcm;
       |
       |import 'dart:math' show min;
       |import 'dart:typed_data';
       |
       |import '../../api.dart';
       |import '../../src/impl/base_aead_block_cipher.dart';
       |import '../../src/registry/registry.dart';
       |
       |class GCMBlockCipher extends BaseAEADBlockCipher {
       |  /// Intended for internal use.
       |  // ignore: non_constant_identifier_names
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      BlockCipher,
       |      '/GCM',
       |      (_, final Match match) => () {
       |            var underlying = BlockCipher(match.group(1));
       |            return GCMBlockCipher(underlying);
       |          });
       |
       |  Uint8List _h;
       |  Uint8List _counter;
       |  Uint8List _e;
       |  Uint8List _e0;
       |  Uint8List _x;
       |  int _processedBytes;
       |
      0|  GCMBlockCipher(BlockCipher cipher) : super(cipher);
       |
      0|  @override
      0|  String get algorithmName => '${underlyingCipher.algorithmName}/GCM';
       |
      0|  @override
       |  void prepare(KeyParameter keyParam) {
      0|    if (macSize != 16) {
      0|      throw ArgumentError('macSize should be equal to 16 for GCM');
       |    }
       |
      0|    underlyingCipher.init(true, keyParam);
       |
      0|    _h = Uint8List(blockSize);
      0|    underlyingCipher.processBlock(_h, 0, _h, 0);
       |
      0|    _counter = _computeInitialCounter(nonce);
       |
      0|    _e0 = Uint8List(16);
      0|    _computeE(_counter, _e0);
       |
      0|    _e = Uint8List(16);
       |
      0|    _x = Uint8List(16);
       |
      0|    _processedBytes = 0;
       |  }
       |
      0|  Uint8List _computeInitialCounter(Uint8List iv) {
      0|    var counter = Uint8List(16);
       |
      0|    if (iv.length == 12) {
      0|      counter.setAll(0, iv);
      0|      counter[15] = 1;
       |    } else {
      0|      _gHASH(counter, iv);
      0|      var length = Uint8List.view((Uint64List(2)..[0] = iv.length * 8).buffer);
      0|      length = Uint8List.fromList(length.reversed.toList());
       |
      0|      _gHASHBlock(counter, length);
       |    }
       |    return counter;
       |  }
       |
      0|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
       |    var length =
      0|        blockSize < inp.length - inpOff ? blockSize : inp.length - inpOff;
       |
      0|    var i = Uint8List(blockSize);
      0|    i.setAll(0, inp.skip(inpOff).take(length));
       |
      0|    _processedBytes += length;
       |
      0|    _getNextCTRBlock(_e);
       |
      0|    var o = Uint8List.fromList(i);
      0|    _xor(o, _e);
      0|    if (length < blockSize) o.fillRange(length, blockSize, 0);
       |
      0|    out.setRange(outOff, outOff + length, o);
       |
      0|    var c = forEncryption ? o : i;
       |
      0|    _gHASHBlock(_x, c);
       |
       |    return length;
       |  }
       |
      0|  void _gHASH(Uint8List x, Uint8List y) {
      0|    var block = Uint8List(16);
      0|    for (var i = 0; i < y.length; i += 16) {
      1|      block.setAll(0, y.sublist(i, min(i + 16, y.length)));
      1|      block.fillRange(min(i + 16, y.length) - i, 16, 0);
      0|      _gHASHBlock(x, block);
       |    }
       |  }
       |
      0|  void _gHASHBlock(Uint8List x, Uint8List y) {
      0|    _xor(x, y);
      0|    _mult(x, _h);
       |  }
       |
      0|  void _getNextCTRBlock(Uint8List out) {
      0|    _counter[15]++;
      0|    for (var i = 15; i >= 12 && _counter[i] == 256; i--) {
      0|      _counter[i] = 0;
      0|      if (i > 12) _counter[i - 1]++;
       |    }
       |
      0|    _computeE(_counter, out);
       |  }
       |
      0|  void _computeE(Uint8List inp, Uint8List out) {
      0|    underlyingCipher.processBlock(inp, 0, out, 0);
       |  }
       |
       |  final Uint8List r = Uint8List(16)..[0] = 0xe1;
       |
      0|  void _mult(Uint8List x, Uint8List y) {
       |    var v = x;
      0|    var z = Uint8List(x.length);
       |
      0|    for (var i = 0; i < 128; i++) {
      0|      if (_bit(y, i)) {
      0|        _xor(z, v);
       |      }
      0|      if (_shiftRight(v)) {
      0|        _xor(v, r);
       |      }
       |    }
       |
      0|    x.setAll(0, z);
       |  }
       |
      0|  void _xor(Uint8List x, Uint8List y) {
      0|    for (var i = 0; i < x.length; i++) {
      0|      x[i] ^= y[i];
       |    }
       |  }
       |
      0|  bool _bit(Uint8List x, int n) {
      0|    var byte = n ~/ 8;
      0|    var mask = 1 << (7 - n % 8);
      0|    return x[byte] & mask == mask;
       |  }
       |
      0|  bool _shiftRight(Uint8List x) {
       |    var overflow = false;
      0|    for (var i = 0; i < x.length; i++) {
      0|      var nextOverflow = x[i] & 0x1 == 0x1;
      0|      x[i] >>= 1;
      0|      if (overflow) x[i] |= 0x80;
       |      overflow = nextOverflow;
       |    }
       |    return overflow;
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    var result = remainingInput.isNotEmpty
      0|        ? processBlock(remainingInput, 0, out, outOff)
       |        : 0;
       |
      0|    var len = Uint8List.view((Uint64List(2)
      0|          ..[1] = aad.length * 8
      0|          ..[0] = _processedBytes * 8)
      0|        .buffer);
      0|    len = Uint8List.fromList(len.reversed.toList());
       |
      0|    _gHASHBlock(_x, len);
       |
      0|    _xor(_x, _e0);
       |
      0|    if (forEncryption) {
      0|      out.setAll(outOff + result, _x);
      0|      result += _x.length;
       |    }
       |
      0|    validateMac();
       |
       |    return result;
       |  }
       |
      0|  @override
      0|  Uint8List get mac => _x;
       |
      0|  @override
       |  void processAADBytes(Uint8List inp, int inpOff, int len) {
      0|    var block = Uint8List(16);
      0|    for (var i = 0; i < len; i += 16) {
      0|      block.fillRange(0, 16, 0);
      0|      block.setAll(
      1|          0, inp.sublist(inpOff + i, inpOff + min(i + 16, len) as int));
      0|      _gHASHBlock(_x, block);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/modes/gctr.dart
       |// See file LICENSE for more information.
       |
       |library impl.block_cipher.modes.gctr;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_block_cipher.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of GOST 28147 OFB counter mode (GCTR) on top of a [BlockCipher].
       |class GCTRBlockCipher extends BaseBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      BlockCipher,
       |      '/GCTR',
       |      (_, final Match match) => () {
       |            var underlying = BlockCipher(match.group(1));
       |            return GCTRBlockCipher(underlying);
       |          });
       |
       |  static const C1 = 16843012; //00000001000000010000000100000100
       |  static const C2 = 16843009; //00000001000000010000000100000001
       |
       |  final BlockCipher _underlyingCipher;
       |
       |  Uint8List _iv;
       |  Uint8List _ofbV;
       |  Uint8List _ofbOutV;
       |
       |  bool _firstStep = true;
       |  int _n3;
       |  int _n4;
       |
      0|  GCTRBlockCipher(this._underlyingCipher) {
      0|    if (blockSize != 8) {
      0|      throw ArgumentError('GCTR can only be used with 64 bit block ciphers');
       |    }
       |
      0|    _iv = Uint8List(_underlyingCipher.blockSize);
      0|    _ofbV = Uint8List(_underlyingCipher.blockSize);
      0|    _ofbOutV = Uint8List(_underlyingCipher.blockSize);
       |  }
       |
      0|  @override
      0|  int get blockSize => _underlyingCipher.blockSize;
      0|  @override
      0|  String get algorithmName => '${_underlyingCipher.algorithmName}/GCTR';
      0|  @override
       |  void reset() {
      0|    _ofbV.setRange(0, _iv.length, _iv);
      0|    _underlyingCipher.reset();
       |  }
       |
       |  /// Initialise the cipher and, possibly, the initialisation vector (IV).
       |  /// If an IV isn't passed as part of the parameter, the IV will be all zeros.
       |  /// An IV which is too short is handled in FIPS compliant fashion.
       |  ///
       |  /// @param encrypting if true the cipher is initialised for
       |  ///  encryption, if false for decryption. //ignored by this CTR mode
       |  /// @param params the key and other data required by the cipher.
       |  /// @exception IllegalArgumentException if the params argument is
       |  /// inappropriate.
      0|  @override
       |  void init(bool encrypting, CipherParameters params) {
      0|    _firstStep = true;
      0|    _n3 = 0;
      0|    _n4 = 0;
       |
      0|    if (params is ParametersWithIV) {
       |      var ivParam = params;
      0|      var iv = ivParam.iv;
       |
      0|      if (iv.length < _iv.length) {
       |        // prepend the supplied IV with zeros (per FIPS PUB 81)
      0|        var offset = _iv.length - iv.length;
      0|        _iv.fillRange(0, offset, 0);
      0|        _iv.setRange(offset, _iv.length, iv);
       |      } else {
      0|        _iv.setRange(0, _iv.length, iv);
       |      }
       |
      0|      reset();
       |
       |      // if params is null we reuse the current working key.
      0|      if (ivParam.parameters != null) {
      0|        _underlyingCipher.init(true, ivParam.parameters);
       |      }
       |    } else {
       |      // TODO: make this behave in a standard way (as the other modes of operation)
      0|      reset();
       |
       |      // if params is null we reuse the current working key.
       |      if (params != null) {
      0|        _underlyingCipher.init(true, params);
       |      }
       |    }
       |  }
       |
      0|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    if ((inpOff + blockSize) > inp.length) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
       |
      0|    if ((outOff + blockSize) > out.length) {
      0|      throw ArgumentError('Output buffer too short');
       |    }
       |
      0|    if (_firstStep) {
      0|      _firstStep = false;
      0|      _underlyingCipher.processBlock(_ofbV, 0, _ofbOutV, 0);
      0|      _n3 = _bytesToint(_ofbOutV, 0);
      0|      _n4 = _bytesToint(_ofbOutV, 4);
       |    }
      0|    _n3 += C2;
      0|    _n4 += C1;
      0|    _intTobytes(_n3, _ofbV, 0);
      0|    _intTobytes(_n4, _ofbV, 4);
       |
      0|    _underlyingCipher.processBlock(_ofbV, 0, _ofbOutV, 0);
       |
       |    // XOR the ofbV with the plaintext producing the cipher text (and the next input block).
      0|    for (var i = 0; i < blockSize; i++) {
      0|      out[outOff + i] = _ofbOutV[i] ^ inp[inpOff + i];
       |    }
       |
       |    // change over the input block.
      0|    var offset = _ofbV.length - blockSize;
      0|    _ofbV.setRange(0, offset, _ofbV.sublist(blockSize));
      0|    _ofbV.setRange(offset, _ofbV.length, _ofbOutV);
       |
      0|    return blockSize;
       |  }
       |
      0|  int _bytesToint(Uint8List inp, int inpOff) {
      0|    return unpack32(inp, inpOff, Endian.little);
       |  }
       |
      0|  void _intTobytes(int num, Uint8List out, int outOff) {
      0|    pack32(num, out, outOff, Endian.little);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/modes/ofb.dart
       |// See file LICENSE for more information.
       |
       |library impl.block_cipher.modes.ofb;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_block_cipher.dart';
       |
       |/// Implementation of Output FeedBack mode (OFB) on top of a [BlockCipher].
       |class OFBBlockCipher extends BaseBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.regex(
       |      BlockCipher,
       |      r'^(.+)/OFB-([0-9]+)$',
       |      (_, final Match match) => () {
       |            var underlying = BlockCipher(match.group(1));
       |            var blockSizeInBits = int.parse(match.group(2));
       |            if ((blockSizeInBits % 8) != 0) {
       |              throw RegistryFactoryException.invalid(
       |                  'Bad OFB block size: $blockSizeInBits (must be a multiple of 8)');
       |            }
       |            return OFBBlockCipher(underlying, blockSizeInBits ~/ 8);
       |          });
       |
       |  @override
       |  final int blockSize;
       |
       |  final BlockCipher _underlyingCipher;
       |
       |  Uint8List _iv;
       |  Uint8List _ofbV;
       |  Uint8List _ofbOutV;
       |
      0|  OFBBlockCipher(this._underlyingCipher, this.blockSize) {
      0|    _iv = Uint8List(_underlyingCipher.blockSize);
      0|    _ofbV = Uint8List(_underlyingCipher.blockSize);
      0|    _ofbOutV = Uint8List(_underlyingCipher.blockSize);
       |  }
       |
      0|  @override
       |  String get algorithmName =>
      0|      '${_underlyingCipher.algorithmName}/OFB-${blockSize * 8}';
       |
      0|  @override
       |  void reset() {
      0|    _ofbV.setRange(0, _iv.length, _iv);
      0|    _underlyingCipher.reset();
       |  }
       |
       |  /// Initialise the cipher and, possibly, the initialisation vector (IV). If an IV isn't passed as part of the parameter, the
       |  /// IV will be all zeros. An IV which is too short is handled in FIPS compliant fashion.
      0|  @override
       |  void init(bool forEncryption, CipherParameters params) {
      0|    if (params is ParametersWithIV) {
       |      var ivParam = params;
      0|      var iv = ivParam.iv;
       |
      0|      if (iv.length < _iv.length) {
       |        // prepend the supplied IV with zeros (per FIPS PUB 81)
      0|        var offset = _iv.length - iv.length;
      0|        _iv.fillRange(0, offset, 0);
      0|        _iv.setAll(offset, iv);
       |      } else {
      0|        _iv.setRange(0, _iv.length, iv);
       |      }
       |
      0|      reset();
       |
       |      // if null it's an IV changed only.
      0|      if (ivParam.parameters != null) {
      0|        _underlyingCipher.init(true, ivParam.parameters);
       |      }
       |    } else {
      0|      _underlyingCipher.init(true, params);
       |    }
       |  }
       |
      0|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    if ((inpOff + blockSize) > inp.length) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
       |
      0|    if ((outOff + blockSize) > out.length) {
      0|      throw ArgumentError('Output buffer too short');
       |    }
       |
      0|    _underlyingCipher.processBlock(_ofbV, 0, _ofbOutV, 0);
       |
       |    // XOR the ofbV with the plaintext producing the cipher text (and the next input block).
      0|    for (var i = 0; i < blockSize; i++) {
      0|      out[outOff + i] = _ofbOutV[i] ^ inp[inpOff + i];
       |    }
       |
       |    // change over the input block.
      0|    var offset = _ofbV.length - blockSize;
      0|    _ofbV.setRange(0, offset, _ofbV.sublist(blockSize));
      0|    _ofbV.setRange(offset, _ofbV.length, _ofbOutV);
       |
      0|    return blockSize;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/block/modes/sic.dart
       |// See file LICENSE for more information.
       |
       |library impl.block_cipher.modes.sic;
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/adapters/stream_cipher_as_block_cipher.dart';
       |import 'package:pointycastle/stream/sic.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// See [SICStreamCipher].
       |class SICBlockCipher extends StreamCipherAsBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      BlockCipher,
       |      '/SIC',
       |      (_, final Match match) => () {
       |            var underlying = BlockCipher(match.group(1));
       |            return SICBlockCipher(
       |                underlying.blockSize, SICStreamCipher(underlying));
       |          });
       |
      0|  SICBlockCipher(int blockSize, StreamCipher underlyingCipher)
      0|      : super(blockSize, underlyingCipher);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/blake2b.dart
       |library impl.digest.blake2b;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |class Blake2bDigest extends BaseDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'Blake2b', () => Blake2bDigest());
       |
       |  static const _rounds = 12;
       |  static const _blockSize = 128;
       |
       |  int _digestLength = 64;
       |  int _keyLength = 0;
       |  Uint8List _salt;
       |  Uint8List _personalization;
       |
       |  Uint8List _key;
       |
       |  Uint8List _buffer;
       |  // Position of last inserted byte:
       |  int _bufferPos = 0; // a value from 0 up to 128
       |  final _internalState =
       |      Register64List(16); // In the Blake2b paper it is called: v
       |  Register64List
       |      _chainValue; // state vector, in the Blake2b paper it is called: h
       |
       |  final _t0 =
       |      Register64(); // holds last significant bits, counter (counts bytes)
       |  final _t1 = Register64(); // counter: Length up to 2^128 are supported
       |  final _f0 = Register64(); // finalization flag, for last block: ~0L
       |
      0|  Blake2bDigest(
       |      {int digestSize = 64,
       |      Uint8List key,
       |      Uint8List salt,
       |      Uint8List personalization}) {
      0|    _buffer = Uint8List(_blockSize);
       |
      0|    if (digestSize < 1 || digestSize > 64) {
      0|      throw ArgumentError('Invalid digest length (required: 1 - 64)');
       |    }
      0|    _digestLength = digestSize;
       |    if (salt != null) {
      0|      if (salt.length != 16) {
      0|        throw ArgumentError('salt length must be exactly 16 bytes');
       |      }
      0|      _salt = Uint8List.fromList(salt);
       |    }
       |    if (personalization != null) {
      0|      if (personalization.length != 16) {
      0|        throw ArgumentError('personalization length must be exactly 16 bytes');
       |      }
      0|      _personalization = Uint8List.fromList(personalization);
       |    }
       |    if (key != null) {
      0|      if (key.length > 64) throw ArgumentError('Keys > 64 are not supported');
      0|      _key = Uint8List.fromList(key);
       |
      0|      _keyLength = key.length;
      0|      _buffer.setAll(0, key);
      0|      _bufferPos = _blockSize;
       |    }
      0|    init();
       |  }
       |
      0|  @override
       |  String get algorithmName => 'Blake2b';
      0|  @override
      0|  int get digestSize => _digestLength;
       |
      0|  void init() {
      0|    if (_chainValue == null) {
      0|      _chainValue = Register64List(8);
      0|      _chainValue[0]
      0|        ..set(_blake2bIV[0])
      0|        ..xor(Register64(digestSize | (_keyLength << 8) | 0x1010000));
      0|      _chainValue[1].set(_blake2bIV[1]);
      0|      _chainValue[2].set(_blake2bIV[2]);
       |
      0|      _chainValue[3].set(_blake2bIV[3]);
       |
      0|      _chainValue[4].set(_blake2bIV[4]);
      0|      _chainValue[5].set(_blake2bIV[5]);
      0|      if (_salt != null) {
      0|        _chainValue[4].xor(Register64()..unpack(_salt, 0, Endian.little));
      0|        _chainValue[5].xor(Register64()..unpack(_salt, 8, Endian.little));
       |      }
       |
      0|      _chainValue[6].set(_blake2bIV[6]);
      0|      _chainValue[7].set(_blake2bIV[7]);
      0|      if (_personalization != null) {
      0|        _chainValue[6]
      0|            .xor(Register64()..unpack(_personalization, 0, Endian.little));
      0|        _chainValue[7]
      0|            .xor(Register64()..unpack(_personalization, 8, Endian.little));
       |      }
       |    }
       |  }
       |
      0|  void _initializeInternalState() {
      0|    _internalState.setRange(0, _chainValue.length, _chainValue);
      0|    _internalState.setRange(
      0|        _chainValue.length, _chainValue.length + 4, _blake2bIV);
      0|    _internalState[12]
      0|      ..set(_t0)
      0|      ..xor(_blake2bIV[4]);
      0|    _internalState[13]
      0|      ..set(_t1)
      0|      ..xor(_blake2bIV[5]);
      0|    _internalState[14]
      0|      ..set(_f0)
      0|      ..xor(_blake2bIV[6]);
      0|    _internalState[15]..set(_blake2bIV[7]); // ^ f1 with f1 = 0
       |  }
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    if (_bufferPos == _blockSize) {
       |      // full buffer
      0|      _t0.sum(_blockSize);
       |      // This requires hashing > 2^64 bytes which is impossible for the forseeable future.
       |      // So _t1 is untested dead code, but I've left it in because it is in the source library.
      0|      if (_t0.lo32 == 0 && _t0.hi32 == 0) _t1.sum(1);
      0|      _compress(_buffer, 0);
      0|      _buffer.fillRange(0, _buffer.length, 0); // clear buffer
      0|      _buffer[0] = inp;
      0|      _bufferPos = 1;
       |    } else {
      0|      _buffer[_bufferPos] = inp;
      0|      ++_bufferPos;
       |    }
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
      0|    if (inp == null || len == 0) return;
       |
       |    var remainingLength = 0;
      0|    if (_bufferPos != 0) {
      0|      remainingLength = _blockSize - _bufferPos;
      0|      if (remainingLength < len) {
      0|        _buffer.setRange(_bufferPos, _bufferPos + remainingLength, inp, inpOff);
      0|        _t0.sum(_blockSize);
      0|        if (_t0.lo32 == 0 && _t0.hi32 == 0) _t1.sum(1);
      0|        _compress(inp, 0);
      0|        _bufferPos = 0;
      0|        _buffer.fillRange(0, _buffer.length, 0); // clear buffer
       |      } else {
      0|        _buffer.setRange(_bufferPos, _bufferPos + len, inp, inpOff);
      0|        _bufferPos += len;
       |        return;
       |      }
       |    }
       |
       |    int msgPos;
      0|    var blockWiseLastPos = inpOff + len - _blockSize;
      0|    for (msgPos = inpOff + remainingLength;
      0|        msgPos < blockWiseLastPos;
      0|        msgPos += _blockSize) {
      0|      _t0.sum(_blockSize);
      0|      if (_t0.lo32 == 0 && _t0.hi32 == 0) _t1.sum(1);
      0|      _compress(inp, msgPos);
       |    }
       |
      0|    _buffer.setRange(0, inpOff + len - msgPos, inp, msgPos);
      0|    _bufferPos += inpOff + len - msgPos;
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    _f0.set(0xFFFFFFFF, 0xFFFFFFFF);
      0|    _t0.sum(_bufferPos);
      0|    if (_bufferPos > 0 && _t0.lo32 == 0 && _t0.hi32 == 0) _t1.sum(1);
      0|    _compress(_buffer, 0);
      0|    _buffer.fillRange(0, _buffer.length, 0); // clear buffer
      0|    _internalState.fillRange(0, _internalState.length, 0);
       |
      0|    final packedValue = Uint8List(8);
      0|    final packedValueData = packedValue.buffer.asByteData();
      0|    for (var i = 0; i < _chainValue.length && (i * 8 < _digestLength); ++i) {
      0|      _chainValue[i].pack(packedValueData, 0, Endian.little);
       |
      0|      final start = outOff + i * 8;
      0|      if (i * 8 < _digestLength - 8) {
      0|        out.setRange(start, start + 8, packedValue);
       |      } else {
      0|        out.setRange(start, start + _digestLength - (i * 8), packedValue);
       |      }
       |    }
       |
      0|    _chainValue.fillRange(0, _chainValue.length, 0);
       |
      0|    reset();
       |
      0|    return _digestLength;
       |  }
       |
      0|  @override
       |  void reset() {
      0|    _bufferPos = 0;
      0|    _f0.set(0);
      0|    _t0.set(0);
      0|    _t1.set(0);
      0|    _chainValue = null;
      0|    _buffer.fillRange(0, _buffer.length, 0);
      0|    if (_key != null) {
      0|      _buffer.setAll(0, _key);
      0|      _bufferPos = _blockSize;
       |    }
      0|    init();
       |  }
       |
       |  // This variable is faster as a class member.
       |  final _m = Register64List(16);
      0|  void _compress(Uint8List message, int messagePos) {
      0|    _initializeInternalState();
       |
      0|    for (var j = 0; j < 16; ++j) {
      0|      _m[j].unpack(message, messagePos + j * 8, Endian.little);
       |    }
       |
      0|    for (var round = 0; round < _rounds; ++round) {
      0|      G(_m[_blake2bSigma[round][0]], _m[_blake2bSigma[round][1]], 0, 4, 8, 12);
      0|      G(_m[_blake2bSigma[round][2]], _m[_blake2bSigma[round][3]], 1, 5, 9, 13);
      0|      G(_m[_blake2bSigma[round][4]], _m[_blake2bSigma[round][5]], 2, 6, 10, 14);
      0|      G(_m[_blake2bSigma[round][6]], _m[_blake2bSigma[round][7]], 3, 7, 11, 15);
      0|      G(_m[_blake2bSigma[round][8]], _m[_blake2bSigma[round][9]], 0, 5, 10, 15);
      0|      G(_m[_blake2bSigma[round][10]], _m[_blake2bSigma[round][11]], 1, 6, 11,
       |          12);
      0|      G(_m[_blake2bSigma[round][12]], _m[_blake2bSigma[round][13]], 2, 7, 8,
       |          13);
      0|      G(_m[_blake2bSigma[round][14]], _m[_blake2bSigma[round][15]], 3, 4, 9,
       |          14);
       |    }
       |
      0|    for (var offset = 0; offset < _chainValue.length; ++offset) {
      0|      _chainValue[offset]
      0|        ..xor(_internalState[offset])
      0|        ..xor(_internalState[offset + 8]);
       |    }
       |  }
       |
      0|  void G(Register64 m1, Register64 m2, int posA, int posB, int posC, int posD) {
       |    // This variable is faster as a local. The allocation is probably sunk.
      0|    final r = Register64();
       |
      0|    _internalState[posA].sumReg(r
      0|      ..set(_internalState[posB])
      0|      ..sumReg(m1));
      0|    _internalState[posD]
      0|      ..xor(_internalState[posA])
      0|      ..rotr(32);
      0|    _internalState[posC].sumReg(_internalState[posD]);
      0|    _internalState[posB]
      0|      ..xor(_internalState[posC])
      0|      ..rotr(24);
      0|    _internalState[posA].sumReg(r
      0|      ..set(_internalState[posB])
      0|      ..sumReg(m2));
      0|    _internalState[posD]
      0|      ..xor(_internalState[posA])
      0|      ..rotr(16);
      0|    _internalState[posC].sumReg(_internalState[posD]);
      0|    _internalState[posB]
      0|      ..xor(_internalState[posC])
      0|      ..rotr(63);
       |  }
       |
      0|  @override
       |  int get byteLength => 128;
       |}
       |
       |// Produced from the square root of primes 2, 3, 5, 7, 11, 13, 17, 19.
       |// The same as SHA-512 IV.
      0|final _blake2bIV = Register64List.from([
       |  [0x6a09e667, 0xf3bcc908],
       |  [0xbb67ae85, 0x84caa73b],
       |  [0x3c6ef372, 0xfe94f82b],
       |  [0xa54ff53a, 0x5f1d36f1],
       |  [0x510e527f, 0xade682d1],
       |  [0x9b05688c, 0x2b3e6c1f],
       |  [0x1f83d9ab, 0xfb41bd6b],
       |  [0x5be0cd19, 0x137e2179],
       |]);
       |
      0|final _blake2bSigma = [
       |  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
       |  [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
       |  [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],
       |  [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],
       |  [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],
       |  [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],
       |  [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],
       |  [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],
       |  [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],
       |  [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],
       |  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
       |  [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
       |];
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/keccak.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.keccak;
       |
       |import 'dart:io';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/keccak_engine.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Implementation of Keccak digest.
       |class KeccakDigest extends KeccakEngine {
      0|  static final RegExp _keccakREGEX = RegExp(r'^Keccak\/([0-9]+)$');
       |
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig(
       |      Digest,
       |      _keccakREGEX,
       |      (_, final Match match) => () {
       |            var bitLength = int.parse(match.group(1));
       |            return KeccakDigest(bitLength);
       |          });
       |
      0|  KeccakDigest([int bitLength = 288]) {
       |    switch (bitLength) {
      0|      case 128:
      0|      case 224:
      0|      case 256:
      0|      case 288:
      0|      case 384:
      0|      case 512:
      0|        init(bitLength);
       |        break;
       |      default:
      0|        throw StateError(
      0|            'invalid bitLength ($bitLength) for Keccak must only be 128,224,256,288,384,512');
       |    }
       |  }
       |
      0|  @override
      0|  String get algorithmName => 'Keccak/$fixedOutputLength';
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    squeeze(out, outOff, fixedOutputLength);
      0|    reset();
      0|    return digestSize;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/md2.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.md2;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Implementation of MD2 as outlined in RFC1319 by B.Kaliski from RSA Laboratories April 1992
       |class MD2Digest extends BaseDigest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'MD2', () => MD2Digest());
       |
       |  static const _DIGEST_LENGTH = 16;
       |
       |  /* X buffer */
       |  final _x = Uint8List(48);
       |  int _xOff = 0;
       |
       |  /* M buffer */
       |  final _m = Uint8List(16);
       |  int _mOff = 0;
       |
       |  /* check sum */
       |  final _c = Uint8List(16);
       |  // ignore: unused_field
       |  int _cOff = 0;
       |
      0|  @override
       |  String get algorithmName => 'MD2';
       |
      0|  @override
       |  int get digestSize => _DIGEST_LENGTH;
       |
      0|  @override
       |  void reset() {
      0|    _xOff = 0;
      0|    _x.fillRange(0, _x.length, 0);
       |
      0|    _mOff = 0;
      0|    _m.fillRange(0, _m.length, 0);
       |
      0|    _cOff = 0;
      0|    _c.fillRange(0, _c.length, 0);
       |  }
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    _m[_mOff++] = inp;
       |
      0|    if (_mOff == 16) {
      0|      _processCheckSum(_m);
      0|      _processBlock(_m);
      0|      _mOff = 0;
       |    }
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
       |    // fill the current word
      0|    while ((_mOff != 0) && (len > 0)) {
      0|      updateByte(inp[inpOff]);
      0|      inpOff++;
      0|      len--;
       |    }
       |
       |    // process whole words.
      0|    while (len > 16) {
      0|      _m.setRange(0, 16, inp.sublist(inpOff));
      0|      _processCheckSum(_m);
      0|      _processBlock(_m);
      0|      len -= 16;
      0|      inpOff += 16;
       |    }
       |
       |    // load in the remainder.
      0|    while (len > 0) {
      0|      updateByte(inp[inpOff]);
      0|      inpOff++;
      0|      len--;
       |    }
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
       |    // add padding
      0|    var paddingByte = _m.length - _mOff;
      0|    for (var i = _mOff; i < _m.length; i++) {
      0|      _m[i] = paddingByte;
       |    }
       |
       |    //do final check sum
      0|    _processCheckSum(_m);
       |
       |    // do final block process
      0|    _processBlock(_m);
       |
      0|    _processBlock(_c);
       |
      0|    out.setRange(outOff, outOff + 16, _x.sublist(_xOff));
       |
      0|    reset();
       |
       |    return _DIGEST_LENGTH;
       |  }
       |
      0|  void _processBlock(Uint8List m) {
      0|    for (var i = 0; i < 16; i++) {
      0|      _x[i + 16] = m[i];
      0|      _x[i + 32] = m[i] ^ _x[i];
       |    }
       |
       |    // encrypt block
       |    var t = 0;
       |
      0|    for (var j = 0; j < 18; j++) {
      0|      for (var k = 0; k < 48; k++) {
      0|        t = _x[k] ^= _s[t];
      0|        t = t & 0xff;
       |      }
      0|      t = (t + j) % 256;
       |    }
       |  }
       |
      0|  void _processCheckSum(Uint8List m) {
      0|    var L = _c[15];
      0|    for (var i = 0; i < 16; i++) {
      0|      _c[i] ^= _s[(m[i] ^ L) & 0xff];
      0|      L = _c[i];
       |    }
       |  }
       |
       |  // 256-byte random permutation constructed from the digits of PI
      0|  static final _s = [
       |    41,
       |    46,
       |    67,
       |    201,
       |    162,
       |    216,
       |    124,
       |    1,
       |    61,
       |    54,
       |    84,
       |    161,
       |    236,
       |    240,
       |    6,
       |    19,
       |    98,
       |    167,
       |    5,
       |    243,
       |    192,
       |    199,
       |    115,
       |    140,
       |    152,
       |    147,
       |    43,
       |    217,
       |    188,
       |    76,
       |    130,
       |    202,
       |    30,
       |    155,
       |    87,
       |    60,
       |    253,
       |    212,
       |    224,
       |    22,
       |    103,
       |    66,
       |    111,
       |    24,
       |    138,
       |    23,
       |    229,
       |    18,
       |    190,
       |    78,
       |    196,
       |    214,
       |    218,
       |    158,
       |    222,
       |    73,
       |    160,
       |    251,
       |    245,
       |    142,
       |    187,
       |    47,
       |    238,
       |    122,
       |    169,
       |    104,
       |    121,
       |    145,
       |    21,
       |    178,
       |    7,
       |    63,
       |    148,
       |    194,
       |    16,
       |    137,
       |    11,
       |    34,
       |    95,
       |    33,
       |    128,
       |    127,
       |    93,
       |    154,
       |    90,
       |    144,
       |    50,
       |    39,
       |    53,
       |    62,
       |    204,
       |    231,
       |    191,
       |    247,
       |    151,
       |    3,
       |    255,
       |    25,
       |    48,
       |    179,
       |    72,
       |    165,
       |    181,
       |    209,
       |    215,
       |    94,
       |    146,
       |    42,
       |    172,
       |    86,
       |    170,
       |    198,
       |    79,
       |    184,
       |    56,
       |    210,
       |    150,
       |    164,
       |    125,
       |    182,
       |    118,
       |    252,
       |    107,
       |    226,
       |    156,
       |    116,
       |    4,
       |    241,
       |    69,
       |    157,
       |    112,
       |    89,
       |    100,
       |    113,
       |    135,
       |    32,
       |    134,
       |    91,
       |    207,
       |    101,
       |    230,
       |    45,
       |    168,
       |    2,
       |    27,
       |    96,
       |    37,
       |    173,
       |    174,
       |    176,
       |    185,
       |    246,
       |    28,
       |    70,
       |    97,
       |    105,
       |    52,
       |    64,
       |    126,
       |    15,
       |    85,
       |    71,
       |    163,
       |    35,
       |    221,
       |    81,
       |    175,
       |    58,
       |    195,
       |    92,
       |    249,
       |    206,
       |    186,
       |    197,
       |    234,
       |    38,
       |    44,
       |    83,
       |    13,
       |    110,
       |    133,
       |    40,
       |    132,
       |    9,
       |    211,
       |    223,
       |    205,
       |    244,
       |    65,
       |    129,
       |    77,
       |    82,
       |    106,
       |    220,
       |    55,
       |    200,
       |    108,
       |    193,
       |    171,
       |    250,
       |    36,
       |    225,
       |    123,
       |    8,
       |    12,
       |    189,
       |    177,
       |    74,
       |    120,
       |    136,
       |    149,
       |    139,
       |    227,
       |    99,
       |    232,
       |    109,
       |    233,
       |    203,
       |    213,
       |    254,
       |    59,
       |    0,
       |    29,
       |    57,
       |    242,
       |    239,
       |    183,
       |    14,
       |    102,
       |    88,
       |    208,
       |    228,
       |    166,
       |    119,
       |    114,
       |    248,
       |    235,
       |    117,
       |    75,
       |    10,
       |    49,
       |    68,
       |    80,
       |    180,
       |    143,
       |    237,
       |    31,
       |    26,
       |    219,
       |    153,
       |    141,
       |    51,
       |    159,
       |    17,
       |    131,
       |    20
       |  ];
       |
      0|  @override
       |  int get byteLength => 16;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/md4.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.md4;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of MD4 digest
       |class MD4Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'MD4', () => MD4Digest());
       |
       |  static const _DIGEST_LENGTH = 16;
       |
      0|  MD4Digest() : super(Endian.little, 4, 16);
       |
       |  @override
       |  final algorithmName = 'MD4';
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void resetState() {
      0|    state[0] = 0x67452301;
      0|    state[1] = 0xefcdab89;
      0|    state[2] = 0x98badcfe;
      0|    state[3] = 0x10325476;
       |  }
       |
      0|  @override
       |  void processBlock() {
      0|    var a = state[0];
      0|    var b = state[1];
      0|    var c = state[2];
      0|    var d = state[3];
       |
       |    // Round 1 - F cycle, 16 times.
      0|    a = crotl32(a + _f(b, c, d) + buffer[0], _S11);
      0|    d = crotl32(d + _f(a, b, c) + buffer[1], _S12);
      0|    c = crotl32(c + _f(d, a, b) + buffer[2], _S13);
      0|    b = crotl32(b + _f(c, d, a) + buffer[3], _S14);
      0|    a = crotl32(a + _f(b, c, d) + buffer[4], _S11);
      0|    d = crotl32(d + _f(a, b, c) + buffer[5], _S12);
      0|    c = crotl32(c + _f(d, a, b) + buffer[6], _S13);
      0|    b = crotl32(b + _f(c, d, a) + buffer[7], _S14);
      0|    a = crotl32(a + _f(b, c, d) + buffer[8], _S11);
      0|    d = crotl32(d + _f(a, b, c) + buffer[9], _S12);
      0|    c = crotl32(c + _f(d, a, b) + buffer[10], _S13);
      0|    b = crotl32(b + _f(c, d, a) + buffer[11], _S14);
      0|    a = crotl32(a + _f(b, c, d) + buffer[12], _S11);
      0|    d = crotl32(d + _f(a, b, c) + buffer[13], _S12);
      0|    c = crotl32(c + _f(d, a, b) + buffer[14], _S13);
      0|    b = crotl32(b + _f(c, d, a) + buffer[15], _S14);
       |
       |    // Round 2 - G cycle, 16 times.
      0|    a = crotl32(a + _g(b, c, d) + buffer[0] + 0x5a827999, _S21);
      0|    d = crotl32(d + _g(a, b, c) + buffer[4] + 0x5a827999, _S22);
      0|    c = crotl32(c + _g(d, a, b) + buffer[8] + 0x5a827999, _S23);
      0|    b = crotl32(b + _g(c, d, a) + buffer[12] + 0x5a827999, _S24);
      0|    a = crotl32(a + _g(b, c, d) + buffer[1] + 0x5a827999, _S21);
      0|    d = crotl32(d + _g(a, b, c) + buffer[5] + 0x5a827999, _S22);
      0|    c = crotl32(c + _g(d, a, b) + buffer[9] + 0x5a827999, _S23);
      0|    b = crotl32(b + _g(c, d, a) + buffer[13] + 0x5a827999, _S24);
      0|    a = crotl32(a + _g(b, c, d) + buffer[2] + 0x5a827999, _S21);
      0|    d = crotl32(d + _g(a, b, c) + buffer[6] + 0x5a827999, _S22);
      0|    c = crotl32(c + _g(d, a, b) + buffer[10] + 0x5a827999, _S23);
      0|    b = crotl32(b + _g(c, d, a) + buffer[14] + 0x5a827999, _S24);
      0|    a = crotl32(a + _g(b, c, d) + buffer[3] + 0x5a827999, _S21);
      0|    d = crotl32(d + _g(a, b, c) + buffer[7] + 0x5a827999, _S22);
      0|    c = crotl32(c + _g(d, a, b) + buffer[11] + 0x5a827999, _S23);
      0|    b = crotl32(b + _g(c, d, a) + buffer[15] + 0x5a827999, _S24);
       |
       |    // Round 3 - H cycle, 16 times.
      0|    a = crotl32(a + _h(b, c, d) + buffer[0] + 0x6ed9eba1, _S31);
      0|    d = crotl32(d + _h(a, b, c) + buffer[8] + 0x6ed9eba1, _S32);
      0|    c = crotl32(c + _h(d, a, b) + buffer[4] + 0x6ed9eba1, _S33);
      0|    b = crotl32(b + _h(c, d, a) + buffer[12] + 0x6ed9eba1, _S34);
      0|    a = crotl32(a + _h(b, c, d) + buffer[2] + 0x6ed9eba1, _S31);
      0|    d = crotl32(d + _h(a, b, c) + buffer[10] + 0x6ed9eba1, _S32);
      0|    c = crotl32(c + _h(d, a, b) + buffer[6] + 0x6ed9eba1, _S33);
      0|    b = crotl32(b + _h(c, d, a) + buffer[14] + 0x6ed9eba1, _S34);
      0|    a = crotl32(a + _h(b, c, d) + buffer[1] + 0x6ed9eba1, _S31);
      0|    d = crotl32(d + _h(a, b, c) + buffer[9] + 0x6ed9eba1, _S32);
      0|    c = crotl32(c + _h(d, a, b) + buffer[5] + 0x6ed9eba1, _S33);
      0|    b = crotl32(b + _h(c, d, a) + buffer[13] + 0x6ed9eba1, _S34);
      0|    a = crotl32(a + _h(b, c, d) + buffer[3] + 0x6ed9eba1, _S31);
      0|    d = crotl32(d + _h(a, b, c) + buffer[11] + 0x6ed9eba1, _S32);
      0|    c = crotl32(c + _h(d, a, b) + buffer[7] + 0x6ed9eba1, _S33);
      0|    b = crotl32(b + _h(c, d, a) + buffer[15] + 0x6ed9eba1, _S34);
       |
      0|    state[0] = clip32(state[0] + a);
      0|    state[1] = clip32(state[1] + b);
      0|    state[2] = clip32(state[2] + c);
      0|    state[3] = clip32(state[3] + d);
       |  }
       |
       |  // round 1 left rotates
       |  static const _S11 = 3;
       |  static const _S12 = 7;
       |  static const _S13 = 11;
       |  static const _S14 = 19;
       |
       |  // round 2 left rotates
       |  static const _S21 = 3;
       |  static const _S22 = 5;
       |  static const _S23 = 9;
       |  static const _S24 = 13;
       |
       |  // round 3 left rotates
       |  static const _S31 = 3;
       |  static const _S32 = 9;
       |  static const _S33 = 11;
       |  static const _S34 = 15;
       |
       |  // F, G and H are the basic MD4 functions.
      0|  int _f(int u, int v, int w) => (u & v) | (not32(u) & w);
       |
      0|  int _g(int u, int v, int w) => (u & v) | (u & w) | (v & w);
       |
      0|  int _h(int u, int v, int w) => u ^ v ^ w;
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/md5.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.md5;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of MD5 digest
       |class MD5Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'MD5', () => MD5Digest());
       |
       |  static const _DIGEST_LENGTH = 16;
       |
      0|  MD5Digest() : super(Endian.little, 4, 16);
       |
       |  @override
       |  final algorithmName = 'MD5';
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void resetState() {
      0|    state[0] = 0x67452301;
      0|    state[1] = 0xefcdab89;
      0|    state[2] = 0x98badcfe;
      0|    state[3] = 0x10325476;
       |  }
       |
      0|  @override
       |  void processBlock() {
      0|    var a = state[0];
      0|    var b = state[1];
      0|    var c = state[2];
      0|    var d = state[3];
       |
       |    // Round 1 - F cycle, 16 times.
      0|    a = sum32(crotl32(a + _f(b, c, d) + buffer[0] + 0xd76aa478, _S11), b);
      0|    d = sum32(crotl32(d + _f(a, b, c) + buffer[1] + 0xe8c7b756, _S12), a);
      0|    c = sum32(crotl32(c + _f(d, a, b) + buffer[2] + 0x242070db, _S13), d);
      0|    b = sum32(crotl32(b + _f(c, d, a) + buffer[3] + 0xc1bdceee, _S14), c);
      0|    a = sum32(crotl32(a + _f(b, c, d) + buffer[4] + 0xf57c0faf, _S11), b);
      0|    d = sum32(crotl32(d + _f(a, b, c) + buffer[5] + 0x4787c62a, _S12), a);
      0|    c = sum32(crotl32(c + _f(d, a, b) + buffer[6] + 0xa8304613, _S13), d);
      0|    b = sum32(crotl32(b + _f(c, d, a) + buffer[7] + 0xfd469501, _S14), c);
      0|    a = sum32(crotl32(a + _f(b, c, d) + buffer[8] + 0x698098d8, _S11), b);
      0|    d = sum32(crotl32(d + _f(a, b, c) + buffer[9] + 0x8b44f7af, _S12), a);
      0|    c = sum32(crotl32(c + _f(d, a, b) + buffer[10] + 0xffff5bb1, _S13), d);
      0|    b = sum32(crotl32(b + _f(c, d, a) + buffer[11] + 0x895cd7be, _S14), c);
      0|    a = sum32(crotl32(a + _f(b, c, d) + buffer[12] + 0x6b901122, _S11), b);
      0|    d = sum32(crotl32(d + _f(a, b, c) + buffer[13] + 0xfd987193, _S12), a);
      0|    c = sum32(crotl32(c + _f(d, a, b) + buffer[14] + 0xa679438e, _S13), d);
      0|    b = sum32(crotl32(b + _f(c, d, a) + buffer[15] + 0x49b40821, _S14), c);
       |
       |    // Round 2 - G cycle, 16 time_S.
      0|    a = sum32(crotl32(a + _g(b, c, d) + buffer[1] + 0xf61e2562, _S21), b);
      0|    d = sum32(crotl32(d + _g(a, b, c) + buffer[6] + 0xc040b340, _S22), a);
      0|    c = sum32(crotl32(c + _g(d, a, b) + buffer[11] + 0x265e5a51, _S23), d);
      0|    b = sum32(crotl32(b + _g(c, d, a) + buffer[0] + 0xe9b6c7aa, _S24), c);
      0|    a = sum32(crotl32(a + _g(b, c, d) + buffer[5] + 0xd62f105d, _S21), b);
      0|    d = sum32(crotl32(d + _g(a, b, c) + buffer[10] + 0x02441453, _S22), a);
      0|    c = sum32(crotl32(c + _g(d, a, b) + buffer[15] + 0xd8a1e681, _S23), d);
      0|    b = sum32(crotl32(b + _g(c, d, a) + buffer[4] + 0xe7d3fbc8, _S24), c);
      0|    a = sum32(crotl32(a + _g(b, c, d) + buffer[9] + 0x21e1cde6, _S21), b);
      0|    d = sum32(crotl32(d + _g(a, b, c) + buffer[14] + 0xc33707d6, _S22), a);
      0|    c = sum32(crotl32(c + _g(d, a, b) + buffer[3] + 0xf4d50d87, _S23), d);
      0|    b = sum32(crotl32(b + _g(c, d, a) + buffer[8] + 0x455a14ed, _S24), c);
      0|    a = sum32(crotl32(a + _g(b, c, d) + buffer[13] + 0xa9e3e905, _S21), b);
      0|    d = sum32(crotl32(d + _g(a, b, c) + buffer[2] + 0xfcefa3f8, _S22), a);
      0|    c = sum32(crotl32(c + _g(d, a, b) + buffer[7] + 0x676f02d9, _S23), d);
      0|    b = sum32(crotl32(b + _g(c, d, a) + buffer[12] + 0x8d2a4c8a, _S24), c);
       |
       |    // Round 3 - H cycle, 16 time_S.
      0|    a = sum32(crotl32(a + _h(b, c, d) + buffer[5] + 0xfffa3942, _S31), b);
      0|    d = sum32(crotl32(d + _h(a, b, c) + buffer[8] + 0x8771f681, _S32), a);
      0|    c = sum32(crotl32(c + _h(d, a, b) + buffer[11] + 0x6d9d6122, _S33), d);
      0|    b = sum32(crotl32(b + _h(c, d, a) + buffer[14] + 0xfde5380c, _S34), c);
      0|    a = sum32(crotl32(a + _h(b, c, d) + buffer[1] + 0xa4beea44, _S31), b);
      0|    d = sum32(crotl32(d + _h(a, b, c) + buffer[4] + 0x4bdecfa9, _S32), a);
      0|    c = sum32(crotl32(c + _h(d, a, b) + buffer[7] + 0xf6bb4b60, _S33), d);
      0|    b = sum32(crotl32(b + _h(c, d, a) + buffer[10] + 0xbebfbc70, _S34), c);
      0|    a = sum32(crotl32(a + _h(b, c, d) + buffer[13] + 0x289b7ec6, _S31), b);
      0|    d = sum32(crotl32(d + _h(a, b, c) + buffer[0] + 0xeaa127fa, _S32), a);
      0|    c = sum32(crotl32(c + _h(d, a, b) + buffer[3] + 0xd4ef3085, _S33), d);
      0|    b = sum32(crotl32(b + _h(c, d, a) + buffer[6] + 0x04881d05, _S34), c);
      0|    a = sum32(crotl32(a + _h(b, c, d) + buffer[9] + 0xd9d4d039, _S31), b);
      0|    d = sum32(crotl32(d + _h(a, b, c) + buffer[12] + 0xe6db99e5, _S32), a);
      0|    c = sum32(crotl32(c + _h(d, a, b) + buffer[15] + 0x1fa27cf8, _S33), d);
      0|    b = sum32(crotl32(b + _h(c, d, a) + buffer[2] + 0xc4ac5665, _S34), c);
       |
       |    // Round 4 - K cycle, 16 time_S.
      0|    a = sum32(crotl32(a + _k(b, c, d) + buffer[0] + 0xf4292244, _S41), b);
      0|    d = sum32(crotl32(d + _k(a, b, c) + buffer[7] + 0x432aff97, _S42), a);
      0|    c = sum32(crotl32(c + _k(d, a, b) + buffer[14] + 0xab9423a7, _S43), d);
      0|    b = sum32(crotl32(b + _k(c, d, a) + buffer[5] + 0xfc93a039, _S44), c);
      0|    a = sum32(crotl32(a + _k(b, c, d) + buffer[12] + 0x655b59c3, _S41), b);
      0|    d = sum32(crotl32(d + _k(a, b, c) + buffer[3] + 0x8f0ccc92, _S42), a);
      0|    c = sum32(crotl32(c + _k(d, a, b) + buffer[10] + 0xffeff47d, _S43), d);
      0|    b = sum32(crotl32(b + _k(c, d, a) + buffer[1] + 0x85845dd1, _S44), c);
      0|    a = sum32(crotl32(a + _k(b, c, d) + buffer[8] + 0x6fa87e4f, _S41), b);
      0|    d = sum32(crotl32(d + _k(a, b, c) + buffer[15] + 0xfe2ce6e0, _S42), a);
      0|    c = sum32(crotl32(c + _k(d, a, b) + buffer[6] + 0xa3014314, _S43), d);
      0|    b = sum32(crotl32(b + _k(c, d, a) + buffer[13] + 0x4e0811a1, _S44), c);
      0|    a = sum32(crotl32(a + _k(b, c, d) + buffer[4] + 0xf7537e82, _S41), b);
      0|    d = sum32(crotl32(d + _k(a, b, c) + buffer[11] + 0xbd3af235, _S42), a);
      0|    c = sum32(crotl32(c + _k(d, a, b) + buffer[2] + 0x2ad7d2bb, _S43), d);
      0|    b = sum32(crotl32(b + _k(c, d, a) + buffer[9] + 0xeb86d391, _S44), c);
       |
      0|    state[0] = clip32(state[0] + a);
      0|    state[1] = clip32(state[1] + b);
      0|    state[2] = clip32(state[2] + c);
      0|    state[3] = clip32(state[3] + d);
       |  }
       |
       |  // round 1 left rotates
       |  static const _S11 = 7;
       |  static const _S12 = 12;
       |  static const _S13 = 17;
       |  static const _S14 = 22;
       |
       |  // round 2 left rotates
       |  static const _S21 = 5;
       |  static const _S22 = 9;
       |  static const _S23 = 14;
       |  static const _S24 = 20;
       |
       |  // round 3 left rotates
       |  static const _S31 = 4;
       |  static const _S32 = 11;
       |  static const _S33 = 16;
       |  static const _S34 = 23;
       |
       |  // round 4 left rotates
       |  static const _S41 = 6;
       |  static const _S42 = 10;
       |  static const _S43 = 15;
       |  static const _S44 = 21;
       |
      0|  int _f(int u, int v, int w) => (u & v) | (not32(u) & w);
       |
      0|  int _g(int u, int v, int w) => (u & w) | (v & not32(w));
       |
      0|  int _h(int u, int v, int w) => u ^ v ^ w;
       |
      0|  int _k(int u, int v, int w) => v ^ (u | not32(w));
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/ripemd128.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.ripemd128;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of RIPEMD-128 digest
       |class RIPEMD128Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'RIPEMD-128', () => RIPEMD128Digest());
       |
       |  static const _DIGEST_LENGTH = 16;
       |
      0|  RIPEMD128Digest() : super(Endian.little, 4, 16);
       |
       |  @override
       |  final algorithmName = 'RIPEMD-128';
       |
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void resetState() {
      0|    state[0] = 0x67452301;
      0|    state[1] = 0xefcdab89;
      0|    state[2] = 0x98badcfe;
      0|    state[3] = 0x10325476;
       |  }
       |
      0|  @override
       |  void processBlock() {
       |    int a, aa;
       |    int b, bb;
       |    int c, cc;
       |    int d, dd;
       |
      0|    a = aa = state[0];
      0|    b = bb = state[1];
      0|    c = cc = state[2];
      0|    d = dd = state[3];
       |
       |    // Round 1
      0|    a = _f1(a, b, c, d, buffer[0], 11);
      0|    d = _f1(d, a, b, c, buffer[1], 14);
      0|    c = _f1(c, d, a, b, buffer[2], 15);
      0|    b = _f1(b, c, d, a, buffer[3], 12);
      0|    a = _f1(a, b, c, d, buffer[4], 5);
      0|    d = _f1(d, a, b, c, buffer[5], 8);
      0|    c = _f1(c, d, a, b, buffer[6], 7);
      0|    b = _f1(b, c, d, a, buffer[7], 9);
      0|    a = _f1(a, b, c, d, buffer[8], 11);
      0|    d = _f1(d, a, b, c, buffer[9], 13);
      0|    c = _f1(c, d, a, b, buffer[10], 14);
      0|    b = _f1(b, c, d, a, buffer[11], 15);
      0|    a = _f1(a, b, c, d, buffer[12], 6);
      0|    d = _f1(d, a, b, c, buffer[13], 7);
      0|    c = _f1(c, d, a, b, buffer[14], 9);
      0|    b = _f1(b, c, d, a, buffer[15], 8);
       |
       |    // Round 2
      0|    a = _f2(a, b, c, d, buffer[7], 7);
      0|    d = _f2(d, a, b, c, buffer[4], 6);
      0|    c = _f2(c, d, a, b, buffer[13], 8);
      0|    b = _f2(b, c, d, a, buffer[1], 13);
      0|    a = _f2(a, b, c, d, buffer[10], 11);
      0|    d = _f2(d, a, b, c, buffer[6], 9);
      0|    c = _f2(c, d, a, b, buffer[15], 7);
      0|    b = _f2(b, c, d, a, buffer[3], 15);
      0|    a = _f2(a, b, c, d, buffer[12], 7);
      0|    d = _f2(d, a, b, c, buffer[0], 12);
      0|    c = _f2(c, d, a, b, buffer[9], 15);
      0|    b = _f2(b, c, d, a, buffer[5], 9);
      0|    a = _f2(a, b, c, d, buffer[2], 11);
      0|    d = _f2(d, a, b, c, buffer[14], 7);
      0|    c = _f2(c, d, a, b, buffer[11], 13);
      0|    b = _f2(b, c, d, a, buffer[8], 12);
       |
       |    // Round 3
      0|    a = _f3(a, b, c, d, buffer[3], 11);
      0|    d = _f3(d, a, b, c, buffer[10], 13);
      0|    c = _f3(c, d, a, b, buffer[14], 6);
      0|    b = _f3(b, c, d, a, buffer[4], 7);
      0|    a = _f3(a, b, c, d, buffer[9], 14);
      0|    d = _f3(d, a, b, c, buffer[15], 9);
      0|    c = _f3(c, d, a, b, buffer[8], 13);
      0|    b = _f3(b, c, d, a, buffer[1], 15);
      0|    a = _f3(a, b, c, d, buffer[2], 14);
      0|    d = _f3(d, a, b, c, buffer[7], 8);
      0|    c = _f3(c, d, a, b, buffer[0], 13);
      0|    b = _f3(b, c, d, a, buffer[6], 6);
      0|    a = _f3(a, b, c, d, buffer[13], 5);
      0|    d = _f3(d, a, b, c, buffer[11], 12);
      0|    c = _f3(c, d, a, b, buffer[5], 7);
      0|    b = _f3(b, c, d, a, buffer[12], 5);
       |
       |    // Round 4
      0|    a = _f4(a, b, c, d, buffer[1], 11);
      0|    d = _f4(d, a, b, c, buffer[9], 12);
      0|    c = _f4(c, d, a, b, buffer[11], 14);
      0|    b = _f4(b, c, d, a, buffer[10], 15);
      0|    a = _f4(a, b, c, d, buffer[0], 14);
      0|    d = _f4(d, a, b, c, buffer[8], 15);
      0|    c = _f4(c, d, a, b, buffer[12], 9);
      0|    b = _f4(b, c, d, a, buffer[4], 8);
      0|    a = _f4(a, b, c, d, buffer[13], 9);
      0|    d = _f4(d, a, b, c, buffer[3], 14);
      0|    c = _f4(c, d, a, b, buffer[7], 5);
      0|    b = _f4(b, c, d, a, buffer[15], 6);
      0|    a = _f4(a, b, c, d, buffer[14], 8);
      0|    d = _f4(d, a, b, c, buffer[5], 6);
      0|    c = _f4(c, d, a, b, buffer[6], 5);
      0|    b = _f4(b, c, d, a, buffer[2], 12);
       |
       |    // Parallel round 1
      0|    aa = _ff4(aa, bb, cc, dd, buffer[5], 8);
      0|    dd = _ff4(dd, aa, bb, cc, buffer[14], 9);
      0|    cc = _ff4(cc, dd, aa, bb, buffer[7], 9);
      0|    bb = _ff4(bb, cc, dd, aa, buffer[0], 11);
      0|    aa = _ff4(aa, bb, cc, dd, buffer[9], 13);
      0|    dd = _ff4(dd, aa, bb, cc, buffer[2], 15);
      0|    cc = _ff4(cc, dd, aa, bb, buffer[11], 15);
      0|    bb = _ff4(bb, cc, dd, aa, buffer[4], 5);
      0|    aa = _ff4(aa, bb, cc, dd, buffer[13], 7);
      0|    dd = _ff4(dd, aa, bb, cc, buffer[6], 7);
      0|    cc = _ff4(cc, dd, aa, bb, buffer[15], 8);
      0|    bb = _ff4(bb, cc, dd, aa, buffer[8], 11);
      0|    aa = _ff4(aa, bb, cc, dd, buffer[1], 14);
      0|    dd = _ff4(dd, aa, bb, cc, buffer[10], 14);
      0|    cc = _ff4(cc, dd, aa, bb, buffer[3], 12);
      0|    bb = _ff4(bb, cc, dd, aa, buffer[12], 6);
       |
       |    // Parallel round 2
      0|    aa = _ff3(aa, bb, cc, dd, buffer[6], 9);
      0|    dd = _ff3(dd, aa, bb, cc, buffer[11], 13);
      0|    cc = _ff3(cc, dd, aa, bb, buffer[3], 15);
      0|    bb = _ff3(bb, cc, dd, aa, buffer[7], 7);
      0|    aa = _ff3(aa, bb, cc, dd, buffer[0], 12);
      0|    dd = _ff3(dd, aa, bb, cc, buffer[13], 8);
      0|    cc = _ff3(cc, dd, aa, bb, buffer[5], 9);
      0|    bb = _ff3(bb, cc, dd, aa, buffer[10], 11);
      0|    aa = _ff3(aa, bb, cc, dd, buffer[14], 7);
      0|    dd = _ff3(dd, aa, bb, cc, buffer[15], 7);
      0|    cc = _ff3(cc, dd, aa, bb, buffer[8], 12);
      0|    bb = _ff3(bb, cc, dd, aa, buffer[12], 7);
      0|    aa = _ff3(aa, bb, cc, dd, buffer[4], 6);
      0|    dd = _ff3(dd, aa, bb, cc, buffer[9], 15);
      0|    cc = _ff3(cc, dd, aa, bb, buffer[1], 13);
      0|    bb = _ff3(bb, cc, dd, aa, buffer[2], 11);
       |
       |    // Parallel round 3
      0|    aa = _ff2(aa, bb, cc, dd, buffer[15], 9);
      0|    dd = _ff2(dd, aa, bb, cc, buffer[5], 7);
      0|    cc = _ff2(cc, dd, aa, bb, buffer[1], 15);
      0|    bb = _ff2(bb, cc, dd, aa, buffer[3], 11);
      0|    aa = _ff2(aa, bb, cc, dd, buffer[7], 8);
      0|    dd = _ff2(dd, aa, bb, cc, buffer[14], 6);
      0|    cc = _ff2(cc, dd, aa, bb, buffer[6], 6);
      0|    bb = _ff2(bb, cc, dd, aa, buffer[9], 14);
      0|    aa = _ff2(aa, bb, cc, dd, buffer[11], 12);
      0|    dd = _ff2(dd, aa, bb, cc, buffer[8], 13);
      0|    cc = _ff2(cc, dd, aa, bb, buffer[12], 5);
      0|    bb = _ff2(bb, cc, dd, aa, buffer[2], 14);
      0|    aa = _ff2(aa, bb, cc, dd, buffer[10], 13);
      0|    dd = _ff2(dd, aa, bb, cc, buffer[0], 13);
      0|    cc = _ff2(cc, dd, aa, bb, buffer[4], 7);
      0|    bb = _ff2(bb, cc, dd, aa, buffer[13], 5);
       |
       |    // Parallel round 4
      0|    aa = _ff1(aa, bb, cc, dd, buffer[8], 15);
      0|    dd = _ff1(dd, aa, bb, cc, buffer[6], 5);
      0|    cc = _ff1(cc, dd, aa, bb, buffer[4], 8);
      0|    bb = _ff1(bb, cc, dd, aa, buffer[1], 11);
      0|    aa = _ff1(aa, bb, cc, dd, buffer[3], 14);
      0|    dd = _ff1(dd, aa, bb, cc, buffer[11], 14);
      0|    cc = _ff1(cc, dd, aa, bb, buffer[15], 6);
      0|    bb = _ff1(bb, cc, dd, aa, buffer[0], 14);
      0|    aa = _ff1(aa, bb, cc, dd, buffer[5], 6);
      0|    dd = _ff1(dd, aa, bb, cc, buffer[12], 9);
      0|    cc = _ff1(cc, dd, aa, bb, buffer[2], 12);
      0|    bb = _ff1(bb, cc, dd, aa, buffer[13], 9);
      0|    aa = _ff1(aa, bb, cc, dd, buffer[9], 12);
      0|    dd = _ff1(dd, aa, bb, cc, buffer[7], 5);
      0|    cc = _ff1(cc, dd, aa, bb, buffer[10], 15);
      0|    bb = _ff1(bb, cc, dd, aa, buffer[14], 8);
       |
      0|    dd = clip32(dd + c + state[1]);
      0|    state[1] = clip32(state[2] + d + aa);
      0|    state[2] = clip32(state[3] + a + bb);
      0|    state[3] = clip32(state[0] + b + cc);
      0|    state[0] = dd;
       |  }
       |
      0|  int _function1(int x, int y, int z) => x ^ y ^ z;
       |
      0|  int _function2(int x, int y, int z) => (x & y) | (~x & z);
       |
      0|  int _function3(int x, int y, int z) => (x | ~y) ^ z;
       |
      0|  int _function4(int x, int y, int z) => (x & z) | (y & ~z);
       |
      0|  int _f1(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function1(b, c, d) + x, s);
       |
      0|  int _f2(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function2(b, c, d) + x + 0x5a827999, s);
       |
      0|  int _f3(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function3(b, c, d) + x + 0x6ed9eba1, s);
       |
      0|  int _f4(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function4(b, c, d) + x + 0x8f1bbcdc, s);
       |
      0|  int _ff1(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function1(b, c, d) + x, s);
       |
      0|  int _ff2(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function2(b, c, d) + x + 0x6d703ef3, s);
       |
      0|  int _ff3(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function3(b, c, d) + x + 0x5c4dd124, s);
       |
      0|  int _ff4(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function4(b, c, d) + x + 0x50a28be6, s);
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/ripemd160.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.ripemd160;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of RIPEMD-160 digest.
       |class RIPEMD160Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'RIPEMD-160', () => RIPEMD160Digest());
       |
       |  static const _DIGEST_LENGTH = 20;
       |
      0|  RIPEMD160Digest() : super(Endian.little, 5, 16);
       |
       |  @override
       |  final algorithmName = 'RIPEMD-160';
       |
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void resetState() {
      0|    state[0] = 0x67452301;
      0|    state[1] = 0xefcdab89;
      0|    state[2] = 0x98badcfe;
      0|    state[3] = 0x10325476;
      0|    state[4] = 0xc3d2e1f0;
       |  }
       |
      0|  @override
       |  void processBlock() {
       |    int a, aa;
       |    int b, bb;
       |    int c, cc;
       |    int d, dd;
       |    int e, ee;
       |
      0|    a = aa = state[0];
      0|    b = bb = state[1];
      0|    c = cc = state[2];
      0|    d = dd = state[3];
      0|    e = ee = state[4];
       |
       |    // Rounds 1 - 16
       |    // left
      0|    a = sum32(crotl32(a + _f1(b, c, d) + buffer[0], 11), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f1(a, b, c) + buffer[1], 14), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f1(e, a, b) + buffer[2], 15), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f1(d, e, a) + buffer[3], 12), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f1(c, d, e) + buffer[4], 5), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f1(b, c, d) + buffer[5], 8), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f1(a, b, c) + buffer[6], 7), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f1(e, a, b) + buffer[7], 9), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f1(d, e, a) + buffer[8], 11), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f1(c, d, e) + buffer[9], 13), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f1(b, c, d) + buffer[10], 14), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f1(a, b, c) + buffer[11], 15), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f1(e, a, b) + buffer[12], 6), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f1(d, e, a) + buffer[13], 7), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f1(c, d, e) + buffer[14], 9), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f1(b, c, d) + buffer[15], 8), e);
      0|    c = rotl32(c, 10);
       |
       |    // right
      0|    aa = sum32(crotl32(aa + _f5(bb, cc, dd) + buffer[5] + 0x50a28be6, 8), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f5(aa, bb, cc) + buffer[14] + 0x50a28be6, 9), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f5(ee, aa, bb) + buffer[7] + 0x50a28be6, 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f5(dd, ee, aa) + buffer[0] + 0x50a28be6, 11), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f5(cc, dd, ee) + buffer[9] + 0x50a28be6, 13), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f5(bb, cc, dd) + buffer[2] + 0x50a28be6, 15), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f5(aa, bb, cc) + buffer[11] + 0x50a28be6, 15), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f5(ee, aa, bb) + buffer[4] + 0x50a28be6, 5), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f5(dd, ee, aa) + buffer[13] + 0x50a28be6, 7), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f5(cc, dd, ee) + buffer[6] + 0x50a28be6, 7), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f5(bb, cc, dd) + buffer[15] + 0x50a28be6, 8), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f5(aa, bb, cc) + buffer[8] + 0x50a28be6, 11), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f5(ee, aa, bb) + buffer[1] + 0x50a28be6, 14), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f5(dd, ee, aa) + buffer[10] + 0x50a28be6, 14), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f5(cc, dd, ee) + buffer[3] + 0x50a28be6, 12), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f5(bb, cc, dd) + buffer[12] + 0x50a28be6, 6), ee);
      0|    cc = rotl32(cc, 10);
       |
       |    // Rounds 16-31
       |    // left
      0|    e = sum32(crotl32(e + _f2(a, b, c) + buffer[7] + 0x5a827999, 7), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f2(e, a, b) + buffer[4] + 0x5a827999, 6), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f2(d, e, a) + buffer[13] + 0x5a827999, 8), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f2(c, d, e) + buffer[1] + 0x5a827999, 13), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f2(b, c, d) + buffer[10] + 0x5a827999, 11), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f2(a, b, c) + buffer[6] + 0x5a827999, 9), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f2(e, a, b) + buffer[15] + 0x5a827999, 7), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f2(d, e, a) + buffer[3] + 0x5a827999, 15), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f2(c, d, e) + buffer[12] + 0x5a827999, 7), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f2(b, c, d) + buffer[0] + 0x5a827999, 12), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f2(a, b, c) + buffer[9] + 0x5a827999, 15), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f2(e, a, b) + buffer[5] + 0x5a827999, 9), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f2(d, e, a) + buffer[2] + 0x5a827999, 11), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f2(c, d, e) + buffer[14] + 0x5a827999, 7), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f2(b, c, d) + buffer[11] + 0x5a827999, 13), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f2(a, b, c) + buffer[8] + 0x5a827999, 12), d);
      0|    b = rotl32(b, 10);
       |
       |    // right
      0|    ee = sum32(crotl32(ee + _f4(aa, bb, cc) + buffer[6] + 0x5c4dd124, 9), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f4(ee, aa, bb) + buffer[11] + 0x5c4dd124, 13), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f4(dd, ee, aa) + buffer[3] + 0x5c4dd124, 15), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f4(cc, dd, ee) + buffer[7] + 0x5c4dd124, 7), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f4(bb, cc, dd) + buffer[0] + 0x5c4dd124, 12), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f4(aa, bb, cc) + buffer[13] + 0x5c4dd124, 8), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f4(ee, aa, bb) + buffer[5] + 0x5c4dd124, 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f4(dd, ee, aa) + buffer[10] + 0x5c4dd124, 11), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f4(cc, dd, ee) + buffer[14] + 0x5c4dd124, 7), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f4(bb, cc, dd) + buffer[15] + 0x5c4dd124, 7), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f4(aa, bb, cc) + buffer[8] + 0x5c4dd124, 12), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f4(ee, aa, bb) + buffer[12] + 0x5c4dd124, 7), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f4(dd, ee, aa) + buffer[4] + 0x5c4dd124, 6), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f4(cc, dd, ee) + buffer[9] + 0x5c4dd124, 15), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f4(bb, cc, dd) + buffer[1] + 0x5c4dd124, 13), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f4(aa, bb, cc) + buffer[2] + 0x5c4dd124, 11), dd);
      0|    bb = rotl32(bb, 10);
       |
       |    // Rounds 32-47
       |    // left
      0|    d = sum32(crotl32(d + _f3(e, a, b) + buffer[3] + 0x6ed9eba1, 11), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f3(d, e, a) + buffer[10] + 0x6ed9eba1, 13), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f3(c, d, e) + buffer[14] + 0x6ed9eba1, 6), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f3(b, c, d) + buffer[4] + 0x6ed9eba1, 7), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f3(a, b, c) + buffer[9] + 0x6ed9eba1, 14), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f3(e, a, b) + buffer[15] + 0x6ed9eba1, 9), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f3(d, e, a) + buffer[8] + 0x6ed9eba1, 13), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f3(c, d, e) + buffer[1] + 0x6ed9eba1, 15), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f3(b, c, d) + buffer[2] + 0x6ed9eba1, 14), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f3(a, b, c) + buffer[7] + 0x6ed9eba1, 8), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f3(e, a, b) + buffer[0] + 0x6ed9eba1, 13), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f3(d, e, a) + buffer[6] + 0x6ed9eba1, 6), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f3(c, d, e) + buffer[13] + 0x6ed9eba1, 5), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f3(b, c, d) + buffer[11] + 0x6ed9eba1, 12), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f3(a, b, c) + buffer[5] + 0x6ed9eba1, 7), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f3(e, a, b) + buffer[12] + 0x6ed9eba1, 5), c);
      0|    a = rotl32(a, 10);
       |
       |    // right
      0|    dd = sum32(crotl32(dd + _f3(ee, aa, bb) + buffer[15] + 0x6d703ef3, 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f3(dd, ee, aa) + buffer[5] + 0x6d703ef3, 7), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f3(cc, dd, ee) + buffer[1] + 0x6d703ef3, 15), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f3(bb, cc, dd) + buffer[3] + 0x6d703ef3, 11), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f3(aa, bb, cc) + buffer[7] + 0x6d703ef3, 8), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f3(ee, aa, bb) + buffer[14] + 0x6d703ef3, 6), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f3(dd, ee, aa) + buffer[6] + 0x6d703ef3, 6), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f3(cc, dd, ee) + buffer[9] + 0x6d703ef3, 14), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f3(bb, cc, dd) + buffer[11] + 0x6d703ef3, 12), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f3(aa, bb, cc) + buffer[8] + 0x6d703ef3, 13), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f3(ee, aa, bb) + buffer[12] + 0x6d703ef3, 5), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f3(dd, ee, aa) + buffer[2] + 0x6d703ef3, 14), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f3(cc, dd, ee) + buffer[10] + 0x6d703ef3, 13), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f3(bb, cc, dd) + buffer[0] + 0x6d703ef3, 13), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f3(aa, bb, cc) + buffer[4] + 0x6d703ef3, 7), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f3(ee, aa, bb) + buffer[13] + 0x6d703ef3, 5), cc);
      0|    aa = rotl32(aa, 10);
       |
       |    // Rounds 48-63
       |    // left
      0|    c = sum32(crotl32(c + _f4(d, e, a) + buffer[1] + 0x8f1bbcdc, 11), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f4(c, d, e) + buffer[9] + 0x8f1bbcdc, 12), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f4(b, c, d) + buffer[11] + 0x8f1bbcdc, 14), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f4(a, b, c) + buffer[10] + 0x8f1bbcdc, 15), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f4(e, a, b) + buffer[0] + 0x8f1bbcdc, 14), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f4(d, e, a) + buffer[8] + 0x8f1bbcdc, 15), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f4(c, d, e) + buffer[12] + 0x8f1bbcdc, 9), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f4(b, c, d) + buffer[4] + 0x8f1bbcdc, 8), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f4(a, b, c) + buffer[13] + 0x8f1bbcdc, 9), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f4(e, a, b) + buffer[3] + 0x8f1bbcdc, 14), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f4(d, e, a) + buffer[7] + 0x8f1bbcdc, 5), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f4(c, d, e) + buffer[15] + 0x8f1bbcdc, 6), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f4(b, c, d) + buffer[14] + 0x8f1bbcdc, 8), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f4(a, b, c) + buffer[5] + 0x8f1bbcdc, 6), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f4(e, a, b) + buffer[6] + 0x8f1bbcdc, 5), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f4(d, e, a) + buffer[2] + 0x8f1bbcdc, 12), b);
      0|    e = rotl32(e, 10);
       |
       |    // right
      0|    cc = sum32(crotl32(cc + _f2(dd, ee, aa) + buffer[8] + 0x7a6d76e9, 15), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f2(cc, dd, ee) + buffer[6] + 0x7a6d76e9, 5), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f2(bb, cc, dd) + buffer[4] + 0x7a6d76e9, 8), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f2(aa, bb, cc) + buffer[1] + 0x7a6d76e9, 11), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f2(ee, aa, bb) + buffer[3] + 0x7a6d76e9, 14), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f2(dd, ee, aa) + buffer[11] + 0x7a6d76e9, 14), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f2(cc, dd, ee) + buffer[15] + 0x7a6d76e9, 6), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f2(bb, cc, dd) + buffer[0] + 0x7a6d76e9, 14), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f2(aa, bb, cc) + buffer[5] + 0x7a6d76e9, 6), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f2(ee, aa, bb) + buffer[12] + 0x7a6d76e9, 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f2(dd, ee, aa) + buffer[2] + 0x7a6d76e9, 12), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f2(cc, dd, ee) + buffer[13] + 0x7a6d76e9, 9), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f2(bb, cc, dd) + buffer[9] + 0x7a6d76e9, 12), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f2(aa, bb, cc) + buffer[7] + 0x7a6d76e9, 5), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f2(ee, aa, bb) + buffer[10] + 0x7a6d76e9, 15), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f2(dd, ee, aa) + buffer[14] + 0x7a6d76e9, 8), bb);
      0|    ee = rotl32(ee, 10);
       |
       |    // Rounds 64-79
       |    // left
      0|    b = sum32(crotl32(b + _f5(c, d, e) + buffer[4] + 0xa953fd4e, 9), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f5(b, c, d) + buffer[0] + 0xa953fd4e, 15), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f5(a, b, c) + buffer[5] + 0xa953fd4e, 5), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f5(e, a, b) + buffer[9] + 0xa953fd4e, 11), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f5(d, e, a) + buffer[7] + 0xa953fd4e, 6), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f5(c, d, e) + buffer[12] + 0xa953fd4e, 8), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f5(b, c, d) + buffer[2] + 0xa953fd4e, 13), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f5(a, b, c) + buffer[10] + 0xa953fd4e, 12), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f5(e, a, b) + buffer[14] + 0xa953fd4e, 5), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f5(d, e, a) + buffer[1] + 0xa953fd4e, 12), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f5(c, d, e) + buffer[3] + 0xa953fd4e, 13), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f5(b, c, d) + buffer[8] + 0xa953fd4e, 14), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f5(a, b, c) + buffer[11] + 0xa953fd4e, 11), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f5(e, a, b) + buffer[6] + 0xa953fd4e, 8), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f5(d, e, a) + buffer[15] + 0xa953fd4e, 5), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f5(c, d, e) + buffer[13] + 0xa953fd4e, 6), a);
      0|    d = rotl32(d, 10);
       |
       |    // right
      0|    bb = sum32(crotl32(bb + _f1(cc, dd, ee) + buffer[12], 8), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f1(bb, cc, dd) + buffer[15], 5), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f1(aa, bb, cc) + buffer[10], 12), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f1(ee, aa, bb) + buffer[4], 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f1(dd, ee, aa) + buffer[1], 12), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f1(cc, dd, ee) + buffer[5], 5), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f1(bb, cc, dd) + buffer[8], 14), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f1(aa, bb, cc) + buffer[7], 6), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f1(ee, aa, bb) + buffer[6], 8), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f1(dd, ee, aa) + buffer[2], 13), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f1(cc, dd, ee) + buffer[13], 6), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f1(bb, cc, dd) + buffer[14], 5), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f1(aa, bb, cc) + buffer[0], 15), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f1(ee, aa, bb) + buffer[3], 13), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f1(dd, ee, aa) + buffer[9], 11), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f1(cc, dd, ee) + buffer[11], 11), aa);
      0|    dd = rotl32(dd, 10);
       |
      0|    dd = clip32(dd + c + state[1]);
      0|    state[1] = clip32(state[2] + d + ee);
      0|    state[2] = clip32(state[3] + e + aa);
      0|    state[3] = clip32(state[4] + a + bb);
      0|    state[4] = clip32(state[0] + b + cc);
      0|    state[0] = dd;
       |  }
       |
      0|  int _f1(int x, int y, int z) => x ^ y ^ z;
       |
      0|  int _f2(int x, int y, int z) => (x & y) | (~x & z);
       |
      0|  int _f3(int x, int y, int z) => (x | ~y) ^ z;
       |
      0|  int _f4(int x, int y, int z) => (x & z) | (y & ~z);
       |
      0|  int _f5(int x, int y, int z) => x ^ (y | ~z);
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/ripemd256.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.ripemd256;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of RIPEMD-256 digest.
       |class RIPEMD256Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'RIPEMD-256', () => RIPEMD256Digest());
       |
       |  static const _DIGEST_LENGTH = 32;
       |
      0|  RIPEMD256Digest() : super(Endian.little, 8, 16);
       |
       |  @override
       |  final algorithmName = 'RIPEMD-256';
       |
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void resetState() {
      0|    state[0] = 0x67452301;
      0|    state[1] = 0xefcdab89;
      0|    state[2] = 0x98badcfe;
      0|    state[3] = 0x10325476;
      0|    state[4] = 0x76543210;
      0|    state[5] = 0xFEDCBA98;
      0|    state[6] = 0x89ABCDEF;
      0|    state[7] = 0x01234567;
       |  }
       |
      0|  @override
       |  void processBlock() {
       |    int a, aa;
       |    int b, bb;
       |    int c, cc;
       |    int d, dd;
       |    int t;
       |
      0|    a = state[0];
      0|    b = state[1];
      0|    c = state[2];
      0|    d = state[3];
      0|    aa = state[4];
      0|    bb = state[5];
      0|    cc = state[6];
      0|    dd = state[7];
       |
       |    // Round 1
      0|    a = _f1(a, b, c, d, buffer[0], 11);
      0|    d = _f1(d, a, b, c, buffer[1], 14);
      0|    c = _f1(c, d, a, b, buffer[2], 15);
      0|    b = _f1(b, c, d, a, buffer[3], 12);
      0|    a = _f1(a, b, c, d, buffer[4], 5);
      0|    d = _f1(d, a, b, c, buffer[5], 8);
      0|    c = _f1(c, d, a, b, buffer[6], 7);
      0|    b = _f1(b, c, d, a, buffer[7], 9);
      0|    a = _f1(a, b, c, d, buffer[8], 11);
      0|    d = _f1(d, a, b, c, buffer[9], 13);
      0|    c = _f1(c, d, a, b, buffer[10], 14);
      0|    b = _f1(b, c, d, a, buffer[11], 15);
      0|    a = _f1(a, b, c, d, buffer[12], 6);
      0|    d = _f1(d, a, b, c, buffer[13], 7);
      0|    c = _f1(c, d, a, b, buffer[14], 9);
      0|    b = _f1(b, c, d, a, buffer[15], 8);
       |
      0|    aa = _ff4(aa, bb, cc, dd, buffer[5], 8);
      0|    dd = _ff4(dd, aa, bb, cc, buffer[14], 9);
      0|    cc = _ff4(cc, dd, aa, bb, buffer[7], 9);
      0|    bb = _ff4(bb, cc, dd, aa, buffer[0], 11);
      0|    aa = _ff4(aa, bb, cc, dd, buffer[9], 13);
      0|    dd = _ff4(dd, aa, bb, cc, buffer[2], 15);
      0|    cc = _ff4(cc, dd, aa, bb, buffer[11], 15);
      0|    bb = _ff4(bb, cc, dd, aa, buffer[4], 5);
      0|    aa = _ff4(aa, bb, cc, dd, buffer[13], 7);
      0|    dd = _ff4(dd, aa, bb, cc, buffer[6], 7);
      0|    cc = _ff4(cc, dd, aa, bb, buffer[15], 8);
      0|    bb = _ff4(bb, cc, dd, aa, buffer[8], 11);
      0|    aa = _ff4(aa, bb, cc, dd, buffer[1], 14);
      0|    dd = _ff4(dd, aa, bb, cc, buffer[10], 14);
      0|    cc = _ff4(cc, dd, aa, bb, buffer[3], 12);
      0|    bb = _ff4(bb, cc, dd, aa, buffer[12], 6);
       |
       |    t = a;
       |    a = aa;
       |    aa = t;
       |
       |    // Round 2
      0|    a = _f2(a, b, c, d, buffer[7], 7);
      0|    d = _f2(d, a, b, c, buffer[4], 6);
      0|    c = _f2(c, d, a, b, buffer[13], 8);
      0|    b = _f2(b, c, d, a, buffer[1], 13);
      0|    a = _f2(a, b, c, d, buffer[10], 11);
      0|    d = _f2(d, a, b, c, buffer[6], 9);
      0|    c = _f2(c, d, a, b, buffer[15], 7);
      0|    b = _f2(b, c, d, a, buffer[3], 15);
      0|    a = _f2(a, b, c, d, buffer[12], 7);
      0|    d = _f2(d, a, b, c, buffer[0], 12);
      0|    c = _f2(c, d, a, b, buffer[9], 15);
      0|    b = _f2(b, c, d, a, buffer[5], 9);
      0|    a = _f2(a, b, c, d, buffer[2], 11);
      0|    d = _f2(d, a, b, c, buffer[14], 7);
      0|    c = _f2(c, d, a, b, buffer[11], 13);
      0|    b = _f2(b, c, d, a, buffer[8], 12);
       |
      0|    aa = _ff3(aa, bb, cc, dd, buffer[6], 9);
      0|    dd = _ff3(dd, aa, bb, cc, buffer[11], 13);
      0|    cc = _ff3(cc, dd, aa, bb, buffer[3], 15);
      0|    bb = _ff3(bb, cc, dd, aa, buffer[7], 7);
      0|    aa = _ff3(aa, bb, cc, dd, buffer[0], 12);
      0|    dd = _ff3(dd, aa, bb, cc, buffer[13], 8);
      0|    cc = _ff3(cc, dd, aa, bb, buffer[5], 9);
      0|    bb = _ff3(bb, cc, dd, aa, buffer[10], 11);
      0|    aa = _ff3(aa, bb, cc, dd, buffer[14], 7);
      0|    dd = _ff3(dd, aa, bb, cc, buffer[15], 7);
      0|    cc = _ff3(cc, dd, aa, bb, buffer[8], 12);
      0|    bb = _ff3(bb, cc, dd, aa, buffer[12], 7);
      0|    aa = _ff3(aa, bb, cc, dd, buffer[4], 6);
      0|    dd = _ff3(dd, aa, bb, cc, buffer[9], 15);
      0|    cc = _ff3(cc, dd, aa, bb, buffer[1], 13);
      0|    bb = _ff3(bb, cc, dd, aa, buffer[2], 11);
       |
       |    t = b;
       |    b = bb;
       |    bb = t;
       |
       |    // Round 3
      0|    a = _f3(a, b, c, d, buffer[3], 11);
      0|    d = _f3(d, a, b, c, buffer[10], 13);
      0|    c = _f3(c, d, a, b, buffer[14], 6);
      0|    b = _f3(b, c, d, a, buffer[4], 7);
      0|    a = _f3(a, b, c, d, buffer[9], 14);
      0|    d = _f3(d, a, b, c, buffer[15], 9);
      0|    c = _f3(c, d, a, b, buffer[8], 13);
      0|    b = _f3(b, c, d, a, buffer[1], 15);
      0|    a = _f3(a, b, c, d, buffer[2], 14);
      0|    d = _f3(d, a, b, c, buffer[7], 8);
      0|    c = _f3(c, d, a, b, buffer[0], 13);
      0|    b = _f3(b, c, d, a, buffer[6], 6);
      0|    a = _f3(a, b, c, d, buffer[13], 5);
      0|    d = _f3(d, a, b, c, buffer[11], 12);
      0|    c = _f3(c, d, a, b, buffer[5], 7);
      0|    b = _f3(b, c, d, a, buffer[12], 5);
       |
      0|    aa = _ff2(aa, bb, cc, dd, buffer[15], 9);
      0|    dd = _ff2(dd, aa, bb, cc, buffer[5], 7);
      0|    cc = _ff2(cc, dd, aa, bb, buffer[1], 15);
      0|    bb = _ff2(bb, cc, dd, aa, buffer[3], 11);
      0|    aa = _ff2(aa, bb, cc, dd, buffer[7], 8);
      0|    dd = _ff2(dd, aa, bb, cc, buffer[14], 6);
      0|    cc = _ff2(cc, dd, aa, bb, buffer[6], 6);
      0|    bb = _ff2(bb, cc, dd, aa, buffer[9], 14);
      0|    aa = _ff2(aa, bb, cc, dd, buffer[11], 12);
      0|    dd = _ff2(dd, aa, bb, cc, buffer[8], 13);
      0|    cc = _ff2(cc, dd, aa, bb, buffer[12], 5);
      0|    bb = _ff2(bb, cc, dd, aa, buffer[2], 14);
      0|    aa = _ff2(aa, bb, cc, dd, buffer[10], 13);
      0|    dd = _ff2(dd, aa, bb, cc, buffer[0], 13);
      0|    cc = _ff2(cc, dd, aa, bb, buffer[4], 7);
      0|    bb = _ff2(bb, cc, dd, aa, buffer[13], 5);
       |
       |    t = c;
       |    c = cc;
       |    cc = t;
       |
       |    // Round 4
      0|    a = _f4(a, b, c, d, buffer[1], 11);
      0|    d = _f4(d, a, b, c, buffer[9], 12);
      0|    c = _f4(c, d, a, b, buffer[11], 14);
      0|    b = _f4(b, c, d, a, buffer[10], 15);
      0|    a = _f4(a, b, c, d, buffer[0], 14);
      0|    d = _f4(d, a, b, c, buffer[8], 15);
      0|    c = _f4(c, d, a, b, buffer[12], 9);
      0|    b = _f4(b, c, d, a, buffer[4], 8);
      0|    a = _f4(a, b, c, d, buffer[13], 9);
      0|    d = _f4(d, a, b, c, buffer[3], 14);
      0|    c = _f4(c, d, a, b, buffer[7], 5);
      0|    b = _f4(b, c, d, a, buffer[15], 6);
      0|    a = _f4(a, b, c, d, buffer[14], 8);
      0|    d = _f4(d, a, b, c, buffer[5], 6);
      0|    c = _f4(c, d, a, b, buffer[6], 5);
      0|    b = _f4(b, c, d, a, buffer[2], 12);
       |
      0|    aa = _ff1(aa, bb, cc, dd, buffer[8], 15);
      0|    dd = _ff1(dd, aa, bb, cc, buffer[6], 5);
      0|    cc = _ff1(cc, dd, aa, bb, buffer[4], 8);
      0|    bb = _ff1(bb, cc, dd, aa, buffer[1], 11);
      0|    aa = _ff1(aa, bb, cc, dd, buffer[3], 14);
      0|    dd = _ff1(dd, aa, bb, cc, buffer[11], 14);
      0|    cc = _ff1(cc, dd, aa, bb, buffer[15], 6);
      0|    bb = _ff1(bb, cc, dd, aa, buffer[0], 14);
      0|    aa = _ff1(aa, bb, cc, dd, buffer[5], 6);
      0|    dd = _ff1(dd, aa, bb, cc, buffer[12], 9);
      0|    cc = _ff1(cc, dd, aa, bb, buffer[2], 12);
      0|    bb = _ff1(bb, cc, dd, aa, buffer[13], 9);
      0|    aa = _ff1(aa, bb, cc, dd, buffer[9], 12);
      0|    dd = _ff1(dd, aa, bb, cc, buffer[7], 5);
      0|    cc = _ff1(cc, dd, aa, bb, buffer[10], 15);
      0|    bb = _ff1(bb, cc, dd, aa, buffer[14], 8);
       |
       |    t = d;
       |    d = dd;
       |    dd = t;
       |
      0|    state[0] = sum32(state[0], a);
      0|    state[1] = sum32(state[1], b);
      0|    state[2] = sum32(state[2], c);
      0|    state[3] = sum32(state[3], d);
      0|    state[4] = sum32(state[4], aa);
      0|    state[5] = sum32(state[5], bb);
      0|    state[6] = sum32(state[6], cc);
      0|    state[7] = sum32(state[7], dd);
       |  }
       |
      0|  int _function1(int x, int y, int z) => x ^ y ^ z;
       |
      0|  int _function2(int x, int y, int z) => (x & y) | (~x & z);
       |
      0|  int _function3(int x, int y, int z) => (x | ~y) ^ z;
       |
      0|  int _function4(int x, int y, int z) => (x & z) | (y & ~z);
       |
      0|  int _f1(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function1(b, c, d) + x, s);
       |
      0|  int _f2(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function2(b, c, d) + x + 0x5a827999, s);
       |
      0|  int _f3(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function3(b, c, d) + x + 0x6ed9eba1, s);
       |
      0|  int _f4(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function4(b, c, d) + x + 0x8f1bbcdc, s);
       |
      0|  int _ff1(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function1(b, c, d) + x, s);
       |
      0|  int _ff2(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function2(b, c, d) + x + 0x6d703ef3, s);
       |
      0|  int _ff3(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function3(b, c, d) + x + 0x5c4dd124, s);
       |
      0|  int _ff4(int a, int b, int c, int d, int x, int s) =>
      0|      crotl32(a + _function4(b, c, d) + x + 0x50a28be6, s);
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/ripemd320.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.ripemd320;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of RIPEMD-320 digest.
       |class RIPEMD320Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'RIPEMD-320', () => RIPEMD320Digest());
       |
       |  static const _DIGEST_LENGTH = 40;
       |
      0|  RIPEMD320Digest() : super(Endian.little, 10, 16);
       |  @override
       |  final algorithmName = 'RIPEMD-320';
       |
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void resetState() {
      0|    state[0] = 0x67452301;
      0|    state[1] = 0xefcdab89;
      0|    state[2] = 0x98badcfe;
      0|    state[3] = 0x10325476;
      0|    state[4] = 0xc3d2e1f0;
      0|    state[5] = 0x76543210;
      0|    state[6] = 0xFEDCBA98;
      0|    state[7] = 0x89ABCDEF;
      0|    state[8] = 0x01234567;
      0|    state[9] = 0x3C2D1E0F;
       |  }
       |
      0|  @override
       |  void processBlock() {
       |    int a, aa;
       |    int b, bb;
       |    int c, cc;
       |    int d, dd;
       |    int e, ee;
       |    int t;
       |
      0|    a = state[0];
      0|    b = state[1];
      0|    c = state[2];
      0|    d = state[3];
      0|    e = state[4];
      0|    aa = state[5];
      0|    bb = state[6];
      0|    cc = state[7];
      0|    dd = state[8];
      0|    ee = state[9];
       |
       |    //
       |    // Rounds 1 - 16
       |    //
       |    // left
      0|    a = sum32(crotl32(a + _f1(b, c, d) + buffer[0], 11), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f1(a, b, c) + buffer[1], 14), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f1(e, a, b) + buffer[2], 15), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f1(d, e, a) + buffer[3], 12), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f1(c, d, e) + buffer[4], 5), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f1(b, c, d) + buffer[5], 8), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f1(a, b, c) + buffer[6], 7), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f1(e, a, b) + buffer[7], 9), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f1(d, e, a) + buffer[8], 11), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f1(c, d, e) + buffer[9], 13), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f1(b, c, d) + buffer[10], 14), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f1(a, b, c) + buffer[11], 15), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f1(e, a, b) + buffer[12], 6), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f1(d, e, a) + buffer[13], 7), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f1(c, d, e) + buffer[14], 9), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f1(b, c, d) + buffer[15], 8), e);
      0|    c = rotl32(c, 10);
       |
       |    // right
      0|    aa = sum32(crotl32(aa + _f5(bb, cc, dd) + buffer[5] + 0x50a28be6, 8), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f5(aa, bb, cc) + buffer[14] + 0x50a28be6, 9), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f5(ee, aa, bb) + buffer[7] + 0x50a28be6, 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f5(dd, ee, aa) + buffer[0] + 0x50a28be6, 11), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f5(cc, dd, ee) + buffer[9] + 0x50a28be6, 13), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f5(bb, cc, dd) + buffer[2] + 0x50a28be6, 15), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f5(aa, bb, cc) + buffer[11] + 0x50a28be6, 15), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f5(ee, aa, bb) + buffer[4] + 0x50a28be6, 5), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f5(dd, ee, aa) + buffer[13] + 0x50a28be6, 7), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f5(cc, dd, ee) + buffer[6] + 0x50a28be6, 7), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f5(bb, cc, dd) + buffer[15] + 0x50a28be6, 8), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f5(aa, bb, cc) + buffer[8] + 0x50a28be6, 11), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f5(ee, aa, bb) + buffer[1] + 0x50a28be6, 14), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f5(dd, ee, aa) + buffer[10] + 0x50a28be6, 14), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f5(cc, dd, ee) + buffer[3] + 0x50a28be6, 12), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f5(bb, cc, dd) + buffer[12] + 0x50a28be6, 6), ee);
      0|    cc = rotl32(cc, 10);
       |
       |    t = a;
       |    a = aa;
       |    aa = t;
       |
       |    //
       |    // Rounds 16-31
       |    //
       |    // left
      0|    e = sum32(crotl32(e + _f2(a, b, c) + buffer[7] + 0x5a827999, 7), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f2(e, a, b) + buffer[4] + 0x5a827999, 6), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f2(d, e, a) + buffer[13] + 0x5a827999, 8), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f2(c, d, e) + buffer[1] + 0x5a827999, 13), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f2(b, c, d) + buffer[10] + 0x5a827999, 11), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f2(a, b, c) + buffer[6] + 0x5a827999, 9), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f2(e, a, b) + buffer[15] + 0x5a827999, 7), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f2(d, e, a) + buffer[3] + 0x5a827999, 15), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f2(c, d, e) + buffer[12] + 0x5a827999, 7), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f2(b, c, d) + buffer[0] + 0x5a827999, 12), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f2(a, b, c) + buffer[9] + 0x5a827999, 15), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f2(e, a, b) + buffer[5] + 0x5a827999, 9), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f2(d, e, a) + buffer[2] + 0x5a827999, 11), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f2(c, d, e) + buffer[14] + 0x5a827999, 7), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f2(b, c, d) + buffer[11] + 0x5a827999, 13), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f2(a, b, c) + buffer[8] + 0x5a827999, 12), d);
      0|    b = rotl32(b, 10);
       |
       |    // right
      0|    ee = sum32(crotl32(ee + _f4(aa, bb, cc) + buffer[6] + 0x5c4dd124, 9), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f4(ee, aa, bb) + buffer[11] + 0x5c4dd124, 13), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f4(dd, ee, aa) + buffer[3] + 0x5c4dd124, 15), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f4(cc, dd, ee) + buffer[7] + 0x5c4dd124, 7), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f4(bb, cc, dd) + buffer[0] + 0x5c4dd124, 12), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f4(aa, bb, cc) + buffer[13] + 0x5c4dd124, 8), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f4(ee, aa, bb) + buffer[5] + 0x5c4dd124, 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f4(dd, ee, aa) + buffer[10] + 0x5c4dd124, 11), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f4(cc, dd, ee) + buffer[14] + 0x5c4dd124, 7), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f4(bb, cc, dd) + buffer[15] + 0x5c4dd124, 7), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f4(aa, bb, cc) + buffer[8] + 0x5c4dd124, 12), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f4(ee, aa, bb) + buffer[12] + 0x5c4dd124, 7), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f4(dd, ee, aa) + buffer[4] + 0x5c4dd124, 6), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f4(cc, dd, ee) + buffer[9] + 0x5c4dd124, 15), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f4(bb, cc, dd) + buffer[1] + 0x5c4dd124, 13), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f4(aa, bb, cc) + buffer[2] + 0x5c4dd124, 11), dd);
      0|    bb = rotl32(bb, 10);
       |
       |    t = b;
       |    b = bb;
       |    bb = t;
       |
       |    //
       |    // Rounds 32-47
       |    //
       |    // left
      0|    d = sum32(crotl32(d + _f3(e, a, b) + buffer[3] + 0x6ed9eba1, 11), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f3(d, e, a) + buffer[10] + 0x6ed9eba1, 13), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f3(c, d, e) + buffer[14] + 0x6ed9eba1, 6), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f3(b, c, d) + buffer[4] + 0x6ed9eba1, 7), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f3(a, b, c) + buffer[9] + 0x6ed9eba1, 14), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f3(e, a, b) + buffer[15] + 0x6ed9eba1, 9), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f3(d, e, a) + buffer[8] + 0x6ed9eba1, 13), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f3(c, d, e) + buffer[1] + 0x6ed9eba1, 15), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f3(b, c, d) + buffer[2] + 0x6ed9eba1, 14), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f3(a, b, c) + buffer[7] + 0x6ed9eba1, 8), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f3(e, a, b) + buffer[0] + 0x6ed9eba1, 13), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f3(d, e, a) + buffer[6] + 0x6ed9eba1, 6), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f3(c, d, e) + buffer[13] + 0x6ed9eba1, 5), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f3(b, c, d) + buffer[11] + 0x6ed9eba1, 12), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f3(a, b, c) + buffer[5] + 0x6ed9eba1, 7), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f3(e, a, b) + buffer[12] + 0x6ed9eba1, 5), c);
      0|    a = rotl32(a, 10);
       |
       |    // right
      0|    dd = sum32(crotl32(dd + _f3(ee, aa, bb) + buffer[15] + 0x6d703ef3, 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f3(dd, ee, aa) + buffer[5] + 0x6d703ef3, 7), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f3(cc, dd, ee) + buffer[1] + 0x6d703ef3, 15), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f3(bb, cc, dd) + buffer[3] + 0x6d703ef3, 11), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f3(aa, bb, cc) + buffer[7] + 0x6d703ef3, 8), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f3(ee, aa, bb) + buffer[14] + 0x6d703ef3, 6), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f3(dd, ee, aa) + buffer[6] + 0x6d703ef3, 6), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f3(cc, dd, ee) + buffer[9] + 0x6d703ef3, 14), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f3(bb, cc, dd) + buffer[11] + 0x6d703ef3, 12), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f3(aa, bb, cc) + buffer[8] + 0x6d703ef3, 13), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f3(ee, aa, bb) + buffer[12] + 0x6d703ef3, 5), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f3(dd, ee, aa) + buffer[2] + 0x6d703ef3, 14), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f3(cc, dd, ee) + buffer[10] + 0x6d703ef3, 13), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f3(bb, cc, dd) + buffer[0] + 0x6d703ef3, 13), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f3(aa, bb, cc) + buffer[4] + 0x6d703ef3, 7), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f3(ee, aa, bb) + buffer[13] + 0x6d703ef3, 5), cc);
      0|    aa = rotl32(aa, 10);
       |
       |    t = c;
       |    c = cc;
       |    cc = t;
       |
       |    //
       |    // Rounds 48-63
       |    //
       |    // left
      0|    c = sum32(crotl32(c + _f4(d, e, a) + buffer[1] + 0x8f1bbcdc, 11), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f4(c, d, e) + buffer[9] + 0x8f1bbcdc, 12), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f4(b, c, d) + buffer[11] + 0x8f1bbcdc, 14), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f4(a, b, c) + buffer[10] + 0x8f1bbcdc, 15), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f4(e, a, b) + buffer[0] + 0x8f1bbcdc, 14), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f4(d, e, a) + buffer[8] + 0x8f1bbcdc, 15), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f4(c, d, e) + buffer[12] + 0x8f1bbcdc, 9), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f4(b, c, d) + buffer[4] + 0x8f1bbcdc, 8), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f4(a, b, c) + buffer[13] + 0x8f1bbcdc, 9), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f4(e, a, b) + buffer[3] + 0x8f1bbcdc, 14), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f4(d, e, a) + buffer[7] + 0x8f1bbcdc, 5), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f4(c, d, e) + buffer[15] + 0x8f1bbcdc, 6), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f4(b, c, d) + buffer[14] + 0x8f1bbcdc, 8), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f4(a, b, c) + buffer[5] + 0x8f1bbcdc, 6), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f4(e, a, b) + buffer[6] + 0x8f1bbcdc, 5), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f4(d, e, a) + buffer[2] + 0x8f1bbcdc, 12), b);
      0|    e = rotl32(e, 10);
       |
       |    // right
      0|    cc = sum32(crotl32(cc + _f2(dd, ee, aa) + buffer[8] + 0x7a6d76e9, 15), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f2(cc, dd, ee) + buffer[6] + 0x7a6d76e9, 5), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f2(bb, cc, dd) + buffer[4] + 0x7a6d76e9, 8), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f2(aa, bb, cc) + buffer[1] + 0x7a6d76e9, 11), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f2(ee, aa, bb) + buffer[3] + 0x7a6d76e9, 14), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f2(dd, ee, aa) + buffer[11] + 0x7a6d76e9, 14), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f2(cc, dd, ee) + buffer[15] + 0x7a6d76e9, 6), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f2(bb, cc, dd) + buffer[0] + 0x7a6d76e9, 14), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f2(aa, bb, cc) + buffer[5] + 0x7a6d76e9, 6), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f2(ee, aa, bb) + buffer[12] + 0x7a6d76e9, 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f2(dd, ee, aa) + buffer[2] + 0x7a6d76e9, 12), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f2(cc, dd, ee) + buffer[13] + 0x7a6d76e9, 9), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f2(bb, cc, dd) + buffer[9] + 0x7a6d76e9, 12), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f2(aa, bb, cc) + buffer[7] + 0x7a6d76e9, 5), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f2(ee, aa, bb) + buffer[10] + 0x7a6d76e9, 15), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f2(dd, ee, aa) + buffer[14] + 0x7a6d76e9, 8), bb);
      0|    ee = rotl32(ee, 10);
       |
       |    t = d;
       |    d = dd;
       |    dd = t;
       |
       |    //
       |    // Rounds 64-79
       |    //
       |    // left
      0|    b = sum32(crotl32(b + _f5(c, d, e) + buffer[4] + 0xa953fd4e, 9), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f5(b, c, d) + buffer[0] + 0xa953fd4e, 15), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f5(a, b, c) + buffer[5] + 0xa953fd4e, 5), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f5(e, a, b) + buffer[9] + 0xa953fd4e, 11), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f5(d, e, a) + buffer[7] + 0xa953fd4e, 6), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f5(c, d, e) + buffer[12] + 0xa953fd4e, 8), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f5(b, c, d) + buffer[2] + 0xa953fd4e, 13), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f5(a, b, c) + buffer[10] + 0xa953fd4e, 12), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f5(e, a, b) + buffer[14] + 0xa953fd4e, 5), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f5(d, e, a) + buffer[1] + 0xa953fd4e, 12), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f5(c, d, e) + buffer[3] + 0xa953fd4e, 13), a);
      0|    d = rotl32(d, 10);
      0|    a = sum32(crotl32(a + _f5(b, c, d) + buffer[8] + 0xa953fd4e, 14), e);
      0|    c = rotl32(c, 10);
      0|    e = sum32(crotl32(e + _f5(a, b, c) + buffer[11] + 0xa953fd4e, 11), d);
      0|    b = rotl32(b, 10);
      0|    d = sum32(crotl32(d + _f5(e, a, b) + buffer[6] + 0xa953fd4e, 8), c);
      0|    a = rotl32(a, 10);
      0|    c = sum32(crotl32(c + _f5(d, e, a) + buffer[15] + 0xa953fd4e, 5), b);
      0|    e = rotl32(e, 10);
      0|    b = sum32(crotl32(b + _f5(c, d, e) + buffer[13] + 0xa953fd4e, 6), a);
      0|    d = rotl32(d, 10);
       |
       |    // right
      0|    bb = sum32(crotl32(bb + _f1(cc, dd, ee) + buffer[12], 8), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f1(bb, cc, dd) + buffer[15], 5), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f1(aa, bb, cc) + buffer[10], 12), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f1(ee, aa, bb) + buffer[4], 9), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f1(dd, ee, aa) + buffer[1], 12), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f1(cc, dd, ee) + buffer[5], 5), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f1(bb, cc, dd) + buffer[8], 14), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f1(aa, bb, cc) + buffer[7], 6), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f1(ee, aa, bb) + buffer[6], 8), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f1(dd, ee, aa) + buffer[2], 13), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f1(cc, dd, ee) + buffer[13], 6), aa);
      0|    dd = rotl32(dd, 10);
      0|    aa = sum32(crotl32(aa + _f1(bb, cc, dd) + buffer[14], 5), ee);
      0|    cc = rotl32(cc, 10);
      0|    ee = sum32(crotl32(ee + _f1(aa, bb, cc) + buffer[0], 15), dd);
      0|    bb = rotl32(bb, 10);
      0|    dd = sum32(crotl32(dd + _f1(ee, aa, bb) + buffer[3], 13), cc);
      0|    aa = rotl32(aa, 10);
      0|    cc = sum32(crotl32(cc + _f1(dd, ee, aa) + buffer[9], 11), bb);
      0|    ee = rotl32(ee, 10);
      0|    bb = sum32(crotl32(bb + _f1(cc, dd, ee) + buffer[11], 11), aa);
      0|    dd = rotl32(dd, 10);
       |
       |    // do (e, ee) swap as part of assignment.
      0|    state[0] = sum32(state[0], a);
      0|    state[1] = sum32(state[1], b);
      0|    state[2] = sum32(state[2], c);
      0|    state[3] = sum32(state[3], d);
      0|    state[4] = sum32(state[4], ee);
      0|    state[5] = sum32(state[5], aa);
      0|    state[6] = sum32(state[6], bb);
      0|    state[7] = sum32(state[7], cc);
      0|    state[8] = sum32(state[8], dd);
      0|    state[9] = sum32(state[9], e);
       |  }
       |
      0|  int _f1(int x, int y, int z) => x ^ y ^ z;
       |
      0|  int _f2(int x, int y, int z) => (x & y) | (~x & z);
       |
      0|  int _f3(int x, int y, int z) => (x | ~y) ^ z;
       |
      0|  int _f4(int x, int y, int z) => (x & z) | (y & ~z);
       |
      0|  int _f5(int x, int y, int z) => x ^ (y | ~z);
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/sha1.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.sha1;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of SHA-1 digest
       |class SHA1Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'SHA-1', () => SHA1Digest());
       |
       |  static const _DIGEST_LENGTH = 20;
       |
      0|  SHA1Digest() : super(Endian.big, 5, 80);
       |
       |  @override
       |  final algorithmName = 'SHA-1';
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void resetState() {
      0|    state[0] = 0x67452301;
      0|    state[1] = 0xefcdab89;
      0|    state[2] = 0x98badcfe;
      0|    state[3] = 0x10325476;
      0|    state[4] = 0xc3d2e1f0;
       |  }
       |
      0|  @override
       |  void processBlock() {
       |    // expand 16 word block into 80 word block.
      0|    for (var i = 16; i < 80; i++) {
      0|      var t = buffer[i - 3] ^ buffer[i - 8] ^ buffer[i - 14] ^ buffer[i - 16];
      0|      buffer[i] = rotl32(t, 1);
       |    }
       |
       |    // set up working variables.
      0|    var A = state[0];
      0|    var B = state[1];
      0|    var C = state[2];
      0|    var D = state[3];
      0|    var E = state[4];
       |
       |    var idx = 0;
       |
       |    // round 1
      0|    for (var j = 0; j < 4; j++) {
      0|      E = clip32(E + rotl32(A, 5) + _f(B, C, D) + buffer[idx++] + _Y1);
      0|      B = rotl32(B, 30);
       |
      0|      D = clip32(D + rotl32(E, 5) + _f(A, B, C) + buffer[idx++] + _Y1);
      0|      A = rotl32(A, 30);
       |
      0|      C = clip32(C + rotl32(D, 5) + _f(E, A, B) + buffer[idx++] + _Y1);
      0|      E = rotl32(E, 30);
       |
      0|      B = clip32(B + rotl32(C, 5) + _f(D, E, A) + buffer[idx++] + _Y1);
      0|      D = rotl32(D, 30);
       |
      0|      A = clip32(A + rotl32(B, 5) + _f(C, D, E) + buffer[idx++] + _Y1);
      0|      C = rotl32(C, 30);
       |    }
       |
       |    // round 2
      0|    for (var j = 0; j < 4; j++) {
      0|      E = clip32(E + rotl32(A, 5) + _h(B, C, D) + buffer[idx++] + _Y2);
      0|      B = rotl32(B, 30);
       |
      0|      D = clip32(D + rotl32(E, 5) + _h(A, B, C) + buffer[idx++] + _Y2);
      0|      A = rotl32(A, 30);
       |
      0|      C = clip32(C + rotl32(D, 5) + _h(E, A, B) + buffer[idx++] + _Y2);
      0|      E = rotl32(E, 30);
       |
      0|      B = clip32(B + rotl32(C, 5) + _h(D, E, A) + buffer[idx++] + _Y2);
      0|      D = rotl32(D, 30);
       |
      0|      A = clip32(A + rotl32(B, 5) + _h(C, D, E) + buffer[idx++] + _Y2);
      0|      C = rotl32(C, 30);
       |    }
       |
       |    // round 3
      0|    for (var j = 0; j < 4; j++) {
      0|      E = clip32(E + rotl32(A, 5) + _g(B, C, D) + buffer[idx++] + _Y3);
      0|      B = rotl32(B, 30);
       |
      0|      D = clip32(D + rotl32(E, 5) + _g(A, B, C) + buffer[idx++] + _Y3);
      0|      A = rotl32(A, 30);
       |
      0|      C = clip32(C + rotl32(D, 5) + _g(E, A, B) + buffer[idx++] + _Y3);
      0|      E = rotl32(E, 30);
       |
      0|      B = clip32(B + rotl32(C, 5) + _g(D, E, A) + buffer[idx++] + _Y3);
      0|      D = rotl32(D, 30);
       |
      0|      A = clip32(A + rotl32(B, 5) + _g(C, D, E) + buffer[idx++] + _Y3);
      0|      C = rotl32(C, 30);
       |    }
       |
       |    // round 4
      0|    for (var j = 0; j < 4; j++) {
      0|      E = clip32(E + rotl32(A, 5) + _h(B, C, D) + buffer[idx++] + _Y4);
      0|      B = rotl32(B, 30);
       |
      0|      D = clip32(D + rotl32(E, 5) + _h(A, B, C) + buffer[idx++] + _Y4);
      0|      A = rotl32(A, 30);
       |
      0|      C = clip32(C + rotl32(D, 5) + _h(E, A, B) + buffer[idx++] + _Y4);
      0|      E = rotl32(E, 30);
       |
      0|      B = clip32(B + rotl32(C, 5) + _h(D, E, A) + buffer[idx++] + _Y4);
      0|      D = rotl32(D, 30);
       |
      0|      A = clip32(A + rotl32(B, 5) + _h(C, D, E) + buffer[idx++] + _Y4);
      0|      C = rotl32(C, 30);
       |    }
       |
      0|    state[0] = clip32(state[0] + A);
      0|    state[1] = clip32(state[1] + B);
      0|    state[2] = clip32(state[2] + C);
      0|    state[3] = clip32(state[3] + D);
      0|    state[4] = clip32(state[4] + E);
       |  }
       |
       |  // Additive constants
       |  static const _Y1 = 0x5a827999;
       |  static const _Y2 = 0x6ed9eba1;
       |  static const _Y3 = 0x8f1bbcdc;
       |  static const _Y4 = 0xca62c1d6;
       |
      0|  int _f(int u, int v, int w) => ((u & v) | ((~u) & w));
       |
      0|  int _h(int u, int v, int w) => (u ^ v ^ w);
       |
      0|  int _g(int u, int v, int w) => ((u & v) | (u & w) | (v & w));
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/sha224.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.sha224;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of SHA-224 digest.
       |class SHA224Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'SHA-224', () => SHA224Digest());
       |
       |  static const _DIGEST_LENGTH = 28;
       |
      0|  SHA224Digest() : super(Endian.big, 8, 64, 7);
       |
       |  @override
       |  final algorithmName = 'SHA-224';
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void resetState() {
      0|    state[0] = 0xc1059ed8;
      0|    state[1] = 0x367cd507;
      0|    state[2] = 0x3070dd17;
      0|    state[3] = 0xf70e5939;
      0|    state[4] = 0xffc00b31;
      0|    state[5] = 0x68581511;
      0|    state[6] = 0x64f98fa7;
      0|    state[7] = 0xbefa4fa4;
       |  }
       |
      0|  @override
       |  void processBlock() {
       |    // expand 16 word block into 64 word blocks.
      0|    for (var t = 16; t < 64; t++) {
      0|      buffer[t] = clip32(_theta1(buffer[t - 2]) +
      0|          buffer[t - 7] +
      0|          _theta0(buffer[t - 15]) +
      0|          buffer[t - 16]);
       |    }
       |
       |    // set up working variables.
      0|    var a = state[0];
      0|    var b = state[1];
      0|    var c = state[2];
      0|    var d = state[3];
      0|    var e = state[4];
      0|    var f = state[5];
      0|    var g = state[6];
      0|    var h = state[7];
       |
       |    var t = 0;
       |
      0|    for (var i = 0; i < 8; i++) {
       |      // t = 8 * i
      0|      h = clip32(h + _sum1(e) + _ch(e, f, g) + _k[t] + buffer[t]);
      0|      d = clip32(d + h);
      0|      h = clip32(h + _sum0(a) + _maj(a, b, c));
      0|      ++t;
       |
       |      // t = 8 * i + 1
      0|      g = clip32(g + _sum1(d) + _ch(d, e, f) + _k[t] + buffer[t]);
      0|      c = clip32(c + g);
      0|      g = clip32(g + _sum0(h) + _maj(h, a, b));
      0|      ++t;
       |
       |      // t = 8 * i + 2
      0|      f = clip32(f + _sum1(c) + _ch(c, d, e) + _k[t] + buffer[t]);
      0|      b = clip32(b + f);
      0|      f = clip32(f + _sum0(g) + _maj(g, h, a));
      0|      ++t;
       |
       |      // t = 8 * i + 3
      0|      e = clip32(e + _sum1(b) + _ch(b, c, d) + _k[t] + buffer[t]);
      0|      a = clip32(a + e);
      0|      e = clip32(e + _sum0(f) + _maj(f, g, h));
      0|      ++t;
       |
       |      // t = 8 * i + 4
      0|      d = clip32(d + _sum1(a) + _ch(a, b, c) + _k[t] + buffer[t]);
      0|      h = clip32(h + d);
      0|      d = clip32(d + _sum0(e) + _maj(e, f, g));
      0|      ++t;
       |
       |      // t = 8 * i + 5
      0|      c = clip32(c + _sum1(h) + _ch(h, a, b) + _k[t] + buffer[t]);
      0|      g = clip32(g + c);
      0|      c = clip32(c + _sum0(d) + _maj(d, e, f));
      0|      ++t;
       |
       |      // t = 8 * i + 6
      0|      b = clip32(b + _sum1(g) + _ch(g, h, a) + _k[t] + buffer[t]);
      0|      f = clip32(f + b);
      0|      b = clip32(b + _sum0(c) + _maj(c, d, e));
      0|      ++t;
       |
       |      // t = 8 * i + 7
      0|      a = clip32(a + _sum1(f) + _ch(f, g, h) + _k[t] + buffer[t]);
      0|      e = clip32(e + a);
      0|      a = clip32(a + _sum0(b) + _maj(b, c, d));
      0|      ++t;
       |    }
       |
      0|    state[0] = clip32(state[0] + a);
      0|    state[1] = clip32(state[1] + b);
      0|    state[2] = clip32(state[2] + c);
      0|    state[3] = clip32(state[3] + d);
      0|    state[4] = clip32(state[4] + e);
      0|    state[5] = clip32(state[5] + f);
      0|    state[6] = clip32(state[6] + g);
      0|    state[7] = clip32(state[7] + h);
       |  }
       |
      0|  int _ch(int x, int y, int z) => ((x & y) ^ ((~x) & z));
       |
      0|  int _maj(int x, int y, int z) => ((x & y) ^ (x & z) ^ (y & z));
       |
      0|  int _sum0(int x) => rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
       |
      0|  int _sum1(int x) => rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
       |
      0|  int _theta0(int x) => rotr32(x, 7) ^ rotr32(x, 18) ^ shiftr32(x, 3);
       |
      0|  int _theta1(int x) => rotr32(x, 17) ^ rotr32(x, 19) ^ shiftr32(x, 10);
       |
       |  /// SHA-224 Constants (represent the first 32 bits of the fractional parts of the cube roots of the
       |  /// first sixty-four prime numbers)
      0|  static final _k = [
       |    0x428a2f98,
       |    0x71374491,
       |    0xb5c0fbcf,
       |    0xe9b5dba5,
       |    0x3956c25b,
       |    0x59f111f1,
       |    0x923f82a4,
       |    0xab1c5ed5,
       |    0xd807aa98,
       |    0x12835b01,
       |    0x243185be,
       |    0x550c7dc3,
       |    0x72be5d74,
       |    0x80deb1fe,
       |    0x9bdc06a7,
       |    0xc19bf174,
       |    0xe49b69c1,
       |    0xefbe4786,
       |    0x0fc19dc6,
       |    0x240ca1cc,
       |    0x2de92c6f,
       |    0x4a7484aa,
       |    0x5cb0a9dc,
       |    0x76f988da,
       |    0x983e5152,
       |    0xa831c66d,
       |    0xb00327c8,
       |    0xbf597fc7,
       |    0xc6e00bf3,
       |    0xd5a79147,
       |    0x06ca6351,
       |    0x14292967,
       |    0x27b70a85,
       |    0x2e1b2138,
       |    0x4d2c6dfc,
       |    0x53380d13,
       |    0x650a7354,
       |    0x766a0abb,
       |    0x81c2c92e,
       |    0x92722c85,
       |    0xa2bfe8a1,
       |    0xa81a664b,
       |    0xc24b8b70,
       |    0xc76c51a3,
       |    0xd192e819,
       |    0xd6990624,
       |    0xf40e3585,
       |    0x106aa070,
       |    0x19a4c116,
       |    0x1e376c08,
       |    0x2748774c,
       |    0x34b0bcb5,
       |    0x391c0cb3,
       |    0x4ed8aa4a,
       |    0x5b9cca4f,
       |    0x682e6ff3,
       |    0x748f82ee,
       |    0x78a5636f,
       |    0x84c87814,
       |    0x8cc70208,
       |    0x90befffa,
       |    0xa4506ceb,
       |    0xbef9a3f7,
       |    0xc67178f2
       |  ];
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/sha256.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.sha256;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/md4_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of SHA-256 digest.
       |class SHA256Digest extends MD4FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'SHA-256', () => SHA256Digest());
       |
       |  static const _DIGEST_LENGTH = 32;
       |
      2|  SHA256Digest() : super(Endian.big, 8, 64);
       |
       |  @override
       |  final algorithmName = 'SHA-256';
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      1|  @override
       |  void resetState() {
      2|    state[0] = 0x6a09e667;
      2|    state[1] = 0xbb67ae85;
      2|    state[2] = 0x3c6ef372;
      2|    state[3] = 0xa54ff53a;
      2|    state[4] = 0x510e527f;
      2|    state[5] = 0x9b05688c;
      2|    state[6] = 0x1f83d9ab;
      2|    state[7] = 0x5be0cd19;
       |  }
       |
      1|  @override
       |  void processBlock() {
       |    // expand 16 word block into 64 word blocks.
      2|    for (var t = 16; t < 64; t++) {
      8|      buffer[t] = clip32(_theta1(buffer[t - 2]) +
      4|          buffer[t - 7] +
      5|          _theta0(buffer[t - 15]) +
      3|          buffer[t - 16]);
       |    }
       |
       |    // set up working variables.
      2|    var a = state[0];
      2|    var b = state[1];
      2|    var c = state[2];
      2|    var d = state[3];
      2|    var e = state[4];
      2|    var f = state[5];
      2|    var g = state[6];
      2|    var h = state[7];
       |
       |    var t = 0;
       |
      2|    for (var i = 0; i < 8; i++) {
       |      // t = 8 * i
     11|      h = clip32(h + _sum1(e) + _ch(e, f, g) + _k[t] + buffer[t]);
      2|      d = clip32(d + h);
      5|      h = clip32(h + _sum0(a) + _maj(a, b, c));
      1|      ++t;
       |
       |      // t = 8 * i + 1
     11|      g = clip32(g + _sum1(d) + _ch(d, e, f) + _k[t] + buffer[t]);
      2|      c = clip32(c + g);
      5|      g = clip32(g + _sum0(h) + _maj(h, a, b));
      1|      ++t;
       |
       |      // t = 8 * i + 2
     11|      f = clip32(f + _sum1(c) + _ch(c, d, e) + _k[t] + buffer[t]);
      2|      b = clip32(b + f);
      5|      f = clip32(f + _sum0(g) + _maj(g, h, a));
      1|      ++t;
       |
       |      // t = 8 * i + 3
     11|      e = clip32(e + _sum1(b) + _ch(b, c, d) + _k[t] + buffer[t]);
      2|      a = clip32(a + e);
      5|      e = clip32(e + _sum0(f) + _maj(f, g, h));
      1|      ++t;
       |
       |      // t = 8 * i + 4
     11|      d = clip32(d + _sum1(a) + _ch(a, b, c) + _k[t] + buffer[t]);
      2|      h = clip32(h + d);
      5|      d = clip32(d + _sum0(e) + _maj(e, f, g));
      1|      ++t;
       |
       |      // t = 8 * i + 5
     11|      c = clip32(c + _sum1(h) + _ch(h, a, b) + _k[t] + buffer[t]);
      2|      g = clip32(g + c);
      5|      c = clip32(c + _sum0(d) + _maj(d, e, f));
      1|      ++t;
       |
       |      // t = 8 * i + 6
     11|      b = clip32(b + _sum1(g) + _ch(g, h, a) + _k[t] + buffer[t]);
      2|      f = clip32(f + b);
      5|      b = clip32(b + _sum0(c) + _maj(c, d, e));
      1|      ++t;
       |
       |      // t = 8 * i + 7
     11|      a = clip32(a + _sum1(f) + _ch(f, g, h) + _k[t] + buffer[t]);
      2|      e = clip32(e + a);
      5|      a = clip32(a + _sum0(b) + _maj(b, c, d));
      1|      ++t;
       |    }
       |
      6|    state[0] = clip32(state[0] + a);
      6|    state[1] = clip32(state[1] + b);
      6|    state[2] = clip32(state[2] + c);
      6|    state[3] = clip32(state[3] + d);
      6|    state[4] = clip32(state[4] + e);
      6|    state[5] = clip32(state[5] + f);
      6|    state[6] = clip32(state[6] + g);
      6|    state[7] = clip32(state[7] + h);
       |  }
       |
      5|  int _ch(int x, int y, int z) => (x & y) ^ ((~x) & z);
       |
      6|  int _maj(int x, int y, int z) => (x & y) ^ (x & z) ^ (y & z);
       |
      6|  int _sum0(int x) => rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
       |
      6|  int _sum1(int x) => rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
       |
      6|  int _theta0(int x) => rotr32(x, 7) ^ rotr32(x, 18) ^ shiftr32(x, 3);
       |
      6|  int _theta1(int x) => rotr32(x, 17) ^ rotr32(x, 19) ^ shiftr32(x, 10);
       |
       |  /// SHA-256 Constants (represent the first 32 bits of the fractional parts of the cube roots of the
       |  /// first sixty-four prime numbers)
      3|  static final _k = [
       |    0x428a2f98,
       |    0x71374491,
       |    0xb5c0fbcf,
       |    0xe9b5dba5,
       |    0x3956c25b,
       |    0x59f111f1,
       |    0x923f82a4,
       |    0xab1c5ed5,
       |    0xd807aa98,
       |    0x12835b01,
       |    0x243185be,
       |    0x550c7dc3,
       |    0x72be5d74,
       |    0x80deb1fe,
       |    0x9bdc06a7,
       |    0xc19bf174,
       |    0xe49b69c1,
       |    0xefbe4786,
       |    0x0fc19dc6,
       |    0x240ca1cc,
       |    0x2de92c6f,
       |    0x4a7484aa,
       |    0x5cb0a9dc,
       |    0x76f988da,
       |    0x983e5152,
       |    0xa831c66d,
       |    0xb00327c8,
       |    0xbf597fc7,
       |    0xc6e00bf3,
       |    0xd5a79147,
       |    0x06ca6351,
       |    0x14292967,
       |    0x27b70a85,
       |    0x2e1b2138,
       |    0x4d2c6dfc,
       |    0x53380d13,
       |    0x650a7354,
       |    0x766a0abb,
       |    0x81c2c92e,
       |    0x92722c85,
       |    0xa2bfe8a1,
       |    0xa81a664b,
       |    0xc24b8b70,
       |    0xc76c51a3,
       |    0xd192e819,
       |    0xd6990624,
       |    0xf40e3585,
       |    0x106aa070,
       |    0x19a4c116,
       |    0x1e376c08,
       |    0x2748774c,
       |    0x34b0bcb5,
       |    0x391c0cb3,
       |    0x4ed8aa4a,
       |    0x5b9cca4f,
       |    0x682e6ff3,
       |    0x748f82ee,
       |    0x78a5636f,
       |    0x84c87814,
       |    0x8cc70208,
       |    0x90befffa,
       |    0xa4506ceb,
       |    0xbef9a3f7,
       |    0xc67178f2
       |  ];
       |
      0|  @override
       |  int get byteLength => 64;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/sha3.dart
       |library impl.digest.sha3;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/keccak_engine.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Implementation of SHA3 digest.
       |/// https://csrc.nist.gov/publications/detail/fips/202/final
       |class SHA3Digest extends KeccakEngine {
      0|  static final RegExp _sha3REGEX = RegExp(r'^SHA3-([0-9]+)$');
       |
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig(
       |      Digest,
       |      _sha3REGEX,
       |      (_, final Match match) => () {
       |            var bitLength = int.parse(match.group(1));
       |            return SHA3Digest(bitLength);
       |          });
       |
      0|  SHA3Digest([int bitLength = 288]) {
       |    switch (bitLength) {
      0|      case 224:
      0|      case 256:
      0|      case 384:
      0|      case 512:
      0|        init(bitLength);
       |        break;
       |      default:
      0|        throw StateError(
      0|            'invalid bitLength ($bitLength) for SHA-3 must only be 224,256,384,512');
       |    }
       |  }
       |
      0|  @override
      0|  String get algorithmName => 'SHA3-$fixedOutputLength';
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
       |    // FIPS 202 SHA3 https://github.com/PointyCastle/pointycastle/issues/128
      0|    absorbBits(0x02, 2);
      0|    squeeze(out, outOff, fixedOutputLength);
      0|    reset();
      0|    return digestSize;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/sha384.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.sha384;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/long_sha2_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Implementation of SHA-384 digest.
       |class SHA384Digest extends LongSHA2FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'SHA-384', () => SHA384Digest());
       |
       |  static const _DIGEST_LENGTH = 48;
       |
      0|  SHA384Digest() {
      0|    reset();
       |  }
       |
       |  @override
       |  final algorithmName = 'SHA-384';
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void reset() {
      0|    super.reset();
       |
      0|    h1.set(0xcbbb9d5d, 0xc1059ed8);
      0|    h2.set(0x629a292a, 0x367cd507);
      0|    h3.set(0x9159015a, 0x3070dd17);
      0|    h4.set(0x152fecd8, 0xf70e5939);
      0|    h5.set(0x67332667, 0xffc00b31);
      0|    h6.set(0x8eb44a87, 0x68581511);
      0|    h7.set(0xdb0c2e0d, 0x64f98fa7);
      0|    h8.set(0x47b5481d, 0xbefa4fa4);
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    finish();
       |
      0|    var view = ByteData.view(out.buffer, out.offsetInBytes, out.length);
      0|    h1.pack(view, outOff, Endian.big);
      0|    h2.pack(view, outOff + 8, Endian.big);
      0|    h3.pack(view, outOff + 16, Endian.big);
      0|    h4.pack(view, outOff + 24, Endian.big);
      0|    h5.pack(view, outOff + 32, Endian.big);
      0|    h6.pack(view, outOff + 40, Endian.big);
       |
      0|    reset();
       |
       |    return _DIGEST_LENGTH;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/sha512.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.sha512;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/long_sha2_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Implementation of SHA-512 digest.
       |class SHA512Digest extends LongSHA2FamilyDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'SHA-512', () => SHA512Digest());
       |
       |  static const _DIGEST_LENGTH = 64;
       |
      0|  SHA512Digest() {
      0|    reset();
       |  }
       |
       |  @override
       |  final algorithmName = 'SHA-512';
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void reset() {
      0|    super.reset();
       |
      0|    h1.set(0x6a09e667, 0xf3bcc908);
      0|    h2.set(0xbb67ae85, 0x84caa73b);
      0|    h3.set(0x3c6ef372, 0xfe94f82b);
      0|    h4.set(0xa54ff53a, 0x5f1d36f1);
      0|    h5.set(0x510e527f, 0xade682d1);
      0|    h6.set(0x9b05688c, 0x2b3e6c1f);
      0|    h7.set(0x1f83d9ab, 0xfb41bd6b);
      0|    h8.set(0x5be0cd19, 0x137e2179);
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    finish();
       |
      0|    var view = ByteData.view(out.buffer, out.offsetInBytes, out.length);
      0|    h1.pack(view, outOff, Endian.big);
      0|    h2.pack(view, outOff + 8, Endian.big);
      0|    h3.pack(view, outOff + 16, Endian.big);
      0|    h4.pack(view, outOff + 24, Endian.big);
      0|    h5.pack(view, outOff + 32, Endian.big);
      0|    h6.pack(view, outOff + 40, Endian.big);
      0|    h7.pack(view, outOff + 48, Endian.big);
      0|    h8.pack(view, outOff + 56, Endian.big);
       |
      0|    reset();
       |
       |    return _DIGEST_LENGTH;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/sha512t.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.sha512t;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/long_sha2_family_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of SHA-512/t digest (see FIPS 180-4).
       |class SHA512tDigest extends LongSHA2FamilyDigest implements Digest {
      0|  static final RegExp _nameRegex = RegExp(r'^SHA-512\/([0-9]+)$');
       |
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig(
       |      Digest,
       |      _nameRegex,
       |      (_, final Match match) => () {
       |            var bitLength = int.parse(match.group(1));
       |            if ((bitLength % 8) != 0) {
       |              throw RegistryFactoryException(
       |                  'Digest length for SHA-512/t is not a multiple of 8: $bitLength');
       |            }
       |            return SHA512tDigest(bitLength ~/ 8);
       |          });
       |
      0|  static final Register64 _hMask = Register64(0xa5a5a5a5, 0xa5a5a5a5);
       |
       |  @override
       |  final int digestSize;
       |
       |  final _h1t = Register64();
       |  final _h2t = Register64();
       |  final _h3t = Register64();
       |  final _h4t = Register64();
       |  final _h5t = Register64();
       |  final _h6t = Register64();
       |  final _h7t = Register64();
       |  final _h8t = Register64();
       |
      0|  SHA512tDigest(this.digestSize) {
      0|    if (digestSize >= 64) {
      0|      throw ArgumentError('Digest size cannot be >= 64 bytes (512 bits)');
       |    }
      0|    if (digestSize == 48) {
      0|      throw ArgumentError(
       |          'Digest size cannot be 48 bytes (384 bits): use SHA-384 instead');
       |    }
       |
      0|    _generateIVs(digestSize * 8);
       |
      0|    reset();
       |  }
       |
      0|  @override
      0|  String get algorithmName => 'SHA-512/${digestSize * 8}';
       |
      0|  @override
       |  void reset() {
      0|    super.reset();
       |
      0|    h1.set(_h1t);
      0|    h2.set(_h2t);
      0|    h3.set(_h3t);
      0|    h4.set(_h4t);
      0|    h5.set(_h5t);
      0|    h6.set(_h6t);
      0|    h7.set(_h7t);
      0|    h8.set(_h8t);
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    finish();
       |
      0|    var tmp = Uint8List(64);
       |
      0|    var view = ByteData.view(tmp.buffer, tmp.offsetInBytes, tmp.length);
      0|    h1.pack(view, 0, Endian.big);
      0|    h2.pack(view, 8, Endian.big);
      0|    h3.pack(view, 16, Endian.big);
      0|    h4.pack(view, 24, Endian.big);
      0|    h5.pack(view, 32, Endian.big);
      0|    h6.pack(view, 40, Endian.big);
      0|    h7.pack(view, 48, Endian.big);
      0|    h8.pack(view, 56, Endian.big);
       |
      0|    out.setRange(outOff, outOff + digestSize, tmp);
       |
      0|    reset();
       |
      0|    return digestSize;
       |  }
       |
      0|  void _generateIVs(int bitLength) {
      0|    h1
      0|      ..set(0x6a09e667, 0xf3bcc908)
      0|      ..xor(_hMask);
      0|    h2
      0|      ..set(0xbb67ae85, 0x84caa73b)
      0|      ..xor(_hMask);
      0|    h3
      0|      ..set(0x3c6ef372, 0xfe94f82b)
      0|      ..xor(_hMask);
      0|    h4
      0|      ..set(0xa54ff53a, 0x5f1d36f1)
      0|      ..xor(_hMask);
      0|    h5
      0|      ..set(0x510e527f, 0xade682d1)
      0|      ..xor(_hMask);
      0|    h6
      0|      ..set(0x9b05688c, 0x2b3e6c1f)
      0|      ..xor(_hMask);
      0|    h7
      0|      ..set(0x1f83d9ab, 0xfb41bd6b)
      0|      ..xor(_hMask);
      0|    h8
      0|      ..set(0x5be0cd19, 0x137e2179)
      0|      ..xor(_hMask);
       |
      0|    updateByte(0x53);
      0|    updateByte(0x48);
      0|    updateByte(0x41);
      0|    updateByte(0x2D);
      0|    updateByte(0x35);
      0|    updateByte(0x31);
      0|    updateByte(0x32);
      0|    updateByte(0x2F);
       |
      0|    if (bitLength > 100) {
      0|      updateByte(bitLength ~/ 100 + 0x30);
      0|      bitLength = bitLength % 100;
      0|      updateByte(bitLength ~/ 10 + 0x30);
      0|      bitLength = bitLength % 10;
      0|      updateByte(bitLength + 0x30);
      0|    } else if (bitLength > 10) {
      0|      updateByte(bitLength ~/ 10 + 0x30);
      0|      bitLength = bitLength % 10;
      0|      updateByte(bitLength + 0x30);
       |    } else {
      0|      updateByte(bitLength + 0x30);
       |    }
       |
      0|    finish();
       |
      0|    _h1t.set(h1);
      0|    _h2t.set(h2);
      0|    _h3t.set(h3);
      0|    _h4t.set(h4);
      0|    _h5t.set(h5);
      0|    _h6t.set(h6);
      0|    _h7t.set(h7);
      0|    _h8t.set(h8);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/shake.dart
       |library impl.digest.shake;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/keccak_engine.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |///
       |/// implementation of SHAKE based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
       |///
       |/// Following the naming conventions used in the C source code to enable easy review of the implementation.
       |///
       |class SHAKEDigest extends KeccakEngine implements Xof {
      0|  static final RegExp _shakeREGEX = RegExp(r'^SHAKE-([0-9]+)$');
       |
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig(
       |      Digest,
       |      _shakeREGEX,
       |      (_, final Match match) => () {
       |            var bitLength = int.parse(match.group(1));
       |            return SHAKEDigest(bitLength);
       |          });
       |
      0|  SHAKEDigest([int bitLength = 256]) {
       |    switch (bitLength) {
      0|      case 128:
      0|      case 256:
      0|        init(bitLength);
       |        break;
       |      default:
      0|        throw StateError(
      0|            'invalid bitLength ($bitLength) for SHAKE must only be 128 or 256');
       |    }
       |  }
       |
      0|  @override
      0|  String get algorithmName => 'SHAKE-$fixedOutputLength';
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    return doFinalRange(out, digestSize, digestSize);
       |  }
       |
      0|  @override
       |  int doFinalRange(Uint8List out, int outOff, int outLen) {
      0|    var length = doOutput(out, outOff, outLen);
      0|    reset();
       |    return length;
       |  }
       |
      0|  int doFinalPartial(
       |      Uint8List out, int outOff, int outLen, int partialByte, int partialBits) {
      0|    if (partialBits < 0 || partialBits > 7) {
      0|      throw ArgumentError('partialBits must be in the range [0,7]');
       |    }
       |
       |    var finalInput =
      0|        (partialByte & ((1 << partialBits) - 1)) | (0x0F << partialBits);
      0|    var finalBits = partialBits + 4;
       |
      0|    if (finalBits >= 8) {
      0|      absorb(finalInput);
      0|      finalBits -= 8;
      0|      finalInput >>= 8;
       |    }
       |
      0|    if (finalBits > 0) {
      0|      absorbBits(finalInput, finalBits);
       |    }
       |
      0|    squeeze(out, outOff, (outLen) * 8);
       |
      0|    reset();
       |
       |    return outLen;
       |  }
       |
      0|  @override
       |  int doOutput(Uint8List out, int outOff, int outLen) {
      0|    if (!squeezing) {
      0|      absorbBits(0x0F, 4);
       |    }
       |
      0|    squeeze(out, outOff, (outLen) * 8);
       |
       |    return outLen;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/cshake.dart
       |library impl.digest.cshake;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/digests/shake.dart';
       |import 'package:pointycastle/digests/xof_utils.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/utils.dart';
       |
       |///
       |/// implementation of SHAKE based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
       |///
       |/// Following the naming conventions used in the C source code to enable easy review of the implementation.
       |///
       |class CSHAKEDigest extends SHAKEDigest implements Xof {
      0|  static final RegExp _cshakeREGEX = RegExp(r'^CSHAKE-([0-9]+)$');
       |
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig(
       |      Digest,
       |      _cshakeREGEX,
       |      (_, final Match match) => () {
       |            var bitLength = int.parse(match.group(1));
       |            return CSHAKEDigest(bitLength);
       |          });
       |
       |  Uint8List _diff;
       |  final _padding = Uint8List(100);
       |
      0|  CSHAKEDigest([int bitLength = 256, Uint8List N, Uint8List S]) {
       |    switch (bitLength) {
      0|      case 128:
      0|      case 256:
      0|        init(bitLength);
      0|        if ((N == null || N.isEmpty) && (S == null || S.isEmpty)) {
      0|          _diff = null;
       |        } else {
      0|          _diff = concatUint8List([
      0|            XofUtils.leftEncode(rate ~/ 8),
      0|            _encodeString(N),
      0|            _encodeString(S)
       |          ]);
      0|          _diffPadAndAbsorb();
       |        }
       |
       |        break;
       |      default:
      0|        throw StateError(
      0|            'invalid bitLength ($bitLength) for CSHAKE must only be 128 or 256');
       |    }
       |  }
       |
      0|  @override
      0|  String get algorithmName => 'CSHAKE-$fixedOutputLength';
      0|  @override
       |  int doOutput(Uint8List out, int outOff, int outLen) {
      0|    if (_diff != null) {
      0|      if (!squeezing) {
      0|        absorbBits(0x00, 2);
       |      }
       |
      0|      squeeze(out, outOff, (outLen) * 8);
       |
       |      return outLen;
       |    } else {
      0|      return super.doOutput(out, outOff, outLen);
       |    }
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
      0|    absorbRange(inp, inpOff, len);
       |  }
       |
      0|  @override
       |  void reset() {
      0|    super.reset();
       |
      0|    if (_diff != null) {
      0|      _diffPadAndAbsorb();
       |    }
       |  }
       |
       |  // bytepad in SP 800-185
      0|  void _diffPadAndAbsorb() {
      0|    var blockSize = rate ~/ 8;
      0|    absorbRange(_diff, 0, _diff.length);
       |
      0|    var delta = _diff.length % blockSize;
       |
       |    // only add padding if needed
      0|    if (delta != 0) {
      0|      var required = blockSize - delta;
       |
      0|      while (required > _padding.length) {
      0|        absorbRange(_padding, 0, _padding.length);
      0|        required -= _padding.length;
       |      }
       |
      0|      absorbRange(_padding, 0, required);
       |    }
       |  }
       |
      0|  Uint8List _encodeString(Uint8List str) {
      0|    if (str == null || str.isEmpty) {
      0|      return XofUtils.leftEncode(0);
       |    }
       |
      0|    return concatUint8List([XofUtils.leftEncode(str.length * 8), str]);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/tiger.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.tiger;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of Tiger digest.
       |class TigerDigest extends BaseDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'Tiger', () => TigerDigest());
       |
       |  static const _DIGEST_LENGTH = 24;
      0|  static final _keyMask0 = Register64(0xA5A5A5A5, 0xA5A5A5A5);
      0|  static final _keyMask7 = Register64(0x01234567, 0x89ABCDEF);
       |
       |  final _a = Register64();
       |  final _b = Register64();
       |  final _c = Register64();
       |
       |  final _byteCount = Register64();
       |
       |  final _wordBuffer = Uint8List(8);
       |  int _wordBufferOffset = 0;
       |
       |  final _buffer = Register64List(8);
       |  int _bufferOffset = 0;
       |
      0|  TigerDigest() {
      0|    reset();
       |  }
       |
       |  @override
       |  final algorithmName = 'Tiger';
       |  @override
       |  final digestSize = _DIGEST_LENGTH;
       |
      0|  @override
       |  void reset() {
      0|    _a.set(0x01234567, 0x89ABCDEF);
      0|    _b.set(0xFEDCBA98, 0x76543210);
      0|    _c.set(0xF096A5B4, 0xC3B2E187);
       |
      0|    _bufferOffset = 0;
      0|    _buffer.fillRange(0, _buffer.length, 0);
       |
      0|    _wordBufferOffset = 0;
      0|    _wordBuffer.fillRange(0, _wordBuffer.length, 0);
       |
      0|    _byteCount.set(0);
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    _finish();
       |
      0|    _a.pack(out, outOff, Endian.little);
      0|    _b.pack(out, outOff + 8, Endian.little);
      0|    _c.pack(out, outOff + 16, Endian.little);
       |
      0|    reset();
       |
       |    return _DIGEST_LENGTH;
       |  }
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    _wordBuffer[_wordBufferOffset++] = inp;
       |
      0|    if (_wordBufferOffset == _wordBuffer.length) {
      0|      _processWord(_wordBuffer, 0);
       |    }
       |
      0|    _byteCount.sum(1);
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
       |    // fill the current word
      0|    while ((_wordBufferOffset != 0) && (len > 0)) {
      0|      updateByte(inp[inpOff]);
       |
      0|      inpOff++;
      0|      len--;
       |    }
       |
       |    // process whole words.
      0|    while (len > 8) {
      0|      _processWord(inp, inpOff);
       |
      0|      inpOff += 8;
      0|      len -= 8;
      0|      _byteCount.sum(8);
       |    }
       |
       |    // load in the remainder.
      0|    while (len > 0) {
      0|      updateByte(inp[inpOff]);
       |
      0|      inpOff++;
      0|      len--;
       |    }
       |  }
       |
      0|  void _processWord(Uint8List b, int off) {
      0|    _buffer[_bufferOffset++].unpack(b, off, Endian.little);
       |
      0|    if (_bufferOffset == _buffer.length) {
      0|      _processBlock();
       |    }
      0|    _wordBufferOffset = 0;
       |  }
       |
      0|  void _processBlock() {
       |    // save abc
      0|    final aa = Register64(_a);
      0|    final bb = Register64(_b);
      0|    final cc = Register64(_c);
       |
       |    // rounds and schedule
      0|    _roundABC(_buffer[0], 5);
      0|    _roundBCA(_buffer[1], 5);
      0|    _roundCAB(_buffer[2], 5);
      0|    _roundABC(_buffer[3], 5);
      0|    _roundBCA(_buffer[4], 5);
      0|    _roundCAB(_buffer[5], 5);
      0|    _roundABC(_buffer[6], 5);
      0|    _roundBCA(_buffer[7], 5);
       |
      0|    _keySchedule();
       |
      0|    _roundCAB(_buffer[0], 7);
      0|    _roundABC(_buffer[1], 7);
      0|    _roundBCA(_buffer[2], 7);
      0|    _roundCAB(_buffer[3], 7);
      0|    _roundABC(_buffer[4], 7);
      0|    _roundBCA(_buffer[5], 7);
      0|    _roundCAB(_buffer[6], 7);
      0|    _roundABC(_buffer[7], 7);
       |
      0|    _keySchedule();
       |
      0|    _roundBCA(_buffer[0], 9);
      0|    _roundCAB(_buffer[1], 9);
      0|    _roundABC(_buffer[2], 9);
      0|    _roundBCA(_buffer[3], 9);
      0|    _roundCAB(_buffer[4], 9);
      0|    _roundABC(_buffer[5], 9);
      0|    _roundBCA(_buffer[6], 9);
      0|    _roundCAB(_buffer[7], 9);
       |
       |    // feed forward
      0|    _a.xor(aa);
      0|    _b.sub(bb);
      0|    _c.sum(cc);
       |
       |    // clear the x buffer
      0|    _bufferOffset = 0;
      0|    _buffer.fillRange(0, _buffer.length, 0);
       |  }
       |
      0|  void _processLength(Register64 bitLength) {
      0|    _buffer[7].set(bitLength);
       |  }
       |
      0|  void _finish() {
      0|    var bitLength = Register64(_byteCount)..shiftl(3);
       |
      0|    updateByte(0x01);
       |
      0|    while (_wordBufferOffset != 0) {
      0|      updateByte(0);
       |    }
       |
      0|    _processLength(bitLength);
       |
      0|    _processBlock();
       |  }
       |
      0|  void _keySchedule() {
      0|    final r = Register64();
       |
      0|    _buffer[0].sub(r
      0|      ..set(_buffer[7])
      0|      ..xor(_keyMask0));
      0|    _buffer[1].xor(_buffer[0]);
      0|    _buffer[2].sum(_buffer[1]);
      0|    _buffer[3].sub(r
      0|      ..set(_buffer[1])
      0|      ..not()
      0|      ..shiftl(19)
      0|      ..xor(_buffer[2]));
      0|    _buffer[4].xor(_buffer[3]);
      0|    _buffer[5].sum(_buffer[4]);
      0|    _buffer[6].sub(r
      0|      ..set(_buffer[4])
      0|      ..not()
      0|      ..shiftr(23)
      0|      ..xor(_buffer[5]));
      0|    _buffer[7].xor(_buffer[6]);
      0|    _buffer[0].sum(_buffer[7]);
      0|    _buffer[1].sub(r
      0|      ..set(_buffer[7])
      0|      ..not()
      0|      ..shiftl(19)
      0|      ..xor(_buffer[0]));
      0|    _buffer[2].xor(_buffer[1]);
      0|    _buffer[3].sum(_buffer[2]);
      0|    _buffer[4].sub(r
      0|      ..set(_buffer[2])
      0|      ..not()
      0|      ..shiftr(23)
      0|      ..xor(_buffer[3]));
      0|    _buffer[5].xor(_buffer[4]);
      0|    _buffer[6].sum(_buffer[5]);
      0|    _buffer[7].sub(r
      0|      ..set(_buffer[6])
      0|      ..xor(_keyMask7));
       |  }
       |
      0|  void _roundABC(Register64 x, int mul) {
      0|    final r = Register64();
      0|    final c = Uint8List(8);
       |
      0|    _c.xor(x);
      0|    _c.pack(c, 0, Endian.little);
      0|    _a.sub(r
      0|      ..set(_t1[c[0]])
      0|      ..xor(_t2[c[2]])
      0|      ..xor(_t3[c[4]])
      0|      ..xor(_t4[c[6]]));
      0|    _b.sum(r
      0|      ..set(_t4[c[1]])
      0|      ..xor(_t3[c[3]])
      0|      ..xor(_t2[c[5]])
      0|      ..xor(_t1[c[7]]));
      0|    _b.mul(mul);
       |  }
       |
      0|  void _roundBCA(Register64 x, int mul) {
      0|    final r = Register64();
      0|    final a = Uint8List(8);
       |
      0|    _a.xor(x);
      0|    _a.pack(a, 0, Endian.little);
      0|    _b.sub(r
      0|      ..set(_t1[a[0]])
      0|      ..xor(_t2[a[2]])
      0|      ..xor(_t3[a[4]])
      0|      ..xor(_t4[a[6]]));
      0|    _c.sum(r
      0|      ..set(_t4[a[1]])
      0|      ..xor(_t3[a[3]])
      0|      ..xor(_t2[a[5]])
      0|      ..xor(_t1[a[7]]));
      0|    _c.mul(mul);
       |  }
       |
      0|  void _roundCAB(Register64 x, int mul) {
      0|    final r = Register64();
      0|    final b = Uint8List(8);
       |
      0|    _b.xor(x);
      0|    _b.pack(b, 0, Endian.little);
      0|    _c.sub(r
      0|      ..set(_t1[b[0]])
      0|      ..xor(_t2[b[2]])
      0|      ..xor(_t3[b[4]])
      0|      ..xor(_t4[b[6]]));
      0|    _a.sum(r
      0|      ..set(_t4[b[1]])
      0|      ..xor(_t3[b[3]])
      0|      ..xor(_t2[b[5]])
      0|      ..xor(_t1[b[7]]));
      0|    _a.mul(mul);
       |  }
       |
      0|  @override
       |  int get byteLength => 64;
       |}
       |
       |// S-Boxes
      0|final _t1 = [
       |  Register64(0x02aab17c, 0xf7e90c5e),
       |  Register64(0xac424b03, 0xe243a8ec),
       |  Register64(0x72cd5be3, 0x0dd5fcd3),
       |  Register64(0x6d019b93, 0xf6f97f3a),
       |  Register64(0xcd9978ff, 0xd21f9193),
       |  Register64(0x7573a1c9, 0x708029e2),
       |  Register64(0xb164326b, 0x922a83c3),
       |  Register64(0x46883eee, 0x04915870),
       |  Register64(0xeaace305, 0x7103ece6),
       |  Register64(0xc54169b8, 0x08a3535c),
       |  Register64(0x4ce75491, 0x8ddec47c),
       |  Register64(0x0aa2f4df, 0xdc0df40c),
       |  Register64(0x10b76f18, 0xa74dbefa),
       |  Register64(0xc6ccb623, 0x5ad1ab6a),
       |  Register64(0x13726121, 0x572fe2ff),
       |  Register64(0x1a488c6f, 0x199d921e),
       |  Register64(0x4bc9f9f4, 0xda0007ca),
       |  Register64(0x26f5e6f6, 0xe85241c7),
       |  Register64(0x859079db, 0xea5947b6),
       |  Register64(0x4f1885c5, 0xc99e8c92),
       |  Register64(0xd78e761e, 0xa96f864b),
       |  Register64(0x8e36428c, 0x52b5c17d),
       |  Register64(0x69cf6827, 0x373063c1),
       |  Register64(0xb607c93d, 0x9bb4c56e),
       |  Register64(0x7d820e76, 0x0e76b5ea),
       |  Register64(0x645c9cc6, 0xf07fdc42),
       |  Register64(0xbf38a078, 0x243342e0),
       |  Register64(0x5f6b343c, 0x9d2e7d04),
       |  Register64(0xf2c28aeb, 0x600b0ec6),
       |  Register64(0x6c0ed85f, 0x7254bcac),
       |  Register64(0x71592281, 0xa4db4fe5),
       |  Register64(0x1967fa69, 0xce0fed9f),
       |  Register64(0xfd5293f8, 0xb96545db),
       |  Register64(0xc879e9d7, 0xf2a7600b),
       |  Register64(0x86024892, 0x0193194e),
       |  Register64(0xa4f9533b, 0x2d9cc0b3),
       |  Register64(0x9053836c, 0x15957613),
       |  Register64(0xdb6dcf8a, 0xfc357bf1),
       |  Register64(0x18beea7a, 0x7a370f57),
       |  Register64(0x037117ca, 0x50b99066),
       |  Register64(0x6ab30a97, 0x74424a35),
       |  Register64(0xf4e92f02, 0xe325249b),
       |  Register64(0x7739db07, 0x061ccae1),
       |  Register64(0xd8f3b49c, 0xeca42a05),
       |  Register64(0xbd56be3f, 0x51382f73),
       |  Register64(0x45faed58, 0x43b0bb28),
       |  Register64(0x1c813d5c, 0x11bf1f83),
       |  Register64(0x8af0e4b6, 0xd75fa169),
       |  Register64(0x33ee18a4, 0x87ad9999),
       |  Register64(0x3c26e8ea, 0xb1c94410),
       |  Register64(0xb510102b, 0xc0a822f9),
       |  Register64(0x141eef31, 0x0ce6123b),
       |  Register64(0xfc65b900, 0x59ddb154),
       |  Register64(0xe0158640, 0xc5e0e607),
       |  Register64(0x884e0798, 0x26c3a3cf),
       |  Register64(0x930d0d95, 0x23c535fd),
       |  Register64(0x35638d75, 0x4e9a2b00),
       |  Register64(0x4085fccf, 0x40469dd5),
       |  Register64(0xc4b17ad2, 0x8be23a4c),
       |  Register64(0xcab2f0fc, 0x6a3e6a2e),
       |  Register64(0x2860971a, 0x6b943fcd),
       |  Register64(0x3dde6ee2, 0x12e30446),
       |  Register64(0x6222f32a, 0xe01765ae),
       |  Register64(0x5d550bb5, 0x478308fe),
       |  Register64(0xa9efa98d, 0xa0eda22a),
       |  Register64(0xc351a716, 0x86c40da7),
       |  Register64(0x1105586d, 0x9c867c84),
       |  Register64(0xdcffee85, 0xfda22853),
       |  Register64(0xccfbd026, 0x2c5eef76),
       |  Register64(0xbaf294cb, 0x8990d201),
       |  Register64(0xe69464f5, 0x2afad975),
       |  Register64(0x94b013af, 0xdf133e14),
       |  Register64(0x06a7d1a3, 0x2823c958),
       |  Register64(0x6f95fe51, 0x30f61119),
       |  Register64(0xd92ab34e, 0x462c06c0),
       |  Register64(0xed7bde33, 0x887c71d2),
       |  Register64(0x79746d6e, 0x6518393e),
       |  Register64(0x5ba41938, 0x5d713329),
       |  Register64(0x7c1ba6b9, 0x48a97564),
       |  Register64(0x31987c19, 0x7bfdac67),
       |  Register64(0xde6c23c4, 0x4b053d02),
       |  Register64(0x581c49fe, 0xd002d64d),
       |  Register64(0xdd474d63, 0x38261571),
       |  Register64(0xaa4546c3, 0xe473d062),
       |  Register64(0x928fce34, 0x9455f860),
       |  Register64(0x48161bba, 0xcaab94d9),
       |  Register64(0x63912430, 0x770e6f68),
       |  Register64(0x6ec8a5e6, 0x02c6641c),
       |  Register64(0x87282515, 0x337ddd2b),
       |  Register64(0x2cda6b42, 0x034b701b),
       |  Register64(0xb03d37c1, 0x81cb096d),
       |  Register64(0xe1084382, 0x66c71c6f),
       |  Register64(0x2b3180c7, 0xeb51b255),
       |  Register64(0xdf92b82f, 0x96c08bbc),
       |  Register64(0x5c68c8c0, 0xa632f3ba),
       |  Register64(0x5504cc86, 0x1c3d0556),
       |  Register64(0xabbfa4e5, 0x5fb26b8f),
       |  Register64(0x41848b0a, 0xb3baceb4),
       |  Register64(0xb334a273, 0xaa445d32),
       |  Register64(0xbca696f0, 0xa85ad881),
       |  Register64(0x24f6ec65, 0xb528d56c),
       |  Register64(0x0ce1512e, 0x90f4524a),
       |  Register64(0x4e9dd79d, 0x5506d35a),
       |  Register64(0x258905fa, 0xc6ce9779),
       |  Register64(0x2019295b, 0x3e109b33),
       |  Register64(0xf8a9478b, 0x73a054cc),
       |  Register64(0x2924f2f9, 0x34417eb0),
       |  Register64(0x3993357d, 0x536d1bc4),
       |  Register64(0x38a81ac2, 0x1db6ff8b),
       |  Register64(0x47c4fbf1, 0x7d6016bf),
       |  Register64(0x1e0faadd, 0x7667e3f5),
       |  Register64(0x7abcff62, 0x938beb96),
       |  Register64(0xa78dad94, 0x8fc179c9),
       |  Register64(0x8f1f98b7, 0x2911e50d),
       |  Register64(0x61e48eae, 0x27121a91),
       |  Register64(0x4d62f7ad, 0x31859808),
       |  Register64(0xeceba345, 0xef5ceaeb),
       |  Register64(0xf5ceb25e, 0xbc9684ce),
       |  Register64(0xf633e20c, 0xb7f76221),
       |  Register64(0xa32cdf06, 0xab8293e4),
       |  Register64(0x985a202c, 0xa5ee2ca4),
       |  Register64(0xcf0b8447, 0xcc8a8fb1),
       |  Register64(0x9f765244, 0x979859a3),
       |  Register64(0xa8d516b1, 0xa1240017),
       |  Register64(0x0bd7ba3e, 0xbb5dc726),
       |  Register64(0xe54bca55, 0xb86adb39),
       |  Register64(0x1d7a3afd, 0x6c478063),
       |  Register64(0x519ec608, 0xe7669edd),
       |  Register64(0x0e5715a2, 0xd149aa23),
       |  Register64(0x177d4571, 0x848ff194),
       |  Register64(0xeeb55f32, 0x41014c22),
       |  Register64(0x0f5e5ca1, 0x3a6e2ec2),
       |  Register64(0x8029927b, 0x75f5c361),
       |  Register64(0xad139fab, 0xc3d6e436),
       |  Register64(0x0d5df1a9, 0x4ccf402f),
       |  Register64(0x3e8bd948, 0xbea5dfc8),
       |  Register64(0xa5a0d357, 0xbd3ff77e),
       |  Register64(0xa2d12e25, 0x1f74f645),
       |  Register64(0x66fd9e52, 0x5e81a082),
       |  Register64(0x2e0c90ce, 0x7f687a49),
       |  Register64(0xc2e8bcbe, 0xba973bc5),
       |  Register64(0x000001bc, 0xe509745f),
       |  Register64(0x423777bb, 0xe6dab3d6),
       |  Register64(0xd1661c7e, 0xaef06eb5),
       |  Register64(0xa1781f35, 0x4daacfd8),
       |  Register64(0x2d11284a, 0x2b16affc),
       |  Register64(0xf1fc4f67, 0xfa891d1f),
       |  Register64(0x73ecc25d, 0xcb920ada),
       |  Register64(0xae610c22, 0xc2a12651),
       |  Register64(0x96e0a810, 0xd356b78a),
       |  Register64(0x5a9a381f, 0x2fe7870f),
       |  Register64(0xd5ad62ed, 0xe94e5530),
       |  Register64(0xd225e5e8, 0x368d1427),
       |  Register64(0x65977b70, 0xc7af4631),
       |  Register64(0x99f889b2, 0xde39d74f),
       |  Register64(0x233f30bf, 0x54e1d143),
       |  Register64(0x9a9675d3, 0xd9a63c97),
       |  Register64(0x5470554f, 0xf334f9a8),
       |  Register64(0x166acb74, 0x4a4f5688),
       |  Register64(0x70c74caa, 0xb2e4aead),
       |  Register64(0xf0d09164, 0x6f294d12),
       |  Register64(0x57b82a89, 0x684031d1),
       |  Register64(0xefd95a5a, 0x61be0b6b),
       |  Register64(0x2fbd12e9, 0x69f2f29a),
       |  Register64(0x9bd37013, 0xfeff9fe8),
       |  Register64(0x3f9b0404, 0xd6085a06),
       |  Register64(0x4940c1f3, 0x166cfe15),
       |  Register64(0x09542c4d, 0xcdf3defb),
       |  Register64(0xb4c52183, 0x85cd5ce3),
       |  Register64(0xc935b7dc, 0x4462a641),
       |  Register64(0x3417f8a6, 0x8ed3b63f),
       |  Register64(0xb8095929, 0x5b215b40),
       |  Register64(0xf99cdaef, 0x3b8c8572),
       |  Register64(0x018c0614, 0xf8fcb95d),
       |  Register64(0x1b14accd, 0x1a3acdf3),
       |  Register64(0x84d471f2, 0x00bb732d),
       |  Register64(0xc1a3110e, 0x95e8da16),
       |  Register64(0x430a7220, 0xbf1a82b8),
       |  Register64(0xb77e090d, 0x39df210e),
       |  Register64(0x5ef4bd9f, 0x3cd05e9d),
       |  Register64(0x9d4ff6da, 0x7e57a444),
       |  Register64(0xda1d60e1, 0x83d4a5f8),
       |  Register64(0xb287c384, 0x17998e47),
       |  Register64(0xfe3edc12, 0x1bb31886),
       |  Register64(0xc7fe3ccc, 0x980ccbef),
       |  Register64(0xe46fb590, 0x189bfd03),
       |  Register64(0x3732fd46, 0x9a4c57dc),
       |  Register64(0x7ef700a0, 0x7cf1ad65),
       |  Register64(0x59c64468, 0xa31d8859),
       |  Register64(0x762fb0b4, 0xd45b61f6),
       |  Register64(0x155baed0, 0x99047718),
       |  Register64(0x68755e4c, 0x3d50baa6),
       |  Register64(0xe9214e7f, 0x22d8b4df),
       |  Register64(0x2addbf53, 0x2eac95f4),
       |  Register64(0x32ae3909, 0xb4bd0109),
       |  Register64(0x834df537, 0xb08e3450),
       |  Register64(0xfa209da8, 0x4220728d),
       |  Register64(0x9e691d9b, 0x9efe23f7),
       |  Register64(0x0446d288, 0xc4ae8d7f),
       |  Register64(0x7b4cc524, 0xe169785b),
       |  Register64(0x21d87f01, 0x35ca1385),
       |  Register64(0xcebb400f, 0x137b8aa5),
       |  Register64(0x272e2b66, 0x580796be),
       |  Register64(0x36122641, 0x25c2b0de),
       |  Register64(0x057702bd, 0xad1efbb2),
       |  Register64(0xd4babb8e, 0xacf84be9),
       |  Register64(0x91583139, 0x641bc67b),
       |  Register64(0x8bdc2de0, 0x8036e024),
       |  Register64(0x603c8156, 0xf49f68ed),
       |  Register64(0xf7d236f7, 0xdbef5111),
       |  Register64(0x9727c459, 0x8ad21e80),
       |  Register64(0xa08a0896, 0x670a5fd7),
       |  Register64(0xcb4a8f43, 0x09eba9cb),
       |  Register64(0x81af564b, 0x0f7036a1),
       |  Register64(0xc0b99aa7, 0x78199abd),
       |  Register64(0x959f1ec8, 0x3fc8e952),
       |  Register64(0x8c505077, 0x794a81b9),
       |  Register64(0x3acaaf8f, 0x056338f0),
       |  Register64(0x07b43f50, 0x627a6778),
       |  Register64(0x4a44ab49, 0xf5eccc77),
       |  Register64(0x3bc3d6e4, 0xb679ee98),
       |  Register64(0x9cc0d4d1, 0xcf14108c),
       |  Register64(0x4406c00b, 0x206bc8a0),
       |  Register64(0x82a18854, 0xc8d72d89),
       |  Register64(0x67e366b3, 0x5c3c432c),
       |  Register64(0xb923dd61, 0x102b37f2),
       |  Register64(0x56ab2779, 0xd884271d),
       |  Register64(0xbe83e1b0, 0xff1525af),
       |  Register64(0xfb7c65d4, 0x217e49a9),
       |  Register64(0x6bdbe0e7, 0x6d48e7d4),
       |  Register64(0x08df8287, 0x45d9179e),
       |  Register64(0x22ea6a9a, 0xdd53bd34),
       |  Register64(0xe36e141c, 0x5622200a),
       |  Register64(0x7f805d1b, 0x8cb750ee),
       |  Register64(0xafe5c7a5, 0x9f58e837),
       |  Register64(0xe27f996a, 0x4fb1c23c),
       |  Register64(0xd3867dfb, 0x0775f0d0),
       |  Register64(0xd0e673de, 0x6e88891a),
       |  Register64(0x123aeb9e, 0xafb86c25),
       |  Register64(0x30f1d5d5, 0xc145b895),
       |  Register64(0xbb434a2d, 0xee7269e7),
       |  Register64(0x78cb67ec, 0xf931fa38),
       |  Register64(0xf33b0372, 0x323bbf9c),
       |  Register64(0x52d66336, 0xfb279c74),
       |  Register64(0x505f33ac, 0x0afb4eaa),
       |  Register64(0xe8a5cd99, 0xa2cce187),
       |  Register64(0x53497480, 0x1e2d30bb),
       |  Register64(0x8d2d5711, 0xd5876d90),
       |  Register64(0x1f1a4128, 0x91bc038e),
       |  Register64(0xd6e2e71d, 0x82e56648),
       |  Register64(0x74036c3a, 0x497732b7),
       |  Register64(0x89b67ed9, 0x6361f5ab),
       |  Register64(0xffed95d8, 0xf1ea02a2),
       |  Register64(0xe72b3bd6, 0x1464d43d),
       |  Register64(0xa6300f17, 0x0bdc4820),
       |  Register64(0xebc18760, 0xed78a77a),
       |];
       |
      0|final _t2 = [
       |  Register64(0xe6a6be5a, 0x05a12138),
       |  Register64(0xb5a122a5, 0xb4f87c98),
       |  Register64(0x563c6089, 0x140b6990),
       |  Register64(0x4c46cb2e, 0x391f5dd5),
       |  Register64(0xd932addb, 0xc9b79434),
       |  Register64(0x08ea70e4, 0x2015aff5),
       |  Register64(0xd765a667, 0x3e478cf1),
       |  Register64(0xc4fb757e, 0xab278d99),
       |  Register64(0xdf11c686, 0x2d6e0692),
       |  Register64(0xddeb84f1, 0x0d7f3b16),
       |  Register64(0x6f2ef604, 0xa665ea04),
       |  Register64(0x4a8e0f0f, 0xf0e0dfb3),
       |  Register64(0xa5edeef8, 0x3dbcba51),
       |  Register64(0xfc4f0a2a, 0x0ea4371e),
       |  Register64(0xe83e1da8, 0x5cb38429),
       |  Register64(0xdc8ff882, 0xba1b1ce2),
       |  Register64(0xcd45505e, 0x8353e80d),
       |  Register64(0x18d19a00, 0xd4db0717),
       |  Register64(0x34a0cfed, 0xa5f38101),
       |  Register64(0x0be77e51, 0x8887caf2),
       |  Register64(0x1e341438, 0xb3c45136),
       |  Register64(0xe05797f4, 0x9089ccf9),
       |  Register64(0xffd23f9d, 0xf2591d14),
       |  Register64(0x543dda22, 0x8595c5cd),
       |  Register64(0x661f81fd, 0x99052a33),
       |  Register64(0x8736e641, 0xdb0f7b76),
       |  Register64(0x15227725, 0x418e5307),
       |  Register64(0xe25f7f46, 0x162eb2fa),
       |  Register64(0x48a8b212, 0x6c13d9fe),
       |  Register64(0xafdc5417, 0x92e76eea),
       |  Register64(0x03d912bf, 0xc6d1898f),
       |  Register64(0x31b1aafa, 0x1b83f51b),
       |  Register64(0xf1ac2796, 0xe42ab7d9),
       |  Register64(0x40a3a7d7, 0xfcd2ebac),
       |  Register64(0x1056136d, 0x0afbbcc5),
       |  Register64(0x7889e1dd, 0x9a6d0c85),
       |  Register64(0xd3352578, 0x2a7974aa),
       |  Register64(0xa7e25d09, 0x078ac09b),
       |  Register64(0xbd4138b3, 0xeac6edd0),
       |  Register64(0x920abfbe, 0x71eb9e70),
       |  Register64(0xa2a5d0f5, 0x4fc2625c),
       |  Register64(0xc054e36b, 0x0b1290a3),
       |  Register64(0xf6dd59ff, 0x62fe932b),
       |  Register64(0x35373545, 0x11a8ac7d),
       |  Register64(0xca845e91, 0x72fadcd4),
       |  Register64(0x84f82b60, 0x329d20dc),
       |  Register64(0x79c62ce1, 0xcd672f18),
       |  Register64(0x8b09a2ad, 0xd124642c),
       |  Register64(0xd0c1e96a, 0x19d9e726),
       |  Register64(0x5a786a9b, 0x4ba9500c),
       |  Register64(0x0e020336, 0x634c43f3),
       |  Register64(0xc17b474a, 0xeb66d822),
       |  Register64(0x6a731ae3, 0xec9baac2),
       |  Register64(0x8226667a, 0xe0840258),
       |  Register64(0x67d45676, 0x91caeca5),
       |  Register64(0x1d94155c, 0x4875adb5),
       |  Register64(0x6d00fd98, 0x5b813fdf),
       |  Register64(0x51286efc, 0xb774cd06),
       |  Register64(0x5e883447, 0x1fa744af),
       |  Register64(0xf72ca0ae, 0xe761ae2e),
       |  Register64(0xbe40e4cd, 0xaee8e09a),
       |  Register64(0xe9970bbb, 0x5118f665),
       |  Register64(0x726e4beb, 0x33df1964),
       |  Register64(0x703b0007, 0x29199762),
       |  Register64(0x4631d816, 0xf5ef30a7),
       |  Register64(0xb880b5b5, 0x1504a6be),
       |  Register64(0x641793c3, 0x7ed84b6c),
       |  Register64(0x7b21ed77, 0xf6e97d96),
       |  Register64(0x77630631, 0x2ef96b73),
       |  Register64(0xae528948, 0xe86ff3f4),
       |  Register64(0x53dbd7f2, 0x86a3f8f8),
       |  Register64(0x16cadce7, 0x4cfc1063),
       |  Register64(0x005c19bd, 0xfa52c6dd),
       |  Register64(0x68868f5d, 0x64d46ad3),
       |  Register64(0x3a9d512c, 0xcf1e186a),
       |  Register64(0x367e62c2, 0x385660ae),
       |  Register64(0xe359e7ea, 0x77dcb1d7),
       |  Register64(0x526c0773, 0x749abe6e),
       |  Register64(0x735ae5f9, 0xd09f734b),
       |  Register64(0x493fc7cc, 0x8a558ba8),
       |  Register64(0xb0b9c153, 0x3041ab45),
       |  Register64(0x321958ba, 0x470a59bd),
       |  Register64(0x852db00b, 0x5f46c393),
       |  Register64(0x91209b2b, 0xd336b0e5),
       |  Register64(0x6e604f7d, 0x659ef19f),
       |  Register64(0xb99a8ae2, 0x782ccb24),
       |  Register64(0xccf52ab6, 0xc814c4c7),
       |  Register64(0x4727d9af, 0xbe11727b),
       |  Register64(0x7e950d0c, 0x0121b34d),
       |  Register64(0x756f4356, 0x70ad471f),
       |  Register64(0xf5add442, 0x615a6849),
       |  Register64(0x4e87e099, 0x80b9957a),
       |  Register64(0x2acfa1df, 0x50aee355),
       |  Register64(0xd898263a, 0xfd2fd556),
       |  Register64(0xc8f4924d, 0xd80c8fd6),
       |  Register64(0xcf99ca3d, 0x754a173a),
       |  Register64(0xfe477bac, 0xaf91bf3c),
       |  Register64(0xed5371f6, 0xd690c12d),
       |  Register64(0x831a5c28, 0x5e687094),
       |  Register64(0xc5d3c90a, 0x3708a0a4),
       |  Register64(0x0f7f9037, 0x17d06580),
       |  Register64(0x19f9bb13, 0xb8fdf27f),
       |  Register64(0xb1bd6f1b, 0x4d502843),
       |  Register64(0x1c761ba3, 0x8fff4012),
       |  Register64(0x0d1530c4, 0xe2e21f3b),
       |  Register64(0x8943ce69, 0xa7372c8a),
       |  Register64(0xe5184e11, 0xfeb5ce66),
       |  Register64(0x618bdb80, 0xbd736621),
       |  Register64(0x7d29bad6, 0x8b574d0b),
       |  Register64(0x81bb613e, 0x25e6fe5b),
       |  Register64(0x071c9c10, 0xbc07913f),
       |  Register64(0xc7beeb79, 0x09ac2d97),
       |  Register64(0xc3e58d35, 0x3bc5d757),
       |  Register64(0xeb017892, 0xf38f61e8),
       |  Register64(0xd4effb9c, 0x9b1cc21a),
       |  Register64(0x99727d26, 0xf494f7ab),
       |  Register64(0xa3e063a2, 0x956b3e03),
       |  Register64(0x9d4a8b9a, 0x4aa09c30),
       |  Register64(0x3f6ab7d5, 0x00090fb4),
       |  Register64(0x9cc0f2a0, 0x57268ac0),
       |  Register64(0x3dee9d2d, 0xedbf42d1),
       |  Register64(0x330f49c8, 0x7960a972),
       |  Register64(0xc6b27202, 0x87421b41),
       |  Register64(0x0ac59ec0, 0x7c00369c),
       |  Register64(0xef4eac49, 0xcb353425),
       |  Register64(0xf450244e, 0xef0129d8),
       |  Register64(0x8acc46e5, 0xcaf4deb6),
       |  Register64(0x2ffeab63, 0x989263f7),
       |  Register64(0x8f7cb9fe, 0x5d7a4578),
       |  Register64(0x5bd8f764, 0x4e634635),
       |  Register64(0x427a7315, 0xbf2dc900),
       |  Register64(0x17d0c4aa, 0x2125261c),
       |  Register64(0x3992486c, 0x93518e50),
       |  Register64(0xb4cbfee0, 0xa2d7d4c3),
       |  Register64(0x7c75d620, 0x2c5ddd8d),
       |  Register64(0xdbc295d8, 0xe35b6c61),
       |  Register64(0x60b369d3, 0x02032b19),
       |  Register64(0xce42685f, 0xdce44132),
       |  Register64(0x06f3ddb9, 0xddf65610),
       |  Register64(0x8ea4d21d, 0xb5e148f0),
       |  Register64(0x20b0fce6, 0x2fcd496f),
       |  Register64(0x2c1b9123, 0x58b0ee31),
       |  Register64(0xb28317b8, 0x18f5a308),
       |  Register64(0xa89c1e18, 0x9ca6d2cf),
       |  Register64(0x0c6b1857, 0x6aaadbc8),
       |  Register64(0xb65deaa9, 0x1299fae3),
       |  Register64(0xfb2b794b, 0x7f1027e7),
       |  Register64(0x04e4317f, 0x443b5beb),
       |  Register64(0x4b852d32, 0x5939d0a6),
       |  Register64(0xd5ae6bee, 0xfb207ffc),
       |  Register64(0x309682b2, 0x81c7d374),
       |  Register64(0xbae309a1, 0x94c3b475),
       |  Register64(0x8cc3f97b, 0x13b49f05),
       |  Register64(0x98a9422f, 0xf8293967),
       |  Register64(0x244b16b0, 0x1076ff7c),
       |  Register64(0xf8bf571c, 0x663d67ee),
       |  Register64(0x1f0d6758, 0xeee30da1),
       |  Register64(0xc9b611d9, 0x7adeb9b7),
       |  Register64(0xb7afd588, 0x7b6c57a2),
       |  Register64(0x6290ae84, 0x6b984fe1),
       |  Register64(0x94df4cde, 0xacc1a5fd),
       |  Register64(0x058a5bd1, 0xc5483aff),
       |  Register64(0x63166cc1, 0x42ba3c37),
       |  Register64(0x8db8526e, 0xb2f76f40),
       |  Register64(0xe1088003, 0x6f0d6d4e),
       |  Register64(0x9e0523c9, 0x971d311d),
       |  Register64(0x45ec2824, 0xcc7cd691),
       |  Register64(0x575b8359, 0xe62382c9),
       |  Register64(0xfa9e400d, 0xc4889995),
       |  Register64(0xd1823ecb, 0x45721568),
       |  Register64(0xdafd983b, 0x8206082f),
       |  Register64(0xaa7d2908, 0x2386a8cb),
       |  Register64(0x269fcd44, 0x03b87588),
       |  Register64(0x1b91f5f7, 0x28bdd1e0),
       |  Register64(0xe4669f39, 0x040201f6),
       |  Register64(0x7a1d7c21, 0x8cf04ade),
       |  Register64(0x65623c29, 0xd79ce5ce),
       |  Register64(0x23684490, 0x96c00bb1),
       |  Register64(0xab9bf187, 0x9da503ba),
       |  Register64(0xbc23ecb1, 0xa458058e),
       |  Register64(0x9a58df01, 0xbb401ecc),
       |  Register64(0xa070e868, 0xa85f143d),
       |  Register64(0x4ff18830, 0x7df2239e),
       |  Register64(0x14d565b4, 0x1a641183),
       |  Register64(0xee133374, 0x52701602),
       |  Register64(0x950e3dcf, 0x3f285e09),
       |  Register64(0x59930254, 0xb9c80953),
       |  Register64(0x3bf29940, 0x8930da6d),
       |  Register64(0xa955943f, 0x53691387),
       |  Register64(0xa15edeca, 0xa9cb8784),
       |  Register64(0x29142127, 0x352be9a0),
       |  Register64(0x76f0371f, 0xff4e7afb),
       |  Register64(0x0239f450, 0x274f2228),
       |  Register64(0xbb073af0, 0x1d5e868b),
       |  Register64(0xbfc80571, 0xc10e96c1),
       |  Register64(0xd2670885, 0x68222e23),
       |  Register64(0x9671a3d4, 0x8e80b5b0),
       |  Register64(0x55b5d38a, 0xe193bb81),
       |  Register64(0x693ae2d0, 0xa18b04b8),
       |  Register64(0x5c48b4ec, 0xadd5335f),
       |  Register64(0xfd743b19, 0x4916a1ca),
       |  Register64(0x25770181, 0x34be98c4),
       |  Register64(0xe77987e8, 0x3c54a4ad),
       |  Register64(0x28e11014, 0xda33e1b9),
       |  Register64(0x270cc59e, 0x226aa213),
       |  Register64(0x71495f75, 0x6d1a5f60),
       |  Register64(0x9be853fb, 0x60afef77),
       |  Register64(0xadc786a7, 0xf7443dbf),
       |  Register64(0x09044561, 0x73b29a82),
       |  Register64(0x58bc7a66, 0xc232bd5e),
       |  Register64(0xf306558c, 0x673ac8b2),
       |  Register64(0x41f639c6, 0xb6c9772a),
       |  Register64(0x216defe9, 0x9fda35da),
       |  Register64(0x11640cc7, 0x1c7be615),
       |  Register64(0x93c43694, 0x565c5527),
       |  Register64(0xea038e62, 0x46777839),
       |  Register64(0xf9abf3ce, 0x5a3e2469),
       |  Register64(0x741e768d, 0x0fd312d2),
       |  Register64(0x0144b883, 0xced652c6),
       |  Register64(0xc20b5a5b, 0xa33f8552),
       |  Register64(0x1ae69633, 0xc3435a9d),
       |  Register64(0x97a28ca4, 0x088cfdec),
       |  Register64(0x8824a43c, 0x1e96f420),
       |  Register64(0x37612fa6, 0x6eeea746),
       |  Register64(0x6b4cb165, 0xf9cf0e5a),
       |  Register64(0x43aa1c06, 0xa0abfb4a),
       |  Register64(0x7f4dc26f, 0xf162796b),
       |  Register64(0x6cbacc8e, 0x54ed9b0f),
       |  Register64(0xa6b7ffef, 0xd2bb253e),
       |  Register64(0x2e25bc95, 0xb0a29d4f),
       |  Register64(0x86d6a58b, 0xdef1388c),
       |  Register64(0xded74ac5, 0x76b6f054),
       |  Register64(0x8030bdbc, 0x2b45805d),
       |  Register64(0x3c81af70, 0xe94d9289),
       |  Register64(0x3eff6dda, 0x9e3100db),
       |  Register64(0xb38dc39f, 0xdfcc8847),
       |  Register64(0x12388552, 0x8d17b87e),
       |  Register64(0xf2da0ed2, 0x40b1b642),
       |  Register64(0x44cefadc, 0xd54bf9a9),
       |  Register64(0x1312200e, 0x433c7ee6),
       |  Register64(0x9ffcc84f, 0x3a78c748),
       |  Register64(0xf0cd1f72, 0x248576bb),
       |  Register64(0xec697405, 0x3638cfe4),
       |  Register64(0x2ba7b67c, 0x0cec4e4c),
       |  Register64(0xac2f4df3, 0xe5ce32ed),
       |  Register64(0xcb33d143, 0x26ea4c11),
       |  Register64(0xa4e9044c, 0xc77e58bc),
       |  Register64(0x5f513293, 0xd934fcef),
       |  Register64(0x5dc96455, 0x06e55444),
       |  Register64(0x50de418f, 0x317de40a),
       |  Register64(0x388cb31a, 0x69dde259),
       |  Register64(0x2db4a834, 0x55820a86),
       |  Register64(0x9010a91e, 0x84711ae9),
       |  Register64(0x4df7f0b7, 0xb1498371),
       |  Register64(0xd62a2eab, 0xc0977179),
       |  Register64(0x22fac097, 0xaa8d5c0e),
       |];
       |
      0|final _t3 = [
       |  Register64(0xf49fcc2f, 0xf1daf39b),
       |  Register64(0x487fd5c6, 0x6ff29281),
       |  Register64(0xe8a30667, 0xfcdca83f),
       |  Register64(0x2c9b4be3, 0xd2fcce63),
       |  Register64(0xda3ff74b, 0x93fbbbc2),
       |  Register64(0x2fa165d2, 0xfe70ba66),
       |  Register64(0xa103e279, 0x970e93d4),
       |  Register64(0xbecdec77, 0xb0e45e71),
       |  Register64(0xcfb41e72, 0x3985e497),
       |  Register64(0xb70aaa02, 0x5ef75017),
       |  Register64(0xd42309f0, 0x3840b8e0),
       |  Register64(0x8efc1ad0, 0x35898579),
       |  Register64(0x96c6920b, 0xe2b2abc5),
       |  Register64(0x66af4163, 0x375a9172),
       |  Register64(0x2174abdc, 0xca7127fb),
       |  Register64(0xb33ccea6, 0x4a72ff41),
       |  Register64(0xf04a4933, 0x083066a5),
       |  Register64(0x8d970acd, 0xd7289af5),
       |  Register64(0x8f96e8e0, 0x31c8c25e),
       |  Register64(0xf3fec022, 0x76875d47),
       |  Register64(0xec7bf310, 0x056190dd),
       |  Register64(0xf5adb0ae, 0xbb0f1491),
       |  Register64(0x9b50f885, 0x0fd58892),
       |  Register64(0x49754883, 0x58b74de8),
       |  Register64(0xa3354ff6, 0x91531c61),
       |  Register64(0x0702bbe4, 0x81d2c6ee),
       |  Register64(0x89fb2405, 0x7deded98),
       |  Register64(0xac307513, 0x8596e902),
       |  Register64(0x1d2d3580, 0x172772ed),
       |  Register64(0xeb738fc2, 0x8e6bc30d),
       |  Register64(0x5854ef8f, 0x63044326),
       |  Register64(0x9e5c5232, 0x5add3bbe),
       |  Register64(0x90aa53cf, 0x325c4623),
       |  Register64(0xc1d24d51, 0x349dd067),
       |  Register64(0x2051cfee, 0xa69ea624),
       |  Register64(0x13220f0a, 0x862e7e4f),
       |  Register64(0xce393994, 0x04e04864),
       |  Register64(0xd9c42ca4, 0x7086fcb7),
       |  Register64(0x685ad223, 0x8a03e7cc),
       |  Register64(0x066484b2, 0xab2ff1db),
       |  Register64(0xfe9d5d70, 0xefbf79ec),
       |  Register64(0x5b13b9dd, 0x9c481854),
       |  Register64(0x15f0d475, 0xed1509ad),
       |  Register64(0x0bebcd06, 0x0ec79851),
       |  Register64(0xd58c6791, 0x183ab7f8),
       |  Register64(0xd1187c50, 0x52f3eee4),
       |  Register64(0xc95d1192, 0xe54e82ff),
       |  Register64(0x86eea14c, 0xb9ac6ca2),
       |  Register64(0x3485beb1, 0x53677d5d),
       |  Register64(0xdd191d78, 0x1f8c492a),
       |  Register64(0xf60866ba, 0xa784ebf9),
       |  Register64(0x518f643b, 0xa2d08c74),
       |  Register64(0x8852e956, 0xe1087c22),
       |  Register64(0xa768cb8d, 0xc410ae8d),
       |  Register64(0x38047726, 0xbfec8e1a),
       |  Register64(0xa67738b4, 0xcd3b45aa),
       |  Register64(0xad16691c, 0xec0dde19),
       |  Register64(0xc6d43193, 0x80462e07),
       |  Register64(0xc5a5876d, 0x0ba61938),
       |  Register64(0x16b9fa1f, 0xa58fd840),
       |  Register64(0x188ab117, 0x3ca74f18),
       |  Register64(0xabda2f98, 0xc99c021f),
       |  Register64(0x3e0580ab, 0x134ae816),
       |  Register64(0x5f3b05b7, 0x73645abb),
       |  Register64(0x2501a2be, 0x5575f2f6),
       |  Register64(0x1b2f7400, 0x4e7e8ba9),
       |  Register64(0x1cd75803, 0x71e8d953),
       |  Register64(0x7f6ed895, 0x62764e30),
       |  Register64(0xb15926ff, 0x596f003d),
       |  Register64(0x9f65293d, 0xa8c5d6b9),
       |  Register64(0x6ecef04d, 0xd690f84c),
       |  Register64(0x4782275f, 0xff33af88),
       |  Register64(0xe4143308, 0x3f820801),
       |  Register64(0xfd0dfe40, 0x9a1af9b5),
       |  Register64(0x4325a334, 0x2cdb396b),
       |  Register64(0x8ae77e62, 0xb301b252),
       |  Register64(0xc36f9e9f, 0x6655615a),
       |  Register64(0x85455a2d, 0x92d32c09),
       |  Register64(0xf2c7dea9, 0x49477485),
       |  Register64(0x63cfb4c1, 0x33a39eba),
       |  Register64(0x83b040cc, 0x6ebc5462),
       |  Register64(0x3b9454c8, 0xfdb326b0),
       |  Register64(0x56f56a9e, 0x87ffd78c),
       |  Register64(0x2dc2940d, 0x99f42bc6),
       |  Register64(0x98f7df09, 0x6b096e2d),
       |  Register64(0x19a6e01e, 0x3ad852bf),
       |  Register64(0x42a99ccb, 0xdbd4b40b),
       |  Register64(0xa59998af, 0x45e9c559),
       |  Register64(0x366295e8, 0x07d93186),
       |  Register64(0x6b48181b, 0xfaa1f773),
       |  Register64(0x1fec57e2, 0x157a0a1d),
       |  Register64(0x4667446a, 0xf6201ad5),
       |  Register64(0xe615ebca, 0xcfb0f075),
       |  Register64(0xb8f31f4f, 0x68290778),
       |  Register64(0x22713ed6, 0xce22d11e),
       |  Register64(0x3057c1a7, 0x2ec3c93b),
       |  Register64(0xcb46acc3, 0x7c3f1f2f),
       |  Register64(0xdbb893fd, 0x02aaf50e),
       |  Register64(0x331fd92e, 0x600b9fcf),
       |  Register64(0xa498f961, 0x48ea3ad6),
       |  Register64(0xa8d8426e, 0x8b6a83ea),
       |  Register64(0xa089b274, 0xb7735cdc),
       |  Register64(0x87f6b373, 0x1e524a11),
       |  Register64(0x118808e5, 0xcbc96749),
       |  Register64(0x9906e4c7, 0xb19bd394),
       |  Register64(0xafed7f7e, 0x9b24a20c),
       |  Register64(0x6509eade, 0xeb3644a7),
       |  Register64(0x6c1ef1d3, 0xe8ef0ede),
       |  Register64(0xb9c97d43, 0xe9798fb4),
       |  Register64(0xa2f2d784, 0x740c28a3),
       |  Register64(0x7b849647, 0x6197566f),
       |  Register64(0x7a5be3e6, 0xb65f069d),
       |  Register64(0xf96330ed, 0x78be6f10),
       |  Register64(0xeee60de7, 0x7a076a15),
       |  Register64(0x2b4bee4a, 0xa08b9bd0),
       |  Register64(0x6a56a63e, 0xc7b8894e),
       |  Register64(0x02121359, 0xba34fef4),
       |  Register64(0x4cbf99f8, 0x283703fc),
       |  Register64(0x39807135, 0x0caf30c8),
       |  Register64(0xd0a77a89, 0xf017687a),
       |  Register64(0xf1c1a9eb, 0x9e423569),
       |  Register64(0x8c797628, 0x2dee8199),
       |  Register64(0x5d1737a5, 0xdd1f7abd),
       |  Register64(0x4f53433c, 0x09a9fa80),
       |  Register64(0xfa8b0c53, 0xdf7ca1d9),
       |  Register64(0x3fd9dcbc, 0x886ccb77),
       |  Register64(0xc040917c, 0xa91b4720),
       |  Register64(0x7dd00142, 0xf9d1dcdf),
       |  Register64(0x8476fc1d, 0x4f387b58),
       |  Register64(0x23f8e7c5, 0xf3316503),
       |  Register64(0x032a2244, 0xe7e37339),
       |  Register64(0x5c87a5d7, 0x50f5a74b),
       |  Register64(0x082b4cc4, 0x3698992e),
       |  Register64(0xdf917bec, 0xb858f63c),
       |  Register64(0x3270b8fc, 0x5bf86dda),
       |  Register64(0x10ae72bb, 0x29b5dd76),
       |  Register64(0x576ac94e, 0x7700362b),
       |  Register64(0x1ad112da, 0xc61efb8f),
       |  Register64(0x691bc30e, 0xc5faa427),
       |  Register64(0xff246311, 0xcc327143),
       |  Register64(0x3142368e, 0x30e53206),
       |  Register64(0x71380e31, 0xe02ca396),
       |  Register64(0x958d5c96, 0x0aad76f1),
       |  Register64(0xf8d6f430, 0xc16da536),
       |  Register64(0xc8ffd13f, 0x1be7e1d2),
       |  Register64(0x7578ae66, 0x004ddbe1),
       |  Register64(0x05833f01, 0x067be646),
       |  Register64(0xbb34b5ad, 0x3bfe586d),
       |  Register64(0x095f34c9, 0xa12b97f0),
       |  Register64(0x247ab645, 0x25d60ca8),
       |  Register64(0xdcdbc6f3, 0x017477d1),
       |  Register64(0x4a2e14d4, 0xdecad24d),
       |  Register64(0xbdb5e6d9, 0xbe0a1eeb),
       |  Register64(0x2a7e70f7, 0x794301ab),
       |  Register64(0xdef42d8a, 0x270540fd),
       |  Register64(0x01078ec0, 0xa34c22c1),
       |  Register64(0xe5de511a, 0xf4c16387),
       |  Register64(0x7ebb3a52, 0xbd9a330a),
       |  Register64(0x77697857, 0xaa7d6435),
       |  Register64(0x004e8316, 0x03ae4c32),
       |  Register64(0xe7a21020, 0xad78e312),
       |  Register64(0x9d41a70c, 0x6ab420f2),
       |  Register64(0x28e06c18, 0xea1141e6),
       |  Register64(0xd2b28cbd, 0x984f6b28),
       |  Register64(0x26b75f6c, 0x446e9d83),
       |  Register64(0xba47568c, 0x4d418d7f),
       |  Register64(0xd80badbf, 0xe6183d8e),
       |  Register64(0x0e206d7f, 0x5f166044),
       |  Register64(0xe258a439, 0x11cbca3e),
       |  Register64(0x723a1746, 0xb21dc0bc),
       |  Register64(0xc7caa854, 0xf5d7cdd3),
       |  Register64(0x7cac3288, 0x3d261d9c),
       |  Register64(0x7690c264, 0x23ba942c),
       |  Register64(0x17e55524, 0x478042b8),
       |  Register64(0xe0be4776, 0x56a2389f),
       |  Register64(0x4d289b5e, 0x67ab2da0),
       |  Register64(0x44862b9c, 0x8fbbfd31),
       |  Register64(0xb47cc804, 0x9d141365),
       |  Register64(0x822c1b36, 0x2b91c793),
       |  Register64(0x4eb14655, 0xfb13dfd8),
       |  Register64(0x1ecbba07, 0x14e2a97b),
       |  Register64(0x6143459d, 0x5cde5f14),
       |  Register64(0x53a8fbf1, 0xd5f0ac89),
       |  Register64(0x97ea04d8, 0x1c5e5b00),
       |  Register64(0x622181a8, 0xd4fdb3f3),
       |  Register64(0xe9bcd341, 0x572a1208),
       |  Register64(0x14112586, 0x43cce58a),
       |  Register64(0x9144c5fe, 0xa4c6e0a4),
       |  Register64(0x0d33d065, 0x65cf620f),
       |  Register64(0x54a48d48, 0x9f219ca1),
       |  Register64(0xc43e5eac, 0x6d63c821),
       |  Register64(0xa9728b3a, 0x72770daf),
       |  Register64(0xd7934e7b, 0x20df87ef),
       |  Register64(0xe35503b6, 0x1a3e86e5),
       |  Register64(0xcae321fb, 0xc819d504),
       |  Register64(0x129a50b3, 0xac60bfa6),
       |  Register64(0xcd5e68ea, 0x7e9fb6c3),
       |  Register64(0xb01c9019, 0x9483b1c7),
       |  Register64(0x3de93cd5, 0xc295376c),
       |  Register64(0xaed52edf, 0x2ab9ad13),
       |  Register64(0x2e60f512, 0xc0a07884),
       |  Register64(0xbc3d86a3, 0xe36210c9),
       |  Register64(0x35269d9b, 0x163951ce),
       |  Register64(0x0c7d6e2a, 0xd0cdb5fa),
       |  Register64(0x59e86297, 0xd87f5733),
       |  Register64(0x298ef221, 0x898db0e7),
       |  Register64(0x55000029, 0xd1a5aa7e),
       |  Register64(0x8bc08ae1, 0xb5061b45),
       |  Register64(0xc2c31c2b, 0x6c92703a),
       |  Register64(0x94cc596b, 0xaf25ef42),
       |  Register64(0x0a1d73db, 0x22540456),
       |  Register64(0x04b6a0f9, 0xd9c4179a),
       |  Register64(0xeffdafa2, 0xae3d3c60),
       |  Register64(0xf7c8075b, 0xb49496c4),
       |  Register64(0x9cc5c714, 0x1d1cd4e3),
       |  Register64(0x78bd1638, 0x218e5534),
       |  Register64(0xb2f11568, 0xf850246a),
       |  Register64(0xedfabcfa, 0x9502bc29),
       |  Register64(0x796ce5f2, 0xda23051b),
       |  Register64(0xaae128b0, 0xdc93537c),
       |  Register64(0x3a493da0, 0xee4b29ae),
       |  Register64(0xb5df6b2c, 0x416895d7),
       |  Register64(0xfcabbd25, 0x122d7f37),
       |  Register64(0x70810b58, 0x105dc4b1),
       |  Register64(0xe10fdd37, 0xf7882a90),
       |  Register64(0x524dcab5, 0x518a3f5c),
       |  Register64(0x3c9e8587, 0x8451255b),
       |  Register64(0x40298281, 0x19bd34e2),
       |  Register64(0x74a05b6f, 0x5d3ceccb),
       |  Register64(0xb6100215, 0x42e13eca),
       |  Register64(0x0ff979d1, 0x2f59e2ac),
       |  Register64(0x6037da27, 0xe4f9cc50),
       |  Register64(0x5e92975a, 0x0df1847d),
       |  Register64(0xd66de190, 0xd3e623fe),
       |  Register64(0x5032d6b8, 0x7b568048),
       |  Register64(0x9a36b7ce, 0x8235216e),
       |  Register64(0x80272a7a, 0x24f64b4a),
       |  Register64(0x93efed8b, 0x8c6916f7),
       |  Register64(0x37ddbff4, 0x4cce1555),
       |  Register64(0x4b95db5d, 0x4b99bd25),
       |  Register64(0x92d3fda1, 0x69812fc0),
       |  Register64(0xfb1a4a9a, 0x90660bb6),
       |  Register64(0x730c1969, 0x46a4b9b2),
       |  Register64(0x81e289aa, 0x7f49da68),
       |  Register64(0x64669a0f, 0x83b1a05f),
       |  Register64(0x27b3ff7d, 0x9644f48b),
       |  Register64(0xcc6b615c, 0x8db675b3),
       |  Register64(0x674f20b9, 0xbcebbe95),
       |  Register64(0x6f312382, 0x75655982),
       |  Register64(0x5ae48871, 0x3e45cf05),
       |  Register64(0xbf619f99, 0x54c21157),
       |  Register64(0xeabac460, 0x40a8eae9),
       |  Register64(0x454c6fe9, 0xf2c0c1cd),
       |  Register64(0x419cf649, 0x6412691c),
       |  Register64(0xd3dc3bef, 0x265b0f70),
       |  Register64(0x6d0e60f5, 0xc3578a9e),
       |];
       |
      0|final _t4 = [
       |  Register64(0x5b0e6085, 0x26323c55),
       |  Register64(0x1a46c1a9, 0xfa1b59f5),
       |  Register64(0xa9e245a1, 0x7c4c8ffa),
       |  Register64(0x65ca5159, 0xdb2955d7),
       |  Register64(0x05db0a76, 0xce35afc2),
       |  Register64(0x81eac77e, 0xa9113d45),
       |  Register64(0x528ef88a, 0xb6ac0a0d),
       |  Register64(0xa09ea253, 0x597be3ff),
       |  Register64(0x430ddfb3, 0xac48cd56),
       |  Register64(0xc4b3a67a, 0xf45ce46f),
       |  Register64(0x4ececfd8, 0xfbe2d05e),
       |  Register64(0x3ef56f10, 0xb39935f0),
       |  Register64(0x0b22d682, 0x9cd619c6),
       |  Register64(0x17fd460a, 0x74df2069),
       |  Register64(0x6cf8cc8e, 0x8510ed40),
       |  Register64(0xd6c824bf, 0x3a6ecaa7),
       |  Register64(0x61243d58, 0x1a817049),
       |  Register64(0x048bacb6, 0xbbc163a2),
       |  Register64(0xd9a38ac2, 0x7d44cc32),
       |  Register64(0x7fddff5b, 0xaaf410ab),
       |  Register64(0xad6d495a, 0xa804824b),
       |  Register64(0xe1a6a74f, 0x2d8c9f94),
       |  Register64(0xd4f78512, 0x35dee8e3),
       |  Register64(0xfd4b7f88, 0x6540d893),
       |  Register64(0x247c2004, 0x2aa4bfda),
       |  Register64(0x096ea1c5, 0x17d1327c),
       |  Register64(0xd56966b4, 0x361a6685),
       |  Register64(0x277da5c3, 0x1221057d),
       |  Register64(0x94d59893, 0xa43acff7),
       |  Register64(0x64f0c51c, 0xcdc02281),
       |  Register64(0x3d33bcc4, 0xff6189db),
       |  Register64(0xe005cb18, 0x4ce66af1),
       |  Register64(0xff5ccd1d, 0x1db99bea),
       |  Register64(0xb0b854a7, 0xfe42980f),
       |  Register64(0x7bd46a6a, 0x718d4b9f),
       |  Register64(0xd10fa8cc, 0x22a5fd8c),
       |  Register64(0xd3148495, 0x2be4bd31),
       |  Register64(0xc7fa975f, 0xcb243847),
       |  Register64(0x4886ed1e, 0x5846c407),
       |  Register64(0x28cddb79, 0x1eb70b04),
       |  Register64(0xc2b00be2, 0xf573417f),
       |  Register64(0x5c959045, 0x2180f877),
       |  Register64(0x7a6bddff, 0xf370eb00),
       |  Register64(0xce509e38, 0xd6d9d6a4),
       |  Register64(0xebeb0f00, 0x647fa702),
       |  Register64(0x1dcc06cf, 0x76606f06),
       |  Register64(0xe4d9f28b, 0xa286ff0a),
       |  Register64(0xd85a305d, 0xc918c262),
       |  Register64(0x475b1d87, 0x32225f54),
       |  Register64(0x2d4fb516, 0x68ccb5fe),
       |  Register64(0xa679b9d9, 0xd72bba20),
       |  Register64(0x53841c0d, 0x912d43a5),
       |  Register64(0x3b7eaa48, 0xbf12a4e8),
       |  Register64(0x781e0e47, 0xf22f1ddf),
       |  Register64(0xeff20ce6, 0x0ab50973),
       |  Register64(0x20d261d1, 0x9dffb742),
       |  Register64(0x16a12b03, 0x062a2e39),
       |  Register64(0x1960eb22, 0x39650495),
       |  Register64(0x251c16fe, 0xd50eb8b8),
       |  Register64(0x9ac0c330, 0xf826016e),
       |  Register64(0xed152665, 0x953e7671),
       |  Register64(0x02d63194, 0xa6369570),
       |  Register64(0x5074f083, 0x94b1c987),
       |  Register64(0x70ba598c, 0x90b25ce1),
       |  Register64(0x794a1581, 0x0b9742f6),
       |  Register64(0x0d5925e9, 0xfcaf8c6c),
       |  Register64(0x3067716c, 0xd868744e),
       |  Register64(0x910ab077, 0xe8d7731b),
       |  Register64(0x6a61bbdb, 0x5ac42f61),
       |  Register64(0x93513efb, 0xf0851567),
       |  Register64(0xf494724b, 0x9e83e9d5),
       |  Register64(0xe887e198, 0x5c09648d),
       |  Register64(0x34b1d3c6, 0x75370cfd),
       |  Register64(0xdc35e433, 0xbc0d255d),
       |  Register64(0xd0aab842, 0x34131be0),
       |  Register64(0x08042a50, 0xb48b7eaf),
       |  Register64(0x9997c4ee, 0x44a3ab35),
       |  Register64(0x829a7b49, 0x201799d0),
       |  Register64(0x263b8307, 0xb7c54441),
       |  Register64(0x752f95f4, 0xfd6a6ca6),
       |  Register64(0x92721740, 0x2c08c6e5),
       |  Register64(0x2a8ab754, 0xa795d9ee),
       |  Register64(0xa442f755, 0x2f72943d),
       |  Register64(0x2c31334e, 0x19781208),
       |  Register64(0x4fa98d7c, 0xeaee6291),
       |  Register64(0x55c3862f, 0x665db309),
       |  Register64(0xbd061017, 0x5d53b1f3),
       |  Register64(0x46fe6cb8, 0x40413f27),
       |  Register64(0x3fe03792, 0xdf0cfa59),
       |  Register64(0xcfe70037, 0x2eb85e8f),
       |  Register64(0xa7be29e7, 0xadbce118),
       |  Register64(0xe544ee5c, 0xde8431dd),
       |  Register64(0x8a781b1b, 0x41f1873e),
       |  Register64(0xa5c94c78, 0xa0d2f0e7),
       |  Register64(0x39412e28, 0x77b60728),
       |  Register64(0xa1265ef3, 0xafc9a62c),
       |  Register64(0xbcc2770c, 0x6a2506c5),
       |  Register64(0x3ab66dd5, 0xdce1ce12),
       |  Register64(0xe65499d0, 0x4a675b37),
       |  Register64(0x7d8f5234, 0x81bfd216),
       |  Register64(0x0f6f64fc, 0xec15f389),
       |  Register64(0x74efbe61, 0x8b5b13c8),
       |  Register64(0xacdc82b7, 0x14273e1d),
       |  Register64(0xdd40bfe0, 0x03199d17),
       |  Register64(0x37e99257, 0xe7e061f8),
       |  Register64(0xfa526269, 0x04775aaa),
       |  Register64(0x8bbbf63a, 0x463d56f9),
       |  Register64(0xf0013f15, 0x43a26e64),
       |  Register64(0xa8307e9f, 0x879ec898),
       |  Register64(0xcc4c27a4, 0x150177cc),
       |  Register64(0x1b432f2c, 0xca1d3348),
       |  Register64(0xde1d1f8f, 0x9f6fa013),
       |  Register64(0x606602a0, 0x47a7ddd6),
       |  Register64(0xd237ab64, 0xcc1cb2c7),
       |  Register64(0x9b938e72, 0x25fcd1d3),
       |  Register64(0xec4e0370, 0x8e0ff476),
       |  Register64(0xfeb2fbda, 0x3d03c12d),
       |  Register64(0xae0bced2, 0xee43889a),
       |  Register64(0x22cb8923, 0xebfb4f43),
       |  Register64(0x69360d01, 0x3cf7396d),
       |  Register64(0x855e3602, 0xd2d4e022),
       |  Register64(0x073805ba, 0xd01f784c),
       |  Register64(0x33e17a13, 0x3852f546),
       |  Register64(0xdf487405, 0x8ac7b638),
       |  Register64(0xba92b29c, 0x678aa14a),
       |  Register64(0x0ce89fc7, 0x6cfaadcd),
       |  Register64(0x5f9d4e09, 0x08339e34),
       |  Register64(0xf1afe929, 0x1f5923b9),
       |  Register64(0x6e3480f6, 0x0f4a265f),
       |  Register64(0xeebf3a2a, 0xb29b841c),
       |  Register64(0xe21938a8, 0x8f91b4ad),
       |  Register64(0x57dfeff8, 0x45c6d3c3),
       |  Register64(0x2f006b0b, 0xf62caaf2),
       |  Register64(0x62f479ef, 0x6f75ee78),
       |  Register64(0x11a55ad4, 0x1c8916a9),
       |  Register64(0xf229d290, 0x84fed453),
       |  Register64(0x42f1c27b, 0x16b000e6),
       |  Register64(0x2b1f7674, 0x9823c074),
       |  Register64(0x4b76eca3, 0xc2745360),
       |  Register64(0x8c98f463, 0xb91691bd),
       |  Register64(0x14bcc93c, 0xf1ade66a),
       |  Register64(0x8885213e, 0x6d458397),
       |  Register64(0x8e177df0, 0x274d4711),
       |  Register64(0xb49b73b5, 0x503f2951),
       |  Register64(0x10168168, 0xc3f96b6b),
       |  Register64(0x0e3d963b, 0x63cab0ae),
       |  Register64(0x8dfc4b56, 0x55a1db14),
       |  Register64(0xf789f135, 0x6e14de5c),
       |  Register64(0x683e68af, 0x4e51dac1),
       |  Register64(0xc9a84f9d, 0x8d4b0fd9),
       |  Register64(0x3691e03f, 0x52a0f9d1),
       |  Register64(0x5ed86e46, 0xe1878e80),
       |  Register64(0x3c711a0e, 0x99d07150),
       |  Register64(0x5a0865b2, 0x0c4e9310),
       |  Register64(0x56fbfc1f, 0xe4f0682e),
       |  Register64(0xea8d5de3, 0x105edf9b),
       |  Register64(0x71abfdb1, 0x2379187a),
       |  Register64(0x2eb99de1, 0xbee77b9c),
       |  Register64(0x21ecc0ea, 0x33cf4523),
       |  Register64(0x59a4d752, 0x1805c7a1),
       |  Register64(0x3896f5eb, 0x56ae7c72),
       |  Register64(0xaa638f3d, 0xb18f75dc),
       |  Register64(0x9f39358d, 0xabe9808e),
       |  Register64(0xb7defa91, 0xc00b72ac),
       |  Register64(0x6b5541fd, 0x62492d92),
       |  Register64(0x6dc6dee8, 0xf92e4d5b),
       |  Register64(0x353f57ab, 0xc4beea7e),
       |  Register64(0x735769d6, 0xda5690ce),
       |  Register64(0x0a234aa6, 0x42391484),
       |  Register64(0xf6f95080, 0x28f80d9d),
       |  Register64(0xb8e319a2, 0x7ab3f215),
       |  Register64(0x31ad9c11, 0x51341a4d),
       |  Register64(0x773c22a5, 0x7bef5805),
       |  Register64(0x45c7561a, 0x07968633),
       |  Register64(0xf913da9e, 0x249dbe36),
       |  Register64(0xda652d9b, 0x78a64c68),
       |  Register64(0x4c27a97f, 0x3bc334ef),
       |  Register64(0x76621220, 0xe66b17f4),
       |  Register64(0x96774389, 0x9acd7d0b),
       |  Register64(0xf3ee5bca, 0xe0ed6782),
       |  Register64(0x409f7536, 0x00c879fc),
       |  Register64(0x06d09a39, 0xb5926db6),
       |  Register64(0x6f83aeb0, 0x317ac588),
       |  Register64(0x01e6ca4a, 0x86381f21),
       |  Register64(0x66ff3462, 0xd19f3025),
       |  Register64(0x72207c24, 0xddfd3bfb),
       |  Register64(0x4af6b6d3, 0xe2ece2eb),
       |  Register64(0x9c994dbe, 0xc7ea08de),
       |  Register64(0x49ace597, 0xb09a8bc4),
       |  Register64(0xb38c4766, 0xcf0797ba),
       |  Register64(0x131b9373, 0xc57c2a75),
       |  Register64(0xb1822cce, 0x61931e58),
       |  Register64(0x9d7555b9, 0x09ba1c0c),
       |  Register64(0x127fafdd, 0x937d11d2),
       |  Register64(0x29da3bad, 0xc66d92e4),
       |  Register64(0xa2c1d571, 0x54c2ecbc),
       |  Register64(0x58c5134d, 0x82f6fe24),
       |  Register64(0x1c3ae351, 0x5b62274f),
       |  Register64(0xe907c82e, 0x01cb8126),
       |  Register64(0xf8ed0919, 0x13e37fcb),
       |  Register64(0x3249d8f9, 0xc80046c9),
       |  Register64(0x80cf9bed, 0xe388fb63),
       |  Register64(0x1881539a, 0x116cf19e),
       |  Register64(0x5103f3f7, 0x6bd52457),
       |  Register64(0x15b7e6f5, 0xae47f7a8),
       |  Register64(0xdbd7c6de, 0xd47e9ccf),
       |  Register64(0x44e55c41, 0x0228bb1a),
       |  Register64(0xb647d425, 0x5edb4e99),
       |  Register64(0x5d11882b, 0xb8aafc30),
       |  Register64(0xf5098bbb, 0x29d3212a),
       |  Register64(0x8fb5ea14, 0xe90296b3),
       |  Register64(0x677b9421, 0x57dd025a),
       |  Register64(0xfb58e7c0, 0xa390acb5),
       |  Register64(0x89d3674c, 0x83bd4a01),
       |  Register64(0x9e2da4df, 0x4bf3b93b),
       |  Register64(0xfcc41e32, 0x8cab4829),
       |  Register64(0x03f38c96, 0xba582c52),
       |  Register64(0xcad1bdbd, 0x7fd85db2),
       |  Register64(0xbbb442c1, 0x6082ae83),
       |  Register64(0xb95fe86b, 0xa5da9ab0),
       |  Register64(0xb22e0467, 0x3771a93f),
       |  Register64(0x845358c9, 0x493152d8),
       |  Register64(0xbe2a4886, 0x97b4541e),
       |  Register64(0x95a2dc2d, 0xd38e6966),
       |  Register64(0xc02c11ac, 0x923c852b),
       |  Register64(0x2388b199, 0x0df2a87b),
       |  Register64(0x7c8008fa, 0x1b4f37be),
       |  Register64(0x1f70d0c8, 0x4d54e503),
       |  Register64(0x5490adec, 0x7ece57d4),
       |  Register64(0x002b3c27, 0xd9063a3a),
       |  Register64(0x7eaea384, 0x8030a2bf),
       |  Register64(0xc602326d, 0xed2003c0),
       |  Register64(0x83a7287d, 0x69a94086),
       |  Register64(0xc57a5fcb, 0x30f57a8a),
       |  Register64(0xb56844e4, 0x79ebe779),
       |  Register64(0xa373b40f, 0x05dcbce9),
       |  Register64(0xd71a786e, 0x88570ee2),
       |  Register64(0x879cbacd, 0xbde8f6a0),
       |  Register64(0x976ad1bc, 0xc164a32f),
       |  Register64(0xab21e25e, 0x9666d78b),
       |  Register64(0x901063aa, 0xe5e5c33c),
       |  Register64(0x9818b344, 0x48698d90),
       |  Register64(0xe36487ae, 0x3e1e8abb),
       |  Register64(0xafbdf931, 0x893bdcb4),
       |  Register64(0x6345a0dc, 0x5fbbd519),
       |  Register64(0x8628fe26, 0x9b9465ca),
       |  Register64(0x1e5d0160, 0x3f9c51ec),
       |  Register64(0x4de44006, 0xa15049b7),
       |  Register64(0xbf6c70e5, 0xf776cbb1),
       |  Register64(0x411218f2, 0xef552bed),
       |  Register64(0xcb0c0708, 0x705a36a3),
       |  Register64(0xe74d1475, 0x4f986044),
       |  Register64(0xcd56d943, 0x0ea8280e),
       |  Register64(0xc12591d7, 0x535f5065),
       |  Register64(0xc83223f1, 0x720aef96),
       |  Register64(0xc3a0396f, 0x7363a51f),
       |];
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/whirlpool.dart
       |// See file LICENSE for more information.
       |
       |library impl.digest.whirlpool;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_digest.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of Whirlpool digest.
       |class WhirlpoolDigest extends BaseDigest implements Digest {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Digest, 'Whirlpool', () => WhirlpoolDigest());
       |
       |  static const _DIGEST_lENGTH_BYTES = 512 ~/ 8;
       |  static const _BUFFER_SIZE = 64;
       |  static const _ROUNDS = 10;
      0|  static final _r64Zero = Register64(0);
       |
      0|  static final _zerosList = Uint8List(_BUFFER_SIZE);
       |
       |  final _buffer = Uint8List(_BUFFER_SIZE);
       |  int _bufferPos = 0;
       |
       |  final _bitCount = Register64List(4);
       |
       |  final _hash = Register64List(8);
       |  final _k = Register64List(8);
       |  final _l = Register64List(8);
       |  final _block = Register64List(8);
       |  final _state = Register64List(8);
       |
      0|  WhirlpoolDigest() {
      0|    reset();
       |  }
       |
       |  @override
       |  final algorithmName = 'Whirlpool';
       |  @override
       |  final digestSize = _DIGEST_lENGTH_BYTES;
       |
      0|  @override
       |  void reset() {
      0|    _bufferPos = 0;
      0|    _buffer.fillRange(0, _buffer.length, 0);
       |
      0|    _bitCount.fillRange(0, _bitCount.length, 0);
       |
      0|    _hash.fillRange(0, _hash.length, 0);
      0|    _k.fillRange(0, _k.length, 0);
      0|    _l.fillRange(0, _l.length, 0);
      0|    _block.fillRange(0, _block.length, 0);
      0|    _state.fillRange(0, _state.length, 0);
       |  }
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    _buffer[_bufferPos++] = inp;
       |
      0|    if (_bufferPos == _buffer.length) {
      0|      _processFilledBuffer(_buffer, 0);
       |    }
       |
      0|    _increment();
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
      0|    for (var i = 0; i < len; i++) {
      0|      _buffer[_bufferPos++] = inp[inpOff + i];
       |
      0|      if (_bufferPos == _buffer.length) {
      0|        _processFilledBuffer(_buffer, 0);
       |      }
       |    }
       |
      0|    _increment(len * 8);
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    _finish();
       |
      0|    for (var i = 0; i < 8; i++) {
      0|      _hash[i].pack(out, outOff + (i * 8), Endian.big);
       |    }
       |
      0|    reset();
       |
      0|    return digestSize;
       |  }
       |
      0|  void _processFilledBuffer(Uint8List inp, int inpOff) {
      0|    for (var i = 0; i < _state.length; i++) {
      0|      _block[i].unpack(_buffer, i * 8, Endian.big);
       |    }
       |
      0|    _processBlock();
       |
      0|    _bufferPos = 0;
      0|    _buffer.fillRange(0, _buffer.length, 0);
       |  }
       |
      0|  void _processBlock() {
       |    // compute and apply K^0
      0|    for (var i = 0; i < 8; i++) {
      0|      _k[i].set(_hash[i]);
      0|      _state[i]
      0|        ..set(_block[i])
      0|        ..xor(_k[i]);
       |    }
       |
       |    // iterate over the rounds
      0|    for (var round = 1; round <= _ROUNDS; round++) {
      0|      for (var i = 0; i < 8; i++) {
      0|        _l[i].set(0);
      0|        _l[i].xor(_c0[clip8(_k[(i - 0) & 7].hi32 >> 24)]);
      0|        _l[i].xor(_c1[clip8(_k[(i - 1) & 7].hi32 >> 16)]);
      0|        _l[i].xor(_c2[clip8(_k[(i - 2) & 7].hi32 >> 8)]);
      0|        _l[i].xor(_c3[clip8(_k[(i - 3) & 7].hi32)]);
      0|        _l[i].xor(_c4[clip8(_k[(i - 4) & 7].lo32 >> 24)]);
      0|        _l[i].xor(_c5[clip8(_k[(i - 5) & 7].lo32 >> 16)]);
      0|        _l[i].xor(_c6[clip8(_k[(i - 6) & 7].lo32 >> 8)]);
      0|        _l[i].xor(_c7[clip8(_k[(i - 7) & 7].lo32)]);
       |      }
       |
      0|      _k.setRange(0, _k.length, _l);
       |
      0|      _k[0].xor(_rc[round]);
       |
       |      // apply the round transformation
      0|      for (var i = 0; i < 8; i++) {
      0|        _l[i].set(_k[i]);
      0|        _l[i].xor(_c0[clip8(_state[(i - 0) & 7].hi32 >> 24)]);
      0|        _l[i].xor(_c1[clip8(_state[(i - 1) & 7].hi32 >> 16)]);
      0|        _l[i].xor(_c2[clip8(_state[(i - 2) & 7].hi32 >> 8)]);
      0|        _l[i].xor(_c3[clip8(_state[(i - 3) & 7].hi32)]);
      0|        _l[i].xor(_c4[clip8(_state[(i - 4) & 7].lo32 >> 24)]);
      0|        _l[i].xor(_c5[clip8(_state[(i - 5) & 7].lo32 >> 16)]);
      0|        _l[i].xor(_c6[clip8(_state[(i - 6) & 7].lo32 >> 8)]);
      0|        _l[i].xor(_c7[clip8(_state[(i - 7) & 7].lo32)]);
       |      }
       |
       |      // save the current state
      0|      _state.setRange(0, _state.length, _l);
       |    }
       |
       |    // apply Miuaguchi-Preneel compression
      0|    final r = Register64();
      0|    for (var i = 0; i < 8; i++) {
      0|      _hash[i].xor(r
      0|        ..set(_state[i])
      0|        ..xor(_block[i]));
       |    }
       |  }
       |
      0|  void _increment([int bits = 8]) {
       |    assert(bits <= 0xFFFFFFFF);
       |
      0|    var i = (_bitCount.length - 1);
      0|    _bitCount[i].sum(bits);
       |
      0|    while (_bitCount[i] == _r64Zero) {
      0|      i--;
      0|      _bitCount[i].sum(1);
       |    }
       |  }
       |
      0|  void _finish() {
       |    /*
       |     * this makes a copy of the current bit length. at the expense of an
       |     * object creation of 32 bytes rather than providing a _stopCounting
       |     * boolean which was the alternative I could think of.
       |     */
      0|    final bitLength = _copyBitLength();
       |
       |    // Add padding
      0|    _buffer[_bufferPos++] |= 0x80;
       |
      0|    if (_bufferPos == _buffer.length) {
      0|      _processFilledBuffer(_buffer, 0);
       |    }
       |
      0|    if (_bufferPos > 32) {
      0|      final padCount = (_buffer.length - _bufferPos);
      0|      update(_zerosList, 0, padCount);
       |    } else {
      0|      final padCount = (32 - _bufferPos);
      0|      update(_zerosList, 0, padCount);
       |    }
       |
       |    // Add the length information to the final 32 bytes of the 64 byte block
      0|    _buffer.setRange(32, 32 + bitLength.length, bitLength);
       |
       |    // Process final block
      0|    _processFilledBuffer(_buffer, 0);
       |  }
       |
      0|  Uint8List _copyBitLength() {
      0|    final rv = Uint8List(_bitCount.length * 8);
      0|    for (var i = 0; i < _bitCount.length; i++) {
      0|      _bitCount[i].pack(rv, i * 8, Endian.big);
       |    }
       |    return rv;
       |  }
       |
      0|  @override
       |  int get byteLength => 64;
       |}
       |
      0|final _c0 = Register64List.from([
       |  [0x18186018, 0xc07830d8],
       |  [0x23238c23, 0x05af4626],
       |  [0xc6c63fc6, 0x7ef991b8],
       |  [0xe8e887e8, 0x136fcdfb],
       |  [0x87872687, 0x4ca113cb],
       |  [0xb8b8dab8, 0xa9626d11],
       |  [0x01010401, 0x08050209],
       |  [0x4f4f214f, 0x426e9e0d],
       |  [0x3636d836, 0xadee6c9b],
       |  [0xa6a6a2a6, 0x590451ff],
       |  [0xd2d26fd2, 0xdebdb90c],
       |  [0xf5f5f3f5, 0xfb06f70e],
       |  [0x7979f979, 0xef80f296],
       |  [0x6f6fa16f, 0x5fcede30],
       |  [0x91917e91, 0xfcef3f6d],
       |  [0x52525552, 0xaa07a4f8],
       |  [0x60609d60, 0x27fdc047],
       |  [0xbcbccabc, 0x89766535],
       |  [0x9b9b569b, 0xaccd2b37],
       |  [0x8e8e028e, 0x048c018a],
       |  [0xa3a3b6a3, 0x71155bd2],
       |  [0x0c0c300c, 0x603c186c],
       |  [0x7b7bf17b, 0xff8af684],
       |  [0x3535d435, 0xb5e16a80],
       |  [0x1d1d741d, 0xe8693af5],
       |  [0xe0e0a7e0, 0x5347ddb3],
       |  [0xd7d77bd7, 0xf6acb321],
       |  [0xc2c22fc2, 0x5eed999c],
       |  [0x2e2eb82e, 0x6d965c43],
       |  [0x4b4b314b, 0x627a9629],
       |  [0xfefedffe, 0xa321e15d],
       |  [0x57574157, 0x8216aed5],
       |  [0x15155415, 0xa8412abd],
       |  [0x7777c177, 0x9fb6eee8],
       |  [0x3737dc37, 0xa5eb6e92],
       |  [0xe5e5b3e5, 0x7b56d79e],
       |  [0x9f9f469f, 0x8cd92313],
       |  [0xf0f0e7f0, 0xd317fd23],
       |  [0x4a4a354a, 0x6a7f9420],
       |  [0xdada4fda, 0x9e95a944],
       |  [0x58587d58, 0xfa25b0a2],
       |  [0xc9c903c9, 0x06ca8fcf],
       |  [0x2929a429, 0x558d527c],
       |  [0x0a0a280a, 0x5022145a],
       |  [0xb1b1feb1, 0xe14f7f50],
       |  [0xa0a0baa0, 0x691a5dc9],
       |  [0x6b6bb16b, 0x7fdad614],
       |  [0x85852e85, 0x5cab17d9],
       |  [0xbdbdcebd, 0x8173673c],
       |  [0x5d5d695d, 0xd234ba8f],
       |  [0x10104010, 0x80502090],
       |  [0xf4f4f7f4, 0xf303f507],
       |  [0xcbcb0bcb, 0x16c08bdd],
       |  [0x3e3ef83e, 0xedc67cd3],
       |  [0x05051405, 0x28110a2d],
       |  [0x67678167, 0x1fe6ce78],
       |  [0xe4e4b7e4, 0x7353d597],
       |  [0x27279c27, 0x25bb4e02],
       |  [0x41411941, 0x32588273],
       |  [0x8b8b168b, 0x2c9d0ba7],
       |  [0xa7a7a6a7, 0x510153f6],
       |  [0x7d7de97d, 0xcf94fab2],
       |  [0x95956e95, 0xdcfb3749],
       |  [0xd8d847d8, 0x8e9fad56],
       |  [0xfbfbcbfb, 0x8b30eb70],
       |  [0xeeee9fee, 0x2371c1cd],
       |  [0x7c7ced7c, 0xc791f8bb],
       |  [0x66668566, 0x17e3cc71],
       |  [0xdddd53dd, 0xa68ea77b],
       |  [0x17175c17, 0xb84b2eaf],
       |  [0x47470147, 0x02468e45],
       |  [0x9e9e429e, 0x84dc211a],
       |  [0xcaca0fca, 0x1ec589d4],
       |  [0x2d2db42d, 0x75995a58],
       |  [0xbfbfc6bf, 0x9179632e],
       |  [0x07071c07, 0x381b0e3f],
       |  [0xadad8ead, 0x012347ac],
       |  [0x5a5a755a, 0xea2fb4b0],
       |  [0x83833683, 0x6cb51bef],
       |  [0x3333cc33, 0x85ff66b6],
       |  [0x63639163, 0x3ff2c65c],
       |  [0x02020802, 0x100a0412],
       |  [0xaaaa92aa, 0x39384993],
       |  [0x7171d971, 0xafa8e2de],
       |  [0xc8c807c8, 0x0ecf8dc6],
       |  [0x19196419, 0xc87d32d1],
       |  [0x49493949, 0x7270923b],
       |  [0xd9d943d9, 0x869aaf5f],
       |  [0xf2f2eff2, 0xc31df931],
       |  [0xe3e3abe3, 0x4b48dba8],
       |  [0x5b5b715b, 0xe22ab6b9],
       |  [0x88881a88, 0x34920dbc],
       |  [0x9a9a529a, 0xa4c8293e],
       |  [0x26269826, 0x2dbe4c0b],
       |  [0x3232c832, 0x8dfa64bf],
       |  [0xb0b0fab0, 0xe94a7d59],
       |  [0xe9e983e9, 0x1b6acff2],
       |  [0x0f0f3c0f, 0x78331e77],
       |  [0xd5d573d5, 0xe6a6b733],
       |  [0x80803a80, 0x74ba1df4],
       |  [0xbebec2be, 0x997c6127],
       |  [0xcdcd13cd, 0x26de87eb],
       |  [0x3434d034, 0xbde46889],
       |  [0x48483d48, 0x7a759032],
       |  [0xffffdbff, 0xab24e354],
       |  [0x7a7af57a, 0xf78ff48d],
       |  [0x90907a90, 0xf4ea3d64],
       |  [0x5f5f615f, 0xc23ebe9d],
       |  [0x20208020, 0x1da0403d],
       |  [0x6868bd68, 0x67d5d00f],
       |  [0x1a1a681a, 0xd07234ca],
       |  [0xaeae82ae, 0x192c41b7],
       |  [0xb4b4eab4, 0xc95e757d],
       |  [0x54544d54, 0x9a19a8ce],
       |  [0x93937693, 0xece53b7f],
       |  [0x22228822, 0x0daa442f],
       |  [0x64648d64, 0x07e9c863],
       |  [0xf1f1e3f1, 0xdb12ff2a],
       |  [0x7373d173, 0xbfa2e6cc],
       |  [0x12124812, 0x905a2482],
       |  [0x40401d40, 0x3a5d807a],
       |  [0x08082008, 0x40281048],
       |  [0xc3c32bc3, 0x56e89b95],
       |  [0xecec97ec, 0x337bc5df],
       |  [0xdbdb4bdb, 0x9690ab4d],
       |  [0xa1a1bea1, 0x611f5fc0],
       |  [0x8d8d0e8d, 0x1c830791],
       |  [0x3d3df43d, 0xf5c97ac8],
       |  [0x97976697, 0xccf1335b],
       |  [0x00000000, 0x00000000],
       |  [0xcfcf1bcf, 0x36d483f9],
       |  [0x2b2bac2b, 0x4587566e],
       |  [0x7676c576, 0x97b3ece1],
       |  [0x82823282, 0x64b019e6],
       |  [0xd6d67fd6, 0xfea9b128],
       |  [0x1b1b6c1b, 0xd87736c3],
       |  [0xb5b5eeb5, 0xc15b7774],
       |  [0xafaf86af, 0x112943be],
       |  [0x6a6ab56a, 0x77dfd41d],
       |  [0x50505d50, 0xba0da0ea],
       |  [0x45450945, 0x124c8a57],
       |  [0xf3f3ebf3, 0xcb18fb38],
       |  [0x3030c030, 0x9df060ad],
       |  [0xefef9bef, 0x2b74c3c4],
       |  [0x3f3ffc3f, 0xe5c37eda],
       |  [0x55554955, 0x921caac7],
       |  [0xa2a2b2a2, 0x791059db],
       |  [0xeaea8fea, 0x0365c9e9],
       |  [0x65658965, 0x0fecca6a],
       |  [0xbabad2ba, 0xb9686903],
       |  [0x2f2fbc2f, 0x65935e4a],
       |  [0xc0c027c0, 0x4ee79d8e],
       |  [0xdede5fde, 0xbe81a160],
       |  [0x1c1c701c, 0xe06c38fc],
       |  [0xfdfdd3fd, 0xbb2ee746],
       |  [0x4d4d294d, 0x52649a1f],
       |  [0x92927292, 0xe4e03976],
       |  [0x7575c975, 0x8fbceafa],
       |  [0x06061806, 0x301e0c36],
       |  [0x8a8a128a, 0x249809ae],
       |  [0xb2b2f2b2, 0xf940794b],
       |  [0xe6e6bfe6, 0x6359d185],
       |  [0x0e0e380e, 0x70361c7e],
       |  [0x1f1f7c1f, 0xf8633ee7],
       |  [0x62629562, 0x37f7c455],
       |  [0xd4d477d4, 0xeea3b53a],
       |  [0xa8a89aa8, 0x29324d81],
       |  [0x96966296, 0xc4f43152],
       |  [0xf9f9c3f9, 0x9b3aef62],
       |  [0xc5c533c5, 0x66f697a3],
       |  [0x25259425, 0x35b14a10],
       |  [0x59597959, 0xf220b2ab],
       |  [0x84842a84, 0x54ae15d0],
       |  [0x7272d572, 0xb7a7e4c5],
       |  [0x3939e439, 0xd5dd72ec],
       |  [0x4c4c2d4c, 0x5a619816],
       |  [0x5e5e655e, 0xca3bbc94],
       |  [0x7878fd78, 0xe785f09f],
       |  [0x3838e038, 0xddd870e5],
       |  [0x8c8c0a8c, 0x14860598],
       |  [0xd1d163d1, 0xc6b2bf17],
       |  [0xa5a5aea5, 0x410b57e4],
       |  [0xe2e2afe2, 0x434dd9a1],
       |  [0x61619961, 0x2ff8c24e],
       |  [0xb3b3f6b3, 0xf1457b42],
       |  [0x21218421, 0x15a54234],
       |  [0x9c9c4a9c, 0x94d62508],
       |  [0x1e1e781e, 0xf0663cee],
       |  [0x43431143, 0x22528661],
       |  [0xc7c73bc7, 0x76fc93b1],
       |  [0xfcfcd7fc, 0xb32be54f],
       |  [0x04041004, 0x20140824],
       |  [0x51515951, 0xb208a2e3],
       |  [0x99995e99, 0xbcc72f25],
       |  [0x6d6da96d, 0x4fc4da22],
       |  [0x0d0d340d, 0x68391a65],
       |  [0xfafacffa, 0x8335e979],
       |  [0xdfdf5bdf, 0xb684a369],
       |  [0x7e7ee57e, 0xd79bfca9],
       |  [0x24249024, 0x3db44819],
       |  [0x3b3bec3b, 0xc5d776fe],
       |  [0xabab96ab, 0x313d4b9a],
       |  [0xcece1fce, 0x3ed181f0],
       |  [0x11114411, 0x88552299],
       |  [0x8f8f068f, 0x0c890383],
       |  [0x4e4e254e, 0x4a6b9c04],
       |  [0xb7b7e6b7, 0xd1517366],
       |  [0xebeb8beb, 0x0b60cbe0],
       |  [0x3c3cf03c, 0xfdcc78c1],
       |  [0x81813e81, 0x7cbf1ffd],
       |  [0x94946a94, 0xd4fe3540],
       |  [0xf7f7fbf7, 0xeb0cf31c],
       |  [0xb9b9deb9, 0xa1676f18],
       |  [0x13134c13, 0x985f268b],
       |  [0x2c2cb02c, 0x7d9c5851],
       |  [0xd3d36bd3, 0xd6b8bb05],
       |  [0xe7e7bbe7, 0x6b5cd38c],
       |  [0x6e6ea56e, 0x57cbdc39],
       |  [0xc4c437c4, 0x6ef395aa],
       |  [0x03030c03, 0x180f061b],
       |  [0x56564556, 0x8a13acdc],
       |  [0x44440d44, 0x1a49885e],
       |  [0x7f7fe17f, 0xdf9efea0],
       |  [0xa9a99ea9, 0x21374f88],
       |  [0x2a2aa82a, 0x4d825467],
       |  [0xbbbbd6bb, 0xb16d6b0a],
       |  [0xc1c123c1, 0x46e29f87],
       |  [0x53535153, 0xa202a6f1],
       |  [0xdcdc57dc, 0xae8ba572],
       |  [0x0b0b2c0b, 0x58271653],
       |  [0x9d9d4e9d, 0x9cd32701],
       |  [0x6c6cad6c, 0x47c1d82b],
       |  [0x3131c431, 0x95f562a4],
       |  [0x7474cd74, 0x87b9e8f3],
       |  [0xf6f6fff6, 0xe309f115],
       |  [0x46460546, 0x0a438c4c],
       |  [0xacac8aac, 0x092645a5],
       |  [0x89891e89, 0x3c970fb5],
       |  [0x14145014, 0xa04428b4],
       |  [0xe1e1a3e1, 0x5b42dfba],
       |  [0x16165816, 0xb04e2ca6],
       |  [0x3a3ae83a, 0xcdd274f7],
       |  [0x6969b969, 0x6fd0d206],
       |  [0x09092409, 0x482d1241],
       |  [0x7070dd70, 0xa7ade0d7],
       |  [0xb6b6e2b6, 0xd954716f],
       |  [0xd0d067d0, 0xceb7bd1e],
       |  [0xeded93ed, 0x3b7ec7d6],
       |  [0xcccc17cc, 0x2edb85e2],
       |  [0x42421542, 0x2a578468],
       |  [0x98985a98, 0xb4c22d2c],
       |  [0xa4a4aaa4, 0x490e55ed],
       |  [0x2828a028, 0x5d885075],
       |  [0x5c5c6d5c, 0xda31b886],
       |  [0xf8f8c7f8, 0x933fed6b],
       |  [0x86862286, 0x44a411c2]
       |]);
       |
      0|final _c1 = Register64List.from([
       |  [0xd8181860, 0x18c07830],
       |  [0x2623238c, 0x2305af46],
       |  [0xb8c6c63f, 0xc67ef991],
       |  [0xfbe8e887, 0xe8136fcd],
       |  [0xcb878726, 0x874ca113],
       |  [0x11b8b8da, 0xb8a9626d],
       |  [0x09010104, 0x01080502],
       |  [0x0d4f4f21, 0x4f426e9e],
       |  [0x9b3636d8, 0x36adee6c],
       |  [0xffa6a6a2, 0xa6590451],
       |  [0x0cd2d26f, 0xd2debdb9],
       |  [0x0ef5f5f3, 0xf5fb06f7],
       |  [0x967979f9, 0x79ef80f2],
       |  [0x306f6fa1, 0x6f5fcede],
       |  [0x6d91917e, 0x91fcef3f],
       |  [0xf8525255, 0x52aa07a4],
       |  [0x4760609d, 0x6027fdc0],
       |  [0x35bcbcca, 0xbc897665],
       |  [0x379b9b56, 0x9baccd2b],
       |  [0x8a8e8e02, 0x8e048c01],
       |  [0xd2a3a3b6, 0xa371155b],
       |  [0x6c0c0c30, 0x0c603c18],
       |  [0x847b7bf1, 0x7bff8af6],
       |  [0x803535d4, 0x35b5e16a],
       |  [0xf51d1d74, 0x1de8693a],
       |  [0xb3e0e0a7, 0xe05347dd],
       |  [0x21d7d77b, 0xd7f6acb3],
       |  [0x9cc2c22f, 0xc25eed99],
       |  [0x432e2eb8, 0x2e6d965c],
       |  [0x294b4b31, 0x4b627a96],
       |  [0x5dfefedf, 0xfea321e1],
       |  [0xd5575741, 0x578216ae],
       |  [0xbd151554, 0x15a8412a],
       |  [0xe87777c1, 0x779fb6ee],
       |  [0x923737dc, 0x37a5eb6e],
       |  [0x9ee5e5b3, 0xe57b56d7],
       |  [0x139f9f46, 0x9f8cd923],
       |  [0x23f0f0e7, 0xf0d317fd],
       |  [0x204a4a35, 0x4a6a7f94],
       |  [0x44dada4f, 0xda9e95a9],
       |  [0xa258587d, 0x58fa25b0],
       |  [0xcfc9c903, 0xc906ca8f],
       |  [0x7c2929a4, 0x29558d52],
       |  [0x5a0a0a28, 0x0a502214],
       |  [0x50b1b1fe, 0xb1e14f7f],
       |  [0xc9a0a0ba, 0xa0691a5d],
       |  [0x146b6bb1, 0x6b7fdad6],
       |  [0xd985852e, 0x855cab17],
       |  [0x3cbdbdce, 0xbd817367],
       |  [0x8f5d5d69, 0x5dd234ba],
       |  [0x90101040, 0x10805020],
       |  [0x07f4f4f7, 0xf4f303f5],
       |  [0xddcbcb0b, 0xcb16c08b],
       |  [0xd33e3ef8, 0x3eedc67c],
       |  [0x2d050514, 0x0528110a],
       |  [0x78676781, 0x671fe6ce],
       |  [0x97e4e4b7, 0xe47353d5],
       |  [0x0227279c, 0x2725bb4e],
       |  [0x73414119, 0x41325882],
       |  [0xa78b8b16, 0x8b2c9d0b],
       |  [0xf6a7a7a6, 0xa7510153],
       |  [0xb27d7de9, 0x7dcf94fa],
       |  [0x4995956e, 0x95dcfb37],
       |  [0x56d8d847, 0xd88e9fad],
       |  [0x70fbfbcb, 0xfb8b30eb],
       |  [0xcdeeee9f, 0xee2371c1],
       |  [0xbb7c7ced, 0x7cc791f8],
       |  [0x71666685, 0x6617e3cc],
       |  [0x7bdddd53, 0xdda68ea7],
       |  [0xaf17175c, 0x17b84b2e],
       |  [0x45474701, 0x4702468e],
       |  [0x1a9e9e42, 0x9e84dc21],
       |  [0xd4caca0f, 0xca1ec589],
       |  [0x582d2db4, 0x2d75995a],
       |  [0x2ebfbfc6, 0xbf917963],
       |  [0x3f07071c, 0x07381b0e],
       |  [0xacadad8e, 0xad012347],
       |  [0xb05a5a75, 0x5aea2fb4],
       |  [0xef838336, 0x836cb51b],
       |  [0xb63333cc, 0x3385ff66],
       |  [0x5c636391, 0x633ff2c6],
       |  [0x12020208, 0x02100a04],
       |  [0x93aaaa92, 0xaa393849],
       |  [0xde7171d9, 0x71afa8e2],
       |  [0xc6c8c807, 0xc80ecf8d],
       |  [0xd1191964, 0x19c87d32],
       |  [0x3b494939, 0x49727092],
       |  [0x5fd9d943, 0xd9869aaf],
       |  [0x31f2f2ef, 0xf2c31df9],
       |  [0xa8e3e3ab, 0xe34b48db],
       |  [0xb95b5b71, 0x5be22ab6],
       |  [0xbc88881a, 0x8834920d],
       |  [0x3e9a9a52, 0x9aa4c829],
       |  [0x0b262698, 0x262dbe4c],
       |  [0xbf3232c8, 0x328dfa64],
       |  [0x59b0b0fa, 0xb0e94a7d],
       |  [0xf2e9e983, 0xe91b6acf],
       |  [0x770f0f3c, 0x0f78331e],
       |  [0x33d5d573, 0xd5e6a6b7],
       |  [0xf480803a, 0x8074ba1d],
       |  [0x27bebec2, 0xbe997c61],
       |  [0xebcdcd13, 0xcd26de87],
       |  [0x893434d0, 0x34bde468],
       |  [0x3248483d, 0x487a7590],
       |  [0x54ffffdb, 0xffab24e3],
       |  [0x8d7a7af5, 0x7af78ff4],
       |  [0x6490907a, 0x90f4ea3d],
       |  [0x9d5f5f61, 0x5fc23ebe],
       |  [0x3d202080, 0x201da040],
       |  [0x0f6868bd, 0x6867d5d0],
       |  [0xca1a1a68, 0x1ad07234],
       |  [0xb7aeae82, 0xae192c41],
       |  [0x7db4b4ea, 0xb4c95e75],
       |  [0xce54544d, 0x549a19a8],
       |  [0x7f939376, 0x93ece53b],
       |  [0x2f222288, 0x220daa44],
       |  [0x6364648d, 0x6407e9c8],
       |  [0x2af1f1e3, 0xf1db12ff],
       |  [0xcc7373d1, 0x73bfa2e6],
       |  [0x82121248, 0x12905a24],
       |  [0x7a40401d, 0x403a5d80],
       |  [0x48080820, 0x08402810],
       |  [0x95c3c32b, 0xc356e89b],
       |  [0xdfecec97, 0xec337bc5],
       |  [0x4ddbdb4b, 0xdb9690ab],
       |  [0xc0a1a1be, 0xa1611f5f],
       |  [0x918d8d0e, 0x8d1c8307],
       |  [0xc83d3df4, 0x3df5c97a],
       |  [0x5b979766, 0x97ccf133],
       |  [0x00000000, 0x00000000],
       |  [0xf9cfcf1b, 0xcf36d483],
       |  [0x6e2b2bac, 0x2b458756],
       |  [0xe17676c5, 0x7697b3ec],
       |  [0xe6828232, 0x8264b019],
       |  [0x28d6d67f, 0xd6fea9b1],
       |  [0xc31b1b6c, 0x1bd87736],
       |  [0x74b5b5ee, 0xb5c15b77],
       |  [0xbeafaf86, 0xaf112943],
       |  [0x1d6a6ab5, 0x6a77dfd4],
       |  [0xea50505d, 0x50ba0da0],
       |  [0x57454509, 0x45124c8a],
       |  [0x38f3f3eb, 0xf3cb18fb],
       |  [0xad3030c0, 0x309df060],
       |  [0xc4efef9b, 0xef2b74c3],
       |  [0xda3f3ffc, 0x3fe5c37e],
       |  [0xc7555549, 0x55921caa],
       |  [0xdba2a2b2, 0xa2791059],
       |  [0xe9eaea8f, 0xea0365c9],
       |  [0x6a656589, 0x650fecca],
       |  [0x03babad2, 0xbab96869],
       |  [0x4a2f2fbc, 0x2f65935e],
       |  [0x8ec0c027, 0xc04ee79d],
       |  [0x60dede5f, 0xdebe81a1],
       |  [0xfc1c1c70, 0x1ce06c38],
       |  [0x46fdfdd3, 0xfdbb2ee7],
       |  [0x1f4d4d29, 0x4d52649a],
       |  [0x76929272, 0x92e4e039],
       |  [0xfa7575c9, 0x758fbcea],
       |  [0x36060618, 0x06301e0c],
       |  [0xae8a8a12, 0x8a249809],
       |  [0x4bb2b2f2, 0xb2f94079],
       |  [0x85e6e6bf, 0xe66359d1],
       |  [0x7e0e0e38, 0x0e70361c],
       |  [0xe71f1f7c, 0x1ff8633e],
       |  [0x55626295, 0x6237f7c4],
       |  [0x3ad4d477, 0xd4eea3b5],
       |  [0x81a8a89a, 0xa829324d],
       |  [0x52969662, 0x96c4f431],
       |  [0x62f9f9c3, 0xf99b3aef],
       |  [0xa3c5c533, 0xc566f697],
       |  [0x10252594, 0x2535b14a],
       |  [0xab595979, 0x59f220b2],
       |  [0xd084842a, 0x8454ae15],
       |  [0xc57272d5, 0x72b7a7e4],
       |  [0xec3939e4, 0x39d5dd72],
       |  [0x164c4c2d, 0x4c5a6198],
       |  [0x945e5e65, 0x5eca3bbc],
       |  [0x9f7878fd, 0x78e785f0],
       |  [0xe53838e0, 0x38ddd870],
       |  [0x988c8c0a, 0x8c148605],
       |  [0x17d1d163, 0xd1c6b2bf],
       |  [0xe4a5a5ae, 0xa5410b57],
       |  [0xa1e2e2af, 0xe2434dd9],
       |  [0x4e616199, 0x612ff8c2],
       |  [0x42b3b3f6, 0xb3f1457b],
       |  [0x34212184, 0x2115a542],
       |  [0x089c9c4a, 0x9c94d625],
       |  [0xee1e1e78, 0x1ef0663c],
       |  [0x61434311, 0x43225286],
       |  [0xb1c7c73b, 0xc776fc93],
       |  [0x4ffcfcd7, 0xfcb32be5],
       |  [0x24040410, 0x04201408],
       |  [0xe3515159, 0x51b208a2],
       |  [0x2599995e, 0x99bcc72f],
       |  [0x226d6da9, 0x6d4fc4da],
       |  [0x650d0d34, 0x0d68391a],
       |  [0x79fafacf, 0xfa8335e9],
       |  [0x69dfdf5b, 0xdfb684a3],
       |  [0xa97e7ee5, 0x7ed79bfc],
       |  [0x19242490, 0x243db448],
       |  [0xfe3b3bec, 0x3bc5d776],
       |  [0x9aabab96, 0xab313d4b],
       |  [0xf0cece1f, 0xce3ed181],
       |  [0x99111144, 0x11885522],
       |  [0x838f8f06, 0x8f0c8903],
       |  [0x044e4e25, 0x4e4a6b9c],
       |  [0x66b7b7e6, 0xb7d15173],
       |  [0xe0ebeb8b, 0xeb0b60cb],
       |  [0xc13c3cf0, 0x3cfdcc78],
       |  [0xfd81813e, 0x817cbf1f],
       |  [0x4094946a, 0x94d4fe35],
       |  [0x1cf7f7fb, 0xf7eb0cf3],
       |  [0x18b9b9de, 0xb9a1676f],
       |  [0x8b13134c, 0x13985f26],
       |  [0x512c2cb0, 0x2c7d9c58],
       |  [0x05d3d36b, 0xd3d6b8bb],
       |  [0x8ce7e7bb, 0xe76b5cd3],
       |  [0x396e6ea5, 0x6e57cbdc],
       |  [0xaac4c437, 0xc46ef395],
       |  [0x1b03030c, 0x03180f06],
       |  [0xdc565645, 0x568a13ac],
       |  [0x5e44440d, 0x441a4988],
       |  [0xa07f7fe1, 0x7fdf9efe],
       |  [0x88a9a99e, 0xa921374f],
       |  [0x672a2aa8, 0x2a4d8254],
       |  [0x0abbbbd6, 0xbbb16d6b],
       |  [0x87c1c123, 0xc146e29f],
       |  [0xf1535351, 0x53a202a6],
       |  [0x72dcdc57, 0xdcae8ba5],
       |  [0x530b0b2c, 0x0b582716],
       |  [0x019d9d4e, 0x9d9cd327],
       |  [0x2b6c6cad, 0x6c47c1d8],
       |  [0xa43131c4, 0x3195f562],
       |  [0xf37474cd, 0x7487b9e8],
       |  [0x15f6f6ff, 0xf6e309f1],
       |  [0x4c464605, 0x460a438c],
       |  [0xa5acac8a, 0xac092645],
       |  [0xb589891e, 0x893c970f],
       |  [0xb4141450, 0x14a04428],
       |  [0xbae1e1a3, 0xe15b42df],
       |  [0xa6161658, 0x16b04e2c],
       |  [0xf73a3ae8, 0x3acdd274],
       |  [0x066969b9, 0x696fd0d2],
       |  [0x41090924, 0x09482d12],
       |  [0xd77070dd, 0x70a7ade0],
       |  [0x6fb6b6e2, 0xb6d95471],
       |  [0x1ed0d067, 0xd0ceb7bd],
       |  [0xd6eded93, 0xed3b7ec7],
       |  [0xe2cccc17, 0xcc2edb85],
       |  [0x68424215, 0x422a5784],
       |  [0x2c98985a, 0x98b4c22d],
       |  [0xeda4a4aa, 0xa4490e55],
       |  [0x752828a0, 0x285d8850],
       |  [0x865c5c6d, 0x5cda31b8],
       |  [0x6bf8f8c7, 0xf8933fed],
       |  [0xc2868622, 0x8644a411]
       |]);
       |
      0|final _c2 = Register64List.from([
       |  [0x30d81818, 0x6018c078],
       |  [0x46262323, 0x8c2305af],
       |  [0x91b8c6c6, 0x3fc67ef9],
       |  [0xcdfbe8e8, 0x87e8136f],
       |  [0x13cb8787, 0x26874ca1],
       |  [0x6d11b8b8, 0xdab8a962],
       |  [0x02090101, 0x04010805],
       |  [0x9e0d4f4f, 0x214f426e],
       |  [0x6c9b3636, 0xd836adee],
       |  [0x51ffa6a6, 0xa2a65904],
       |  [0xb90cd2d2, 0x6fd2debd],
       |  [0xf70ef5f5, 0xf3f5fb06],
       |  [0xf2967979, 0xf979ef80],
       |  [0xde306f6f, 0xa16f5fce],
       |  [0x3f6d9191, 0x7e91fcef],
       |  [0xa4f85252, 0x5552aa07],
       |  [0xc0476060, 0x9d6027fd],
       |  [0x6535bcbc, 0xcabc8976],
       |  [0x2b379b9b, 0x569baccd],
       |  [0x018a8e8e, 0x028e048c],
       |  [0x5bd2a3a3, 0xb6a37115],
       |  [0x186c0c0c, 0x300c603c],
       |  [0xf6847b7b, 0xf17bff8a],
       |  [0x6a803535, 0xd435b5e1],
       |  [0x3af51d1d, 0x741de869],
       |  [0xddb3e0e0, 0xa7e05347],
       |  [0xb321d7d7, 0x7bd7f6ac],
       |  [0x999cc2c2, 0x2fc25eed],
       |  [0x5c432e2e, 0xb82e6d96],
       |  [0x96294b4b, 0x314b627a],
       |  [0xe15dfefe, 0xdffea321],
       |  [0xaed55757, 0x41578216],
       |  [0x2abd1515, 0x5415a841],
       |  [0xeee87777, 0xc1779fb6],
       |  [0x6e923737, 0xdc37a5eb],
       |  [0xd79ee5e5, 0xb3e57b56],
       |  [0x23139f9f, 0x469f8cd9],
       |  [0xfd23f0f0, 0xe7f0d317],
       |  [0x94204a4a, 0x354a6a7f],
       |  [0xa944dada, 0x4fda9e95],
       |  [0xb0a25858, 0x7d58fa25],
       |  [0x8fcfc9c9, 0x03c906ca],
       |  [0x527c2929, 0xa429558d],
       |  [0x145a0a0a, 0x280a5022],
       |  [0x7f50b1b1, 0xfeb1e14f],
       |  [0x5dc9a0a0, 0xbaa0691a],
       |  [0xd6146b6b, 0xb16b7fda],
       |  [0x17d98585, 0x2e855cab],
       |  [0x673cbdbd, 0xcebd8173],
       |  [0xba8f5d5d, 0x695dd234],
       |  [0x20901010, 0x40108050],
       |  [0xf507f4f4, 0xf7f4f303],
       |  [0x8bddcbcb, 0x0bcb16c0],
       |  [0x7cd33e3e, 0xf83eedc6],
       |  [0x0a2d0505, 0x14052811],
       |  [0xce786767, 0x81671fe6],
       |  [0xd597e4e4, 0xb7e47353],
       |  [0x4e022727, 0x9c2725bb],
       |  [0x82734141, 0x19413258],
       |  [0x0ba78b8b, 0x168b2c9d],
       |  [0x53f6a7a7, 0xa6a75101],
       |  [0xfab27d7d, 0xe97dcf94],
       |  [0x37499595, 0x6e95dcfb],
       |  [0xad56d8d8, 0x47d88e9f],
       |  [0xeb70fbfb, 0xcbfb8b30],
       |  [0xc1cdeeee, 0x9fee2371],
       |  [0xf8bb7c7c, 0xed7cc791],
       |  [0xcc716666, 0x856617e3],
       |  [0xa77bdddd, 0x53dda68e],
       |  [0x2eaf1717, 0x5c17b84b],
       |  [0x8e454747, 0x01470246],
       |  [0x211a9e9e, 0x429e84dc],
       |  [0x89d4caca, 0x0fca1ec5],
       |  [0x5a582d2d, 0xb42d7599],
       |  [0x632ebfbf, 0xc6bf9179],
       |  [0x0e3f0707, 0x1c07381b],
       |  [0x47acadad, 0x8ead0123],
       |  [0xb4b05a5a, 0x755aea2f],
       |  [0x1bef8383, 0x36836cb5],
       |  [0x66b63333, 0xcc3385ff],
       |  [0xc65c6363, 0x91633ff2],
       |  [0x04120202, 0x0802100a],
       |  [0x4993aaaa, 0x92aa3938],
       |  [0xe2de7171, 0xd971afa8],
       |  [0x8dc6c8c8, 0x07c80ecf],
       |  [0x32d11919, 0x6419c87d],
       |  [0x923b4949, 0x39497270],
       |  [0xaf5fd9d9, 0x43d9869a],
       |  [0xf931f2f2, 0xeff2c31d],
       |  [0xdba8e3e3, 0xabe34b48],
       |  [0xb6b95b5b, 0x715be22a],
       |  [0x0dbc8888, 0x1a883492],
       |  [0x293e9a9a, 0x529aa4c8],
       |  [0x4c0b2626, 0x98262dbe],
       |  [0x64bf3232, 0xc8328dfa],
       |  [0x7d59b0b0, 0xfab0e94a],
       |  [0xcff2e9e9, 0x83e91b6a],
       |  [0x1e770f0f, 0x3c0f7833],
       |  [0xb733d5d5, 0x73d5e6a6],
       |  [0x1df48080, 0x3a8074ba],
       |  [0x6127bebe, 0xc2be997c],
       |  [0x87ebcdcd, 0x13cd26de],
       |  [0x68893434, 0xd034bde4],
       |  [0x90324848, 0x3d487a75],
       |  [0xe354ffff, 0xdbffab24],
       |  [0xf48d7a7a, 0xf57af78f],
       |  [0x3d649090, 0x7a90f4ea],
       |  [0xbe9d5f5f, 0x615fc23e],
       |  [0x403d2020, 0x80201da0],
       |  [0xd00f6868, 0xbd6867d5],
       |  [0x34ca1a1a, 0x681ad072],
       |  [0x41b7aeae, 0x82ae192c],
       |  [0x757db4b4, 0xeab4c95e],
       |  [0xa8ce5454, 0x4d549a19],
       |  [0x3b7f9393, 0x7693ece5],
       |  [0x442f2222, 0x88220daa],
       |  [0xc8636464, 0x8d6407e9],
       |  [0xff2af1f1, 0xe3f1db12],
       |  [0xe6cc7373, 0xd173bfa2],
       |  [0x24821212, 0x4812905a],
       |  [0x807a4040, 0x1d403a5d],
       |  [0x10480808, 0x20084028],
       |  [0x9b95c3c3, 0x2bc356e8],
       |  [0xc5dfecec, 0x97ec337b],
       |  [0xab4ddbdb, 0x4bdb9690],
       |  [0x5fc0a1a1, 0xbea1611f],
       |  [0x07918d8d, 0x0e8d1c83],
       |  [0x7ac83d3d, 0xf43df5c9],
       |  [0x335b9797, 0x6697ccf1],
       |  [0x00000000, 0x00000000],
       |  [0x83f9cfcf, 0x1bcf36d4],
       |  [0x566e2b2b, 0xac2b4587],
       |  [0xece17676, 0xc57697b3],
       |  [0x19e68282, 0x328264b0],
       |  [0xb128d6d6, 0x7fd6fea9],
       |  [0x36c31b1b, 0x6c1bd877],
       |  [0x7774b5b5, 0xeeb5c15b],
       |  [0x43beafaf, 0x86af1129],
       |  [0xd41d6a6a, 0xb56a77df],
       |  [0xa0ea5050, 0x5d50ba0d],
       |  [0x8a574545, 0x0945124c],
       |  [0xfb38f3f3, 0xebf3cb18],
       |  [0x60ad3030, 0xc0309df0],
       |  [0xc3c4efef, 0x9bef2b74],
       |  [0x7eda3f3f, 0xfc3fe5c3],
       |  [0xaac75555, 0x4955921c],
       |  [0x59dba2a2, 0xb2a27910],
       |  [0xc9e9eaea, 0x8fea0365],
       |  [0xca6a6565, 0x89650fec],
       |  [0x6903baba, 0xd2bab968],
       |  [0x5e4a2f2f, 0xbc2f6593],
       |  [0x9d8ec0c0, 0x27c04ee7],
       |  [0xa160dede, 0x5fdebe81],
       |  [0x38fc1c1c, 0x701ce06c],
       |  [0xe746fdfd, 0xd3fdbb2e],
       |  [0x9a1f4d4d, 0x294d5264],
       |  [0x39769292, 0x7292e4e0],
       |  [0xeafa7575, 0xc9758fbc],
       |  [0x0c360606, 0x1806301e],
       |  [0x09ae8a8a, 0x128a2498],
       |  [0x794bb2b2, 0xf2b2f940],
       |  [0xd185e6e6, 0xbfe66359],
       |  [0x1c7e0e0e, 0x380e7036],
       |  [0x3ee71f1f, 0x7c1ff863],
       |  [0xc4556262, 0x956237f7],
       |  [0xb53ad4d4, 0x77d4eea3],
       |  [0x4d81a8a8, 0x9aa82932],
       |  [0x31529696, 0x6296c4f4],
       |  [0xef62f9f9, 0xc3f99b3a],
       |  [0x97a3c5c5, 0x33c566f6],
       |  [0x4a102525, 0x942535b1],
       |  [0xb2ab5959, 0x7959f220],
       |  [0x15d08484, 0x2a8454ae],
       |  [0xe4c57272, 0xd572b7a7],
       |  [0x72ec3939, 0xe439d5dd],
       |  [0x98164c4c, 0x2d4c5a61],
       |  [0xbc945e5e, 0x655eca3b],
       |  [0xf09f7878, 0xfd78e785],
       |  [0x70e53838, 0xe038ddd8],
       |  [0x05988c8c, 0x0a8c1486],
       |  [0xbf17d1d1, 0x63d1c6b2],
       |  [0x57e4a5a5, 0xaea5410b],
       |  [0xd9a1e2e2, 0xafe2434d],
       |  [0xc24e6161, 0x99612ff8],
       |  [0x7b42b3b3, 0xf6b3f145],
       |  [0x42342121, 0x842115a5],
       |  [0x25089c9c, 0x4a9c94d6],
       |  [0x3cee1e1e, 0x781ef066],
       |  [0x86614343, 0x11432252],
       |  [0x93b1c7c7, 0x3bc776fc],
       |  [0xe54ffcfc, 0xd7fcb32b],
       |  [0x08240404, 0x10042014],
       |  [0xa2e35151, 0x5951b208],
       |  [0x2f259999, 0x5e99bcc7],
       |  [0xda226d6d, 0xa96d4fc4],
       |  [0x1a650d0d, 0x340d6839],
       |  [0xe979fafa, 0xcffa8335],
       |  [0xa369dfdf, 0x5bdfb684],
       |  [0xfca97e7e, 0xe57ed79b],
       |  [0x48192424, 0x90243db4],
       |  [0x76fe3b3b, 0xec3bc5d7],
       |  [0x4b9aabab, 0x96ab313d],
       |  [0x81f0cece, 0x1fce3ed1],
       |  [0x22991111, 0x44118855],
       |  [0x03838f8f, 0x068f0c89],
       |  [0x9c044e4e, 0x254e4a6b],
       |  [0x7366b7b7, 0xe6b7d151],
       |  [0xcbe0ebeb, 0x8beb0b60],
       |  [0x78c13c3c, 0xf03cfdcc],
       |  [0x1ffd8181, 0x3e817cbf],
       |  [0x35409494, 0x6a94d4fe],
       |  [0xf31cf7f7, 0xfbf7eb0c],
       |  [0x6f18b9b9, 0xdeb9a167],
       |  [0x268b1313, 0x4c13985f],
       |  [0x58512c2c, 0xb02c7d9c],
       |  [0xbb05d3d3, 0x6bd3d6b8],
       |  [0xd38ce7e7, 0xbbe76b5c],
       |  [0xdc396e6e, 0xa56e57cb],
       |  [0x95aac4c4, 0x37c46ef3],
       |  [0x061b0303, 0x0c03180f],
       |  [0xacdc5656, 0x45568a13],
       |  [0x885e4444, 0x0d441a49],
       |  [0xfea07f7f, 0xe17fdf9e],
       |  [0x4f88a9a9, 0x9ea92137],
       |  [0x54672a2a, 0xa82a4d82],
       |  [0x6b0abbbb, 0xd6bbb16d],
       |  [0x9f87c1c1, 0x23c146e2],
       |  [0xa6f15353, 0x5153a202],
       |  [0xa572dcdc, 0x57dcae8b],
       |  [0x16530b0b, 0x2c0b5827],
       |  [0x27019d9d, 0x4e9d9cd3],
       |  [0xd82b6c6c, 0xad6c47c1],
       |  [0x62a43131, 0xc43195f5],
       |  [0xe8f37474, 0xcd7487b9],
       |  [0xf115f6f6, 0xfff6e309],
       |  [0x8c4c4646, 0x05460a43],
       |  [0x45a5acac, 0x8aac0926],
       |  [0x0fb58989, 0x1e893c97],
       |  [0x28b41414, 0x5014a044],
       |  [0xdfbae1e1, 0xa3e15b42],
       |  [0x2ca61616, 0x5816b04e],
       |  [0x74f73a3a, 0xe83acdd2],
       |  [0xd2066969, 0xb9696fd0],
       |  [0x12410909, 0x2409482d],
       |  [0xe0d77070, 0xdd70a7ad],
       |  [0x716fb6b6, 0xe2b6d954],
       |  [0xbd1ed0d0, 0x67d0ceb7],
       |  [0xc7d6eded, 0x93ed3b7e],
       |  [0x85e2cccc, 0x17cc2edb],
       |  [0x84684242, 0x15422a57],
       |  [0x2d2c9898, 0x5a98b4c2],
       |  [0x55eda4a4, 0xaaa4490e],
       |  [0x50752828, 0xa0285d88],
       |  [0xb8865c5c, 0x6d5cda31],
       |  [0xed6bf8f8, 0xc7f8933f],
       |  [0x11c28686, 0x228644a4]
       |]);
       |
      0|final _c3 = Register64List.from([
       |  [0x7830d818, 0x186018c0],
       |  [0xaf462623, 0x238c2305],
       |  [0xf991b8c6, 0xc63fc67e],
       |  [0x6fcdfbe8, 0xe887e813],
       |  [0xa113cb87, 0x8726874c],
       |  [0x626d11b8, 0xb8dab8a9],
       |  [0x05020901, 0x01040108],
       |  [0x6e9e0d4f, 0x4f214f42],
       |  [0xee6c9b36, 0x36d836ad],
       |  [0x0451ffa6, 0xa6a2a659],
       |  [0xbdb90cd2, 0xd26fd2de],
       |  [0x06f70ef5, 0xf5f3f5fb],
       |  [0x80f29679, 0x79f979ef],
       |  [0xcede306f, 0x6fa16f5f],
       |  [0xef3f6d91, 0x917e91fc],
       |  [0x07a4f852, 0x525552aa],
       |  [0xfdc04760, 0x609d6027],
       |  [0x766535bc, 0xbccabc89],
       |  [0xcd2b379b, 0x9b569bac],
       |  [0x8c018a8e, 0x8e028e04],
       |  [0x155bd2a3, 0xa3b6a371],
       |  [0x3c186c0c, 0x0c300c60],
       |  [0x8af6847b, 0x7bf17bff],
       |  [0xe16a8035, 0x35d435b5],
       |  [0x693af51d, 0x1d741de8],
       |  [0x47ddb3e0, 0xe0a7e053],
       |  [0xacb321d7, 0xd77bd7f6],
       |  [0xed999cc2, 0xc22fc25e],
       |  [0x965c432e, 0x2eb82e6d],
       |  [0x7a96294b, 0x4b314b62],
       |  [0x21e15dfe, 0xfedffea3],
       |  [0x16aed557, 0x57415782],
       |  [0x412abd15, 0x155415a8],
       |  [0xb6eee877, 0x77c1779f],
       |  [0xeb6e9237, 0x37dc37a5],
       |  [0x56d79ee5, 0xe5b3e57b],
       |  [0xd923139f, 0x9f469f8c],
       |  [0x17fd23f0, 0xf0e7f0d3],
       |  [0x7f94204a, 0x4a354a6a],
       |  [0x95a944da, 0xda4fda9e],
       |  [0x25b0a258, 0x587d58fa],
       |  [0xca8fcfc9, 0xc903c906],
       |  [0x8d527c29, 0x29a42955],
       |  [0x22145a0a, 0x0a280a50],
       |  [0x4f7f50b1, 0xb1feb1e1],
       |  [0x1a5dc9a0, 0xa0baa069],
       |  [0xdad6146b, 0x6bb16b7f],
       |  [0xab17d985, 0x852e855c],
       |  [0x73673cbd, 0xbdcebd81],
       |  [0x34ba8f5d, 0x5d695dd2],
       |  [0x50209010, 0x10401080],
       |  [0x03f507f4, 0xf4f7f4f3],
       |  [0xc08bddcb, 0xcb0bcb16],
       |  [0xc67cd33e, 0x3ef83eed],
       |  [0x110a2d05, 0x05140528],
       |  [0xe6ce7867, 0x6781671f],
       |  [0x53d597e4, 0xe4b7e473],
       |  [0xbb4e0227, 0x279c2725],
       |  [0x58827341, 0x41194132],
       |  [0x9d0ba78b, 0x8b168b2c],
       |  [0x0153f6a7, 0xa7a6a751],
       |  [0x94fab27d, 0x7de97dcf],
       |  [0xfb374995, 0x956e95dc],
       |  [0x9fad56d8, 0xd847d88e],
       |  [0x30eb70fb, 0xfbcbfb8b],
       |  [0x71c1cdee, 0xee9fee23],
       |  [0x91f8bb7c, 0x7ced7cc7],
       |  [0xe3cc7166, 0x66856617],
       |  [0x8ea77bdd, 0xdd53dda6],
       |  [0x4b2eaf17, 0x175c17b8],
       |  [0x468e4547, 0x47014702],
       |  [0xdc211a9e, 0x9e429e84],
       |  [0xc589d4ca, 0xca0fca1e],
       |  [0x995a582d, 0x2db42d75],
       |  [0x79632ebf, 0xbfc6bf91],
       |  [0x1b0e3f07, 0x071c0738],
       |  [0x2347acad, 0xad8ead01],
       |  [0x2fb4b05a, 0x5a755aea],
       |  [0xb51bef83, 0x8336836c],
       |  [0xff66b633, 0x33cc3385],
       |  [0xf2c65c63, 0x6391633f],
       |  [0x0a041202, 0x02080210],
       |  [0x384993aa, 0xaa92aa39],
       |  [0xa8e2de71, 0x71d971af],
       |  [0xcf8dc6c8, 0xc807c80e],
       |  [0x7d32d119, 0x196419c8],
       |  [0x70923b49, 0x49394972],
       |  [0x9aaf5fd9, 0xd943d986],
       |  [0x1df931f2, 0xf2eff2c3],
       |  [0x48dba8e3, 0xe3abe34b],
       |  [0x2ab6b95b, 0x5b715be2],
       |  [0x920dbc88, 0x881a8834],
       |  [0xc8293e9a, 0x9a529aa4],
       |  [0xbe4c0b26, 0x2698262d],
       |  [0xfa64bf32, 0x32c8328d],
       |  [0x4a7d59b0, 0xb0fab0e9],
       |  [0x6acff2e9, 0xe983e91b],
       |  [0x331e770f, 0x0f3c0f78],
       |  [0xa6b733d5, 0xd573d5e6],
       |  [0xba1df480, 0x803a8074],
       |  [0x7c6127be, 0xbec2be99],
       |  [0xde87ebcd, 0xcd13cd26],
       |  [0xe4688934, 0x34d034bd],
       |  [0x75903248, 0x483d487a],
       |  [0x24e354ff, 0xffdbffab],
       |  [0x8ff48d7a, 0x7af57af7],
       |  [0xea3d6490, 0x907a90f4],
       |  [0x3ebe9d5f, 0x5f615fc2],
       |  [0xa0403d20, 0x2080201d],
       |  [0xd5d00f68, 0x68bd6867],
       |  [0x7234ca1a, 0x1a681ad0],
       |  [0x2c41b7ae, 0xae82ae19],
       |  [0x5e757db4, 0xb4eab4c9],
       |  [0x19a8ce54, 0x544d549a],
       |  [0xe53b7f93, 0x937693ec],
       |  [0xaa442f22, 0x2288220d],
       |  [0xe9c86364, 0x648d6407],
       |  [0x12ff2af1, 0xf1e3f1db],
       |  [0xa2e6cc73, 0x73d173bf],
       |  [0x5a248212, 0x12481290],
       |  [0x5d807a40, 0x401d403a],
       |  [0x28104808, 0x08200840],
       |  [0xe89b95c3, 0xc32bc356],
       |  [0x7bc5dfec, 0xec97ec33],
       |  [0x90ab4ddb, 0xdb4bdb96],
       |  [0x1f5fc0a1, 0xa1bea161],
       |  [0x8307918d, 0x8d0e8d1c],
       |  [0xc97ac83d, 0x3df43df5],
       |  [0xf1335b97, 0x976697cc],
       |  [0x00000000, 0x00000000],
       |  [0xd483f9cf, 0xcf1bcf36],
       |  [0x87566e2b, 0x2bac2b45],
       |  [0xb3ece176, 0x76c57697],
       |  [0xb019e682, 0x82328264],
       |  [0xa9b128d6, 0xd67fd6fe],
       |  [0x7736c31b, 0x1b6c1bd8],
       |  [0x5b7774b5, 0xb5eeb5c1],
       |  [0x2943beaf, 0xaf86af11],
       |  [0xdfd41d6a, 0x6ab56a77],
       |  [0x0da0ea50, 0x505d50ba],
       |  [0x4c8a5745, 0x45094512],
       |  [0x18fb38f3, 0xf3ebf3cb],
       |  [0xf060ad30, 0x30c0309d],
       |  [0x74c3c4ef, 0xef9bef2b],
       |  [0xc37eda3f, 0x3ffc3fe5],
       |  [0x1caac755, 0x55495592],
       |  [0x1059dba2, 0xa2b2a279],
       |  [0x65c9e9ea, 0xea8fea03],
       |  [0xecca6a65, 0x6589650f],
       |  [0x686903ba, 0xbad2bab9],
       |  [0x935e4a2f, 0x2fbc2f65],
       |  [0xe79d8ec0, 0xc027c04e],
       |  [0x81a160de, 0xde5fdebe],
       |  [0x6c38fc1c, 0x1c701ce0],
       |  [0x2ee746fd, 0xfdd3fdbb],
       |  [0x649a1f4d, 0x4d294d52],
       |  [0xe0397692, 0x927292e4],
       |  [0xbceafa75, 0x75c9758f],
       |  [0x1e0c3606, 0x06180630],
       |  [0x9809ae8a, 0x8a128a24],
       |  [0x40794bb2, 0xb2f2b2f9],
       |  [0x59d185e6, 0xe6bfe663],
       |  [0x361c7e0e, 0x0e380e70],
       |  [0x633ee71f, 0x1f7c1ff8],
       |  [0xf7c45562, 0x62956237],
       |  [0xa3b53ad4, 0xd477d4ee],
       |  [0x324d81a8, 0xa89aa829],
       |  [0xf4315296, 0x966296c4],
       |  [0x3aef62f9, 0xf9c3f99b],
       |  [0xf697a3c5, 0xc533c566],
       |  [0xb14a1025, 0x25942535],
       |  [0x20b2ab59, 0x597959f2],
       |  [0xae15d084, 0x842a8454],
       |  [0xa7e4c572, 0x72d572b7],
       |  [0xdd72ec39, 0x39e439d5],
       |  [0x6198164c, 0x4c2d4c5a],
       |  [0x3bbc945e, 0x5e655eca],
       |  [0x85f09f78, 0x78fd78e7],
       |  [0xd870e538, 0x38e038dd],
       |  [0x8605988c, 0x8c0a8c14],
       |  [0xb2bf17d1, 0xd163d1c6],
       |  [0x0b57e4a5, 0xa5aea541],
       |  [0x4dd9a1e2, 0xe2afe243],
       |  [0xf8c24e61, 0x6199612f],
       |  [0x457b42b3, 0xb3f6b3f1],
       |  [0xa5423421, 0x21842115],
       |  [0xd625089c, 0x9c4a9c94],
       |  [0x663cee1e, 0x1e781ef0],
       |  [0x52866143, 0x43114322],
       |  [0xfc93b1c7, 0xc73bc776],
       |  [0x2be54ffc, 0xfcd7fcb3],
       |  [0x14082404, 0x04100420],
       |  [0x08a2e351, 0x515951b2],
       |  [0xc72f2599, 0x995e99bc],
       |  [0xc4da226d, 0x6da96d4f],
       |  [0x391a650d, 0x0d340d68],
       |  [0x35e979fa, 0xfacffa83],
       |  [0x84a369df, 0xdf5bdfb6],
       |  [0x9bfca97e, 0x7ee57ed7],
       |  [0xb4481924, 0x2490243d],
       |  [0xd776fe3b, 0x3bec3bc5],
       |  [0x3d4b9aab, 0xab96ab31],
       |  [0xd181f0ce, 0xce1fce3e],
       |  [0x55229911, 0x11441188],
       |  [0x8903838f, 0x8f068f0c],
       |  [0x6b9c044e, 0x4e254e4a],
       |  [0x517366b7, 0xb7e6b7d1],
       |  [0x60cbe0eb, 0xeb8beb0b],
       |  [0xcc78c13c, 0x3cf03cfd],
       |  [0xbf1ffd81, 0x813e817c],
       |  [0xfe354094, 0x946a94d4],
       |  [0x0cf31cf7, 0xf7fbf7eb],
       |  [0x676f18b9, 0xb9deb9a1],
       |  [0x5f268b13, 0x134c1398],
       |  [0x9c58512c, 0x2cb02c7d],
       |  [0xb8bb05d3, 0xd36bd3d6],
       |  [0x5cd38ce7, 0xe7bbe76b],
       |  [0xcbdc396e, 0x6ea56e57],
       |  [0xf395aac4, 0xc437c46e],
       |  [0x0f061b03, 0x030c0318],
       |  [0x13acdc56, 0x5645568a],
       |  [0x49885e44, 0x440d441a],
       |  [0x9efea07f, 0x7fe17fdf],
       |  [0x374f88a9, 0xa99ea921],
       |  [0x8254672a, 0x2aa82a4d],
       |  [0x6d6b0abb, 0xbbd6bbb1],
       |  [0xe29f87c1, 0xc123c146],
       |  [0x02a6f153, 0x535153a2],
       |  [0x8ba572dc, 0xdc57dcae],
       |  [0x2716530b, 0x0b2c0b58],
       |  [0xd327019d, 0x9d4e9d9c],
       |  [0xc1d82b6c, 0x6cad6c47],
       |  [0xf562a431, 0x31c43195],
       |  [0xb9e8f374, 0x74cd7487],
       |  [0x09f115f6, 0xf6fff6e3],
       |  [0x438c4c46, 0x4605460a],
       |  [0x2645a5ac, 0xac8aac09],
       |  [0x970fb589, 0x891e893c],
       |  [0x4428b414, 0x145014a0],
       |  [0x42dfbae1, 0xe1a3e15b],
       |  [0x4e2ca616, 0x165816b0],
       |  [0xd274f73a, 0x3ae83acd],
       |  [0xd0d20669, 0x69b9696f],
       |  [0x2d124109, 0x09240948],
       |  [0xade0d770, 0x70dd70a7],
       |  [0x54716fb6, 0xb6e2b6d9],
       |  [0xb7bd1ed0, 0xd067d0ce],
       |  [0x7ec7d6ed, 0xed93ed3b],
       |  [0xdb85e2cc, 0xcc17cc2e],
       |  [0x57846842, 0x4215422a],
       |  [0xc22d2c98, 0x985a98b4],
       |  [0x0e55eda4, 0xa4aaa449],
       |  [0x88507528, 0x28a0285d],
       |  [0x31b8865c, 0x5c6d5cda],
       |  [0x3fed6bf8, 0xf8c7f893],
       |  [0xa411c286, 0x86228644]
       |]);
       |
      0|final _c4 = Register64List.from([
       |  [0xc07830d8, 0x18186018],
       |  [0x05af4626, 0x23238c23],
       |  [0x7ef991b8, 0xc6c63fc6],
       |  [0x136fcdfb, 0xe8e887e8],
       |  [0x4ca113cb, 0x87872687],
       |  [0xa9626d11, 0xb8b8dab8],
       |  [0x08050209, 0x01010401],
       |  [0x426e9e0d, 0x4f4f214f],
       |  [0xadee6c9b, 0x3636d836],
       |  [0x590451ff, 0xa6a6a2a6],
       |  [0xdebdb90c, 0xd2d26fd2],
       |  [0xfb06f70e, 0xf5f5f3f5],
       |  [0xef80f296, 0x7979f979],
       |  [0x5fcede30, 0x6f6fa16f],
       |  [0xfcef3f6d, 0x91917e91],
       |  [0xaa07a4f8, 0x52525552],
       |  [0x27fdc047, 0x60609d60],
       |  [0x89766535, 0xbcbccabc],
       |  [0xaccd2b37, 0x9b9b569b],
       |  [0x048c018a, 0x8e8e028e],
       |  [0x71155bd2, 0xa3a3b6a3],
       |  [0x603c186c, 0x0c0c300c],
       |  [0xff8af684, 0x7b7bf17b],
       |  [0xb5e16a80, 0x3535d435],
       |  [0xe8693af5, 0x1d1d741d],
       |  [0x5347ddb3, 0xe0e0a7e0],
       |  [0xf6acb321, 0xd7d77bd7],
       |  [0x5eed999c, 0xc2c22fc2],
       |  [0x6d965c43, 0x2e2eb82e],
       |  [0x627a9629, 0x4b4b314b],
       |  [0xa321e15d, 0xfefedffe],
       |  [0x8216aed5, 0x57574157],
       |  [0xa8412abd, 0x15155415],
       |  [0x9fb6eee8, 0x7777c177],
       |  [0xa5eb6e92, 0x3737dc37],
       |  [0x7b56d79e, 0xe5e5b3e5],
       |  [0x8cd92313, 0x9f9f469f],
       |  [0xd317fd23, 0xf0f0e7f0],
       |  [0x6a7f9420, 0x4a4a354a],
       |  [0x9e95a944, 0xdada4fda],
       |  [0xfa25b0a2, 0x58587d58],
       |  [0x06ca8fcf, 0xc9c903c9],
       |  [0x558d527c, 0x2929a429],
       |  [0x5022145a, 0x0a0a280a],
       |  [0xe14f7f50, 0xb1b1feb1],
       |  [0x691a5dc9, 0xa0a0baa0],
       |  [0x7fdad614, 0x6b6bb16b],
       |  [0x5cab17d9, 0x85852e85],
       |  [0x8173673c, 0xbdbdcebd],
       |  [0xd234ba8f, 0x5d5d695d],
       |  [0x80502090, 0x10104010],
       |  [0xf303f507, 0xf4f4f7f4],
       |  [0x16c08bdd, 0xcbcb0bcb],
       |  [0xedc67cd3, 0x3e3ef83e],
       |  [0x28110a2d, 0x05051405],
       |  [0x1fe6ce78, 0x67678167],
       |  [0x7353d597, 0xe4e4b7e4],
       |  [0x25bb4e02, 0x27279c27],
       |  [0x32588273, 0x41411941],
       |  [0x2c9d0ba7, 0x8b8b168b],
       |  [0x510153f6, 0xa7a7a6a7],
       |  [0xcf94fab2, 0x7d7de97d],
       |  [0xdcfb3749, 0x95956e95],
       |  [0x8e9fad56, 0xd8d847d8],
       |  [0x8b30eb70, 0xfbfbcbfb],
       |  [0x2371c1cd, 0xeeee9fee],
       |  [0xc791f8bb, 0x7c7ced7c],
       |  [0x17e3cc71, 0x66668566],
       |  [0xa68ea77b, 0xdddd53dd],
       |  [0xb84b2eaf, 0x17175c17],
       |  [0x02468e45, 0x47470147],
       |  [0x84dc211a, 0x9e9e429e],
       |  [0x1ec589d4, 0xcaca0fca],
       |  [0x75995a58, 0x2d2db42d],
       |  [0x9179632e, 0xbfbfc6bf],
       |  [0x381b0e3f, 0x07071c07],
       |  [0x012347ac, 0xadad8ead],
       |  [0xea2fb4b0, 0x5a5a755a],
       |  [0x6cb51bef, 0x83833683],
       |  [0x85ff66b6, 0x3333cc33],
       |  [0x3ff2c65c, 0x63639163],
       |  [0x100a0412, 0x02020802],
       |  [0x39384993, 0xaaaa92aa],
       |  [0xafa8e2de, 0x7171d971],
       |  [0x0ecf8dc6, 0xc8c807c8],
       |  [0xc87d32d1, 0x19196419],
       |  [0x7270923b, 0x49493949],
       |  [0x869aaf5f, 0xd9d943d9],
       |  [0xc31df931, 0xf2f2eff2],
       |  [0x4b48dba8, 0xe3e3abe3],
       |  [0xe22ab6b9, 0x5b5b715b],
       |  [0x34920dbc, 0x88881a88],
       |  [0xa4c8293e, 0x9a9a529a],
       |  [0x2dbe4c0b, 0x26269826],
       |  [0x8dfa64bf, 0x3232c832],
       |  [0xe94a7d59, 0xb0b0fab0],
       |  [0x1b6acff2, 0xe9e983e9],
       |  [0x78331e77, 0x0f0f3c0f],
       |  [0xe6a6b733, 0xd5d573d5],
       |  [0x74ba1df4, 0x80803a80],
       |  [0x997c6127, 0xbebec2be],
       |  [0x26de87eb, 0xcdcd13cd],
       |  [0xbde46889, 0x3434d034],
       |  [0x7a759032, 0x48483d48],
       |  [0xab24e354, 0xffffdbff],
       |  [0xf78ff48d, 0x7a7af57a],
       |  [0xf4ea3d64, 0x90907a90],
       |  [0xc23ebe9d, 0x5f5f615f],
       |  [0x1da0403d, 0x20208020],
       |  [0x67d5d00f, 0x6868bd68],
       |  [0xd07234ca, 0x1a1a681a],
       |  [0x192c41b7, 0xaeae82ae],
       |  [0xc95e757d, 0xb4b4eab4],
       |  [0x9a19a8ce, 0x54544d54],
       |  [0xece53b7f, 0x93937693],
       |  [0x0daa442f, 0x22228822],
       |  [0x07e9c863, 0x64648d64],
       |  [0xdb12ff2a, 0xf1f1e3f1],
       |  [0xbfa2e6cc, 0x7373d173],
       |  [0x905a2482, 0x12124812],
       |  [0x3a5d807a, 0x40401d40],
       |  [0x40281048, 0x08082008],
       |  [0x56e89b95, 0xc3c32bc3],
       |  [0x337bc5df, 0xecec97ec],
       |  [0x9690ab4d, 0xdbdb4bdb],
       |  [0x611f5fc0, 0xa1a1bea1],
       |  [0x1c830791, 0x8d8d0e8d],
       |  [0xf5c97ac8, 0x3d3df43d],
       |  [0xccf1335b, 0x97976697],
       |  [0x00000000, 0x00000000],
       |  [0x36d483f9, 0xcfcf1bcf],
       |  [0x4587566e, 0x2b2bac2b],
       |  [0x97b3ece1, 0x7676c576],
       |  [0x64b019e6, 0x82823282],
       |  [0xfea9b128, 0xd6d67fd6],
       |  [0xd87736c3, 0x1b1b6c1b],
       |  [0xc15b7774, 0xb5b5eeb5],
       |  [0x112943be, 0xafaf86af],
       |  [0x77dfd41d, 0x6a6ab56a],
       |  [0xba0da0ea, 0x50505d50],
       |  [0x124c8a57, 0x45450945],
       |  [0xcb18fb38, 0xf3f3ebf3],
       |  [0x9df060ad, 0x3030c030],
       |  [0x2b74c3c4, 0xefef9bef],
       |  [0xe5c37eda, 0x3f3ffc3f],
       |  [0x921caac7, 0x55554955],
       |  [0x791059db, 0xa2a2b2a2],
       |  [0x0365c9e9, 0xeaea8fea],
       |  [0x0fecca6a, 0x65658965],
       |  [0xb9686903, 0xbabad2ba],
       |  [0x65935e4a, 0x2f2fbc2f],
       |  [0x4ee79d8e, 0xc0c027c0],
       |  [0xbe81a160, 0xdede5fde],
       |  [0xe06c38fc, 0x1c1c701c],
       |  [0xbb2ee746, 0xfdfdd3fd],
       |  [0x52649a1f, 0x4d4d294d],
       |  [0xe4e03976, 0x92927292],
       |  [0x8fbceafa, 0x7575c975],
       |  [0x301e0c36, 0x06061806],
       |  [0x249809ae, 0x8a8a128a],
       |  [0xf940794b, 0xb2b2f2b2],
       |  [0x6359d185, 0xe6e6bfe6],
       |  [0x70361c7e, 0x0e0e380e],
       |  [0xf8633ee7, 0x1f1f7c1f],
       |  [0x37f7c455, 0x62629562],
       |  [0xeea3b53a, 0xd4d477d4],
       |  [0x29324d81, 0xa8a89aa8],
       |  [0xc4f43152, 0x96966296],
       |  [0x9b3aef62, 0xf9f9c3f9],
       |  [0x66f697a3, 0xc5c533c5],
       |  [0x35b14a10, 0x25259425],
       |  [0xf220b2ab, 0x59597959],
       |  [0x54ae15d0, 0x84842a84],
       |  [0xb7a7e4c5, 0x7272d572],
       |  [0xd5dd72ec, 0x3939e439],
       |  [0x5a619816, 0x4c4c2d4c],
       |  [0xca3bbc94, 0x5e5e655e],
       |  [0xe785f09f, 0x7878fd78],
       |  [0xddd870e5, 0x3838e038],
       |  [0x14860598, 0x8c8c0a8c],
       |  [0xc6b2bf17, 0xd1d163d1],
       |  [0x410b57e4, 0xa5a5aea5],
       |  [0x434dd9a1, 0xe2e2afe2],
       |  [0x2ff8c24e, 0x61619961],
       |  [0xf1457b42, 0xb3b3f6b3],
       |  [0x15a54234, 0x21218421],
       |  [0x94d62508, 0x9c9c4a9c],
       |  [0xf0663cee, 0x1e1e781e],
       |  [0x22528661, 0x43431143],
       |  [0x76fc93b1, 0xc7c73bc7],
       |  [0xb32be54f, 0xfcfcd7fc],
       |  [0x20140824, 0x04041004],
       |  [0xb208a2e3, 0x51515951],
       |  [0xbcc72f25, 0x99995e99],
       |  [0x4fc4da22, 0x6d6da96d],
       |  [0x68391a65, 0x0d0d340d],
       |  [0x8335e979, 0xfafacffa],
       |  [0xb684a369, 0xdfdf5bdf],
       |  [0xd79bfca9, 0x7e7ee57e],
       |  [0x3db44819, 0x24249024],
       |  [0xc5d776fe, 0x3b3bec3b],
       |  [0x313d4b9a, 0xabab96ab],
       |  [0x3ed181f0, 0xcece1fce],
       |  [0x88552299, 0x11114411],
       |  [0x0c890383, 0x8f8f068f],
       |  [0x4a6b9c04, 0x4e4e254e],
       |  [0xd1517366, 0xb7b7e6b7],
       |  [0x0b60cbe0, 0xebeb8beb],
       |  [0xfdcc78c1, 0x3c3cf03c],
       |  [0x7cbf1ffd, 0x81813e81],
       |  [0xd4fe3540, 0x94946a94],
       |  [0xeb0cf31c, 0xf7f7fbf7],
       |  [0xa1676f18, 0xb9b9deb9],
       |  [0x985f268b, 0x13134c13],
       |  [0x7d9c5851, 0x2c2cb02c],
       |  [0xd6b8bb05, 0xd3d36bd3],
       |  [0x6b5cd38c, 0xe7e7bbe7],
       |  [0x57cbdc39, 0x6e6ea56e],
       |  [0x6ef395aa, 0xc4c437c4],
       |  [0x180f061b, 0x03030c03],
       |  [0x8a13acdc, 0x56564556],
       |  [0x1a49885e, 0x44440d44],
       |  [0xdf9efea0, 0x7f7fe17f],
       |  [0x21374f88, 0xa9a99ea9],
       |  [0x4d825467, 0x2a2aa82a],
       |  [0xb16d6b0a, 0xbbbbd6bb],
       |  [0x46e29f87, 0xc1c123c1],
       |  [0xa202a6f1, 0x53535153],
       |  [0xae8ba572, 0xdcdc57dc],
       |  [0x58271653, 0x0b0b2c0b],
       |  [0x9cd32701, 0x9d9d4e9d],
       |  [0x47c1d82b, 0x6c6cad6c],
       |  [0x95f562a4, 0x3131c431],
       |  [0x87b9e8f3, 0x7474cd74],
       |  [0xe309f115, 0xf6f6fff6],
       |  [0x0a438c4c, 0x46460546],
       |  [0x092645a5, 0xacac8aac],
       |  [0x3c970fb5, 0x89891e89],
       |  [0xa04428b4, 0x14145014],
       |  [0x5b42dfba, 0xe1e1a3e1],
       |  [0xb04e2ca6, 0x16165816],
       |  [0xcdd274f7, 0x3a3ae83a],
       |  [0x6fd0d206, 0x6969b969],
       |  [0x482d1241, 0x09092409],
       |  [0xa7ade0d7, 0x7070dd70],
       |  [0xd954716f, 0xb6b6e2b6],
       |  [0xceb7bd1e, 0xd0d067d0],
       |  [0x3b7ec7d6, 0xeded93ed],
       |  [0x2edb85e2, 0xcccc17cc],
       |  [0x2a578468, 0x42421542],
       |  [0xb4c22d2c, 0x98985a98],
       |  [0x490e55ed, 0xa4a4aaa4],
       |  [0x5d885075, 0x2828a028],
       |  [0xda31b886, 0x5c5c6d5c],
       |  [0x933fed6b, 0xf8f8c7f8],
       |  [0x44a411c2, 0x86862286]
       |]);
       |
      0|final _c5 = Register64List.from([
       |  [0x18c07830, 0xd8181860],
       |  [0x2305af46, 0x2623238c],
       |  [0xc67ef991, 0xb8c6c63f],
       |  [0xe8136fcd, 0xfbe8e887],
       |  [0x874ca113, 0xcb878726],
       |  [0xb8a9626d, 0x11b8b8da],
       |  [0x01080502, 0x09010104],
       |  [0x4f426e9e, 0x0d4f4f21],
       |  [0x36adee6c, 0x9b3636d8],
       |  [0xa6590451, 0xffa6a6a2],
       |  [0xd2debdb9, 0x0cd2d26f],
       |  [0xf5fb06f7, 0x0ef5f5f3],
       |  [0x79ef80f2, 0x967979f9],
       |  [0x6f5fcede, 0x306f6fa1],
       |  [0x91fcef3f, 0x6d91917e],
       |  [0x52aa07a4, 0xf8525255],
       |  [0x6027fdc0, 0x4760609d],
       |  [0xbc897665, 0x35bcbcca],
       |  [0x9baccd2b, 0x379b9b56],
       |  [0x8e048c01, 0x8a8e8e02],
       |  [0xa371155b, 0xd2a3a3b6],
       |  [0x0c603c18, 0x6c0c0c30],
       |  [0x7bff8af6, 0x847b7bf1],
       |  [0x35b5e16a, 0x803535d4],
       |  [0x1de8693a, 0xf51d1d74],
       |  [0xe05347dd, 0xb3e0e0a7],
       |  [0xd7f6acb3, 0x21d7d77b],
       |  [0xc25eed99, 0x9cc2c22f],
       |  [0x2e6d965c, 0x432e2eb8],
       |  [0x4b627a96, 0x294b4b31],
       |  [0xfea321e1, 0x5dfefedf],
       |  [0x578216ae, 0xd5575741],
       |  [0x15a8412a, 0xbd151554],
       |  [0x779fb6ee, 0xe87777c1],
       |  [0x37a5eb6e, 0x923737dc],
       |  [0xe57b56d7, 0x9ee5e5b3],
       |  [0x9f8cd923, 0x139f9f46],
       |  [0xf0d317fd, 0x23f0f0e7],
       |  [0x4a6a7f94, 0x204a4a35],
       |  [0xda9e95a9, 0x44dada4f],
       |  [0x58fa25b0, 0xa258587d],
       |  [0xc906ca8f, 0xcfc9c903],
       |  [0x29558d52, 0x7c2929a4],
       |  [0x0a502214, 0x5a0a0a28],
       |  [0xb1e14f7f, 0x50b1b1fe],
       |  [0xa0691a5d, 0xc9a0a0ba],
       |  [0x6b7fdad6, 0x146b6bb1],
       |  [0x855cab17, 0xd985852e],
       |  [0xbd817367, 0x3cbdbdce],
       |  [0x5dd234ba, 0x8f5d5d69],
       |  [0x10805020, 0x90101040],
       |  [0xf4f303f5, 0x07f4f4f7],
       |  [0xcb16c08b, 0xddcbcb0b],
       |  [0x3eedc67c, 0xd33e3ef8],
       |  [0x0528110a, 0x2d050514],
       |  [0x671fe6ce, 0x78676781],
       |  [0xe47353d5, 0x97e4e4b7],
       |  [0x2725bb4e, 0x0227279c],
       |  [0x41325882, 0x73414119],
       |  [0x8b2c9d0b, 0xa78b8b16],
       |  [0xa7510153, 0xf6a7a7a6],
       |  [0x7dcf94fa, 0xb27d7de9],
       |  [0x95dcfb37, 0x4995956e],
       |  [0xd88e9fad, 0x56d8d847],
       |  [0xfb8b30eb, 0x70fbfbcb],
       |  [0xee2371c1, 0xcdeeee9f],
       |  [0x7cc791f8, 0xbb7c7ced],
       |  [0x6617e3cc, 0x71666685],
       |  [0xdda68ea7, 0x7bdddd53],
       |  [0x17b84b2e, 0xaf17175c],
       |  [0x4702468e, 0x45474701],
       |  [0x9e84dc21, 0x1a9e9e42],
       |  [0xca1ec589, 0xd4caca0f],
       |  [0x2d75995a, 0x582d2db4],
       |  [0xbf917963, 0x2ebfbfc6],
       |  [0x07381b0e, 0x3f07071c],
       |  [0xad012347, 0xacadad8e],
       |  [0x5aea2fb4, 0xb05a5a75],
       |  [0x836cb51b, 0xef838336],
       |  [0x3385ff66, 0xb63333cc],
       |  [0x633ff2c6, 0x5c636391],
       |  [0x02100a04, 0x12020208],
       |  [0xaa393849, 0x93aaaa92],
       |  [0x71afa8e2, 0xde7171d9],
       |  [0xc80ecf8d, 0xc6c8c807],
       |  [0x19c87d32, 0xd1191964],
       |  [0x49727092, 0x3b494939],
       |  [0xd9869aaf, 0x5fd9d943],
       |  [0xf2c31df9, 0x31f2f2ef],
       |  [0xe34b48db, 0xa8e3e3ab],
       |  [0x5be22ab6, 0xb95b5b71],
       |  [0x8834920d, 0xbc88881a],
       |  [0x9aa4c829, 0x3e9a9a52],
       |  [0x262dbe4c, 0x0b262698],
       |  [0x328dfa64, 0xbf3232c8],
       |  [0xb0e94a7d, 0x59b0b0fa],
       |  [0xe91b6acf, 0xf2e9e983],
       |  [0x0f78331e, 0x770f0f3c],
       |  [0xd5e6a6b7, 0x33d5d573],
       |  [0x8074ba1d, 0xf480803a],
       |  [0xbe997c61, 0x27bebec2],
       |  [0xcd26de87, 0xebcdcd13],
       |  [0x34bde468, 0x893434d0],
       |  [0x487a7590, 0x3248483d],
       |  [0xffab24e3, 0x54ffffdb],
       |  [0x7af78ff4, 0x8d7a7af5],
       |  [0x90f4ea3d, 0x6490907a],
       |  [0x5fc23ebe, 0x9d5f5f61],
       |  [0x201da040, 0x3d202080],
       |  [0x6867d5d0, 0x0f6868bd],
       |  [0x1ad07234, 0xca1a1a68],
       |  [0xae192c41, 0xb7aeae82],
       |  [0xb4c95e75, 0x7db4b4ea],
       |  [0x549a19a8, 0xce54544d],
       |  [0x93ece53b, 0x7f939376],
       |  [0x220daa44, 0x2f222288],
       |  [0x6407e9c8, 0x6364648d],
       |  [0xf1db12ff, 0x2af1f1e3],
       |  [0x73bfa2e6, 0xcc7373d1],
       |  [0x12905a24, 0x82121248],
       |  [0x403a5d80, 0x7a40401d],
       |  [0x08402810, 0x48080820],
       |  [0xc356e89b, 0x95c3c32b],
       |  [0xec337bc5, 0xdfecec97],
       |  [0xdb9690ab, 0x4ddbdb4b],
       |  [0xa1611f5f, 0xc0a1a1be],
       |  [0x8d1c8307, 0x918d8d0e],
       |  [0x3df5c97a, 0xc83d3df4],
       |  [0x97ccf133, 0x5b979766],
       |  [0x00000000, 0x00000000],
       |  [0xcf36d483, 0xf9cfcf1b],
       |  [0x2b458756, 0x6e2b2bac],
       |  [0x7697b3ec, 0xe17676c5],
       |  [0x8264b019, 0xe6828232],
       |  [0xd6fea9b1, 0x28d6d67f],
       |  [0x1bd87736, 0xc31b1b6c],
       |  [0xb5c15b77, 0x74b5b5ee],
       |  [0xaf112943, 0xbeafaf86],
       |  [0x6a77dfd4, 0x1d6a6ab5],
       |  [0x50ba0da0, 0xea50505d],
       |  [0x45124c8a, 0x57454509],
       |  [0xf3cb18fb, 0x38f3f3eb],
       |  [0x309df060, 0xad3030c0],
       |  [0xef2b74c3, 0xc4efef9b],
       |  [0x3fe5c37e, 0xda3f3ffc],
       |  [0x55921caa, 0xc7555549],
       |  [0xa2791059, 0xdba2a2b2],
       |  [0xea0365c9, 0xe9eaea8f],
       |  [0x650fecca, 0x6a656589],
       |  [0xbab96869, 0x03babad2],
       |  [0x2f65935e, 0x4a2f2fbc],
       |  [0xc04ee79d, 0x8ec0c027],
       |  [0xdebe81a1, 0x60dede5f],
       |  [0x1ce06c38, 0xfc1c1c70],
       |  [0xfdbb2ee7, 0x46fdfdd3],
       |  [0x4d52649a, 0x1f4d4d29],
       |  [0x92e4e039, 0x76929272],
       |  [0x758fbcea, 0xfa7575c9],
       |  [0x06301e0c, 0x36060618],
       |  [0x8a249809, 0xae8a8a12],
       |  [0xb2f94079, 0x4bb2b2f2],
       |  [0xe66359d1, 0x85e6e6bf],
       |  [0x0e70361c, 0x7e0e0e38],
       |  [0x1ff8633e, 0xe71f1f7c],
       |  [0x6237f7c4, 0x55626295],
       |  [0xd4eea3b5, 0x3ad4d477],
       |  [0xa829324d, 0x81a8a89a],
       |  [0x96c4f431, 0x52969662],
       |  [0xf99b3aef, 0x62f9f9c3],
       |  [0xc566f697, 0xa3c5c533],
       |  [0x2535b14a, 0x10252594],
       |  [0x59f220b2, 0xab595979],
       |  [0x8454ae15, 0xd084842a],
       |  [0x72b7a7e4, 0xc57272d5],
       |  [0x39d5dd72, 0xec3939e4],
       |  [0x4c5a6198, 0x164c4c2d],
       |  [0x5eca3bbc, 0x945e5e65],
       |  [0x78e785f0, 0x9f7878fd],
       |  [0x38ddd870, 0xe53838e0],
       |  [0x8c148605, 0x988c8c0a],
       |  [0xd1c6b2bf, 0x17d1d163],
       |  [0xa5410b57, 0xe4a5a5ae],
       |  [0xe2434dd9, 0xa1e2e2af],
       |  [0x612ff8c2, 0x4e616199],
       |  [0xb3f1457b, 0x42b3b3f6],
       |  [0x2115a542, 0x34212184],
       |  [0x9c94d625, 0x089c9c4a],
       |  [0x1ef0663c, 0xee1e1e78],
       |  [0x43225286, 0x61434311],
       |  [0xc776fc93, 0xb1c7c73b],
       |  [0xfcb32be5, 0x4ffcfcd7],
       |  [0x04201408, 0x24040410],
       |  [0x51b208a2, 0xe3515159],
       |  [0x99bcc72f, 0x2599995e],
       |  [0x6d4fc4da, 0x226d6da9],
       |  [0x0d68391a, 0x650d0d34],
       |  [0xfa8335e9, 0x79fafacf],
       |  [0xdfb684a3, 0x69dfdf5b],
       |  [0x7ed79bfc, 0xa97e7ee5],
       |  [0x243db448, 0x19242490],
       |  [0x3bc5d776, 0xfe3b3bec],
       |  [0xab313d4b, 0x9aabab96],
       |  [0xce3ed181, 0xf0cece1f],
       |  [0x11885522, 0x99111144],
       |  [0x8f0c8903, 0x838f8f06],
       |  [0x4e4a6b9c, 0x044e4e25],
       |  [0xb7d15173, 0x66b7b7e6],
       |  [0xeb0b60cb, 0xe0ebeb8b],
       |  [0x3cfdcc78, 0xc13c3cf0],
       |  [0x817cbf1f, 0xfd81813e],
       |  [0x94d4fe35, 0x4094946a],
       |  [0xf7eb0cf3, 0x1cf7f7fb],
       |  [0xb9a1676f, 0x18b9b9de],
       |  [0x13985f26, 0x8b13134c],
       |  [0x2c7d9c58, 0x512c2cb0],
       |  [0xd3d6b8bb, 0x05d3d36b],
       |  [0xe76b5cd3, 0x8ce7e7bb],
       |  [0x6e57cbdc, 0x396e6ea5],
       |  [0xc46ef395, 0xaac4c437],
       |  [0x03180f06, 0x1b03030c],
       |  [0x568a13ac, 0xdc565645],
       |  [0x441a4988, 0x5e44440d],
       |  [0x7fdf9efe, 0xa07f7fe1],
       |  [0xa921374f, 0x88a9a99e],
       |  [0x2a4d8254, 0x672a2aa8],
       |  [0xbbb16d6b, 0x0abbbbd6],
       |  [0xc146e29f, 0x87c1c123],
       |  [0x53a202a6, 0xf1535351],
       |  [0xdcae8ba5, 0x72dcdc57],
       |  [0x0b582716, 0x530b0b2c],
       |  [0x9d9cd327, 0x019d9d4e],
       |  [0x6c47c1d8, 0x2b6c6cad],
       |  [0x3195f562, 0xa43131c4],
       |  [0x7487b9e8, 0xf37474cd],
       |  [0xf6e309f1, 0x15f6f6ff],
       |  [0x460a438c, 0x4c464605],
       |  [0xac092645, 0xa5acac8a],
       |  [0x893c970f, 0xb589891e],
       |  [0x14a04428, 0xb4141450],
       |  [0xe15b42df, 0xbae1e1a3],
       |  [0x16b04e2c, 0xa6161658],
       |  [0x3acdd274, 0xf73a3ae8],
       |  [0x696fd0d2, 0x066969b9],
       |  [0x09482d12, 0x41090924],
       |  [0x70a7ade0, 0xd77070dd],
       |  [0xb6d95471, 0x6fb6b6e2],
       |  [0xd0ceb7bd, 0x1ed0d067],
       |  [0xed3b7ec7, 0xd6eded93],
       |  [0xcc2edb85, 0xe2cccc17],
       |  [0x422a5784, 0x68424215],
       |  [0x98b4c22d, 0x2c98985a],
       |  [0xa4490e55, 0xeda4a4aa],
       |  [0x285d8850, 0x752828a0],
       |  [0x5cda31b8, 0x865c5c6d],
       |  [0xf8933fed, 0x6bf8f8c7],
       |  [0x8644a411, 0xc2868622]
       |]);
       |
      0|final _c6 = Register64List.from([
       |  [0x6018c078, 0x30d81818],
       |  [0x8c2305af, 0x46262323],
       |  [0x3fc67ef9, 0x91b8c6c6],
       |  [0x87e8136f, 0xcdfbe8e8],
       |  [0x26874ca1, 0x13cb8787],
       |  [0xdab8a962, 0x6d11b8b8],
       |  [0x04010805, 0x02090101],
       |  [0x214f426e, 0x9e0d4f4f],
       |  [0xd836adee, 0x6c9b3636],
       |  [0xa2a65904, 0x51ffa6a6],
       |  [0x6fd2debd, 0xb90cd2d2],
       |  [0xf3f5fb06, 0xf70ef5f5],
       |  [0xf979ef80, 0xf2967979],
       |  [0xa16f5fce, 0xde306f6f],
       |  [0x7e91fcef, 0x3f6d9191],
       |  [0x5552aa07, 0xa4f85252],
       |  [0x9d6027fd, 0xc0476060],
       |  [0xcabc8976, 0x6535bcbc],
       |  [0x569baccd, 0x2b379b9b],
       |  [0x028e048c, 0x018a8e8e],
       |  [0xb6a37115, 0x5bd2a3a3],
       |  [0x300c603c, 0x186c0c0c],
       |  [0xf17bff8a, 0xf6847b7b],
       |  [0xd435b5e1, 0x6a803535],
       |  [0x741de869, 0x3af51d1d],
       |  [0xa7e05347, 0xddb3e0e0],
       |  [0x7bd7f6ac, 0xb321d7d7],
       |  [0x2fc25eed, 0x999cc2c2],
       |  [0xb82e6d96, 0x5c432e2e],
       |  [0x314b627a, 0x96294b4b],
       |  [0xdffea321, 0xe15dfefe],
       |  [0x41578216, 0xaed55757],
       |  [0x5415a841, 0x2abd1515],
       |  [0xc1779fb6, 0xeee87777],
       |  [0xdc37a5eb, 0x6e923737],
       |  [0xb3e57b56, 0xd79ee5e5],
       |  [0x469f8cd9, 0x23139f9f],
       |  [0xe7f0d317, 0xfd23f0f0],
       |  [0x354a6a7f, 0x94204a4a],
       |  [0x4fda9e95, 0xa944dada],
       |  [0x7d58fa25, 0xb0a25858],
       |  [0x03c906ca, 0x8fcfc9c9],
       |  [0xa429558d, 0x527c2929],
       |  [0x280a5022, 0x145a0a0a],
       |  [0xfeb1e14f, 0x7f50b1b1],
       |  [0xbaa0691a, 0x5dc9a0a0],
       |  [0xb16b7fda, 0xd6146b6b],
       |  [0x2e855cab, 0x17d98585],
       |  [0xcebd8173, 0x673cbdbd],
       |  [0x695dd234, 0xba8f5d5d],
       |  [0x40108050, 0x20901010],
       |  [0xf7f4f303, 0xf507f4f4],
       |  [0x0bcb16c0, 0x8bddcbcb],
       |  [0xf83eedc6, 0x7cd33e3e],
       |  [0x14052811, 0x0a2d0505],
       |  [0x81671fe6, 0xce786767],
       |  [0xb7e47353, 0xd597e4e4],
       |  [0x9c2725bb, 0x4e022727],
       |  [0x19413258, 0x82734141],
       |  [0x168b2c9d, 0x0ba78b8b],
       |  [0xa6a75101, 0x53f6a7a7],
       |  [0xe97dcf94, 0xfab27d7d],
       |  [0x6e95dcfb, 0x37499595],
       |  [0x47d88e9f, 0xad56d8d8],
       |  [0xcbfb8b30, 0xeb70fbfb],
       |  [0x9fee2371, 0xc1cdeeee],
       |  [0xed7cc791, 0xf8bb7c7c],
       |  [0x856617e3, 0xcc716666],
       |  [0x53dda68e, 0xa77bdddd],
       |  [0x5c17b84b, 0x2eaf1717],
       |  [0x01470246, 0x8e454747],
       |  [0x429e84dc, 0x211a9e9e],
       |  [0x0fca1ec5, 0x89d4caca],
       |  [0xb42d7599, 0x5a582d2d],
       |  [0xc6bf9179, 0x632ebfbf],
       |  [0x1c07381b, 0x0e3f0707],
       |  [0x8ead0123, 0x47acadad],
       |  [0x755aea2f, 0xb4b05a5a],
       |  [0x36836cb5, 0x1bef8383],
       |  [0xcc3385ff, 0x66b63333],
       |  [0x91633ff2, 0xc65c6363],
       |  [0x0802100a, 0x04120202],
       |  [0x92aa3938, 0x4993aaaa],
       |  [0xd971afa8, 0xe2de7171],
       |  [0x07c80ecf, 0x8dc6c8c8],
       |  [0x6419c87d, 0x32d11919],
       |  [0x39497270, 0x923b4949],
       |  [0x43d9869a, 0xaf5fd9d9],
       |  [0xeff2c31d, 0xf931f2f2],
       |  [0xabe34b48, 0xdba8e3e3],
       |  [0x715be22a, 0xb6b95b5b],
       |  [0x1a883492, 0x0dbc8888],
       |  [0x529aa4c8, 0x293e9a9a],
       |  [0x98262dbe, 0x4c0b2626],
       |  [0xc8328dfa, 0x64bf3232],
       |  [0xfab0e94a, 0x7d59b0b0],
       |  [0x83e91b6a, 0xcff2e9e9],
       |  [0x3c0f7833, 0x1e770f0f],
       |  [0x73d5e6a6, 0xb733d5d5],
       |  [0x3a8074ba, 0x1df48080],
       |  [0xc2be997c, 0x6127bebe],
       |  [0x13cd26de, 0x87ebcdcd],
       |  [0xd034bde4, 0x68893434],
       |  [0x3d487a75, 0x90324848],
       |  [0xdbffab24, 0xe354ffff],
       |  [0xf57af78f, 0xf48d7a7a],
       |  [0x7a90f4ea, 0x3d649090],
       |  [0x615fc23e, 0xbe9d5f5f],
       |  [0x80201da0, 0x403d2020],
       |  [0xbd6867d5, 0xd00f6868],
       |  [0x681ad072, 0x34ca1a1a],
       |  [0x82ae192c, 0x41b7aeae],
       |  [0xeab4c95e, 0x757db4b4],
       |  [0x4d549a19, 0xa8ce5454],
       |  [0x7693ece5, 0x3b7f9393],
       |  [0x88220daa, 0x442f2222],
       |  [0x8d6407e9, 0xc8636464],
       |  [0xe3f1db12, 0xff2af1f1],
       |  [0xd173bfa2, 0xe6cc7373],
       |  [0x4812905a, 0x24821212],
       |  [0x1d403a5d, 0x807a4040],
       |  [0x20084028, 0x10480808],
       |  [0x2bc356e8, 0x9b95c3c3],
       |  [0x97ec337b, 0xc5dfecec],
       |  [0x4bdb9690, 0xab4ddbdb],
       |  [0xbea1611f, 0x5fc0a1a1],
       |  [0x0e8d1c83, 0x07918d8d],
       |  [0xf43df5c9, 0x7ac83d3d],
       |  [0x6697ccf1, 0x335b9797],
       |  [0x00000000, 0x00000000],
       |  [0x1bcf36d4, 0x83f9cfcf],
       |  [0xac2b4587, 0x566e2b2b],
       |  [0xc57697b3, 0xece17676],
       |  [0x328264b0, 0x19e68282],
       |  [0x7fd6fea9, 0xb128d6d6],
       |  [0x6c1bd877, 0x36c31b1b],
       |  [0xeeb5c15b, 0x7774b5b5],
       |  [0x86af1129, 0x43beafaf],
       |  [0xb56a77df, 0xd41d6a6a],
       |  [0x5d50ba0d, 0xa0ea5050],
       |  [0x0945124c, 0x8a574545],
       |  [0xebf3cb18, 0xfb38f3f3],
       |  [0xc0309df0, 0x60ad3030],
       |  [0x9bef2b74, 0xc3c4efef],
       |  [0xfc3fe5c3, 0x7eda3f3f],
       |  [0x4955921c, 0xaac75555],
       |  [0xb2a27910, 0x59dba2a2],
       |  [0x8fea0365, 0xc9e9eaea],
       |  [0x89650fec, 0xca6a6565],
       |  [0xd2bab968, 0x6903baba],
       |  [0xbc2f6593, 0x5e4a2f2f],
       |  [0x27c04ee7, 0x9d8ec0c0],
       |  [0x5fdebe81, 0xa160dede],
       |  [0x701ce06c, 0x38fc1c1c],
       |  [0xd3fdbb2e, 0xe746fdfd],
       |  [0x294d5264, 0x9a1f4d4d],
       |  [0x7292e4e0, 0x39769292],
       |  [0xc9758fbc, 0xeafa7575],
       |  [0x1806301e, 0x0c360606],
       |  [0x128a2498, 0x09ae8a8a],
       |  [0xf2b2f940, 0x794bb2b2],
       |  [0xbfe66359, 0xd185e6e6],
       |  [0x380e7036, 0x1c7e0e0e],
       |  [0x7c1ff863, 0x3ee71f1f],
       |  [0x956237f7, 0xc4556262],
       |  [0x77d4eea3, 0xb53ad4d4],
       |  [0x9aa82932, 0x4d81a8a8],
       |  [0x6296c4f4, 0x31529696],
       |  [0xc3f99b3a, 0xef62f9f9],
       |  [0x33c566f6, 0x97a3c5c5],
       |  [0x942535b1, 0x4a102525],
       |  [0x7959f220, 0xb2ab5959],
       |  [0x2a8454ae, 0x15d08484],
       |  [0xd572b7a7, 0xe4c57272],
       |  [0xe439d5dd, 0x72ec3939],
       |  [0x2d4c5a61, 0x98164c4c],
       |  [0x655eca3b, 0xbc945e5e],
       |  [0xfd78e785, 0xf09f7878],
       |  [0xe038ddd8, 0x70e53838],
       |  [0x0a8c1486, 0x05988c8c],
       |  [0x63d1c6b2, 0xbf17d1d1],
       |  [0xaea5410b, 0x57e4a5a5],
       |  [0xafe2434d, 0xd9a1e2e2],
       |  [0x99612ff8, 0xc24e6161],
       |  [0xf6b3f145, 0x7b42b3b3],
       |  [0x842115a5, 0x42342121],
       |  [0x4a9c94d6, 0x25089c9c],
       |  [0x781ef066, 0x3cee1e1e],
       |  [0x11432252, 0x86614343],
       |  [0x3bc776fc, 0x93b1c7c7],
       |  [0xd7fcb32b, 0xe54ffcfc],
       |  [0x10042014, 0x08240404],
       |  [0x5951b208, 0xa2e35151],
       |  [0x5e99bcc7, 0x2f259999],
       |  [0xa96d4fc4, 0xda226d6d],
       |  [0x340d6839, 0x1a650d0d],
       |  [0xcffa8335, 0xe979fafa],
       |  [0x5bdfb684, 0xa369dfdf],
       |  [0xe57ed79b, 0xfca97e7e],
       |  [0x90243db4, 0x48192424],
       |  [0xec3bc5d7, 0x76fe3b3b],
       |  [0x96ab313d, 0x4b9aabab],
       |  [0x1fce3ed1, 0x81f0cece],
       |  [0x44118855, 0x22991111],
       |  [0x068f0c89, 0x03838f8f],
       |  [0x254e4a6b, 0x9c044e4e],
       |  [0xe6b7d151, 0x7366b7b7],
       |  [0x8beb0b60, 0xcbe0ebeb],
       |  [0xf03cfdcc, 0x78c13c3c],
       |  [0x3e817cbf, 0x1ffd8181],
       |  [0x6a94d4fe, 0x35409494],
       |  [0xfbf7eb0c, 0xf31cf7f7],
       |  [0xdeb9a167, 0x6f18b9b9],
       |  [0x4c13985f, 0x268b1313],
       |  [0xb02c7d9c, 0x58512c2c],
       |  [0x6bd3d6b8, 0xbb05d3d3],
       |  [0xbbe76b5c, 0xd38ce7e7],
       |  [0xa56e57cb, 0xdc396e6e],
       |  [0x37c46ef3, 0x95aac4c4],
       |  [0x0c03180f, 0x061b0303],
       |  [0x45568a13, 0xacdc5656],
       |  [0x0d441a49, 0x885e4444],
       |  [0xe17fdf9e, 0xfea07f7f],
       |  [0x9ea92137, 0x4f88a9a9],
       |  [0xa82a4d82, 0x54672a2a],
       |  [0xd6bbb16d, 0x6b0abbbb],
       |  [0x23c146e2, 0x9f87c1c1],
       |  [0x5153a202, 0xa6f15353],
       |  [0x57dcae8b, 0xa572dcdc],
       |  [0x2c0b5827, 0x16530b0b],
       |  [0x4e9d9cd3, 0x27019d9d],
       |  [0xad6c47c1, 0xd82b6c6c],
       |  [0xc43195f5, 0x62a43131],
       |  [0xcd7487b9, 0xe8f37474],
       |  [0xfff6e309, 0xf115f6f6],
       |  [0x05460a43, 0x8c4c4646],
       |  [0x8aac0926, 0x45a5acac],
       |  [0x1e893c97, 0x0fb58989],
       |  [0x5014a044, 0x28b41414],
       |  [0xa3e15b42, 0xdfbae1e1],
       |  [0x5816b04e, 0x2ca61616],
       |  [0xe83acdd2, 0x74f73a3a],
       |  [0xb9696fd0, 0xd2066969],
       |  [0x2409482d, 0x12410909],
       |  [0xdd70a7ad, 0xe0d77070],
       |  [0xe2b6d954, 0x716fb6b6],
       |  [0x67d0ceb7, 0xbd1ed0d0],
       |  [0x93ed3b7e, 0xc7d6eded],
       |  [0x17cc2edb, 0x85e2cccc],
       |  [0x15422a57, 0x84684242],
       |  [0x5a98b4c2, 0x2d2c9898],
       |  [0xaaa4490e, 0x55eda4a4],
       |  [0xa0285d88, 0x50752828],
       |  [0x6d5cda31, 0xb8865c5c],
       |  [0xc7f8933f, 0xed6bf8f8],
       |  [0x228644a4, 0x11c28686]
       |]);
       |
      0|final _c7 = Register64List.from([
       |  [0x186018c0, 0x7830d818],
       |  [0x238c2305, 0xaf462623],
       |  [0xc63fc67e, 0xf991b8c6],
       |  [0xe887e813, 0x6fcdfbe8],
       |  [0x8726874c, 0xa113cb87],
       |  [0xb8dab8a9, 0x626d11b8],
       |  [0x01040108, 0x05020901],
       |  [0x4f214f42, 0x6e9e0d4f],
       |  [0x36d836ad, 0xee6c9b36],
       |  [0xa6a2a659, 0x0451ffa6],
       |  [0xd26fd2de, 0xbdb90cd2],
       |  [0xf5f3f5fb, 0x06f70ef5],
       |  [0x79f979ef, 0x80f29679],
       |  [0x6fa16f5f, 0xcede306f],
       |  [0x917e91fc, 0xef3f6d91],
       |  [0x525552aa, 0x07a4f852],
       |  [0x609d6027, 0xfdc04760],
       |  [0xbccabc89, 0x766535bc],
       |  [0x9b569bac, 0xcd2b379b],
       |  [0x8e028e04, 0x8c018a8e],
       |  [0xa3b6a371, 0x155bd2a3],
       |  [0x0c300c60, 0x3c186c0c],
       |  [0x7bf17bff, 0x8af6847b],
       |  [0x35d435b5, 0xe16a8035],
       |  [0x1d741de8, 0x693af51d],
       |  [0xe0a7e053, 0x47ddb3e0],
       |  [0xd77bd7f6, 0xacb321d7],
       |  [0xc22fc25e, 0xed999cc2],
       |  [0x2eb82e6d, 0x965c432e],
       |  [0x4b314b62, 0x7a96294b],
       |  [0xfedffea3, 0x21e15dfe],
       |  [0x57415782, 0x16aed557],
       |  [0x155415a8, 0x412abd15],
       |  [0x77c1779f, 0xb6eee877],
       |  [0x37dc37a5, 0xeb6e9237],
       |  [0xe5b3e57b, 0x56d79ee5],
       |  [0x9f469f8c, 0xd923139f],
       |  [0xf0e7f0d3, 0x17fd23f0],
       |  [0x4a354a6a, 0x7f94204a],
       |  [0xda4fda9e, 0x95a944da],
       |  [0x587d58fa, 0x25b0a258],
       |  [0xc903c906, 0xca8fcfc9],
       |  [0x29a42955, 0x8d527c29],
       |  [0x0a280a50, 0x22145a0a],
       |  [0xb1feb1e1, 0x4f7f50b1],
       |  [0xa0baa069, 0x1a5dc9a0],
       |  [0x6bb16b7f, 0xdad6146b],
       |  [0x852e855c, 0xab17d985],
       |  [0xbdcebd81, 0x73673cbd],
       |  [0x5d695dd2, 0x34ba8f5d],
       |  [0x10401080, 0x50209010],
       |  [0xf4f7f4f3, 0x03f507f4],
       |  [0xcb0bcb16, 0xc08bddcb],
       |  [0x3ef83eed, 0xc67cd33e],
       |  [0x05140528, 0x110a2d05],
       |  [0x6781671f, 0xe6ce7867],
       |  [0xe4b7e473, 0x53d597e4],
       |  [0x279c2725, 0xbb4e0227],
       |  [0x41194132, 0x58827341],
       |  [0x8b168b2c, 0x9d0ba78b],
       |  [0xa7a6a751, 0x0153f6a7],
       |  [0x7de97dcf, 0x94fab27d],
       |  [0x956e95dc, 0xfb374995],
       |  [0xd847d88e, 0x9fad56d8],
       |  [0xfbcbfb8b, 0x30eb70fb],
       |  [0xee9fee23, 0x71c1cdee],
       |  [0x7ced7cc7, 0x91f8bb7c],
       |  [0x66856617, 0xe3cc7166],
       |  [0xdd53dda6, 0x8ea77bdd],
       |  [0x175c17b8, 0x4b2eaf17],
       |  [0x47014702, 0x468e4547],
       |  [0x9e429e84, 0xdc211a9e],
       |  [0xca0fca1e, 0xc589d4ca],
       |  [0x2db42d75, 0x995a582d],
       |  [0xbfc6bf91, 0x79632ebf],
       |  [0x071c0738, 0x1b0e3f07],
       |  [0xad8ead01, 0x2347acad],
       |  [0x5a755aea, 0x2fb4b05a],
       |  [0x8336836c, 0xb51bef83],
       |  [0x33cc3385, 0xff66b633],
       |  [0x6391633f, 0xf2c65c63],
       |  [0x02080210, 0x0a041202],
       |  [0xaa92aa39, 0x384993aa],
       |  [0x71d971af, 0xa8e2de71],
       |  [0xc807c80e, 0xcf8dc6c8],
       |  [0x196419c8, 0x7d32d119],
       |  [0x49394972, 0x70923b49],
       |  [0xd943d986, 0x9aaf5fd9],
       |  [0xf2eff2c3, 0x1df931f2],
       |  [0xe3abe34b, 0x48dba8e3],
       |  [0x5b715be2, 0x2ab6b95b],
       |  [0x881a8834, 0x920dbc88],
       |  [0x9a529aa4, 0xc8293e9a],
       |  [0x2698262d, 0xbe4c0b26],
       |  [0x32c8328d, 0xfa64bf32],
       |  [0xb0fab0e9, 0x4a7d59b0],
       |  [0xe983e91b, 0x6acff2e9],
       |  [0x0f3c0f78, 0x331e770f],
       |  [0xd573d5e6, 0xa6b733d5],
       |  [0x803a8074, 0xba1df480],
       |  [0xbec2be99, 0x7c6127be],
       |  [0xcd13cd26, 0xde87ebcd],
       |  [0x34d034bd, 0xe4688934],
       |  [0x483d487a, 0x75903248],
       |  [0xffdbffab, 0x24e354ff],
       |  [0x7af57af7, 0x8ff48d7a],
       |  [0x907a90f4, 0xea3d6490],
       |  [0x5f615fc2, 0x3ebe9d5f],
       |  [0x2080201d, 0xa0403d20],
       |  [0x68bd6867, 0xd5d00f68],
       |  [0x1a681ad0, 0x7234ca1a],
       |  [0xae82ae19, 0x2c41b7ae],
       |  [0xb4eab4c9, 0x5e757db4],
       |  [0x544d549a, 0x19a8ce54],
       |  [0x937693ec, 0xe53b7f93],
       |  [0x2288220d, 0xaa442f22],
       |  [0x648d6407, 0xe9c86364],
       |  [0xf1e3f1db, 0x12ff2af1],
       |  [0x73d173bf, 0xa2e6cc73],
       |  [0x12481290, 0x5a248212],
       |  [0x401d403a, 0x5d807a40],
       |  [0x08200840, 0x28104808],
       |  [0xc32bc356, 0xe89b95c3],
       |  [0xec97ec33, 0x7bc5dfec],
       |  [0xdb4bdb96, 0x90ab4ddb],
       |  [0xa1bea161, 0x1f5fc0a1],
       |  [0x8d0e8d1c, 0x8307918d],
       |  [0x3df43df5, 0xc97ac83d],
       |  [0x976697cc, 0xf1335b97],
       |  [0x00000000, 0x00000000],
       |  [0xcf1bcf36, 0xd483f9cf],
       |  [0x2bac2b45, 0x87566e2b],
       |  [0x76c57697, 0xb3ece176],
       |  [0x82328264, 0xb019e682],
       |  [0xd67fd6fe, 0xa9b128d6],
       |  [0x1b6c1bd8, 0x7736c31b],
       |  [0xb5eeb5c1, 0x5b7774b5],
       |  [0xaf86af11, 0x2943beaf],
       |  [0x6ab56a77, 0xdfd41d6a],
       |  [0x505d50ba, 0x0da0ea50],
       |  [0x45094512, 0x4c8a5745],
       |  [0xf3ebf3cb, 0x18fb38f3],
       |  [0x30c0309d, 0xf060ad30],
       |  [0xef9bef2b, 0x74c3c4ef],
       |  [0x3ffc3fe5, 0xc37eda3f],
       |  [0x55495592, 0x1caac755],
       |  [0xa2b2a279, 0x1059dba2],
       |  [0xea8fea03, 0x65c9e9ea],
       |  [0x6589650f, 0xecca6a65],
       |  [0xbad2bab9, 0x686903ba],
       |  [0x2fbc2f65, 0x935e4a2f],
       |  [0xc027c04e, 0xe79d8ec0],
       |  [0xde5fdebe, 0x81a160de],
       |  [0x1c701ce0, 0x6c38fc1c],
       |  [0xfdd3fdbb, 0x2ee746fd],
       |  [0x4d294d52, 0x649a1f4d],
       |  [0x927292e4, 0xe0397692],
       |  [0x75c9758f, 0xbceafa75],
       |  [0x06180630, 0x1e0c3606],
       |  [0x8a128a24, 0x9809ae8a],
       |  [0xb2f2b2f9, 0x40794bb2],
       |  [0xe6bfe663, 0x59d185e6],
       |  [0x0e380e70, 0x361c7e0e],
       |  [0x1f7c1ff8, 0x633ee71f],
       |  [0x62956237, 0xf7c45562],
       |  [0xd477d4ee, 0xa3b53ad4],
       |  [0xa89aa829, 0x324d81a8],
       |  [0x966296c4, 0xf4315296],
       |  [0xf9c3f99b, 0x3aef62f9],
       |  [0xc533c566, 0xf697a3c5],
       |  [0x25942535, 0xb14a1025],
       |  [0x597959f2, 0x20b2ab59],
       |  [0x842a8454, 0xae15d084],
       |  [0x72d572b7, 0xa7e4c572],
       |  [0x39e439d5, 0xdd72ec39],
       |  [0x4c2d4c5a, 0x6198164c],
       |  [0x5e655eca, 0x3bbc945e],
       |  [0x78fd78e7, 0x85f09f78],
       |  [0x38e038dd, 0xd870e538],
       |  [0x8c0a8c14, 0x8605988c],
       |  [0xd163d1c6, 0xb2bf17d1],
       |  [0xa5aea541, 0x0b57e4a5],
       |  [0xe2afe243, 0x4dd9a1e2],
       |  [0x6199612f, 0xf8c24e61],
       |  [0xb3f6b3f1, 0x457b42b3],
       |  [0x21842115, 0xa5423421],
       |  [0x9c4a9c94, 0xd625089c],
       |  [0x1e781ef0, 0x663cee1e],
       |  [0x43114322, 0x52866143],
       |  [0xc73bc776, 0xfc93b1c7],
       |  [0xfcd7fcb3, 0x2be54ffc],
       |  [0x04100420, 0x14082404],
       |  [0x515951b2, 0x08a2e351],
       |  [0x995e99bc, 0xc72f2599],
       |  [0x6da96d4f, 0xc4da226d],
       |  [0x0d340d68, 0x391a650d],
       |  [0xfacffa83, 0x35e979fa],
       |  [0xdf5bdfb6, 0x84a369df],
       |  [0x7ee57ed7, 0x9bfca97e],
       |  [0x2490243d, 0xb4481924],
       |  [0x3bec3bc5, 0xd776fe3b],
       |  [0xab96ab31, 0x3d4b9aab],
       |  [0xce1fce3e, 0xd181f0ce],
       |  [0x11441188, 0x55229911],
       |  [0x8f068f0c, 0x8903838f],
       |  [0x4e254e4a, 0x6b9c044e],
       |  [0xb7e6b7d1, 0x517366b7],
       |  [0xeb8beb0b, 0x60cbe0eb],
       |  [0x3cf03cfd, 0xcc78c13c],
       |  [0x813e817c, 0xbf1ffd81],
       |  [0x946a94d4, 0xfe354094],
       |  [0xf7fbf7eb, 0x0cf31cf7],
       |  [0xb9deb9a1, 0x676f18b9],
       |  [0x134c1398, 0x5f268b13],
       |  [0x2cb02c7d, 0x9c58512c],
       |  [0xd36bd3d6, 0xb8bb05d3],
       |  [0xe7bbe76b, 0x5cd38ce7],
       |  [0x6ea56e57, 0xcbdc396e],
       |  [0xc437c46e, 0xf395aac4],
       |  [0x030c0318, 0x0f061b03],
       |  [0x5645568a, 0x13acdc56],
       |  [0x440d441a, 0x49885e44],
       |  [0x7fe17fdf, 0x9efea07f],
       |  [0xa99ea921, 0x374f88a9],
       |  [0x2aa82a4d, 0x8254672a],
       |  [0xbbd6bbb1, 0x6d6b0abb],
       |  [0xc123c146, 0xe29f87c1],
       |  [0x535153a2, 0x02a6f153],
       |  [0xdc57dcae, 0x8ba572dc],
       |  [0x0b2c0b58, 0x2716530b],
       |  [0x9d4e9d9c, 0xd327019d],
       |  [0x6cad6c47, 0xc1d82b6c],
       |  [0x31c43195, 0xf562a431],
       |  [0x74cd7487, 0xb9e8f374],
       |  [0xf6fff6e3, 0x09f115f6],
       |  [0x4605460a, 0x438c4c46],
       |  [0xac8aac09, 0x2645a5ac],
       |  [0x891e893c, 0x970fb589],
       |  [0x145014a0, 0x4428b414],
       |  [0xe1a3e15b, 0x42dfbae1],
       |  [0x165816b0, 0x4e2ca616],
       |  [0x3ae83acd, 0xd274f73a],
       |  [0x69b9696f, 0xd0d20669],
       |  [0x09240948, 0x2d124109],
       |  [0x70dd70a7, 0xade0d770],
       |  [0xb6e2b6d9, 0x54716fb6],
       |  [0xd067d0ce, 0xb7bd1ed0],
       |  [0xed93ed3b, 0x7ec7d6ed],
       |  [0xcc17cc2e, 0xdb85e2cc],
       |  [0x4215422a, 0x57846842],
       |  [0x985a98b4, 0xc22d2c98],
       |  [0xa4aaa449, 0x0e55eda4],
       |  [0x28a0285d, 0x88507528],
       |  [0x5c6d5cda, 0x31b8865c],
       |  [0xf8c7f893, 0x3fed6bf8],
       |  [0x86228644, 0xa411c286]
       |]);
       |
      0|final _rc = Register64List.from([
       |  [0x00000000, 0x00000000],
       |  [0x1823c6e8, 0x87b8014f],
       |  [0x36a6d2f5, 0x796f9152],
       |  [0x60bc9b8e, 0xa30c7b35],
       |  [0x1de0d7c2, 0x2e4bfe57],
       |  [0x157737e5, 0x9ff04ada],
       |  [0x58c9290a, 0xb1a06b85],
       |  [0xbd5d10f4, 0xcb3e0567],
       |  [0xe427418b, 0xa77d95d8],
       |  [0xfbee7c66, 0xdd17479e],
       |  [0xca2dbf07, 0xad5a8333]
       |]);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp160r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp160r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp160r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp160r1', () => ECCurve_brainpoolp160r1());
       |
      0|  factory ECCurve_brainpoolp160r1() => constructFpStandardCurve(
       |      'brainpoolp160r1', ECCurve_brainpoolp160r1._make,
      0|      q: BigInt.parse('e95e4a5f737059dc60dfc7ad95b3d8139515620f', radix: 16),
      0|      a: BigInt.parse('340e7be2a280eb74e2be61bada745d97e8f7c300', radix: 16),
      0|      b: BigInt.parse('1e589a8595423412134faa2dbdec95c8d8675e58', radix: 16),
      0|      g: BigInt.parse(
       |          '04bed5af16ea3f6a4f62938c4631eb5af7bdbcdbc31667cb477a1a8ec338f94741669c976316da6321',
       |          radix: 16),
      0|      n: BigInt.parse('e95e4a5f737059dc60df5991d45029409e60fc09', radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp160r1;
       |
      0|  static ECCurve_brainpoolp160r1 _make(String domainName, ECCurve curve,
       |          ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp160r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp160r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp160t1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp160t1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp160t1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp160t1', () => ECCurve_brainpoolp160t1());
       |
      0|  factory ECCurve_brainpoolp160t1() => constructFpStandardCurve(
       |      'brainpoolp160t1', ECCurve_brainpoolp160t1._make,
      0|      q: BigInt.parse('e95e4a5f737059dc60dfc7ad95b3d8139515620f', radix: 16),
      0|      a: BigInt.parse('e95e4a5f737059dc60dfc7ad95b3d8139515620c', radix: 16),
      0|      b: BigInt.parse('7a556b6dae535b7b51ed2c4d7daa7a0b5c55f380', radix: 16),
      0|      g: BigInt.parse(
       |          '04b199b13b9b34efc1397e64baeb05acc265ff2378add6718b7c7c1961f0991b842443772152c9e0ad',
       |          radix: 16),
      0|      n: BigInt.parse('e95e4a5f737059dc60df5991d45029409e60fc09', radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp160t1;
       |
      0|  static ECCurve_brainpoolp160t1 _make(String domainName, ECCurve curve,
       |          ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp160t1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp160t1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp192r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp192r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp192r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp192r1', () => ECCurve_brainpoolp192r1());
       |
      0|  factory ECCurve_brainpoolp192r1() => constructFpStandardCurve(
       |      'brainpoolp192r1', ECCurve_brainpoolp192r1._make,
      0|      q: BigInt.parse('c302f41d932a36cda7a3463093d18db78fce476de1a86297',
       |          radix: 16),
      0|      a: BigInt.parse('6a91174076b1e0e19c39c031fe8685c1cae040e5c69a28ef',
       |          radix: 16),
      0|      b: BigInt.parse('469a28ef7c28cca3dc721d044f4496bcca7ef4146fbf25c9',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '04c0a0647eaab6a48753b033c56cb0f0900a2f5c4853375fd614b690866abd5bb88b5f4828c1490002e6773fa2fa299b8f',
       |          radix: 16),
      0|      n: BigInt.parse('c302f41d932a36cda7a3462f9e9e916b5be8f1029ac4acc1',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp192r1;
       |
      0|  static ECCurve_brainpoolp192r1 _make(String domainName, ECCurve curve,
       |          ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp192r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp192r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp192t1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp192t1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp192t1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp192t1', () => ECCurve_brainpoolp192t1());
       |
      0|  factory ECCurve_brainpoolp192t1() => constructFpStandardCurve(
       |      'brainpoolp192t1', ECCurve_brainpoolp192t1._make,
      0|      q: BigInt.parse('c302f41d932a36cda7a3463093d18db78fce476de1a86297',
       |          radix: 16),
      0|      a: BigInt.parse('c302f41d932a36cda7a3463093d18db78fce476de1a86294',
       |          radix: 16),
      0|      b: BigInt.parse('13d56ffaec78681e68f9deb43b35bec2fb68542e27897b79',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '043ae9e58c82f63c30282e1fe7bbf43fa72c446af6f4618129097e2c5667c2223a902ab5ca449d0084b7e5b3de7ccc01c9',
       |          radix: 16),
      0|      n: BigInt.parse('c302f41d932a36cda7a3462f9e9e916b5be8f1029ac4acc1',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp192t1;
       |
      0|  static ECCurve_brainpoolp192t1 _make(String domainName, ECCurve curve,
       |          ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp192t1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp192t1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp224r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp224r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp224r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp224r1', () => ECCurve_brainpoolp224r1());
       |
      0|  factory ECCurve_brainpoolp224r1() => constructFpStandardCurve(
       |      'brainpoolp224r1', ECCurve_brainpoolp224r1._make,
      0|      q: BigInt.parse(
       |          'd7c134aa264366862a18302575d1d787b09f075797da89f57ec8c0ff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '68a5e62ca9ce6c1c299803a6c1530b514e182ad8b0042a59cad29f43',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '2580f63ccfe44138870713b1a92369e33e2135d266dbb372386c400b',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '040d9029ad2c7e5cf4340823b2a87dc68c9e4ce3174c1e6efdee12c07d58aa56f772c0726f24c6b89e4ecdac24354b9e99caa3f6d3761402cd',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'd7c134aa264366862a18302575d0fb98d116bc4b6ddebca3a5a7939f',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp224r1 ;
       |
      0|  static ECCurve_brainpoolp224r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp224r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp224r1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp224t1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp224t1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp224t1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp224t1', () => ECCurve_brainpoolp224t1());
       |
      0|  factory ECCurve_brainpoolp224t1() => constructFpStandardCurve(
       |      'brainpoolp224t1', ECCurve_brainpoolp224t1._make,
      0|      q: BigInt.parse(
       |          'd7c134aa264366862a18302575d1d787b09f075797da89f57ec8c0ff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'd7c134aa264366862a18302575d1d787b09f075797da89f57ec8c0fc',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '4b337d934104cd7bef271bf60ced1ed20da14c08b3bb64f18a60888d',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '046ab1e344ce25ff3896424e7ffe14762ecb49f8928ac0c76029b4d5800374e9f5143e568cd23f3f4d7c0d4b1e41c8cc0d1c6abd5f1a46db4c',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'd7c134aa264366862a18302575d0fb98d116bc4b6ddebca3a5a7939f',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp224t1;
       |
      0|  static ECCurve_brainpoolp224t1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp224t1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp224t1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp256r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp256r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp256r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp256r1', () => ECCurve_brainpoolp256r1());
       |
      0|  factory ECCurve_brainpoolp256r1() => constructFpStandardCurve(
       |      'brainpoolp256r1', ECCurve_brainpoolp256r1._make,
      0|      q: BigInt.parse(
       |          'a9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '048bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'a9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp256r1;
       |
      0|  static ECCurve_brainpoolp256r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp256r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp256r1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp256t1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp256t1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp256t1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp256t1', () => ECCurve_brainpoolp256t1());
       |
      0|  factory ECCurve_brainpoolp256t1() => constructFpStandardCurve(
       |      'brainpoolp256t1', ECCurve_brainpoolp256t1._make,
      0|      q: BigInt.parse(
       |          'a9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'a9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5374',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '662c61c430d84ea4fe66a7733d0b76b7bf93ebc4af2f49256ae58101fee92b04',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '04a3e8eb3cc1cfe7b7732213b23a656149afa142c47aafbc2b79a191562e1305f42d996c823439c56d7f7b22e14644417e69bcb6de39d027001dabe8f35b25c9be',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'a9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp256t1;
       |
      0|  static ECCurve_brainpoolp256t1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp256t1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp256t1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp320r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp320r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp320r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp320r1', () => ECCurve_brainpoolp320r1());
       |
      0|  factory ECCurve_brainpoolp320r1() => constructFpStandardCurve(
       |      'brainpoolp320r1', ECCurve_brainpoolp320r1._make,
      0|      q: BigInt.parse(
       |          'd35e472036bc4fb7e13c785ed201e065f98fcfa6f6f40def4f92b9ec7893ec28fcd412b1f1b32e27',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '3ee30b568fbab0f883ccebd46d3f3bb8a2a73513f5eb79da66190eb085ffa9f492f375a97d860eb4',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '520883949dfdbc42d3ad198640688a6fe13f41349554b49acc31dccd884539816f5eb4ac8fb1f1a6',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '0443bd7e9afb53d8b85289bcc48ee5bfe6f20137d10a087eb6e7871e2a10a599c710af8d0d39e2061114fdd05545ec1cc8ab4093247f77275e0743ffed117182eaa9c77877aaac6ac7d35245d1692e8ee1',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'd35e472036bc4fb7e13c785ed201e065f98fcfa5b68f12a32d482ec7ee8658e98691555b44c59311',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp320r1;
       |
      0|  static ECCurve_brainpoolp320r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp320r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp320r1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp320t1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp320t1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp320t1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp320t1', () => ECCurve_brainpoolp320t1());
       |
      0|  factory ECCurve_brainpoolp320t1() => constructFpStandardCurve(
       |      'brainpoolp320t1', ECCurve_brainpoolp320t1._make,
      0|      q: BigInt.parse(
       |          'd35e472036bc4fb7e13c785ed201e065f98fcfa6f6f40def4f92b9ec7893ec28fcd412b1f1b32e27',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'd35e472036bc4fb7e13c785ed201e065f98fcfa6f6f40def4f92b9ec7893ec28fcd412b1f1b32e24',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          'a7f561e038eb1ed560b3d147db782013064c19f27ed27c6780aaf77fb8a547ceb5b4fef422340353',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '04925be9fb01afc6fb4d3e7d4990010f813408ab106c4f09cb7ee07868cc136fff3357f624a21bed5263ba3a7a27483ebf6671dbef7abb30ebee084e58a0b077ad42a5a0989d1ee71b1b9bc0455fb0d2c3',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'd35e472036bc4fb7e13c785ed201e065f98fcfa5b68f12a32d482ec7ee8658e98691555b44c59311',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp320t1;
       |
      0|  static ECCurve_brainpoolp320t1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp320t1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp320t1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp384r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp384r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp384r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp384r1', () => ECCurve_brainpoolp384r1());
       |
      0|  factory ECCurve_brainpoolp384r1() => constructFpStandardCurve(
       |      'brainpoolp384r1', ECCurve_brainpoolp384r1._make,
      0|      q: BigInt.parse(
       |          '8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '4a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '041d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp384r1;
       |
      0|  static ECCurve_brainpoolp384r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp384r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp384r1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp384t1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp384t1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp384t1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp384t1', () => ECCurve_brainpoolp384t1());
       |
      0|  factory ECCurve_brainpoolp384t1() => constructFpStandardCurve(
       |      'brainpoolp384t1', ECCurve_brainpoolp384t1._make,
      0|      q: BigInt.parse(
       |          '8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec50',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '7f519eada7bda81bd826dba647910f8c4b9346ed8ccdc64e4b1abd11756dce1d2074aa263b88805ced70355a33b471ee',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '0418de98b02db9a306f2afcd7235f72a819b80ab12ebd653172476fecd462aabffc4ff191b946a5f54d8d0aa2f418808cc25ab056962d30651a114afd2755ad336747f93475b7a1fca3b88f2b6a208ccfe469408584dc2b2912675bf5b9e582928',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp384t1;
       |
      0|  static ECCurve_brainpoolp384t1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp384t1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp384t1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp512r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp512r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp512r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp512r1', () => ECCurve_brainpoolp512r1());
       |
      0|  factory ECCurve_brainpoolp512r1() => constructFpStandardCurve(
       |      'brainpoolp512r1', ECCurve_brainpoolp512r1._make,
      0|      q: BigInt.parse(
       |          'aadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '0481aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f8227dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'aadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp512r1;
       |
      0|  static ECCurve_brainpoolp512r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp512r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp512r1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/brainpoolp512t1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.brainpoolp512t1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_brainpoolp512t1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'brainpoolp512t1', () => ECCurve_brainpoolp512t1());
       |
      0|  factory ECCurve_brainpoolp512t1() => constructFpStandardCurve(
       |      'brainpoolp512t1', ECCurve_brainpoolp512t1._make,
      0|      q: BigInt.parse(
       |          'aadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'aadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f0',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '7cbbbcf9441cfab76e1890e46884eae321f70c0bcb4981527897504bec3e36a62bcdfa2304976540f6450085f2dae145c22553b465763689180ea2571867423e',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '04640ece5c12788717b9c1ba06cbc2a6feba85842458c56dde9db1758d39c0313d82ba51735cdb3ea499aa77a7d6943a64f7a3f25fe26f06b51baa2696fa9035da5b534bd595f5af0fa2c892376c84ace1bb4e3019b71634c01131159cae03cee9d9932184beef216bd71df2dadf86a627306ecff96dbb8bace198b61e00f8b332',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'aadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_brainpoolp512t1;
       |
      0|  static ECCurve_brainpoolp512t1 _make(String domainName, ECCurve curve,
       |          ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_brainpoolp512t1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_brainpoolp512t1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/gostr3410_2001_cryptopro_a.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.gostr3410_2001_cryptopro_a;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_gostr3410_2001_cryptopro_a extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters,
       |      'GostR3410-2001-CryptoPro-A',
       |      () => ECCurve_gostr3410_2001_cryptopro_a());
       |
      0|  factory ECCurve_gostr3410_2001_cryptopro_a() => constructFpStandardCurve(
       |      'GostR3410-2001-CryptoPro-A', ECCurve_gostr3410_2001_cryptopro_a._make,
      0|      q: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd97',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd94',
       |          radix: 16),
      0|      b: BigInt.parse('a6', radix: 16),
      0|      g: BigInt.parse(
       |          '0400000000000000000000000000000000000000000000000000000000000000018d91e471e0989cda27df505a453f2b7635294f2ddf23e3b122acc99c9e9f1e14',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'ffffffffffffffffffffffffffffffff6c611070995ad10045841b09b761b893',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_gostr3410_2001_cryptopro_a;
       |
      0|  static ECCurve_gostr3410_2001_cryptopro_a _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_gostr3410_2001_cryptopro_a._super(
       |          domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_gostr3410_2001_cryptopro_a._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/gostr3410_2001_cryptopro_b.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.gostr3410_2001_cryptopro_b;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_gostr3410_2001_cryptopro_b extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters,
       |      'GostR3410-2001-CryptoPro-B',
       |      () => ECCurve_gostr3410_2001_cryptopro_b());
       |
      0|  factory ECCurve_gostr3410_2001_cryptopro_b() => constructFpStandardCurve(
       |      'GostR3410-2001-CryptoPro-B', ECCurve_gostr3410_2001_cryptopro_b._make,
      0|      q: BigInt.parse(
       |          '8000000000000000000000000000000000000000000000000000000000000c99',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '8000000000000000000000000000000000000000000000000000000000000c96',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '3e1af419a269a5f866a7d3c25c3df80ae979259373ff2b182f49d4ce7e1bbc8b',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '0400000000000000000000000000000000000000000000000000000000000000013fa8124359f96680b83d1c3eb2c070e5c545c9858d03ecfb744bf8d717717efc',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '800000000000000000000000000000015f700cfff1a624e5e497161bcc8a198f',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_gostr3410_2001_cryptopro_b;
       |
      0|  static ECCurve_gostr3410_2001_cryptopro_b _make(String domainName,
       |          ECCurve curve, ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_gostr3410_2001_cryptopro_b._super(
       |          domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_gostr3410_2001_cryptopro_b._super(String domainName, ECCurve curve,
       |      ECPoint G, BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/gostr3410_2001_cryptopro_c.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.gostr3410_2001_cryptopro_c;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_gostr3410_2001_cryptopro_c extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters,
       |      'GostR3410-2001-CryptoPro-C',
       |      () => ECCurve_gostr3410_2001_cryptopro_c());
       |
      0|  factory ECCurve_gostr3410_2001_cryptopro_c() => constructFpStandardCurve(
       |      'GostR3410-2001-CryptoPro-C', ECCurve_gostr3410_2001_cryptopro_c._make,
      0|      q: BigInt.parse(
       |          '9b9f605f5a858107ab1ec85e6b41c8aacf846e86789051d37998f7b9022d759b',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '9b9f605f5a858107ab1ec85e6b41c8aacf846e86789051d37998f7b9022d7598',
       |          radix: 16),
      0|      b: BigInt.parse('805a', radix: 16),
      0|      g: BigInt.parse(
       |          '04000000000000000000000000000000000000000000000000000000000000000041ece55743711a8c3cbf3783cd08c0ee4d4dc440d4641a8f366e550dfdb3bb67',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '9b9f605f5a858107ab1ec85e6b41c8aa582ca3511eddfb74f02f3a6598980bb9',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_gostr3410_2001_cryptopro_c;
       |
      0|  static ECCurve_gostr3410_2001_cryptopro_c _make(String domainName,
       |          ECCurve curve, ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_gostr3410_2001_cryptopro_c._super(
       |          domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_gostr3410_2001_cryptopro_c._super(String domainName, ECCurve curve,
       |      ECPoint G, BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/gostr3410_2001_cryptopro_xcha.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.gostr3410_2001_cryptopro_xcha;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_gostr3410_2001_cryptopro_xcha extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters,
       |      'GostR3410-2001-CryptoPro-XchA',
       |      () => ECCurve_gostr3410_2001_cryptopro_xcha());
       |
      0|  factory ECCurve_gostr3410_2001_cryptopro_xcha() => constructFpStandardCurve(
       |      'GostR3410-2001-CryptoPro-XchA',
       |      ECCurve_gostr3410_2001_cryptopro_xcha._make,
      0|      q: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd97',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd94',
       |          radix: 16),
      0|      b: BigInt.parse('a6', radix: 16),
      0|      g: BigInt.parse(
       |          '0400000000000000000000000000000000000000000000000000000000000000018d91e471e0989cda27df505a453f2b7635294f2ddf23e3b122acc99c9e9f1e14',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'ffffffffffffffffffffffffffffffff6c611070995ad10045841b09b761b893',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_gostr3410_2001_cryptopro_xcha;
       |
      0|  static ECCurve_gostr3410_2001_cryptopro_xcha _make(String domainName,
       |          ECCurve curve, ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_gostr3410_2001_cryptopro_xcha._super(
       |          domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_gostr3410_2001_cryptopro_xcha._super(String domainName, ECCurve curve,
       |      ECPoint G, BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/gostr3410_2001_cryptopro_xchb.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.gostr3410_2001_cryptopro_xchb;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_gostr3410_2001_cryptopro_xchb extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters,
       |      'GostR3410-2001-CryptoPro-XchB',
       |      () => ECCurve_gostr3410_2001_cryptopro_xchb());
       |
      0|  factory ECCurve_gostr3410_2001_cryptopro_xchb() => constructFpStandardCurve(
       |      'GostR3410-2001-CryptoPro-XchB',
       |      ECCurve_gostr3410_2001_cryptopro_xchb._make,
      0|      q: BigInt.parse(
       |          '9b9f605f5a858107ab1ec85e6b41c8aacf846e86789051d37998f7b9022d759b',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '9b9f605f5a858107ab1ec85e6b41c8aacf846e86789051d37998f7b9022d7598',
       |          radix: 16),
      0|      b: BigInt.parse('805a', radix: 16),
      0|      g: BigInt.parse(
       |          '04000000000000000000000000000000000000000000000000000000000000000041ece55743711a8c3cbf3783cd08c0ee4d4dc440d4641a8f366e550dfdb3bb67',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '9b9f605f5a858107ab1ec85e6b41c8aa582ca3511eddfb74f02f3a6598980bb9',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_gostr3410_2001_cryptopro_xchb;
       |
      0|  static ECCurve_gostr3410_2001_cryptopro_xchb _make(String domainName,
       |          ECCurve curve, ECPoint G, BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_gostr3410_2001_cryptopro_xchb._super(
       |          domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_gostr3410_2001_cryptopro_xchb._super(String domainName, ECCurve curve,
       |      ECPoint G, BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/prime192v1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.prime192v1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_prime192v1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'prime192v1', () => ECCurve_prime192v1());
       |
      0|  factory ECCurve_prime192v1() =>
      0|      constructFpStandardCurve('prime192v1', ECCurve_prime192v1._make,
      0|          q: BigInt.parse('fffffffffffffffffffffffffffffffeffffffffffffffff',
       |              radix: 16),
      0|          a: BigInt.parse('fffffffffffffffffffffffffffffffefffffffffffffffc',
       |              radix: 16),
      0|          b: BigInt.parse('64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1',
       |              radix: 16),
      0|          g: BigInt.parse('03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012',
       |              radix: 16),
      0|          n: BigInt.parse('ffffffffffffffffffffffff99def836146bc9b1b4d22831',
       |              radix: 16),
      0|          h: BigInt.parse('1', radix: 16),
      0|          seed: BigInt.parse('3045ae6fc8422f64ed579528d38120eae12196d5',
       |              radix: 16)) as ECCurve_prime192v1;
       |
      0|  static ECCurve_prime192v1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_prime192v1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_prime192v1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/prime192v2.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.prime192v2;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_prime192v2 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'prime192v2', () => ECCurve_prime192v2());
       |
      0|  factory ECCurve_prime192v2() =>
      0|      constructFpStandardCurve('prime192v2', ECCurve_prime192v2._make,
      0|          q: BigInt.parse('fffffffffffffffffffffffffffffffeffffffffffffffff',
       |              radix: 16),
      0|          a: BigInt.parse('fffffffffffffffffffffffffffffffefffffffffffffffc',
       |              radix: 16),
      0|          b: BigInt.parse('cc22d6dfb95c6b25e49c0d6364a4e5980c393aa21668d953',
       |              radix: 16),
      0|          g: BigInt.parse('03eea2bae7e1497842f2de7769cfe9c989c072ad696f48034a',
       |              radix: 16),
      0|          n: BigInt.parse('fffffffffffffffffffffffe5fb1a724dc80418648d8dd31',
       |              radix: 16),
      0|          h: BigInt.parse('1', radix: 16),
      0|          seed: BigInt.parse('31a92ee2029fd10d901b113e990710f0d21ac6b6',
       |              radix: 16)) as ECCurve_prime192v2;
       |
      0|  static ECCurve_prime192v2 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_prime192v2._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_prime192v2._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/prime192v3.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.prime192v3;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_prime192v3 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'prime192v3', () => ECCurve_prime192v3());
       |
      0|  factory ECCurve_prime192v3() =>
      0|      constructFpStandardCurve('prime192v3', ECCurve_prime192v3._make,
      0|          q: BigInt.parse('fffffffffffffffffffffffffffffffeffffffffffffffff',
       |              radix: 16),
      0|          a: BigInt.parse('fffffffffffffffffffffffffffffffefffffffffffffffc',
       |              radix: 16),
      0|          b: BigInt.parse('22123dc2395a05caa7423daeccc94760a7d462256bd56916',
       |              radix: 16),
      0|          g: BigInt.parse('027d29778100c65a1da1783716588dce2b8b4aee8e228f1896',
       |              radix: 16),
      0|          n: BigInt.parse('ffffffffffffffffffffffff7a62d031c83f4294f640ec13',
       |              radix: 16),
      0|          h: BigInt.parse('1', radix: 16),
      0|          seed: BigInt.parse('c469684435deb378c4b65ca9591e2a5763059a2e',
       |              radix: 16)) as ECCurve_prime192v3;
       |
      0|  static ECCurve_prime192v3 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_prime192v3._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_prime192v3._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/prime239v1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.prime239v1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_prime239v1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'prime239v1', () => ECCurve_prime239v1());
       |
      0|  factory ECCurve_prime239v1() => constructFpStandardCurve(
       |      'prime239v1', ECCurve_prime239v1._make,
      0|      q: BigInt.parse(
       |          '7fffffffffffffffffffffff7fffffffffff8000000000007fffffffffff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '7fffffffffffffffffffffff7fffff9e5e9a9f5d9071fbd1522688909d0b',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed:
      0|          BigInt.parse('e43bb460f0b80cc0c0b075798e948060f8321b7d', radix: 16)) as ECCurve_prime239v1;
       |
      0|  static ECCurve_prime239v1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_prime239v1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_prime239v1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/prime239v2.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.prime239v2;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_prime239v2 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'prime239v2', () => ECCurve_prime239v2());
       |
      0|  factory ECCurve_prime239v2() => constructFpStandardCurve(
       |      'prime239v2', ECCurve_prime239v2._make,
      0|      q: BigInt.parse(
       |          '7fffffffffffffffffffffff7fffffffffff8000000000007fffffffffff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '617fab6832576cbbfed50d99f0249c3fee58b94ba0038c7ae84c8c832f2c',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '0238af09d98727705120c921bb5e9e26296a3cdcf2f35757a0eafd87b830e7',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '7fffffffffffffffffffffff800000cfa7e8594377d414c03821bc582063',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed:
      0|          BigInt.parse('e8b4011604095303ca3b8099982be09fcb9ae616', radix: 16)) as ECCurve_prime239v2;
       |
      0|  static ECCurve_prime239v2 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_prime239v2._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_prime239v2._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/prime239v3.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.prime239v3;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_prime239v3 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'prime239v3', () => ECCurve_prime239v3());
       |
      0|  factory ECCurve_prime239v3() => constructFpStandardCurve(
       |      'prime239v3', ECCurve_prime239v3._make,
      0|      q: BigInt.parse(
       |          '7fffffffffffffffffffffff7fffffffffff8000000000007fffffffffff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '255705fa2a306654b1f4cb03d6a750a30c250102d4988717d9ba15ab6d3e',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '036768ae8e18bb92cfcf005c949aa2c6d94853d0e660bbf854b1c9505fe95a',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '7fffffffffffffffffffffff7fffff975deb41b3a6057c3c432146526551',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed:
      0|          BigInt.parse('7d7374168ffe3471b60a857686a19475d3bfa2ff', radix: 16)) as ECCurve_prime239v3;
       |
      0|  static ECCurve_prime239v3 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_prime239v3._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_prime239v3._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/prime256v1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.prime256v1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_prime256v1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'prime256v1', () => ECCurve_prime256v1());
       |
      0|  factory ECCurve_prime256v1() => constructFpStandardCurve(
       |      'prime256v1', ECCurve_prime256v1._make,
      0|      q: BigInt.parse(
       |          'ffffffff00000001000000000000000000000000ffffffffffffffffffffffff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'ffffffff00000001000000000000000000000000fffffffffffffffffffffffc',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed:
      0|          BigInt.parse('c49d360886e704936a6678e1139d26b7819f7e90', radix: 16)) as ECCurve_prime256v1;
       |
      0|  static ECCurve_prime256v1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_prime256v1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_prime256v1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp112r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp112r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp112r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp112r1', () => ECCurve_secp112r1());
       |
      0|  factory ECCurve_secp112r1() =>
      0|      constructFpStandardCurve('secp112r1', ECCurve_secp112r1._make,
      0|          q: BigInt.parse('db7c2abf62e35e668076bead208b', radix: 16),
      0|          a: BigInt.parse('db7c2abf62e35e668076bead2088', radix: 16),
      0|          b: BigInt.parse('659ef8ba043916eede8911702b22', radix: 16),
      0|          g: BigInt.parse(
       |              '0409487239995a5ee76b55f9c2f098a89ce5af8724c0a23e0e0ff77500',
       |              radix: 16),
      0|          n: BigInt.parse('db7c2abf62e35e7628dfac6561c5', radix: 16),
      0|          h: BigInt.parse('1', radix: 16),
      0|          seed: BigInt.parse('00f50b028e4d696e676875615175290472783fb1',
       |              radix: 16)) as ECCurve_secp112r1;
       |
      0|  static ECCurve_secp112r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp112r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp112r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp112r2.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp112r2;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp112r2 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp112r2', () => ECCurve_secp112r2());
       |
      0|  factory ECCurve_secp112r2() =>
      0|      constructFpStandardCurve('secp112r2', ECCurve_secp112r2._make,
      0|          q: BigInt.parse('db7c2abf62e35e668076bead208b', radix: 16),
      0|          a: BigInt.parse('6127c24c05f38a0aaaf65c0ef02c', radix: 16),
      0|          b: BigInt.parse('51def1815db5ed74fcc34c85d709', radix: 16),
      0|          g: BigInt.parse(
       |              '044ba30ab5e892b4e1649dd0928643adcd46f5882e3747def36e956e97',
       |              radix: 16),
      0|          n: BigInt.parse('36df0aafd8b8d7597ca10520d04b', radix: 16),
      0|          h: BigInt.parse('4', radix: 16),
      0|          seed: BigInt.parse('002757a1114d696e6768756151755316c05e0bd4',
       |              radix: 16)) as ECCurve_secp112r2;
       |
      0|  static ECCurve_secp112r2 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp112r2._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp112r2._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp128r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp128r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp128r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp128r1', () => ECCurve_secp128r1());
       |
      0|  factory ECCurve_secp128r1() => constructFpStandardCurve(
       |      'secp128r1', ECCurve_secp128r1._make,
      0|      q: BigInt.parse('fffffffdffffffffffffffffffffffff', radix: 16),
      0|      a: BigInt.parse('fffffffdfffffffffffffffffffffffc', radix: 16),
      0|      b: BigInt.parse('e87579c11079f43dd824993c2cee5ed3', radix: 16),
      0|      g: BigInt.parse(
       |          '04161ff7528b899b2d0c28607ca52c5b86cf5ac8395bafeb13c02da292dded7a83',
       |          radix: 16),
      0|      n: BigInt.parse('fffffffe0000000075a30d1b9038a115', radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
      0|      seed: BigInt.parse('000e0d4d696e6768756151750cc03a4473d03679',
       |          radix: 16)) as ECCurve_secp128r1;
       |
      0|  static ECCurve_secp128r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp128r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp128r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp128r2.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp128r2;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp128r2 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp128r2', () => ECCurve_secp128r2());
       |
      0|  factory ECCurve_secp128r2() => constructFpStandardCurve(
       |      'secp128r2', ECCurve_secp128r2._make,
      0|      q: BigInt.parse('fffffffdffffffffffffffffffffffff', radix: 16),
      0|      a: BigInt.parse('d6031998d1b3bbfebf59cc9bbff9aee1', radix: 16),
      0|      b: BigInt.parse('5eeefca380d02919dc2c6558bb6d8a5d', radix: 16),
      0|      g: BigInt.parse(
       |          '047b6aa5d85e572983e6fb32a7cdebc14027b6916a894d3aee7106fe805fc34b44',
       |          radix: 16),
      0|      n: BigInt.parse('3fffffff7fffffffbe0024720613b5a3', radix: 16),
      0|      h: BigInt.parse('4', radix: 16),
      0|      seed: BigInt.parse('004d696e67687561517512d8f03431fce63b88f4',
       |          radix: 16)) as ECCurve_secp128r2;
       |
      0|  static ECCurve_secp128r2 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp128r2._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp128r2._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp160k1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp160k1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp160k1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp160k1', () => ECCurve_secp160k1());
       |
      0|  factory ECCurve_secp160k1() => constructFpStandardCurve(
       |      'secp160k1', ECCurve_secp160k1._make,
      0|      q: BigInt.parse('fffffffffffffffffffffffffffffffeffffac73', radix: 16),
      0|      a: BigInt.parse('0', radix: 16),
      0|      b: BigInt.parse('7', radix: 16),
      0|      g: BigInt.parse(
       |          '043b4c382ce37aa192a4019e763036f4f5dd4d7ebb938cf935318fdced6bc28286531733c3f03c4fee',
       |          radix: 16),
      0|      n: BigInt.parse('100000000000000000001b8fa16dfab9aca16b6b3', radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_secp160k1;
       |
      0|  static ECCurve_secp160k1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp160k1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp160k1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp160r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp160r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp160r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp160r1', () => ECCurve_secp160r1());
       |
      0|  factory ECCurve_secp160r1() => constructFpStandardCurve(
       |      'secp160r1', ECCurve_secp160r1._make,
      0|      q: BigInt.parse('ffffffffffffffffffffffffffffffff7fffffff', radix: 16),
      0|      a: BigInt.parse('ffffffffffffffffffffffffffffffff7ffffffc', radix: 16),
      0|      b: BigInt.parse('1c97befc54bd7a8b65acf89f81d4d4adc565fa45', radix: 16),
      0|      g: BigInt.parse(
       |          '044a96b5688ef573284664698968c38bb913cbfc8223a628553168947d59dcc912042351377ac5fb32',
       |          radix: 16),
      0|      n: BigInt.parse('100000000000000000001f4c8f927aed3ca752257', radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
      0|      seed: BigInt.parse('1053cde42c14d696e67687561517533bf3f83345',
       |          radix: 16)) as ECCurve_secp160r1;
       |
      0|  static ECCurve_secp160r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp160r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp160r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp160r2.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp160r2;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp160r2 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp160r2', () => ECCurve_secp160r2());
       |
      0|  factory ECCurve_secp160r2() => constructFpStandardCurve(
       |      'secp160r2', ECCurve_secp160r2._make,
      0|      q: BigInt.parse('fffffffffffffffffffffffffffffffeffffac73', radix: 16),
      0|      a: BigInt.parse('fffffffffffffffffffffffffffffffeffffac70', radix: 16),
      0|      b: BigInt.parse('b4e134d3fb59eb8bab57274904664d5af50388ba', radix: 16),
      0|      g: BigInt.parse(
       |          '0452dcb034293a117e1f4ff11b30f7199d3144ce6dfeaffef2e331f296e071fa0df9982cfea7d43f2e',
       |          radix: 16),
      0|      n: BigInt.parse('100000000000000000000351ee786a818f3a1a16b', radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
      0|      seed: BigInt.parse('b99b99b099b323e02709a4d696e6768756151751',
       |          radix: 16)) as ECCurve_secp160r2;
       |
      0|  static ECCurve_secp160r2 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp160r2._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp160r2._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp192k1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp192k1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp192k1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp192k1', () => ECCurve_secp192k1());
       |
      0|  factory ECCurve_secp192k1() => constructFpStandardCurve(
       |      'secp192k1', ECCurve_secp192k1._make,
      0|      q: BigInt.parse('fffffffffffffffffffffffffffffffffffffffeffffee37',
       |          radix: 16),
      0|      a: BigInt.parse('0', radix: 16),
      0|      b: BigInt.parse('3', radix: 16),
      0|      g: BigInt.parse(
       |          '04db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d',
       |          radix: 16),
      0|      n: BigInt.parse('fffffffffffffffffffffffe26f2fc170f69466a74defd8d',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_secp192k1;
       |
      0|  static ECCurve_secp192k1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp192k1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp192k1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp192r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp192r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp192r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp192r1', () => ECCurve_secp192r1());
       |
      0|  factory ECCurve_secp192r1() => constructFpStandardCurve(
       |      'secp192r1', ECCurve_secp192r1._make,
      0|      q: BigInt.parse('fffffffffffffffffffffffffffffffeffffffffffffffff',
       |          radix: 16),
      0|      a: BigInt.parse('fffffffffffffffffffffffffffffffefffffffffffffffc',
       |          radix: 16),
      0|      b: BigInt.parse('64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '04188da80eb03090f67cbf20eb43a18800f4ff0afd82ff101207192b95ffc8da78631011ed6b24cdd573f977a11e794811',
       |          radix: 16),
      0|      n: BigInt.parse('ffffffffffffffffffffffff99def836146bc9b1b4d22831',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed:
      0|          BigInt.parse('3045ae6fc8422f64ed579528d38120eae12196d5', radix: 16)) as ECCurve_secp192r1;
       |
      0|  static ECCurve_secp192r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp192r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp192r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp224k1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp224k1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp224k1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp224k1', () => ECCurve_secp224k1());
       |
      0|  factory ECCurve_secp224k1() => constructFpStandardCurve(
       |      'secp224k1', ECCurve_secp224k1._make,
      0|      q: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffffffffffffffffffeffffe56d',
       |          radix: 16),
      0|      a: BigInt.parse('0', radix: 16),
      0|      b: BigInt.parse('5', radix: 16),
      0|      g: BigInt.parse(
       |          '04a1455b334df099df30fc28a169a467e9e47075a90f7e650eb6b7a45c7e089fed7fba344282cafbd6f7e319f7c0b0bd59e2ca4bdb556d61a5',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '10000000000000000000000000001dce8d2ec6184caf0a971769fb1f7',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_secp224k1;
       |
      0|  static ECCurve_secp224k1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp224k1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp224k1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp224r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp224r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp224r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp224r1', () => ECCurve_secp224r1());
       |
      0|  factory ECCurve_secp224r1() => constructFpStandardCurve(
       |      'secp224r1', ECCurve_secp224r1._make,
      0|      q: BigInt.parse(
       |          'ffffffffffffffffffffffffffffffff000000000000000000000001',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffefffffffffffffffffffffffe',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          'b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '04b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'ffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed:
      0|          BigInt.parse('bd71344799d5c7fcdc45b59fa3b9ab8f6a948bc5', radix: 16)) as ECCurve_secp224r1;
       |
      0|  static ECCurve_secp224r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp224r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp224r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp256k1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp256k1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp256k1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp256k1', () => ECCurve_secp256k1());
       |
      0|  factory ECCurve_secp256k1() => constructFpStandardCurve(
       |      'secp256k1', ECCurve_secp256k1._make,
      0|      q: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',
       |          radix: 16),
      0|      a: BigInt.parse('0', radix: 16),
      0|      b: BigInt.parse('7', radix: 16),
      0|      g: BigInt.parse(
       |          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed: null) as ECCurve_secp256k1;
       |
      0|  static ECCurve_secp256k1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp256k1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp256k1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp256r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp256r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp256r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp256r1', () => ECCurve_secp256r1());
       |
      0|  factory ECCurve_secp256r1() => constructFpStandardCurve(
       |      'secp256r1', ECCurve_secp256r1._make,
      0|      q: BigInt.parse(
       |          'ffffffff00000001000000000000000000000000ffffffffffffffffffffffff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'ffffffff00000001000000000000000000000000fffffffffffffffffffffffc',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '046b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2964fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed:
      0|          BigInt.parse('c49d360886e704936a6678e1139d26b7819f7e90', radix: 16)) as ECCurve_secp256r1;
       |
      0|  static ECCurve_secp256r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp256r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp256r1._super(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp384r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp384r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp384r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp384r1', () => ECCurve_secp384r1());
       |
      0|  factory ECCurve_secp384r1() => constructFpStandardCurve(
       |      'secp384r1', ECCurve_secp384r1._make,
      0|      q: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          'fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          'b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '04aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab73617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          'ffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
       |      seed:
      0|          BigInt.parse('a335926aa319a27a1d00896a6773a4827acdac73', radix: 16)) as ECCurve_secp384r1;
       |
      0|  static ECCurve_secp384r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp384r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp384r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/curves/secp521r1.dart
       |// See file LICENSE for more information.
       |
       |library impl.ec_domain_parameters.secp521r1;
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/src/ec_standard_curve_constructor.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// ignore: camel_case_types
       |class ECCurve_secp521r1 extends ECDomainParametersImpl {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      ECDomainParameters, 'secp521r1', () => ECCurve_secp521r1());
       |
      0|  factory ECCurve_secp521r1() => constructFpStandardCurve(
       |      'secp521r1', ECCurve_secp521r1._make,
      0|      q: BigInt.parse('1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
       |          radix: 16),
      0|      a: BigInt.parse(
       |          '1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc',
       |          radix: 16),
      0|      b: BigInt.parse(
       |          '51953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00',
       |          radix: 16),
      0|      g: BigInt.parse(
       |          '0400c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650',
       |          radix: 16),
      0|      n: BigInt.parse(
       |          '1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409',
       |          radix: 16),
      0|      h: BigInt.parse('1', radix: 16),
      0|      seed: BigInt.parse('d09e8800291cb85396cc6717393284aaa0da64ba',
       |          radix: 16)) as ECCurve_secp521r1;
       |
      0|  static ECCurve_secp521r1 _make(String domainName, ECCurve curve, ECPoint G,
       |          BigInt n, BigInt _h, List<int> seed) =>
      0|      ECCurve_secp521r1._super(domainName, curve, G, n, _h, seed);
       |
      0|  ECCurve_secp521r1._super(String domainName, ECCurve curve, ECPoint G,
       |      BigInt n, BigInt _h, List<int> seed)
      0|      : super(domainName, curve, G, n, _h, seed);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/key_derivators/hkdf.dart
       |// See file LICENSE for more information.
       |
       |library impl.key_derivator.hkdf;
       |
       |import 'dart:math';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/export.dart';
       |import 'package:pointycastle/key_derivators/api.dart';
       |import 'package:pointycastle/src/impl/base_key_derivator.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// HMAC-based Extract-and-Expand Key Derivation Function (HKDF) implemented
       |/// according to IETF RFC 5869.
       |class HKDFKeyDerivator extends BaseKeyDerivator {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig =
       |      DynamicFactoryConfig.suffix(KeyDerivator, '/HKDF', (_, Match match) {
       |    final digestName = match.group(1);
       |    final digest = Digest(digestName);
       |    return () {
       |      return HKDFKeyDerivator(digest);
       |    };
       |  });
       |
      0|  static final Map<String, int> _digestBlockLength = {
       |    'GOST3411': 32,
       |    'MD2': 16,
       |    'MD4': 64,
       |    'MD5': 64,
       |    'RIPEMD-128': 64,
       |    'RIPEMD-160': 64,
       |    'SHA-1': 64,
       |    'SHA-224': 64,
       |    'SHA-256': 64,
       |    'SHA-384': 128,
       |    'SHA-512': 128,
       |    'Tiger': 64,
       |    'Whirlpool': 64,
       |  };
       |
       |  HkdfParameters _params;
       |
       |  HMac _hMac;
       |  int _hashLen;
       |
       |  Uint8List _info;
       |  Uint8List _currentT;
       |
       |  int _generatedBytes;
       |
      0|  HKDFKeyDerivator(Digest digest) {
      0|    ArgumentError.checkNotNull(digest);
       |
      0|    _hMac = HMac(digest, _getBlockLengthFromDigest(digest.algorithmName));
      0|    _hashLen = _hMac.macSize;
       |  }
       |
      0|  @override
      0|  String get algorithmName => '${_hMac.algorithmName}/HKDF';
       |
      0|  @override
      0|  int get keySize => _params.desiredKeyLength;
       |
      0|  @override
       |  void init(covariant HkdfParameters params) {
      0|    _params = params;
       |
      0|    if (_params.skipExtract) {
       |      // use IKM directly as PRK
      0|      _hMac.init(KeyParameter(_params.ikm));
       |    } else {
      0|      _hMac.init(extract(_params.salt, _params.ikm));
       |    }
       |
      0|    _info = _params.info;
       |
      0|    _generatedBytes = 0;
      0|    _currentT = Uint8List(_hashLen);
       |  }
       |
      0|  @override
       |  int deriveKey(Uint8List inp, int inpOff, Uint8List out, int outOff) {
       |    // append input to the 'info' part for key derivation
       |    if (inp != null) {
      0|      _info = Uint8List.fromList(_info + inp);
       |    }
       |
      0|    return _generate(out, outOff, keySize);
       |  }
       |
       |  /// Performs the extract part of the key derivation function.
      0|  KeyParameter extract(Uint8List salt, Uint8List ikm) {
      0|    if (salt == null || salt.isEmpty) {
      0|      if (_hashLen != _hMac.macSize) {
      0|        throw ArgumentError(
      0|            'Hash length doesn\'t equal MAC size of: ${_hMac.algorithmName}');
       |      }
       |
      0|      _hMac.init(KeyParameter(Uint8List(_hashLen)));
       |    } else {
      0|      _hMac.init(KeyParameter(salt));
       |    }
       |
      0|    _hMac.update(ikm, 0, ikm.length);
       |
      0|    var prk = Uint8List(_hashLen);
      0|    _hMac.doFinal(prk, 0);
      0|    return KeyParameter(prk);
       |  }
       |
       |  /// Performs the expand part of the key derivation function, using currentT
       |  /// as input and output buffer.
      0|  void expandNext() {
      0|    var n = _generatedBytes ~/ _hashLen + 1;
      0|    if (n >= 256) {
      0|      throw ArgumentError(
       |          'HKDF cannot generate more than 255 blocks of HashLen size');
       |    }
       |
       |    // special case for T(0): T(0) is empty, so no update
      0|    if (_generatedBytes != 0) {
      0|      _hMac.update(_currentT, 0, _hashLen);
       |    }
       |
      0|    _hMac.update(_info, 0, _info.length);
      0|    _hMac.updateByte(n);
      0|    _hMac.doFinal(_currentT, 0);
       |  }
       |
      0|  int _generate(Uint8List out, int outOff, int len) {
      0|    if (_generatedBytes + len > 255 * _hashLen) {
      0|      throw ArgumentError(
       |          'HKDF may only be used for 255 * HashLen bytes of output');
       |    }
       |
      0|    if (_generatedBytes % _hashLen == 0) {
      0|      expandNext();
       |    }
       |
       |    // copy what is left in the currentT
       |    var toGenerate = len;
      0|    var posInT = _generatedBytes % _hashLen;
      0|    var leftInT = _hashLen - _generatedBytes % _hashLen;
      1|    var toCopy = min(leftInT, toGenerate);
      0|    out.setRange(outOff, outOff + toCopy, _currentT.sublist(posInT));
      0|    _generatedBytes += toCopy;
      0|    toGenerate -= toCopy;
      0|    outOff += toCopy;
       |
      0|    while (toGenerate > 0) {
      0|      expandNext();
      1|      toCopy = min(_hashLen, toGenerate);
      0|      out.setRange(outOff, outOff + toCopy, _currentT.sublist(0));
      0|      _generatedBytes += toCopy;
      0|      toGenerate -= toCopy;
      0|      outOff += toCopy;
       |    }
       |
       |    return len;
       |  }
       |
      0|  static int _getBlockLengthFromDigest(String digestName) {
      0|    var blockLength = _digestBlockLength.entries
      0|        .firstWhere((map) => map.key.toLowerCase() == digestName.toLowerCase(),
      0|            orElse: () => null)
      0|        .value;
       |    if (blockLength == null) {
      0|      throw ArgumentError('Invalid block length for digest: $digestName');
       |    }
       |
       |    return blockLength;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/key_derivators/pbkdf2.dart
       |// See file LICENSE for more information.
       |
       |library impl.key_derivator.pbkdf2;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/key_derivators/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_key_derivator.dart';
       |
       |/// Generator for PBE derived keys and ivs as defined by PKCS 5 V2.0 Scheme 2. This generator uses a SHA-1 HMac as the
       |/// calculation function. The document this implementation is based on can be found at:
       |///
       |/// * [http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html]
       |///
       |class PBKDF2KeyDerivator extends BaseKeyDerivator {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      KeyDerivator,
       |      '/PBKDF2',
       |      (_, final Match match) => () {
       |            var mac = Mac(match.group(1));
       |            return PBKDF2KeyDerivator(mac);
       |          });
       |
       |  Pbkdf2Parameters _params;
       |  final Mac _mac;
       |  Uint8List _state;
       |
      0|  PBKDF2KeyDerivator(this._mac) {
      0|    _state = Uint8List(_mac.macSize);
       |  }
       |
      0|  @override
      0|  String get algorithmName => '${_mac.algorithmName}/PBKDF2';
       |
      0|  @override
      0|  int get keySize => _params.desiredKeyLength;
       |
      0|  void reset() {
      0|    _mac.reset();
      0|    _state.fillRange(0, _state.length, 0);
       |  }
       |
      0|  @override
       |  void init(covariant Pbkdf2Parameters params) {
      0|    _params = params;
       |  }
       |
      0|  @override
       |  int deriveKey(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    var dkLen = _params.desiredKeyLength;
      0|    var hLen = _mac.macSize;
      0|    var l = (dkLen + hLen - 1) ~/ hLen;
      0|    var iBuf = Uint8List(4);
      0|    var outBytes = Uint8List(l * hLen);
       |    var outPos = 0;
       |
      0|    CipherParameters param = KeyParameter(inp.sublist(inpOff));
      0|    _mac.init(param);
       |
      0|    for (var i = 1; i <= l; i++) {
       |      // Increment the value in 'iBuf'
      0|      for (var pos = 3;; pos--) {
      0|        iBuf[pos]++;
      0|        if (iBuf[pos] != 0) break;
       |      }
       |
      0|      _f(_params.salt, _params.iterationCount, iBuf, outBytes, outPos);
      0|      outPos += hLen;
       |    }
       |
      0|    out.setRange(outOff, outOff + dkLen, outBytes);
       |
      0|    return keySize;
       |  }
       |
      0|  void _f(Uint8List S, int c, Uint8List iBuf, Uint8List out, int outOff) {
      0|    if (c <= 0) {
      0|      throw ArgumentError('Iteration count must be at least 1.');
       |    }
       |
       |    if (S != null) {
      0|      _mac.update(S, 0, S.length);
       |    }
       |
      0|    _mac.update(iBuf, 0, iBuf.length);
      0|    _mac.doFinal(_state, 0);
       |
      0|    out.setRange(outOff, outOff + _state.length, _state);
       |
      0|    for (var count = 1; count < c; count++) {
      0|      _mac.update(_state, 0, _state.length);
      0|      _mac.doFinal(_state, 0);
       |
      0|      for (var j = 0; j != _state.length; j++) {
      0|        out[outOff + j] ^= _state[j];
       |      }
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/key_derivators/scrypt.dart
       |// See file LICENSE for more information.
       |
       |library impl.key_derivator.scrypt;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/digests/sha256.dart';
       |import 'package:pointycastle/key_derivators/api.dart';
       |import 'package:pointycastle/key_derivators/pbkdf2.dart';
       |import 'package:pointycastle/macs/hmac.dart';
       |import 'package:pointycastle/src/impl/base_key_derivator.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |///
       |/// Implementation of SCrypt password based key derivation function. See the next link for info on
       |/// how to choose N, r, and p:
       |/// * <http://stackoverflow.com/questions/11126315/what-are-optimal-scrypt-work-factors>
       |///
       |/// This implementation is based on Java implementation by Will Glozer, which can be found at:
       |/// * <https://github.com/wg/scrypt>
       |///
       |class Scrypt extends BaseKeyDerivator {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(KeyDerivator, 'scrypt', () => Scrypt());
       |
       |  static final int _maxValue = 0x7fffffff;
       |
       |  ScryptParameters _params;
       |
       |  @override
       |  final String algorithmName = 'scrypt';
       |
      0|  @override
      0|  int get keySize => _params.desiredKeyLength;
       |
      0|  void reset() {
      0|    _params = null;
       |  }
       |
      0|  @override
       |  void init(covariant ScryptParameters params) {
      0|    _params = params;
       |  }
       |
      0|  @override
       |  int deriveKey(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    var key = _scryptJ(Uint8List.fromList(inp.sublist(inpOff)), _params.salt,
      0|        _params.N, _params.r, _params.p, _params.desiredKeyLength);
       |
      0|    out.setRange(0, keySize, key);
       |
      0|    return keySize;
       |  }
       |
      0|  Uint8List _scryptJ(
       |      Uint8List passwd, Uint8List salt, int N, int r, int p, int dkLen) {
      0|    if (N < 2 || (N & (N - 1)) != 0) {
      0|      throw ArgumentError('N must be a power of 2 greater than 1');
       |    }
       |
      0|    if (N > _maxValue / 128 / r) {
      0|      throw ArgumentError('Parameter N is too large');
       |    }
       |
      0|    if (r > _maxValue / 128 / p) {
      0|      throw ArgumentError('Parameter r is too large');
       |    }
       |
      0|    final dk = Uint8List(dkLen);
       |
      0|    final b = Uint8List(128 * r * p);
      0|    final xy = Uint8List(256 * r);
      0|    final v = Uint8List(128 * r * N);
       |
      0|    final pbkdf2 = PBKDF2KeyDerivator(HMac(SHA256Digest(), 64));
       |
      0|    pbkdf2.init(Pbkdf2Parameters(salt, 1, p * 128 * r));
      0|    pbkdf2.deriveKey(passwd, 0, b, 0);
       |
      0|    for (var i = 0; i < p; i++) {
      0|      _smix(b, i * 128 * r, r, N, v, xy);
       |    }
       |
      0|    pbkdf2.init(Pbkdf2Parameters(b, 1, dkLen));
      0|    pbkdf2.deriveKey(passwd, 0, dk, 0);
       |
       |    return dk;
       |  }
       |
      0|  void _smix(Uint8List B, int bi, int r, int N, Uint8List V, Uint8List xy) {
       |    var xi = 0;
      0|    var yi = 128 * r;
       |
      0|    _arraycopy(B, bi, xy, xi, 128 * r);
       |
      0|    for (var i = 0; i < N; i++) {
      0|      _arraycopy(xy, xi, V, i * (128 * r), 128 * r);
      0|      _blockmixSalsa8(xy, xi, yi, r);
       |    }
       |
      0|    for (var i = 0; i < N; i++) {
      0|      var j = _integerify(xy, xi, r) & (N - 1);
      0|      _blockxor(V, j * (128 * r), xy, xi, 128 * r);
      0|      _blockmixSalsa8(xy, xi, yi, r);
       |    }
       |
      0|    _arraycopy(xy, xi, B, bi, 128 * r);
       |  }
       |
      0|  void _blockmixSalsa8(Uint8List by, int bi, int yi, int r) {
      0|    final X = Uint8List(64);
       |
      0|    _arraycopy(by, bi + (2 * r - 1) * 64, X, 0, 64);
       |
      0|    for (var i = 0; i < 2 * r; i++) {
      0|      _blockxor(by, i * 64, X, 0, 64);
      0|      _salsa20_8(X);
      0|      _arraycopy(X, 0, by, yi + (i * 64), 64);
       |    }
       |
      0|    for (var i = 0; i < r; i++) {
      0|      _arraycopy(by, yi + (i * 2) * 64, by, bi + (i * 64), 64);
       |    }
       |
      0|    for (var i = 0; i < r; i++) {
      0|      _arraycopy(by, yi + (i * 2 + 1) * 64, by, bi + (i + r) * 64, 64);
       |    }
       |  }
       |
      0|  void _salsa20_8(Uint8List B) {
      0|    final b32 = Uint32List(16);
      0|    final x = Uint32List(16);
       |
      0|    for (var i = 0; i < 16; i++) {
      0|      b32[i] = unpack32(B, i * 4, Endian.little);
       |    }
       |
      0|    _arraycopy(b32, 0, x, 0, 16);
       |
      0|    for (var i = 8; i > 0; i -= 2) {
      0|      x[4] ^= crotl32(x[0] + x[12], 7);
      0|      x[8] ^= crotl32(x[4] + x[0], 9);
      0|      x[12] ^= crotl32(x[8] + x[4], 13);
      0|      x[0] ^= crotl32(x[12] + x[8], 18);
      0|      x[9] ^= crotl32(x[5] + x[1], 7);
      0|      x[13] ^= crotl32(x[9] + x[5], 9);
      0|      x[1] ^= crotl32(x[13] + x[9], 13);
      0|      x[5] ^= crotl32(x[1] + x[13], 18);
      0|      x[14] ^= crotl32(x[10] + x[6], 7);
      0|      x[2] ^= crotl32(x[14] + x[10], 9);
      0|      x[6] ^= crotl32(x[2] + x[14], 13);
      0|      x[10] ^= crotl32(x[6] + x[2], 18);
      0|      x[3] ^= crotl32(x[15] + x[11], 7);
      0|      x[7] ^= crotl32(x[3] + x[15], 9);
      0|      x[11] ^= crotl32(x[7] + x[3], 13);
      0|      x[15] ^= crotl32(x[11] + x[7], 18);
      0|      x[1] ^= crotl32(x[0] + x[3], 7);
      0|      x[2] ^= crotl32(x[1] + x[0], 9);
      0|      x[3] ^= crotl32(x[2] + x[1], 13);
      0|      x[0] ^= crotl32(x[3] + x[2], 18);
      0|      x[6] ^= crotl32(x[5] + x[4], 7);
      0|      x[7] ^= crotl32(x[6] + x[5], 9);
      0|      x[4] ^= crotl32(x[7] + x[6], 13);
      0|      x[5] ^= crotl32(x[4] + x[7], 18);
      0|      x[11] ^= crotl32(x[10] + x[9], 7);
      0|      x[8] ^= crotl32(x[11] + x[10], 9);
      0|      x[9] ^= crotl32(x[8] + x[11], 13);
      0|      x[10] ^= crotl32(x[9] + x[8], 18);
      0|      x[12] ^= crotl32(x[15] + x[14], 7);
      0|      x[13] ^= crotl32(x[12] + x[15], 9);
      0|      x[14] ^= crotl32(x[13] + x[12], 13);
      0|      x[15] ^= crotl32(x[14] + x[13], 18);
       |    }
       |
      0|    for (var i = 0; i < 16; i++) {
      0|      b32[i] = x[i] + b32[i];
       |    }
       |
      0|    for (var i = 0; i < 16; i++) {
      0|      pack32(b32[i], B, i * 4, Endian.little);
       |    }
       |  }
       |
      0|  void _blockxor(Uint8List s, int si, Uint8List d, int di, int len) {
      0|    for (var i = 0; i < len; i++) {
      0|      d[di + i] ^= s[si + i];
       |    }
       |  }
       |
      0|  int _integerify(Uint8List b, int bi, int r) {
      0|    bi += (2 * r - 1) * 64;
      0|    return unpack32(b, bi, Endian.little);
       |  }
       |
      0|  void _arraycopy(
       |          List<int> inp, int inpOff, List<int> out, int outOff, int len) =>
      0|      out.setRange(outOff, outOff + len, inp.sublist(inpOff));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/key_generators/ec_key_generator.dart
       |// See file LICENSE for more information.
       |
       |library impl.key_generator.ec_key_generator;
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/key_generators/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Abstract [CipherParameters] to init an ECC key generator.
       |class ECKeyGenerator implements KeyGenerator {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(KeyGenerator, 'EC', () => ECKeyGenerator());
       |
       |  ECDomainParameters _params;
       |  SecureRandom _random;
       |
      0|  @override
       |  String get algorithmName => 'EC';
       |
      0|  @override
       |  void init(CipherParameters params) {
       |    ECKeyGeneratorParameters ecparams;
       |
      0|    if (params is ParametersWithRandom) {
      0|      _random = params.random;
      0|      ecparams = params.parameters;
       |    } else {
      0|      _random = SecureRandom();
       |      ecparams = params;
       |    }
       |
      0|    _params = ecparams.domainParameters;
       |  }
       |
      0|  @override
       |  AsymmetricKeyPair generateKeyPair() {
      0|    var n = _params.n;
      0|    var nBitLength = n.bitLength;
       |    BigInt d;
       |
       |    do {
      0|      d = _random.nextBigInteger(nBitLength);
      0|    } while (d == BigInt.zero || (d >= n));
       |
      0|    var Q = _params.G * d;
       |
      0|    return AsymmetricKeyPair(ECPublicKey(Q, _params), ECPrivateKey(d, _params));
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/key_generators/rsa_key_generator.dart
       |// See file LICENSE for more information.
       |
       |library impl.key_generator.rsa_key_generator;
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/asymmetric/api.dart';
       |import 'package:pointycastle/key_generators/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
      1|bool _testBit(BigInt i, int n) {
      5|  return (i & (BigInt.one << n)) != BigInt.zero;
       |}
       |
       |class RSAKeyGenerator implements KeyGenerator {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(KeyGenerator, 'RSA', () => RSAKeyGenerator());
       |
       |  SecureRandom _random;
       |  RSAKeyGeneratorParameters _params;
       |
      0|  @override
       |  String get algorithmName => 'RSA';
       |
      1|  @override
       |  void init(CipherParameters params) {
      1|    if (params is ParametersWithRandom) {
      2|      _random = params.random;
      2|      _params = params.parameters;
       |    } else {
      0|      _random = SecureRandom();
      0|      _params = params;
       |    }
       |
      3|    if (_params.bitStrength < 12) {
      0|      throw ArgumentError('key bit strength cannot be smaller than 12');
       |    }
       |
      3|    if (!_testBit(_params.publicExponent, 0)) {
      0|      throw ArgumentError('Public exponent cannot be even');
       |    }
       |  }
       |
      1|  @override
       |  AsymmetricKeyPair generateKeyPair() {
       |    BigInt p, q, n, e;
       |
       |    // p and q values should have a length of half the strength in bits
      2|    var strength = _params.bitStrength;
      2|    var pbitlength = (strength + 1) ~/ 2;
      1|    var qbitlength = strength - pbitlength;
      1|    var mindiffbits = strength ~/ 3;
       |
      2|    e = _params.publicExponent;
       |
       |    // TODO Consider generating safe primes for p, q (see DHParametersHelper.generateSafePrimes)
       |    // (then p-1 and q-1 will not consist of only small factors - see "Pollard's algorithm")
       |
       |    // generate p, prime and (p-1) relatively prime to e
       |    for (;;) {
      2|      p = generateProbablePrime(pbitlength, 1, _random);
       |
      3|      if (p % e == BigInt.one) {
       |        continue;
       |      }
       |
      3|      if (!_isProbablePrime(p, _params.certainty)) {
       |        continue;
       |      }
       |
      5|      if (e.gcd(p - BigInt.one) == BigInt.one) {
       |        break;
       |      }
       |    }
       |
       |    // generate a modulus of the required length
       |    for (;;) {
       |      // generate q, prime and (q-1) relatively prime to e, and not equal to p
       |      for (;;) {
      2|        q = generateProbablePrime(qbitlength, 1, _random);
       |
      4|        if ((q - p).abs().bitLength < mindiffbits) {
       |          continue;
       |        }
       |
      3|        if (q % e == BigInt.one) {
       |          continue;
       |        }
       |
      3|        if (!_isProbablePrime(q, _params.certainty)) {
       |          continue;
       |        }
       |
      5|        if (e.gcd(q - BigInt.one) == BigInt.one) {
       |          break;
       |        }
       |      }
       |
       |      // calculate the modulus
      1|      n = (p * q);
       |
      4|      if (n.bitLength == _params.bitStrength) {
       |        break;
       |      }
       |
       |      // if we get here our primes aren't big enough, make the largest of the two p and try again
      0|      p = (p.compareTo(q) > 0) ? p : q;
       |    }
       |
       |    // Swap p and q if necessary
      1|    if (p < q) {
       |      var swap = p;
       |      p = q;
       |      q = swap;
       |    }
       |
       |    // calculate the private exponent
      2|    var pSub1 = (p - BigInt.one);
      2|    var qSub1 = (q - BigInt.one);
      1|    var phi = (pSub1 * qSub1);
      1|    var d = e.modInverse(phi);
       |
      3|    return AsymmetricKeyPair(RSAPublicKey(n, e), RSAPrivateKey(n, d, p, q, e));
       |  }
       |}
       |
       |/// [List] of low primes
      3|final List<BigInt> _lowprimes = [
      1|  BigInt.from(2),
      1|  BigInt.from(3),
      1|  BigInt.from(5),
      1|  BigInt.from(7),
      1|  BigInt.from(11),
      1|  BigInt.from(13),
      1|  BigInt.from(17),
      1|  BigInt.from(19),
      1|  BigInt.from(23),
      1|  BigInt.from(29),
      1|  BigInt.from(31),
      1|  BigInt.from(37),
      1|  BigInt.from(41),
      1|  BigInt.from(43),
      1|  BigInt.from(47),
      1|  BigInt.from(53),
      1|  BigInt.from(59),
      1|  BigInt.from(61),
      1|  BigInt.from(67),
      1|  BigInt.from(71),
      1|  BigInt.from(73),
      1|  BigInt.from(79),
      1|  BigInt.from(83),
      1|  BigInt.from(89),
      1|  BigInt.from(97),
      1|  BigInt.from(101),
      1|  BigInt.from(103),
      1|  BigInt.from(107),
      1|  BigInt.from(109),
      1|  BigInt.from(113),
      1|  BigInt.from(127),
      1|  BigInt.from(131),
      1|  BigInt.from(137),
      1|  BigInt.from(139),
      1|  BigInt.from(149),
      1|  BigInt.from(151),
      1|  BigInt.from(157),
      1|  BigInt.from(163),
      1|  BigInt.from(167),
      1|  BigInt.from(173),
      1|  BigInt.from(179),
      1|  BigInt.from(181),
      1|  BigInt.from(191),
      1|  BigInt.from(193),
      1|  BigInt.from(197),
      1|  BigInt.from(199),
      1|  BigInt.from(211),
      1|  BigInt.from(223),
      1|  BigInt.from(227),
      1|  BigInt.from(229),
      1|  BigInt.from(233),
      1|  BigInt.from(239),
      1|  BigInt.from(241),
      1|  BigInt.from(251),
      1|  BigInt.from(257),
      1|  BigInt.from(263),
      1|  BigInt.from(269),
      1|  BigInt.from(271),
      1|  BigInt.from(277),
      1|  BigInt.from(281),
      1|  BigInt.from(283),
      1|  BigInt.from(293),
      1|  BigInt.from(307),
      1|  BigInt.from(311),
      1|  BigInt.from(313),
      1|  BigInt.from(317),
      1|  BigInt.from(331),
      1|  BigInt.from(337),
      1|  BigInt.from(347),
      1|  BigInt.from(349),
      1|  BigInt.from(353),
      1|  BigInt.from(359),
      1|  BigInt.from(367),
      1|  BigInt.from(373),
      1|  BigInt.from(379),
      1|  BigInt.from(383),
      1|  BigInt.from(389),
      1|  BigInt.from(397),
      1|  BigInt.from(401),
      1|  BigInt.from(409),
      1|  BigInt.from(419),
      1|  BigInt.from(421),
      1|  BigInt.from(431),
      1|  BigInt.from(433),
      1|  BigInt.from(439),
      1|  BigInt.from(443),
      1|  BigInt.from(449),
      1|  BigInt.from(457),
      1|  BigInt.from(461),
      1|  BigInt.from(463),
      1|  BigInt.from(467),
      1|  BigInt.from(479),
      1|  BigInt.from(487),
      1|  BigInt.from(491),
      1|  BigInt.from(499),
      1|  BigInt.from(503),
      1|  BigInt.from(509)
       |];
       |
      7|final BigInt _lplim = (BigInt.one << 26) ~/ _lowprimes.last;
       |
      3|final BigInt _bigTwo = BigInt.from(2);
       |
       |/// return index of lowest 1-bit in x, x < 2^31
      1|int _lbit(BigInt x) {
       |  // Implementation borrowed from bignum.BigIntegerDartvm.
      2|  if (x == BigInt.zero) return -1;
       |  var r = 0;
      4|  while ((x & BigInt.from(0xffffffff)) == BigInt.zero) {
      0|    x >>= 32;
      0|    r += 32;
       |  }
      4|  if ((x & BigInt.from(0xffff)) == BigInt.zero) {
      0|    x >>= 16;
      0|    r += 16;
       |  }
      4|  if ((x & BigInt.from(0xff)) == BigInt.zero) {
      1|    x >>= 8;
      1|    r += 8;
       |  }
      4|  if ((x & BigInt.from(0xf)) == BigInt.zero) {
      1|    x >>= 4;
      1|    r += 4;
       |  }
      4|  if ((x & BigInt.from(3)) == BigInt.zero) {
      1|    x >>= 2;
      1|    r += 2;
       |  }
      5|  if ((x & BigInt.one) == BigInt.zero) ++r;
       |  return r;
       |}
       |
       |/// true if probably prime (HAC 4.24, Miller-Rabin) */
      1|bool _millerRabin(BigInt b, int t) {
       |  // Implementation borrowed from bignum.BigIntegerDartvm.
      2|  var n1 = b - BigInt.one;
      1|  var k = _lbit(n1);
      1|  if (k <= 0) return false;
      1|  var r = n1 >> k;
      2|  t = (t + 1) >> 1;
      3|  if (t > _lowprimes.length) t = _lowprimes.length;
       |  BigInt a;
      2|  for (var i = 0; i < t; ++i) {
      2|    a = _lowprimes[i];
      1|    var y = a.modPow(r, b);
      5|    if (y.compareTo(BigInt.one) != 0 && y.compareTo(n1) != 0) {
       |      var j = 1;
      4|      while (j++ < k && y.compareTo(n1) != 0) {
      2|        y = y.modPow(_bigTwo, b);
      3|        if (y.compareTo(BigInt.one) == 0) return false;
       |      }
      2|      if (y.compareTo(n1) != 0) return false;
       |    }
       |  }
       |  return true;
       |}
       |
       |/// test primality with certainty >= 1-.5^t */
      1|bool _isProbablePrime(BigInt b, int t) {
       |  // Implementation borrowed from bignum.BigIntegerDartvm.
       |  var i;
      1|  var x = b.abs();
      3|  if (b <= _lowprimes.last) {
      0|    for (i = 0; i < _lowprimes.length; ++i) {
      0|      if (b == _lowprimes[i]) return true;
       |    }
       |    return false;
       |  }
      1|  if (x.isEven) return false;
       |  i = 1;
      3|  while (i < _lowprimes.length) {
      3|    var m = _lowprimes[i], j = i + 1;
      5|    while (j < _lowprimes.length && m < _lplim) {
      4|      m *= _lowprimes[j++];
       |    }
      1|    m = x % m;
      1|    while (i < j)
      5|      if (m % _lowprimes[i++] == 0) {
       |        return false;
       |      }
       |  }
      1|  return _millerRabin(x, t);
       |}
       |
      1|BigInt generateProbablePrime(int bitLength, int certainty, SecureRandom rnd) {
      1|  if (bitLength < 2) {
      0|    return BigInt.one;
       |  }
       |
      1|  var candidate = rnd.nextBigInteger(bitLength);
       |
       |  // force MSB set
      2|  if (!_testBit(candidate, bitLength - 1)) {
      4|    candidate |= BigInt.one << (bitLength - 1);
       |  }
       |
       |  // force odd
      1|  if (candidate.isEven) {
      2|    candidate += BigInt.one;
       |  }
       |
      1|  while (!_isProbablePrime(candidate, certainty)) {
      2|    candidate += _bigTwo;
      2|    if (candidate.bitLength > bitLength) {
      0|      candidate -= BigInt.one << (bitLength - 1);
       |    }
       |  }
       |
       |  return candidate;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/macs/cbc_block_cipher_mac.dart
       |// See file LICENSE for more information.
       |
       |library impl.mac.cbc_block_cipher_mac;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_mac.dart';
       |import 'package:pointycastle/block/modes/cbc.dart';
       |
       |/// standard CBC Block Cipher MAC - if no padding is specified the default of
       |/// pad of zeroes is used.
       |class CBCBlockCipherMac extends BaseMac {
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.regex(
       |    Mac,
       |    r'^(.+)/CBC_CMAC(/(.+))?$',
       |    (_, final Match match) => () {
       |      var cipher = BlockCipher(match.group(1));
       |      var padding = match.groupCount >= 3 &&
       |              match.group(3) != null &&
       |              match.group(3).isNotEmpty
       |          ? Padding(match.group(3))
       |          : null;
       |      return CBCBlockCipherMac.fromCipherAndPadding(cipher, padding);
       |    },
       |  );
       |
       |  Uint8List _mac;
       |
       |  Uint8List _buf;
       |  int _bufOff;
       |  final BlockCipher _cipher;
       |  final Padding _padding;
       |
       |  final int _macSize;
       |
       |  ParametersWithIV _params;
       |
       |  ///
       |  /// create a standard MAC based on a CBC block cipher. This will produce an
       |  /// authentication code half the length of the block size of the cipher.
       |  ///
       |  /// * [cipher] the cipher to be used as the basis of the MAC generation.
      0|  CBCBlockCipherMac.fromCipher(BlockCipher cipher)
      0|      : this(cipher, (cipher.blockSize * 8) ~/ 2, null);
       |
       |  ///
       |  /// create a standard MAC based on a CBC block cipher. This will produce an
       |  /// authentication code half the length of the block size of the cipher.
       |  ///
       |  /// * [cipher] the cipher to be used as the basis of the MAC generation.
       |  /// * [padding] the padding to be used to complete the last block.
      0|  CBCBlockCipherMac.fromCipherAndPadding(BlockCipher cipher, Padding padding)
      0|      : this(cipher, (cipher.blockSize * 8) ~/ 2, padding);
       |
       |  ///
       |  /// create a standard MAC based on a block cipher with the size of the
       |  /// MAC been given in bits. This class uses CBC mode as the basis for the
       |  /// MAC generation.
       |  ///
       |  /// Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
       |  /// or 16 bits if being used as a data authenticator (FIPS Publication 113),
       |  /// and in general should be less than the size of the block cipher as it
       |  /// reduces the chance of an exhaustive attack (see Handbook of Applied
       |  /// Cryptography).
       |  ///
       |  /// * [cipher] the cipher to be used as the basis of the MAC generation.
       |  /// * [macSizeInBits] the size of the MAC in bits, must be a multiple of 8.
      0|  CBCBlockCipherMac.fromCipherAndMacSize(BlockCipher cipher, int macSizeInBits)
      0|      : this(cipher, macSizeInBits, null);
       |
       |  ///
       |  /// create a standard MAC based on a block cipher with the size of the
       |  /// MAC been given in bits. This class uses CBC mode as the basis for the
       |  /// MAC generation.
       |  ///
       |  /// Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
       |  /// or 16 bits if being used as a data authenticator (FIPS Publication 113),
       |  /// and in general should be less than the size of the block cipher as it
       |  /// reduces the chance of an exhaustive attack (see Handbook of Applied
       |  /// Cryptography).
       |  ///
       |  /// * [cipher] the cipher to be used as the basis of the MAC generation.
       |  /// * [macSizeInBits] the size of the MAC in bits, must be a multiple of 8.
       |  /// * [padding] the padding to be used to complete the last block.
      0|  CBCBlockCipherMac(BlockCipher cipher, int macSizeInBits, Padding padding)
      0|      : _cipher = CBCBlockCipher(cipher),
      0|        _macSize = macSizeInBits ~/ 8,
       |        _padding = padding {
      0|    if ((macSizeInBits % 8) != 0) {
      0|      throw ArgumentError('MAC size must be multiple of 8');
       |    }
       |
      0|    _mac = Uint8List(cipher.blockSize);
       |
      0|    _buf = Uint8List(cipher.blockSize);
      0|    _bufOff = 0;
       |  }
       |
      0|  @override
       |  String get algorithmName {
      0|    var paddingName = _padding != null ? '/${_padding.algorithmName}' : '';
      0|    return '${_cipher.algorithmName}_CMAC$paddingName';
       |  }
       |
      0|  @override
       |  void init(CipherParameters params) {
      0|    if (params is ParametersWithIV) {
      0|      _params = params;
      0|    } else if (params is KeyParameter) {
      0|      final zeroIV = Uint8List(params.key.length);
      0|      _params = ParametersWithIV(params, zeroIV);
       |    }
       |
      0|    reset();
       |
      0|    _cipher.init(true, _params);
       |  }
       |
      0|  @override
      0|  int get macSize => _macSize;
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    if (_bufOff == _buf.length) {
      0|      _cipher.processBlock(_buf, 0, _mac, 0);
      0|      _bufOff = 0;
       |    }
       |
      0|    _buf[_bufOff++] = inp;
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inOff, int len) {
      0|    if (len < 0) {
      0|      throw ArgumentError('Can\'t have a negative input length!');
       |    }
       |
      0|    var blockSize = _cipher.blockSize;
      0|    var gapLen = blockSize - _bufOff;
       |
      0|    if (len > gapLen) {
      0|      _buf.setRange(_bufOff, _bufOff + gapLen, inp.sublist(inOff));
       |
      0|      _cipher.processBlock(_buf, 0, _mac, 0);
       |
      0|      _bufOff = 0;
      0|      len -= gapLen;
      0|      inOff += gapLen;
       |
      0|      while (len > blockSize) {
      0|        _cipher.processBlock(inp, inOff, _mac, 0);
       |
      0|        len -= blockSize;
      0|        inOff += blockSize;
       |      }
       |    }
       |
      0|    _buf.setRange(_bufOff, _bufOff + len, inp.sublist(inOff));
       |
      0|    _bufOff += len;
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    var blockSize = _cipher.blockSize;
       |
      0|    if (_padding == null) {
       |      //
       |      // pad with zeroes
       |      //
      0|      while (_bufOff < blockSize) {
      0|        _buf[_bufOff] = 0;
      0|        _bufOff++;
       |      }
       |    } else {
      0|      if (_bufOff == blockSize) {
      0|        _cipher.processBlock(_buf, 0, _mac, 0);
      0|        _bufOff = 0;
       |      }
       |
      0|      _padding.addPadding(_buf, _bufOff);
       |    }
       |
      0|    _cipher.processBlock(_buf, 0, _mac, 0);
       |
      0|    out.setRange(outOff, outOff + _macSize, _mac);
       |
      0|    reset();
       |
      0|    return _macSize;
       |  }
       |
       |  /// Reset the mac generator.
      0|  @override
       |  void reset() {
       |    // clean the buffer.
      0|    for (var i = 0; i < _buf.length; i++) {
      0|      _buf[i] = 0;
       |    }
       |
      0|    _bufOff = 0;
       |
       |    // reset the underlying cipher.
      0|    _cipher.reset();
       |
      0|    if (_params != null) {
      0|      _cipher.init(true, _params);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/macs/cmac.dart
       |// See file LICENSE for more information.
       |
       |library impl.mac.cmac;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/impl/base_mac.dart';
       |import 'package:pointycastle/paddings/iso7816d4.dart';
       |import 'package:pointycastle/block/modes/cbc.dart';
       |
       |/// CMAC - as specified at www.nuee.nagoya-u.ac.jp/labs/tiwata/omac/omac.html
       |/// <p>
       |/// CMAC is analogous to OMAC1 - see also en.wikipedia.org/wiki/CMAC
       |/// </p><p>
       |/// CMAC is a NIST recomendation - see
       |/// csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38B.pdf
       |/// </p><p>
       |/// CMAC/OMAC1 is a blockcipher-based message authentication code designed and
       |/// analyzed by Tetsu Iwata and Kaoru Kurosawa.
       |/// </p><p>
       |/// CMAC/OMAC1 is a simple variant of the CBC MAC (Cipher Block Chaining Message
       |/// Authentication Code). OMAC stands for One-Key CBC MAC.
       |/// </p><p>
       |/// It supports 128- or 64-bits block ciphers, with any key size, and returns
       |/// a MAC with dimension less or equal to the block size of the underlying
       |/// cipher.
       |/// </p>
       |class CMac extends BaseMac {
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |    Mac,
       |    '/CMAC',
       |    (_, final Match match) => () {
       |      var cipher = BlockCipher(match.group(1));
       |      return CMac.fromCipher(cipher);
       |    },
       |  );
       |
       |  Uint8List _poly;
       |  Uint8List _zeros;
       |
       |  Uint8List _mac;
       |
       |  Uint8List _buf;
       |  int _bufOff;
       |  final BlockCipher _cipher;
       |
       |  final int _macSize;
       |
       |  Uint8List _lu, _lu2;
       |
       |  ParametersWithIV _params;
       |
       |  ///
       |  /// create a standard MAC based on a CBC block cipher (64 or 128 bit block).
       |  /// This will produce an authentication code the length of the block size
       |  /// of the cipher.
       |  ///
       |  /// @param cipher the cipher to be used as the basis of the MAC generation.
      0|  CMac.fromCipher(BlockCipher cipher) : this(cipher, cipher.blockSize * 8);
       |
       |  ///
       |  /// create a standard MAC based on a block cipher with the size of the
       |  /// MAC been given in bits.
       |  /// <p>
       |  /// Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
       |  /// or 16 bits if being used as a data authenticator (FIPS Publication 113),
       |  /// and in general should be less than the size of the block cipher as it
       |  /// reduces the chance of an exhaustive attack (see Handbook of Applied
       |  /// Cryptography).
       |  ///
       |  /// @param cipher        the cipher to be used as the basis of the MAC generation.
       |  /// @param macSizeInBits the size of the MAC in bits, must be a multiple of 8 and &lt;= 128.
      0|  CMac(BlockCipher cipher, int macSizeInBits)
      0|      : _macSize = macSizeInBits ~/ 8,
      0|        _cipher = CBCBlockCipher(cipher) {
      0|    if ((macSizeInBits % 8) != 0) {
      0|      throw ArgumentError('MAC size must be multiple of 8');
       |    }
       |
      0|    if (macSizeInBits > (_cipher.blockSize * 8)) {
      0|      throw ArgumentError(
      0|          'MAC size must be less or equal to ${_cipher.blockSize * 8}');
       |    }
       |
      0|    _poly = lookupPoly(cipher.blockSize);
       |
      0|    _mac = Uint8List(cipher.blockSize);
       |
      0|    _buf = Uint8List(cipher.blockSize);
       |
      0|    _zeros = Uint8List(cipher.blockSize);
       |
      0|    _bufOff = 0;
       |  }
       |
      0|  @override
       |  String get algorithmName {
      0|    var blockCipherAlgorithmName = _cipher.algorithmName.split('/').first;
      0|    return '$blockCipherAlgorithmName/CMAC';
       |  }
       |
      0|  static int shiftLeft(Uint8List block, Uint8List output) {
      0|    var i = block.length;
       |    var bit = 0;
      0|    while (--i >= 0) {
      0|      var b = block[i] & 0xff;
      0|      output[i] = ((b << 1) | bit);
      0|      bit = (b >> 7) & 1;
       |    }
       |    return bit;
       |  }
       |
      0|  Uint8List _doubleLu(Uint8List inp) {
      0|    var ret = Uint8List(inp.length);
      0|    var carry = shiftLeft(inp, ret);
       |
       |    // NOTE: This construction is an attempt at a constant-time implementation.
      0|    var mask = (-carry) & 0xff;
      0|    ret[inp.length - 3] ^= _poly[1] & mask;
      0|    ret[inp.length - 2] ^= _poly[2] & mask;
      0|    ret[inp.length - 1] ^= _poly[3] & mask;
       |
       |    return ret;
       |  }
       |
      0|  static Uint8List lookupPoly(int blockSizeLength) {
       |    int xor;
      0|    switch (blockSizeLength * 8) {
      0|      case 64:
       |        xor = 0x1B;
       |        break;
      0|      case 128:
       |        xor = 0x87;
       |        break;
      0|      case 160:
       |        xor = 0x2D;
       |        break;
      0|      case 192:
       |        xor = 0x87;
       |        break;
      0|      case 224:
       |        xor = 0x309;
       |        break;
      0|      case 256:
       |        xor = 0x425;
       |        break;
      0|      case 320:
       |        xor = 0x1B;
       |        break;
      0|      case 384:
       |        xor = 0x100D;
       |        break;
      0|      case 448:
       |        xor = 0x851;
       |        break;
      0|      case 512:
       |        xor = 0x125;
       |        break;
      0|      case 768:
       |        xor = 0xA0011;
       |        break;
      0|      case 1024:
       |        xor = 0x80043;
       |        break;
      0|      case 2048:
       |        xor = 0x86001;
       |        break;
       |      default:
      0|        throw ArgumentError(
      0|            'Unknown block size for CMAC: ${blockSizeLength * 8}');
       |    }
       |
      0|    final out = Uint8List(4);
      0|    out[3] = (xor >> 0);
      0|    out[2] = (xor >> 8);
      0|    out[1] = (xor >> 16);
      0|    out[0] = (xor >> 24);
       |    return out;
       |  }
       |
      0|  @override
       |  void init(covariant KeyParameter keyParams) {
      0|    final zeroIV = Uint8List(keyParams.key.length);
      0|    _params = ParametersWithIV(keyParams, zeroIV);
       |
       |    // Initialize before computing L, Lu, Lu2
      0|    _cipher.init(true, _params);
       |
       |    //initializes the L, Lu, Lu2 numbers
      0|    var L = Uint8List(_zeros.length);
      0|    _cipher.processBlock(_zeros, 0, L, 0);
      0|    _lu = _doubleLu(L);
      0|    _lu2 = _doubleLu(_lu);
       |
       |    // Reset _buf/_cipher state after computing L, Lu, Lu2
      0|    reset();
       |  }
       |
      0|  @override
      0|  int get macSize => _macSize;
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    if (_bufOff == _buf.length) {
      0|      _cipher.processBlock(_buf, 0, _mac, 0);
      0|      _bufOff = 0;
       |    }
       |
      0|    _buf[_bufOff++] = inp;
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inOff, int len) {
      0|    if (len < 0) {
      0|      throw ArgumentError('Can\'t have a negative input length!');
       |    }
       |
      0|    var blockSize = _cipher.blockSize;
      0|    var gapLen = blockSize - _bufOff;
       |
      0|    if (len > gapLen) {
      0|      _buf.setRange(_bufOff, _bufOff + gapLen, inp.sublist(inOff));
       |
      0|      _cipher.processBlock(_buf, 0, _mac, 0);
       |
      0|      _bufOff = 0;
      0|      len -= gapLen;
      0|      inOff += gapLen;
       |
      0|      while (len > blockSize) {
      0|        _cipher.processBlock(inp, inOff, _mac, 0);
       |
      0|        len -= blockSize;
      0|        inOff += blockSize;
       |      }
       |    }
       |
      0|    _buf.setRange(_bufOff, _bufOff + len, inp.sublist(inOff));
       |
      0|    _bufOff += len;
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    var blockSize = _cipher.blockSize;
       |
       |    Uint8List lu;
      0|    if (_bufOff == blockSize) {
      0|      lu = _lu;
       |    } else {
      0|      ISO7816d4Padding().addPadding(_buf, _bufOff);
      0|      lu = _lu2;
       |    }
       |
      0|    for (var i = 0; i < _mac.length; i++) {
      0|      _buf[i] ^= lu[i];
       |    }
       |
      0|    _cipher.processBlock(_buf, 0, _mac, 0);
       |
      0|    out.setRange(outOff, outOff + _macSize, _mac);
       |
      0|    reset();
       |
      0|    return _macSize;
       |  }
       |
       |  /// Reset the mac generator.
      0|  @override
       |  void reset() {
       |    // clean the buffer.
      0|    for (var i = 0; i < _buf.length; i++) {
      0|      _buf[i] = 0;
       |    }
       |
      0|    _bufOff = 0;
       |
       |    // reset the underlying cipher.
      0|    _cipher.reset();
       |
      0|    if (_params != null) {
      0|      _cipher.init(true, _params);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/macs/hmac.dart
       |// See file LICENSE for more information.
       |
       |library impl.mac.hmac;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_mac.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// HMAC implementation based on RFC2104
       |///
       |/// H(K XOR opad, H(K XOR ipad, text))
       |class HMac extends BaseMac {
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |    Mac,
       |    '/HMAC',
       |    (_, Match match) {
       |      final digestName = match.group(1);
       |      return () {
       |        return HMac.withDigest(Digest(digestName));
       |      };
       |    },
       |  );
       |
       |  //TODO reindent
       |
       |  static final _ipad = 0x36;
       |  static final _opad = 0x5C;
       |
       |  final Digest _digest;
       |  int _digestSize;
       |  int _blockLength;
       |
       |  Uint8List _inputPad;
       |  Uint8List _outputBuf;
       |
      0|  HMac(this._digest, this._blockLength) {
      0|    _digestSize = _digest.digestSize;
      0|    _inputPad = Uint8List(_blockLength);
      0|    _outputBuf = Uint8List(_blockLength + _digestSize);
       |  }
       |
      0|  HMac.withDigest(this._digest) {
      0|    _blockLength = _digest.byteLength;
      0|    if (_blockLength == null) {
      0|      throw ArgumentError(
      0|          'Digest, ${_digest.algorithmName} does not implement ExtendedDigest or is not listed in the _DIGEST_BLOCK_LENGTH map');
       |    }
       |
      0|    _digestSize = _digest.digestSize;
      0|    _inputPad = Uint8List(_blockLength);
      0|    _outputBuf = Uint8List(_blockLength + _digestSize);
       |  }
       |
      0|  @override
      0|  String get algorithmName => '${_digest.algorithmName}/HMAC';
       |
      0|  @override
      0|  int get macSize => _digestSize;
       |
      0|  @override
       |  void reset() {
       |    // reset the underlying digest.
      0|    _digest.reset();
       |
       |    // reinitialize the digest.
      0|    _digest.update(_inputPad, 0, _inputPad.length);
       |  }
       |
      0|  @override
       |  void init(covariant KeyParameter params) {
      0|    _digest.reset();
       |
      0|    var key = params.key;
      0|    var keyLength = key.length;
       |
      0|    if (keyLength > _blockLength) {
      0|      _digest.update(key, 0, keyLength);
      0|      _digest.doFinal(_inputPad, 0);
       |
      0|      keyLength = _digestSize;
       |    } else {
      0|      _inputPad.setRange(0, keyLength, key);
       |    }
       |
      0|    _inputPad.fillRange(keyLength, _inputPad.length, 0);
       |
      0|    _outputBuf.setRange(0, _blockLength, _inputPad);
       |
      0|    _xorPad(_inputPad, _blockLength, _ipad);
      0|    _xorPad(_outputBuf, _blockLength, _opad);
       |
      0|    _digest.update(_inputPad, 0, _inputPad.length);
       |  }
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    _digest.updateByte(inp);
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
      0|    _digest.update(inp, inpOff, len);
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    _digest.doFinal(_outputBuf, _blockLength);
      0|    _digest.update(_outputBuf, 0, _outputBuf.length);
       |
      0|    var len = _digest.doFinal(out, outOff);
      0|    _outputBuf.fillRange(_blockLength, _outputBuf.length, 0);
      0|    _digest.update(_inputPad, 0, _inputPad.length);
       |
       |    return len;
       |  }
       |
      0|  void _xorPad(Uint8List pad, int len, int n) {
      0|    for (var i = 0; i < len; i++) {
      0|      pad[i] ^= n;
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/macs/poly1305.dart
       |library impl.mac.poly1305;
       |
       |import 'dart:typed_data';
       |
       |import '../api.dart';
       |import '../src/impl/base_mac.dart';
       |import '../src/registry/registry.dart';
       |import '../src/ufixnum.dart';
       |import '../src/utils.dart';
       |
       |class Poly1305 extends BaseMac {
       |  static const R_MASK_LOW_2 = 0xFC;
       |  static const R_MASK_HIGH_4 = 0x0F;
       |
      0|  Poly1305() {
      0|    cipher = null;
       |  }
       |
      0|  Poly1305.withCipher(final this.cipher) {
      0|    if (cipher.blockSize != BLOCK_SIZE) {
      0|      throw ArgumentError('Poly1305 requires a 128 bit block cipher.');
       |    }
       |  }
       |
       |  // ignore: non_constant_identifier_names
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |    Mac,
       |    '/Poly1305',
       |    (_, final Match match) => () {
       |      var cipher = BlockCipher(match.group(1));
       |      return Poly1305.withCipher(cipher);
       |    },
       |  );
       |
      0|  static void clamp(Uint8List key) {
      0|    key[3] &= R_MASK_HIGH_4;
      0|    key[7] &= R_MASK_HIGH_4;
      0|    key[11] &= R_MASK_HIGH_4;
      0|    key[15] &= R_MASK_HIGH_4;
       |
      0|    key[4] &= R_MASK_LOW_2;
      0|    key[8] &= R_MASK_LOW_2;
      0|    key[12] &= R_MASK_LOW_2;
       |  }
       |
      0|  static bool checkKey(Uint8List key) {
      0|    var c1 = checkMask(key[3], R_MASK_HIGH_4);
      0|    var c2 = checkMask(key[7], R_MASK_HIGH_4);
      0|    var c3 = checkMask(key[11], R_MASK_HIGH_4);
      0|    var c4 = checkMask(key[15], R_MASK_HIGH_4);
       |
      0|    var c5 = checkMask(key[4], R_MASK_LOW_2);
      0|    var c6 = checkMask(key[8], R_MASK_LOW_2);
      0|    var c7 = checkMask(key[12], R_MASK_LOW_2);
       |
       |    return !(c1 || c2 || c3 || c4 || c5 || c6 || c7);
       |  }
       |
      0|  static bool checkMask(int b, int mask) {
      0|    if (b & not32(mask) != 0) {
       |      return false;
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  String get algorithmName =>
      0|      cipher == null ? 'Poly1305' : cipher.algorithmName + '/Poly1305';
       |
      0|  @override
       |  int get macSize => BLOCK_SIZE;
       |
       |  static const BLOCK_SIZE = 16;
       |
       |  BlockCipher cipher;
       |
       |  final Uint8List singleByte = Uint8List(1);
       |
       |  int r0, r1, r2, r3, r4;
       |
       |  int s1, s2, s3, s4;
       |
       |  int k0, k1, k2, k3;
       |
       |  final Uint8List currentBlock = Uint8List(BLOCK_SIZE);
       |
       |  int currentBlockOffset = 0;
       |
       |  int h0, h1, h2, h3, h4;
       |
      0|  @override
       |  void init(CipherParameters params) {
       |    Uint8List nonce;
       |
      0|    if (cipher != null) {
      0|      if (!(params is ParametersWithIV)) {
      0|        throw ArgumentError(
       |            'Poly1305 requires an IV when used with a block cipher.');
       |      }
       |
       |      var ivParams = params as ParametersWithIV;
      0|      nonce = ivParams.iv;
      0|      params = ivParams.parameters;
       |    }
       |
      0|    if (!(params is KeyParameter)) {
      0|      throw ArgumentError('Poly1305 requires a key.');
       |    }
       |
       |    var keyParams = params as KeyParameter;
       |
      0|    if (!checkKey(keyParams.key)) clamp(keyParams.key);
       |
      0|    setKey(keyParams.key, nonce);
       |
      0|    reset();
       |  }
       |
      0|  void setKey(Uint8List key, Uint8List nonce) {
      0|    if (key.length != 32) throw ArgumentError('Poly1305 key must be 256 bits.');
      0|    if (cipher != null && (nonce == null || nonce.length != BLOCK_SIZE)) {
      0|      throw ArgumentError('Poly1305-AES requires a 128 bit IV.');
       |    }
       |
      0|    var keyByteData = ByteData.view(key.buffer, key.offsetInBytes, key.length);
      0|    var t0 = unpack32(keyByteData, 0, Endian.little);
      0|    var t1 = unpack32(keyByteData, 4, Endian.little);
      0|    var t2 = unpack32(keyByteData, 8, Endian.little);
      0|    var t3 = unpack32(keyByteData, 12, Endian.little);
       |
      0|    r0 = t0 & (0x03FFFFFF);
      0|    r1 = (cshiftr32(t0, 26) | shiftl32(t1, 6)) & 0x03FFFF03;
      0|    r2 = (cshiftr32(t1, 20) | shiftl32(t2, 12)) & 0x03FFC0FF;
      0|    r3 = (cshiftr32(t2, 14) | shiftl32(t3, 18)) & 0x03F03FFF;
      0|    r4 = (cshiftr32(t3, 8)) & 0x000FFFFF;
       |
      0|    s1 = r1 * 5;
      0|    s2 = r2 * 5;
      0|    s3 = r3 * 5;
      0|    s4 = r4 * 5;
       |
       |    Uint8List kBytes;
       |    int kOff;
      0|    if (cipher == null) {
       |      kBytes = key;
       |      kOff = BLOCK_SIZE;
       |    } else {
      0|      kBytes = Uint8List(BLOCK_SIZE);
       |      kOff = 0;
       |
      0|      cipher.init(true, KeyParameter.offset(key, BLOCK_SIZE, BLOCK_SIZE));
      0|      cipher.processBlock(nonce, 0, kBytes, 0);
       |    }
       |
       |    var kByteData =
      0|        ByteData.view(kBytes.buffer, kBytes.offsetInBytes, kBytes.length);
      0|    k0 = unpack32(kByteData, kOff, Endian.little);
      0|    k1 = unpack32(kByteData, kOff + 4, Endian.little);
      0|    k2 = unpack32(kByteData, kOff + 8, Endian.little);
      0|    k3 = unpack32(kByteData, kOff + 12, Endian.little);
       |  }
       |
      0|  @override
       |  void updateByte(final int inp) {
      0|    singleByte[0] = inp;
      0|    update(singleByte, 0, 1);
       |  }
       |
      0|  @override
       |  void update(final Uint8List inp, final int inOff, final int len) {
       |    var copied = 0;
      0|    while (len > copied) {
      0|      if (currentBlockOffset == BLOCK_SIZE) {
      0|        processBlock();
      0|        currentBlockOffset = 0;
       |      }
       |
      0|      var toCopy = (len - copied) > (BLOCK_SIZE - currentBlockOffset)
      0|          ? (BLOCK_SIZE - currentBlockOffset)
      0|          : (len - copied);
      0|      arrayCopy(inp, copied + inOff, currentBlock, currentBlockOffset, toCopy);
      0|      copied += toCopy;
      0|      currentBlockOffset += toCopy;
       |    }
       |  }
       |
      0|  void processBlock() {
      0|    if (currentBlockOffset < BLOCK_SIZE) {
      0|      currentBlock[currentBlockOffset] = 1;
      0|      for (var i = currentBlockOffset + 1; i < BLOCK_SIZE; i++) {
      0|        currentBlock[i] = 0;
       |      }
       |    }
       |
      0|    final t0 = unpack32(currentBlock, 0, Endian.little);
      0|    final t1 = unpack32(currentBlock, 4, Endian.little);
      0|    final t2 = unpack32(currentBlock, 8, Endian.little);
      0|    final t3 = unpack32(currentBlock, 12, Endian.little);
       |
      0|    h0 += t0 & 0x3ffffff;
      0|    h1 += uRS((t1 << 32) | t0, 26) & 0x3ffffff;
      0|    h2 += uRS((t2 << 32) | t1, 20) & 0x3ffffff;
      0|    h3 += uRS((t3 << 32) | t2, 14) & 0x3ffffff;
      0|    h4 += uRS(t3, 8);
       |
      0|    if (currentBlockOffset == BLOCK_SIZE) {
      0|      h4 += shiftl32(1, 24);
       |    }
       |
      0|    var tp0 = h0 * r0 + h1 * s4 + h2 * s3 + h3 * s2 + h4 * s1;
      0|    var tp1 = h0 * r1 + h1 * r0 + h2 * s4 + h3 * s3 + h4 * s2;
      0|    var tp2 = h0 * r2 + h1 * r1 + h2 * r0 + h3 * s4 + h4 * s3;
      0|    var tp3 = h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * s4;
      0|    var tp4 = h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
       |
      0|    h0 = (tp0 & 0xffffffff) & 0x3ffffff;
      0|    tp1 += uRS(tp0, 26);
      0|    h1 = (tp1 & 0xffffffff) & 0x3ffffff;
      0|    tp2 += uRS(tp1, 26);
      0|    h2 = (tp2 & 0xffffffff) & 0x3ffffff;
      0|    tp3 += uRS(tp2, 26);
      0|    h3 = (tp3 & 0xffffffff) & 0x3ffffff;
      0|    tp4 += uRS(tp3, 26);
      0|    h4 = (tp4 & 0xffffffff) & 0x3ffffff;
       |
      0|    h0 += (uRS(tp4, 26) & 0xffffffff) * 5;
      0|    h1 += cshiftr32(h0, 26);
      0|    h0 &= 0x3ffffff;
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, final int outOff) {
      0|    if (outOff + BLOCK_SIZE > out.length) {
      0|      throw ArgumentError('Output buffer is too short.');
       |    }
       |
      0|    if (currentBlockOffset > 0) {
      0|      processBlock();
       |    }
       |
      0|    h1 += cshiftr32(h0, 26);
      0|    h0 &= 0x3ffffff;
      0|    h2 += cshiftr32(h1, 26);
      0|    h1 &= 0x3ffffff;
      0|    h3 += cshiftr32(h2, 26);
      0|    h2 &= 0x3ffffff;
      0|    h4 += cshiftr32(h3, 26);
      0|    h3 &= 0x3ffffff;
      0|    h0 += cshiftr32(h4, 26) * 5;
      0|    h4 &= 0x3ffffff;
      0|    h1 += cshiftr32(h0, 26);
      0|    h0 &= 0x3ffffff;
       |
       |    int g0, g1, g2, g3, g4, b;
      0|    g0 = sum32(h0, 5);
      0|    b = cshiftr32(g0, 26);
      0|    g0 &= 0x3ffffff;
      0|    g1 = sum32(h1, b);
      0|    b = cshiftr32(g1, 26);
      0|    g1 &= 0x3ffffff;
      0|    g2 = sum32(h2, b);
      0|    b = cshiftr32(g2, 26);
      0|    g2 &= 0x3ffffff;
      0|    g3 = sum32(h3, b);
      0|    b = cshiftr32(g3, 26);
      0|    g3 &= 0x3ffffff;
      0|    g4 = sum32(h4, b) - shiftl32(1, 26);
       |
      0|    b = cshiftr32(g4, 31) - 1;
      0|    var nb = not32(b);
      0|    h0 = (h0 & nb) | (g0 & b);
      0|    h1 = (h1 & nb) | (g1 & b);
      0|    h2 = (h2 & nb) | (g2 & b);
      0|    h3 = (h3 & nb) | (g3 & b);
      0|    h4 = (h4 & nb) | (g4 & b);
       |
       |    int f0, f1, f2, f3;
      0|    f0 = (h0 | shiftl32(h1, 26)) + (k0);
      0|    f1 = (cshiftr32(h1, 6) | shiftl32(h2, 20)) + (k1);
      0|    f2 = (cshiftr32(h2, 12) | shiftl32(h3, 14)) + (k2);
      0|    f3 = (cshiftr32(h3, 18) | shiftl32(h4, 8)) + (k3);
       |
      0|    var outByte = ByteData.view(out.buffer, out.offsetInBytes, out.length);
      0|    pack32(f0 & 0xffffffff, outByte, outOff, Endian.little);
      0|    f1 += uRS(f0, 32);
      0|    pack32(f1 & 0xffffffff, outByte, outOff + 4, Endian.little);
      0|    f2 += uRS(f1, 32);
      0|    pack32(f2 & 0xffffffff, outByte, outOff + 8, Endian.little);
      0|    f3 += uRS(f2, 32);
      0|    pack32(f3 & 0xffffffff, outByte, outOff + 12, Endian.little);
       |    //End come back here chunk
       |
      0|    out = outByte.buffer.asUint8List();
       |
      0|    reset();
       |    return BLOCK_SIZE;
       |  }
       |
      0|  @override
       |  void reset() {
      0|    currentBlockOffset = 0;
       |
      0|    h0 = 0;
      0|    h1 = 0;
      0|    h2 = 0;
      0|    h3 = 0;
      0|    h4 = 0;
       |  }
       |}
       |
      0|int uRS(int x, int n) {
      0|  return x >= 0 ? x >> n : ~(~x >> n);
       |}
       |
       |/*
       |int uRS(int x, int n) {
       |  return (x >= 0) ? x >> (64 - n) : ~(~x >> (64 - n));
       |}
       |*/
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/padded_block_cipher/padded_block_cipher_impl.dart
       |// See file LICENSE for more information.
       |
       |library impl.padded_block_cipher.padded_block_cipher_impl;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// The standard implementation of [PaddedBlockCipher].
       |class PaddedBlockCipherImpl implements PaddedBlockCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.regex(
       |      PaddedBlockCipher,
       |      r'^(.+)/([^/]+)$',
       |      (_, final Match match) => () {
       |            var padding = Padding(match.group(2));
       |            var underlyingCipher = BlockCipher(match.group(1));
       |            return PaddedBlockCipherImpl(padding, underlyingCipher);
       |          });
       |
       |  @override
       |  final Padding padding;
       |  @override
       |  final BlockCipher cipher;
       |
       |  bool _encrypting;
       |
      0|  PaddedBlockCipherImpl(this.padding, this.cipher);
       |
      0|  @override
       |  String get algorithmName =>
      0|      cipher.algorithmName + '/' + padding.algorithmName;
       |
      0|  @override
      0|  int get blockSize => cipher.blockSize;
       |
      0|  @override
       |  void reset() {
      0|    _encrypting = null;
      0|    cipher.reset();
       |  }
       |
      0|  @override
       |  void init(bool forEncryption, covariant PaddedBlockCipherParameters params) {
      0|    _encrypting = forEncryption;
      0|    cipher.init(forEncryption, params.underlyingCipherParameters);
      0|    padding.init(params.paddingCipherParameters);
       |  }
       |
      0|  @override
       |  Uint8List process(Uint8List data) {
      0|    var inputBlocks = (data.length + blockSize - 1) ~/ blockSize;
       |
       |    int outputBlocks;
      0|    if (_encrypting) {
      0|      outputBlocks = (data.length + blockSize) ~/ blockSize;
       |    } else {
      0|      if ((data.length % blockSize) != 0) {
      0|        throw ArgumentError(
       |            'Input data length must be a multiple of cipher\'s block size');
       |      }
       |      outputBlocks = inputBlocks;
       |    }
       |
      0|    var out = Uint8List(outputBlocks * blockSize);
       |
      0|    for (var i = 0; i < (inputBlocks - 1); i++) {
      0|      var offset = (i * blockSize);
      0|      processBlock(data, offset, out, offset);
       |    }
       |
      0|    var lastBlockOffset = ((inputBlocks - 1) * blockSize);
      0|    var lastBlockSize = doFinal(data, lastBlockOffset, out, lastBlockOffset);
       |
      0|    return out.sublist(0, lastBlockOffset + lastBlockSize);
       |  }
       |
      0|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    return cipher.processBlock(inp, inpOff, out, outOff);
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    if (_encrypting) {
      0|      var lastInputBlock = Uint8List(blockSize)..setAll(0, inp.sublist(inpOff));
       |
      0|      var remainder = inp.length - inpOff;
       |
      0|      if (remainder < blockSize) {
       |        // Padding goes embedded in last block of data
      0|        padding.addPadding(lastInputBlock, (inp.length - inpOff));
       |
      0|        processBlock(lastInputBlock, 0, out, outOff);
       |
      0|        return blockSize;
       |      } else {
       |        // Padding goes alone in an additional block
      0|        processBlock(inp, inpOff, out, outOff);
       |
      0|        padding.addPadding(lastInputBlock, 0);
       |
      0|        processBlock(lastInputBlock, 0, out, outOff + blockSize);
       |
      0|        return 2 * blockSize;
       |      }
       |    } else {
       |      // Decrypt last block and remove padding
      0|      processBlock(inp, inpOff, out, outOff);
       |
      0|      var padCount = padding.padCount(out.sublist(outOff));
       |
      0|      var padOffsetInBlock = blockSize - padCount;
       |
      0|      out.fillRange(outOff + padOffsetInBlock, out.length, 0);
       |
       |      return padOffsetInBlock;
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/paddings/iso7816d4.dart
       |// See file LICENSE for more information.
       |
       |library impl.padding.iso7816d4;
       |
       |import 'dart:typed_data' show Uint8List;
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_padding.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// A padder that adds the padding according to the scheme referenced in
       |/// ISO 7814-4 - scheme 2 from ISO 9797-1. The first byte is 0x80, rest is 0x00
       |class ISO7816d4Padding extends BasePadding {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Padding, 'ISO7816-4', () => ISO7816d4Padding());
       |
      0|  @override
       |  String get algorithmName => 'ISO7816-4';
       |
      0|  @override
       |  void init([CipherParameters params]) {
       |    // nothing to do.
       |  }
       |
       |  /// add the pad bytes to the passed in block, returning the
       |  /// number of bytes added.
      0|  @override
       |  int addPadding(Uint8List data, int offset) {
      0|    var added = (data.length - offset);
       |
      0|    data[offset] = 0x80;
      0|    offset++;
       |
      0|    while (offset < data.length) {
      0|      data[offset] = 0;
      0|      offset++;
       |    }
       |
       |    return added;
       |  }
       |
       |  /// return the number of pad bytes present in the block.
      0|  @override
       |  int padCount(Uint8List data) {
      0|    var count = data.length - 1;
       |
      0|    while (count > 0 && data[count] == 0) {
      0|      count--;
       |    }
       |
      0|    if (data[count] != 0x80) {
      0|      throw ArgumentError('pad block corrupted');
       |    }
       |
      0|    return data.length - count;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/paddings/pkcs7.dart
       |// See file LICENSE for more information.
       |
       |library impl.padding.pkcs7;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_padding.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// A [Padding] that adds PKCS7/PKCS5 padding to a block.
       |class PKCS7Padding extends BasePadding {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(Padding, 'PKCS7', () => PKCS7Padding());
       |
      0|  @override
       |  String get algorithmName => 'PKCS7';
       |
      0|  @override
       |  void init([CipherParameters params]) {
       |    // nothing to do.
       |  }
       |
      0|  @override
       |  int addPadding(Uint8List data, int offset) {
      0|    var code = (data.length - offset);
       |
      0|    while (offset < data.length) {
      0|      data[offset] = code;
      0|      offset++;
       |    }
       |
       |    return code;
       |  }
       |
      0|  @override
       |  int padCount(Uint8List data) {
      0|    var count = clip8(data[data.length - 1]);
       |
      0|    if (count > data.length || count == 0) {
      0|      throw ArgumentError('Invalid or corrupted pad block');
       |    }
       |
      0|    for (var i = 1; i <= count; i++) {
      0|      if (data[data.length - i] != count) {
      0|        throw ArgumentError('Invalid or corrupted pad block');
       |      }
       |    }
       |
       |    return count;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/random/auto_seed_block_ctr_random.dart
       |// See file LICENSE for more information.
       |
       |library impl.secure_random.auto_seed_block_ctr_random;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/random/block_ctr_random.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// An implementation of [SecureRandom]that uses a [BlockCipher] with CTR mode to generate random
       |/// values and automatically self reseeds itself after each request for data, in order to achieve
       |/// forward security. See section 4.1 of the paper:
       |/// Practical Random Number Generation in Software (by John Viega).
       |class AutoSeedBlockCtrRandom implements SecureRandom {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.regex(
       |      SecureRandom,
       |      r'^(.*)/CTR/AUTO-SEED-PRNG$',
       |      (_, final Match match) => () {
       |            var blockCipherName = match.group(1);
       |            var blockCipher = BlockCipher(blockCipherName);
       |            return AutoSeedBlockCtrRandom(blockCipher);
       |          });
       |
       |  BlockCtrRandom _delegate;
       |  final bool _reseedIV;
       |
       |  var _inAutoReseed = false;
       |  int _autoReseedKeyLength;
       |
      0|  @override
       |  String get algorithmName =>
      0|      '${_delegate.cipher.algorithmName}/CTR/AUTO-SEED-PRNG';
       |
      1|  AutoSeedBlockCtrRandom(BlockCipher cipher, [this._reseedIV = true]) {
      2|    _delegate = BlockCtrRandom(cipher);
       |  }
       |
      1|  @override
       |  void seed(CipherParameters params) {
      1|    if (params is ParametersWithIV<KeyParameter>) {
      4|      _autoReseedKeyLength = params.parameters.key.length;
      2|      _delegate.seed(params);
      0|    } else if (params is KeyParameter) {
      0|      _autoReseedKeyLength = params.key.length;
      0|      _delegate.seed(params);
       |    } else {
      0|      throw ArgumentError(
       |          'Only types ParametersWithIV<KeyParameter> or KeyParameter allowed for seeding');
       |    }
       |  }
       |
      0|  @override
      0|  int nextUint8() => _autoReseedIfNeededAfter(() {
      0|        return _delegate.nextUint8();
       |      });
       |
      0|  @override
      0|  int nextUint16() => _autoReseedIfNeededAfter(() {
      0|        return _delegate.nextUint16();
       |      });
       |
      0|  @override
      0|  int nextUint32() => _autoReseedIfNeededAfter(() {
      0|        return _delegate.nextUint32();
       |      });
       |
      1|  @override
      2|  BigInt nextBigInteger(int bitLength) => _autoReseedIfNeededAfter(() {
      2|        return _delegate.nextBigInteger(bitLength);
       |      });
       |
      1|  @override
      2|  Uint8List nextBytes(int count) => _autoReseedIfNeededAfter(() {
      2|        return _delegate.nextBytes(count);
       |      });
       |
      1|  dynamic _autoReseedIfNeededAfter(dynamic closure) {
      1|    if (_inAutoReseed) {
      1|      return closure();
       |    } else {
      1|      _inAutoReseed = true;
      1|      var ret = closure();
      1|      _doAutoReseed();
      1|      _inAutoReseed = false;
       |      return ret;
       |    }
       |  }
       |
      1|  void _doAutoReseed() {
      2|    var newKey = nextBytes(_autoReseedKeyLength);
      1|    var keyParam = KeyParameter(newKey);
       |
       |    CipherParameters params;
      1|    if (_reseedIV) {
       |      params =
      0|          ParametersWithIV(keyParam, nextBytes(_delegate.cipher.blockSize));
       |    } else {
       |      params = keyParam;
       |    }
       |
      2|    _delegate.seed(params);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/random/block_ctr_random.dart
       |// See file LICENSE for more information.
       |
       |library impl.secure_random.block_ctr_random;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |import 'package:pointycastle/src/impl/secure_random_base.dart';
       |
       |/// An implementation of [SecureRandom]that uses a [BlockCipher] with CTR mode to generate random
       |/// values.
       |class BlockCtrRandom extends SecureRandomBase implements SecureRandom {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.regex(
       |      SecureRandom,
       |      r'^(.*)/CTR/PRNG$',
       |      (_, final Match match) => () {
       |            var blockCipherName = match.group(1);
       |            var blockCipher = BlockCipher(blockCipherName);
       |            return BlockCtrRandom(blockCipher);
       |          });
       |
       |  final BlockCipher cipher;
       |
       |  Uint8List _input;
       |  Uint8List _output;
       |  int _used;
       |
      1|  BlockCtrRandom(this.cipher) {
      4|    _input = Uint8List(cipher.blockSize);
      4|    _output = Uint8List(cipher.blockSize);
      3|    _used = _output.length;
       |  }
       |
      0|  @override
      0|  String get algorithmName => '${cipher.algorithmName}/CTR/PRNG';
       |
      1|  @override
       |  void seed(CipherParameters params) {
      3|    _used = _output.length;
      1|    if (params is ParametersWithIV) {
      3|      _input.setAll(0, params.iv);
      3|      cipher.init(true, params.parameters);
       |    } else {
      2|      cipher.init(true, params);
       |    }
       |  }
       |
      1|  @override
       |  int nextUint8() {
      4|    if (_used == _output.length) {
      4|      cipher.processBlock(_input, 0, _output, 0);
      1|      _used = 0;
      1|      _incrementInput();
       |    }
       |
      5|    return clip8(_output[_used++]);
       |  }
       |
      1|  void _incrementInput() {
      2|    var offset = _input.length;
       |    do {
      1|      offset--;
      3|      _input[offset] += 1;
      3|    } while (_input[offset] == 0);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/random/fortuna_random.dart
       |// See file LICENSE for more information.
       |
       |library impl.secure_random.fortuna_random;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/block/aes_fast.dart';
       |import 'package:pointycastle/random/auto_seed_block_ctr_random.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// An implementation of [SecureRandom] as specified in the Fortuna algorithm.
       |class FortunaRandom implements SecureRandom {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(SecureRandom, 'Fortuna', () => FortunaRandom());
       |
       |  AESFastEngine _aes;
       |  AutoSeedBlockCtrRandom _prng;
       |
      0|  @override
       |  String get algorithmName => 'Fortuna';
       |
      1|  FortunaRandom() {
      2|    _aes = AESFastEngine();
      3|    _prng = AutoSeedBlockCtrRandom(_aes, false);
       |  }
       |
      1|  @override
       |  void seed(covariant KeyParameter param) {
      3|    if (param.key.length != 32) {
      0|      throw ArgumentError('Fortuna PRNG can only be used with 256 bits keys');
       |    }
       |
      1|    final iv = Uint8List(16);
      1|    iv[15] = 1;
      3|    _prng.seed(ParametersWithIV(param, iv));
       |  }
       |
      0|  @override
      0|  int nextUint8() => _prng.nextUint8();
       |
      0|  @override
      0|  int nextUint16() => _prng.nextUint16();
       |
      0|  @override
      0|  int nextUint32() => _prng.nextUint32();
       |
      1|  @override
      2|  BigInt nextBigInteger(int bitLength) => _prng.nextBigInteger(bitLength);
       |
      0|  @override
       |  Uint8List nextBytes(int count) {
      0|    if (count > 1048576) {
      0|      throw ArgumentError(
       |          'Fortuna PRNG cannot generate more than 1MB of random data per invocation');
       |    }
       |
      0|    return _prng.nextBytes(count);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/signers/ecdsa_signer.dart
       |// See file LICENSE for more information.
       |
       |library impl.signer.ecdsa_signer;
       |
       |import 'dart:math';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/utils.dart' as utils;
       |
      0|bool _testBit(BigInt i, int n) {
      0|  return (i & (BigInt.one << n)) != BigInt.zero;
       |}
       |
       |class ECDSASigner implements Signer {
       |  /// Intended for internal use.
       |  // ignore: non_constant_identifier_names
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.regex(
       |      Signer, r'^(.+)/(DET-)?ECDSA$', (_, final Match match) {
       |    // ignore: omit_local_variable_types
       |    final String digestName = match.group(1);
       |    // ignore: omit_local_variable_types
       |    final bool withMac = match.group(2) != null;
       |    return () {
       |      var underlyingDigest = Digest(digestName);
       |      var mac = withMac ? Mac('$digestName/HMAC') : null;
       |      return ECDSASigner(underlyingDigest, mac);
       |    };
       |  });
       |
       |  ECPublicKey _pbkey;
       |  ECPrivateKey _pvkey;
       |  SecureRandom _random;
       |  final Digest _digest;
       |  final Mac _kMac;
       |
       |  /// If [_digest] is not null it is used to hash the message before signing and verifying, otherwise, the message needs to be
       |  /// hashed by the user of this [ECDSASigner] object.
       |  /// If [_kMac]is not null, RFC 6979 is used for k calculation with the given [Mac]. Keep in mind that, to comply with
       |  /// RFC 69679, [_kMac] must be HMAC with the same digest used to hash the message.
      0|  ECDSASigner([this._digest, this._kMac]);
       |
      0|  @override
       |  String get algorithmName =>
      0|      '${_digest.algorithmName}/${_kMac == null ? '' : 'DET-'}ECDSA';
       |
      0|  @override
       |  void reset() {}
       |
       |  /// Init this [Signer]. The [params]argument can be:
       |  /// -A [ParametersWithRandom] containing a [PrivateKeyParameter] or a raw [PrivateKeyParameter] for signing
       |  /// -An [PublicKeyParameter] for verifying.
      0|  @override
       |  void init(bool forSigning, CipherParameters params) {
      0|    _pbkey = _pvkey = null;
       |
       |    if (forSigning) {
       |      PrivateKeyParameter pvparams;
       |
      0|      if (params is ParametersWithRandom) {
      0|        _random = params.random;
      0|        pvparams = params.parameters as PrivateKeyParameter<PrivateKey>;
      0|      } else if (_kMac != null) {
      0|        _random = null;
       |        pvparams = params as PrivateKeyParameter<PrivateKey>;
       |      } else {
      0|        _random = SecureRandom();
       |        pvparams = params as PrivateKeyParameter<PrivateKey>;
       |      }
       |
      0|      if (pvparams is! PrivateKeyParameter) {
      0|        throw ArgumentError(
      0|            'Unsupported parameters type ${pvparams.runtimeType}: should be PrivateKeyParameter');
       |      }
      0|      _pvkey = pvparams.key as ECPrivateKey;
       |    } else {
       |      PublicKeyParameter pbparams;
       |
       |      pbparams = params as PublicKeyParameter<PublicKey>;
       |
      0|      if (pbparams is! PublicKeyParameter) {
      0|        throw ArgumentError(
      0|            'Unsupported parameters type ${pbparams.runtimeType}: should be PublicKeyParameter');
       |      }
      0|      _pbkey = pbparams.key as ECPublicKey;
       |    }
       |  }
       |
      0|  @override
       |  Signature generateSignature(Uint8List message) {
      0|    message = _hashMessageIfNeeded(message);
       |
      0|    var n = _pvkey.parameters.n;
      0|    var e = _calculateE(n, message);
       |    BigInt r;
       |    BigInt s;
       |
       |    dynamic kCalculator;
      0|    if (_kMac != null) {
      0|      kCalculator = _RFC6979KCalculator(_kMac, n, _pvkey.d, message);
       |    } else {
      0|      kCalculator = _RandomKCalculator(n, _random);
       |    }
       |
       |    // 5.3.2
       |    do {
       |      // generate s
       |      BigInt k;
       |
       |      do {
       |        // generate r
      0|        k = kCalculator.nextK() as BigInt;
       |
      0|        var p = _pvkey.parameters.G * k;
       |
       |        // 5.3.3
      0|        var x = p.x.toBigInteger();
       |
      0|        r = x % n;
      0|      } while (r == BigInt.zero);
       |
      0|      var d = _pvkey.d;
       |
      0|      s = (k.modInverse(n) * (e + (d * r))) % n;
      0|    } while (s == BigInt.zero);
       |
      0|    return ECSignature(r, s);
       |  }
       |
      0|  @override
       |  bool verifySignature(Uint8List message, covariant ECSignature signature) {
      0|    message = _hashMessageIfNeeded(message);
       |
      0|    var n = _pbkey.parameters.n;
      0|    var e = _calculateE(n, message);
       |
      0|    var r = signature.r;
      0|    var s = signature.s;
       |
       |    // r in the range [1,n-1]
      0|    if (r.compareTo(BigInt.one) < 0 || r.compareTo(n) >= 0) {
       |      return false;
       |    }
       |
       |    // s in the range [1,n-1]
      0|    if (s.compareTo(BigInt.one) < 0 || s.compareTo(n) >= 0) {
       |      return false;
       |    }
       |
      0|    var c = s.modInverse(n);
       |
      0|    var u1 = (e * c) % n;
      0|    var u2 = (r * c) % n;
       |
      0|    var G = _pbkey.parameters.G;
      0|    var Q = _pbkey.Q;
       |
      0|    var point = _sumOfTwoMultiplies(G, u1, Q, u2);
       |
       |    // components must be bogus.
      0|    if (point.isInfinity) {
       |      return false;
       |    }
       |
      0|    var v = point.x.toBigInteger() % n;
       |
      0|    return v == r;
       |  }
       |
      0|  Uint8List _hashMessageIfNeeded(Uint8List message) {
      0|    if (_digest != null) {
      0|      _digest.reset();
      0|      return _digest.process(message);
       |    } else {
       |      return message;
       |    }
       |  }
       |
      0|  BigInt _calculateE(BigInt n, Uint8List message) {
      0|    var log2n = n.bitLength;
      0|    var messageBitLength = message.length * 8;
       |
      0|    if (log2n >= messageBitLength) {
      0|      return utils.decodeBigInt(message);
       |    } else {
      0|      var trunc = utils.decodeBigInt(message);
       |
      0|      trunc = trunc >> (messageBitLength - log2n);
       |
       |      return trunc;
       |    }
       |  }
       |
      0|  ECPoint _sumOfTwoMultiplies(ECPoint P, BigInt a, ECPoint Q, BigInt b) {
      0|    var c = P.curve;
       |
      0|    if (c != Q.curve) {
      0|      throw ArgumentError('P and Q must be on same curve');
       |    }
       |
       |    // Point multiplication for Koblitz curves (using WTNAF) beats Shamir's trick
       |    // TODO: uncomment this when F2m available
       |    /*
       |    if( c is ECCurve.F2m ) {
       |      ECCurve.F2m f2mCurve = (ECCurve.F2m)c;
       |      if( f2mCurve.isKoblitz() ) {
       |        return P.multiply(a).add(Q.multiply(b));
       |      }
       |    }
       |    */
       |
      0|    return _implShamirsTrick(P, a, Q, b);
       |  }
       |
      0|  ECPoint _implShamirsTrick(ECPoint P, BigInt k, ECPoint Q, BigInt l) {
      1|    var m = max(k.bitLength, l.bitLength);
       |
      0|    var Z = P + Q;
      0|    var R = P.curve.infinity;
       |
      0|    for (var i = m - 1; i >= 0; --i) {
      0|      R = R.twice();
       |
      0|      if (_testBit(k, i)) {
      0|        if (_testBit(l, i)) {
      0|          R = R + Z;
       |        } else {
      0|          R = R + P;
       |        }
       |      } else {
      0|        if (_testBit(l, i)) {
      0|          R = R + Q;
       |        }
       |      }
       |    }
       |
       |    return R;
       |  }
       |}
       |
       |class NormalizedECDSASigner implements Signer {
       |  final ECDSASigner signer;
       |  final bool enforceNormalized;
       |
       |  /// Wraps ECDSASigner and enforces normalisation on verify if
       |  /// [enforceNormalized] is true.
       |  ///
       |  /// Always generates normalized signatures.
      0|  NormalizedECDSASigner(this.signer, {this.enforceNormalized = false});
       |
      0|  @override
      0|  String get algorithmName => signer.algorithmName;
       |
      0|  @override
       |  Signature generateSignature(Uint8List message) {
      0|    return (signer.generateSignature(message) as ECSignature)
      0|        .normalize(signer._pvkey.parameters);
       |  }
       |
      0|  @override
       |  void init(bool forSigning, CipherParameters params) {
      0|    signer.init(forSigning, params);
       |  }
       |
      0|  @override
       |  void reset() {
      0|    signer.reset();
       |  }
       |
      0|  @override
       |  bool verifySignature(Uint8List message, Signature signature) {
       |    var isNormalized =
      0|        (signature as ECSignature).isNormalized(signer._pbkey.parameters);
      0|    var isVerified = signer.verifySignature(message, signature as ECSignature);
       |
       |    // Constant time.
      0|    return (isNormalized | !enforceNormalized) & isVerified;
       |  }
       |}
       |
       |class _RFC6979KCalculator {
       |  final Mac _mac;
       |  // ignore: non_constant_identifier_names
       |  Uint8List _K;
       |  // ignore: non_constant_identifier_names
       |  Uint8List _V;
       |  final BigInt _n;
       |
      0|  _RFC6979KCalculator(this._mac, this._n, BigInt d, Uint8List message) {
      0|    _V = Uint8List(_mac.macSize);
      0|    _K = Uint8List(_mac.macSize);
      0|    _init(d, message);
       |  }
       |
      0|  void _init(BigInt d, Uint8List message) {
      0|    _V.fillRange(0, _V.length, 0x01);
      0|    _K.fillRange(0, _K.length, 0x00);
       |
      0|    var x = Uint8List((_n.bitLength + 7) ~/ 8);
      0|    var dVal = _asUnsignedByteArray(d);
       |
      0|    x.setRange((x.length - dVal.length), x.length, dVal);
       |
      0|    var m = Uint8List((_n.bitLength + 7) ~/ 8);
       |
      0|    var mInt = _bitsToInt(message);
       |
      0|    if (mInt > _n) {
      0|      mInt -= _n;
       |    }
       |
      0|    var mVal = _asUnsignedByteArray(mInt);
       |
      0|    m.setRange((m.length - mVal.length), m.length, mVal);
       |
      0|    _mac.init(KeyParameter(_K));
       |
      0|    _mac.update(_V, 0, _V.length);
      0|    _mac.updateByte(0x00);
      0|    _mac.update(x, 0, x.length);
      0|    _mac.update(m, 0, m.length);
      0|    _mac.doFinal(_K, 0);
       |
      0|    _mac.init(KeyParameter(_K));
      0|    _mac.update(_V, 0, _V.length);
      0|    _mac.doFinal(_V, 0);
       |
      0|    _mac.update(_V, 0, _V.length);
      0|    _mac.updateByte(0x01);
      0|    _mac.update(x, 0, x.length);
      0|    _mac.update(m, 0, m.length);
      0|    _mac.doFinal(_K, 0);
       |
      0|    _mac.init(KeyParameter(_K));
      0|    _mac.update(_V, 0, _V.length);
      0|    _mac.doFinal(_V, 0);
       |  }
       |
      0|  BigInt nextK() {
      0|    var t = Uint8List((_n.bitLength + 7) ~/ 8);
       |
       |    for (;;) {
       |      var tOff = 0;
       |
      0|      while (tOff < t.length) {
      0|        _mac.update(_V, 0, _V.length);
      0|        _mac.doFinal(_V, 0);
       |
      0|        if ((t.length - tOff) < _V.length) {
      0|          t.setRange(tOff, t.length, _V);
      0|          tOff += (t.length - tOff);
       |        } else {
      0|          t.setRange(tOff, tOff + _V.length, _V);
      0|          tOff += _V.length;
       |        }
       |      }
       |
      0|      var k = _bitsToInt(t);
       |
       |      // ignore: unrelated_type_equality_checks
      0|      if ((k == 0) || (k >= _n)) {
      0|        _mac.update(_V, 0, _V.length);
      0|        _mac.updateByte(0x00);
      0|        _mac.doFinal(_K, 0);
       |
      0|        _mac.init(KeyParameter(_K));
      0|        _mac.update(_V, 0, _V.length);
      0|        _mac.doFinal(_V, 0);
       |      } else {
       |        return k;
       |      }
       |    }
       |  }
       |
      0|  BigInt _bitsToInt(Uint8List t) {
      0|    var v = utils.decodeBigInt(t);
      0|    if ((t.length * 8) > _n.bitLength) {
      0|      v = v >> ((t.length * 8) - _n.bitLength);
       |    }
       |
       |    return v;
       |  }
       |
      0|  Uint8List _asUnsignedByteArray(BigInt value) {
      0|    var bytes = utils.encodeBigInt(value);
       |
      0|    if (bytes[0] == 0) {
      0|      return Uint8List.fromList(bytes.sublist(1));
       |    } else {
      0|      return Uint8List.fromList(bytes);
       |    }
       |  }
       |}
       |
       |class _RandomKCalculator {
       |  final BigInt _n;
       |  final SecureRandom _random;
       |
      0|  _RandomKCalculator(this._n, this._random);
       |
      0|  BigInt nextK() {
       |    BigInt k;
       |    do {
      0|      k = _random.nextBigInteger(_n.bitLength);
      0|    } while (k == BigInt.zero || k >= _n);
       |    return k;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/signers/rsa_signer.dart
       |// See file LICENSE for more information.
       |
       |library impl.signer.rsa_signer;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/asymmetric/api.dart';
       |import 'package:pointycastle/asymmetric/pkcs1.dart';
       |import 'package:pointycastle/asymmetric/rsa.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |// TODO: implement full ASN1 encoding (for now I will do a little ad-hoc implementation of just what is needed here)
       |class RSASigner implements Signer {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig =
       |      DynamicFactoryConfig.suffix(Signer, '/RSA', (_, Match match) {
       |    final digestName = match.group(1);
       |    final digestIdentifierHex = _digestIdentifierHexes[digestName];
       |    if (digestIdentifierHex == null) {
       |      throw RegistryFactoryException(
       |          'RSA signing with digest $digestName is not supported');
       |    }
       |    return () => RSASigner(Digest(digestName), digestIdentifierHex);
       |  });
       |
      0|  static final Map<String, String> _digestIdentifierHexes = {
       |    'MD2': '06082a864886f70d0202',
       |    'MD4': '06082a864886f70d0204',
       |    'MD5': '06082a864886f70d0205',
       |    'RIPEMD-128': '06052b24030202',
       |    'RIPEMD-160': '06052b24030201',
       |    'RIPEMD-256': '06052b24030203',
       |    'SHA-1': '06052b0e03021a',
       |    'SHA-224': '0609608648016503040204',
       |    'SHA-256': '0609608648016503040201',
       |    'SHA-384': '0609608648016503040202',
       |    'SHA-512': '0609608648016503040203'
       |  };
       |
       |  final AsymmetricBlockCipher _rsa = PKCS1Encoding(RSAEngine());
       |  final Digest _digest;
       |  Uint8List _digestIdentifier; // DER encoded with trailing tag (06)+length byte
       |  bool _forSigning;
       |
      1|  RSASigner(this._digest, String digestIdentifierHex) {
      2|    _digestIdentifier = _hexStringToBytes(digestIdentifierHex);
       |  }
       |
      0|  @override
      0|  String get algorithmName => '${_digest.algorithmName}/RSA';
       |
      1|  @override
       |  void reset() {
      2|    _digest.reset();
      2|    _rsa.reset();
       |  }
       |
      1|  @override
       |  void init(bool forSigning, CipherParameters params) {
      1|    _forSigning = forSigning;
       |
       |    AsymmetricKeyParameter akparams;
      1|    if (params is ParametersWithRandom) {
      0|      akparams = params.parameters as AsymmetricKeyParameter<AsymmetricKey>;
       |    } else {
       |      akparams = params as AsymmetricKeyParameter<AsymmetricKey>;
       |    }
      1|    var k = akparams.key as RSAAsymmetricKey;
       |
      1|    if (forSigning && (k is! RSAPrivateKey)) {
      0|      throw ArgumentError('Signing requires private key');
       |    }
       |
      1|    if (!forSigning && (k is! RSAPublicKey)) {
      0|      throw ArgumentError('Verification requires public key');
       |    }
       |
      1|    reset();
       |
      2|    _rsa.init(forSigning, params);
       |  }
       |
      1|  @override
       |  RSASignature generateSignature(Uint8List message, {bool normalize = false}) {
      1|    if (!_forSigning) {
      0|      throw StateError('Signer was not initialised for signature generation');
       |    }
       |
      3|    var hash = Uint8List(_digest.digestSize);
      2|    _digest.reset();
      3|    _digest.update(message, 0, message.length);
      2|    _digest.doFinal(hash, 0);
       |
      1|    var data = _derEncode(hash);
      3|    var out = Uint8List(_rsa.outputBlockSize);
      3|    var len = _rsa.processBlock(data, 0, data.length, out, 0);
      2|    return RSASignature(out.sublist(0, len));
       |  }
       |
      1|  @override
       |  bool verifySignature(Uint8List message, covariant RSASignature signature) {
      1|    if (_forSigning) {
      0|      throw StateError('Signer was not initialised for signature verification');
       |    }
       |
      3|    var hash = Uint8List(_digest.digestSize);
      2|    _digest.reset();
      3|    _digest.update(message, 0, message.length);
      2|    _digest.doFinal(hash, 0);
      3|    var sig = Uint8List(_rsa.outputBlockSize);
       |
       |    try {
       |      final len =
      5|          _rsa.processBlock(signature.bytes, 0, signature.bytes.length, sig, 0);
      1|      sig = sig.sublist(0, len);
      0|    } on ArgumentError {
       |      // Signature was tampered with so the RSA 'decrypted' block is totally
       |      // different to the original, causing [PKCS1Encoding._decodeBlock] to
       |      // throw an exception because it does not recognise it.
       |      return false;
       |    }
       |
      1|    var expected = _derEncode(hash);
       |
      3|    if (sig.length == expected.length) {
      3|      for (var i = 0; i < sig.length; i++) {
      3|        if (sig[i] != expected[i]) {
       |          return false;
       |        }
       |      }
       |      return true; //return Arrays.constantTimeAreEqual(sig, expected);
       |
      0|    } else if (sig.length == expected.length - 2) {
       |      // NULL left out
      0|      var sigOffset = sig.length - hash.length - 2;
      0|      var expectedOffset = expected.length - hash.length - 2;
       |
      0|      expected[1] -= 2; // adjust lengths
      0|      expected[3] -= 2;
       |
       |      var nonEqual = 0;
       |
      0|      for (var i = 0; i < hash.length; i++) {
      0|        nonEqual |= (sig[sigOffset + i] ^ expected[expectedOffset + i]);
       |      }
       |
      0|      for (var i = 0; i < sigOffset; i++) {
      0|        nonEqual |= (sig[i] ^ expected[i]); // check header less NULL
       |      }
       |
      0|      return nonEqual == 0;
       |    } else {
       |      return false;
       |    }
       |  }
       |
      1|  Uint8List _derEncode(Uint8List hash) {
      9|    var out = Uint8List(2 + 2 + _digestIdentifier.length + 2 + 2 + hash.length);
       |    var i = 0;
       |
       |    // header
      2|    out[i++] = 48;
      4|    out[i++] = out.length - 2;
       |
       |    // algorithmIdentifier.header
      2|    out[i++] = 48;
      5|    out[i++] = _digestIdentifier.length + 2;
       |
       |    // algorithmIdentifier.bytes
      2|    out.setAll(i, _digestIdentifier);
      3|    i += _digestIdentifier.length;
       |
       |    // algorithmIdentifier.null
      2|    out[i++] = 5;
      2|    out[i++] = 0;
       |
       |    // hash.header
      2|    out[i++] = 4;
      3|    out[i++] = hash.length;
       |
       |    // hash.bytes
      1|    out.setAll(i, hash);
       |
       |    return out;
       |  }
       |
      1|  Uint8List _hexStringToBytes(String hex) {
      3|    var result = Uint8List(hex.length ~/ 2);
      3|    for (var i = 0; i < hex.length; i += 2) {
      2|      var num = hex.substring(i, i + 2);
      1|      var byte = int.parse(num, radix: 16);
      2|      result[i ~/ 2] = byte;
       |    }
       |    return result;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/stream/chacha20poly1305.dart
       |library impl.stream_cipher.chacha20poly1305;
       |
       |import 'dart:math';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/stream/chacha7539.dart';
       |import '../api.dart';
       |import '../export.dart';
       |import '../src/impl/base_aead_cipher.dart';
       |import '../src/ufixnum.dart';
       |
       |import '../src/utils.dart' as utils;
       |
       |// ignore_for_file: non_constant_identifier_names
       |
       |class ChaCha20Poly1305 extends BaseAEADCipher {
      0|  static final FactoryConfig factoryConfig = StaticFactoryConfig(
       |      AEADCipher,
       |      'ChaCha20-Poly1305',
       |      () => ChaCha20Poly1305(ChaCha7539Engine(), Poly1305()));
       |  static const BUF_SIZE = 64;
       |  static const KEY_SIZE = 32;
       |  static const NONCE_SIZE = 12;
       |  static const MAC_SIZE = 16;
      0|  static final MAX = pow(2, 63) - 1;
      0|  static final MIN = -pow(2, 63);
      0|  static final Uint8List ZEROES = Uint8List(MAC_SIZE - 1);
       |
      0|  static final int AADLimit = (MAX - MIN).toInt();
       |  static const DATA_LIMIT = (1 << 32 - 1) * 64;
       |  final ChaCha7539Engine chacha20;
       |  final Poly1305 poly1305;
       |
       |  final Uint8List _key = Uint8List(KEY_SIZE);
       |  final Uint8List _nonce = Uint8List(NONCE_SIZE);
       |  final Uint8List _buf = Uint8List(MAC_SIZE + BUF_SIZE);
       |  final Uint8List _mac = Uint8List(MAC_SIZE);
       |
      0|  @override
       |  String get algorithmName => 'ChaCha20-Poly1305';
       |
      0|  @override
      0|  Uint8List get mac => _mac;
       |
       |  Uint8List _initialAAD;
       |  int _aadCount;
       |  int _dataCount;
       |  int _state = State.UNINITIALIZED;
       |  int _bufPos;
       |
      0|  ChaCha20Poly1305(this.chacha20, this.poly1305) {
      0|    if (null == poly1305) {
      0|      throw ArgumentError('\'poly1305\' cannot be null');
       |    }
      0|    if (MAC_SIZE != poly1305.macSize) {
      0|      throw ArgumentError('\'poly1305\' must be a 128-bit MAC');
       |    }
       |  }
       |
      0|  @override
       |  void init(bool forEncryption, CipherParameters params) {
       |    KeyParameter initKeyParam;
       |    Uint8List initNonce;
       |    CipherParameters chacha20Params;
       |
      0|    if (params is AEADParameters) {
       |      var aeadParams = params;
       |
      0|      var macSizeBits = aeadParams.macSize;
      0|      if ((MAC_SIZE * 8) != macSizeBits) {
      0|        throw ArgumentError(
      0|            'Invalid value for MAC size: ' + macSizeBits.toString());
       |      }
       |
      0|      initKeyParam = aeadParams.parameters as KeyParameter;
      0|      initNonce = aeadParams.nonce;
      0|      chacha20Params = ParametersWithIV(initKeyParam, initNonce);
       |
      0|      _initialAAD = aeadParams.associatedData;
      0|    } else if (params is ParametersWithIV) {
       |      var ivParams = params;
       |
      0|      initKeyParam = ivParams.parameters as KeyParameter;
      0|      initNonce = ivParams.iv;
       |      chacha20Params = ivParams;
       |
      0|      _initialAAD = null;
       |    } else {
      0|      throw ArgumentError('invalid parameters passed to ChaCha20Poly1305');
       |    }
       |
       |    // Validate key
       |    if (null == initKeyParam) {
      0|      if (State.UNINITIALIZED == _state) {
      0|        throw ArgumentError('Key must be specified in initial init');
       |      }
       |    } else {
      0|      if (KEY_SIZE != initKeyParam.key.length) {
      0|        throw ArgumentError('Key must be 256 bits');
       |      }
       |    }
       |
       |    // Validate nonce
      0|    if (null == initNonce || NONCE_SIZE != initNonce.length) {
      0|      throw ArgumentError('Nonce must be 96 bits');
       |    }
       |
       |    // Check for encryption with reused nonce
      0|    if (State.UNINITIALIZED != _state &&
       |        forEncryption &&
      0|        (_nonce == initNonce)) {
      0|      if (null == initKeyParam || (_key == initKeyParam.key)) {
      0|        throw ArgumentError(
       |            'cannot reuse nonce for ChaCha20Poly1305 encryption');
       |      }
       |    }
       |
       |    if (null != initKeyParam) {
      0|      utils.arrayCopy(initKeyParam.key, 0, _key, 0, KEY_SIZE);
       |    }
       |
      0|    utils.arrayCopy(initNonce, 0, _nonce, 0, NONCE_SIZE);
       |
      0|    chacha20.init(true, chacha20Params as ParametersWithIV<KeyParameter>);
       |
      0|    _state = forEncryption ? State.ENC_INIT : State.DEC_INIT;
       |
      0|    resetBool(true, false);
       |  }
       |
      0|  @override
       |  // ignore: missing_return
       |  int getOutputSize(int len) {
      1|    var total = max(0, len) + _bufPos;
       |
      0|    switch (_state) {
      0|      case State.DEC_INIT:
      0|      case State.DEC_AAD:
      0|      case State.DEC_DATA:
      1|        return max(0, total - MAC_SIZE);
      0|      case State.ENC_INIT:
      0|      case State.ENC_AAD:
      0|      case State.ENC_DATA:
      0|        return total + MAC_SIZE;
       |      default:
      0|        throw StateError('state = ' + _state.toString());
       |    }
       |  }
       |
      0|  @override
       |  int getUpdateOutputSize(int len) {
      1|    var total = max(0, len) + _bufPos;
       |
      0|    switch (_state) {
      0|      case State.DEC_INIT:
      0|      case State.DEC_AAD:
      0|      case State.DEC_DATA:
      1|        total = max(0, total - MAC_SIZE);
       |        break;
      0|      case State.ENC_INIT:
      0|      case State.ENC_AAD:
      0|      case State.ENC_DATA:
       |        break;
       |      default:
      0|        throw StateError('');
       |    }
       |
      0|    return total - (total % BUF_SIZE);
       |  }
       |
      0|  @override
       |  void processAADByte(int inp) {
      0|    checkAAD();
       |
      0|    _aadCount = incrementCount(_aadCount, 1, AADLimit);
      0|    poly1305.updateByte(inp);
       |  }
       |
      0|  @override
       |  void processAADBytes(Uint8List inp, int inOff, int len) {
       |    if (null == inp) {
      0|      throw ArgumentError('\'in\' cannot be null');
       |    }
      0|    if (inOff < 0) {
      0|      throw ArgumentError('\'inOff\' cannot be negative');
       |    }
      0|    if (len < 0) {
      0|      throw ArgumentError('\'len\' cannot be negative');
       |    }
      0|    if (inOff > (inp.length - len)) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
       |
      0|    checkAAD();
       |
      0|    if (len > 0) {
      0|      _aadCount = incrementCount(_aadCount, len, AADLimit);
      0|      poly1305.update(inp, inOff, len);
       |    }
       |  }
       |
      0|  @override
       |  int processByte(int inp, Uint8List out, int outOff) {
      0|    checkData();
       |
      0|    switch (_state) {
      0|      case State.DEC_DATA:
       |        {
      0|          _buf[_bufPos] = inp;
      0|          if (++_bufPos == _buf.length) {
      0|            poly1305.update(_buf, 0, BUF_SIZE);
      0|            processData(_buf, 0, BUF_SIZE, out, outOff);
      0|            utils.arrayCopy(_buf, BUF_SIZE, _buf, 0, MAC_SIZE);
      0|            _bufPos = MAC_SIZE;
       |            return BUF_SIZE;
       |          }
       |
       |          return 0;
       |        }
      0|      case State.ENC_DATA:
       |        {
      0|          _buf[_bufPos] = inp;
      0|          if (++_bufPos == BUF_SIZE) {
      0|            processData(_buf, 0, BUF_SIZE, out, outOff);
      0|            poly1305.update(out, outOff, BUF_SIZE);
      0|            _bufPos = 0;
       |            return BUF_SIZE;
       |          }
       |
       |          return 0;
       |        }
       |      default:
      0|        throw StateError('');
       |    }
       |  }
       |
      0|  @override
       |  int processBytes(
       |      Uint8List inp, int inOff, int len, Uint8List out, int outOff) {
       |    if (null == inp) {
      0|      throw ArgumentError('\'in\' cannot be null');
       |    }
      0|    if (inOff < 0) {
      0|      throw ArgumentError('\'inOff\' cannot be negative');
       |    }
      0|    if (len < 0) {
      0|      throw ArgumentError('\'len\' cannot be negative');
       |    }
      0|    if (inOff > (inp.length - len)) {
      0|      throw ArgumentError('Input buffer too short');
       |    }
      0|    if (outOff < 0) {
      0|      throw ArgumentError('\'outOff\' cannot be negative');
       |    }
       |
      0|    checkData();
       |
       |    var resultLen = 0;
       |
      0|    switch (_state) {
      0|      case State.DEC_DATA:
       |        {
      0|          for (var i = 0; i < len; ++i) {
      0|            _buf[_bufPos] = inp[inOff + i];
      0|            if (++_bufPos == _buf.length) {
      0|              poly1305.update(_buf, 0, BUF_SIZE);
      0|              processData(_buf, 0, BUF_SIZE, out, outOff + resultLen);
      0|              utils.arrayCopy(_buf, BUF_SIZE, _buf, 0, MAC_SIZE);
      0|              _bufPos = MAC_SIZE;
      0|              resultLen += BUF_SIZE;
       |            }
       |          }
       |          break;
       |        }
      0|      case State.ENC_DATA:
       |        {
      0|          if (_bufPos != 0) {
      0|            while (len > 0) {
      0|              --len;
      0|              _buf[_bufPos] = inp[inOff++];
      0|              if (++_bufPos == BUF_SIZE) {
      0|                processData(_buf, 0, BUF_SIZE, out, outOff);
      0|                poly1305.update(out, outOff, BUF_SIZE);
      0|                _bufPos = 0;
       |                resultLen = BUF_SIZE;
       |                break;
       |              }
       |            }
       |          }
       |
      0|          while (len >= BUF_SIZE) {
      0|            processData(inp, inOff, BUF_SIZE, out, outOff + resultLen);
      0|            poly1305.update(out, outOff + resultLen, BUF_SIZE);
      0|            inOff += BUF_SIZE;
      0|            len -= BUF_SIZE;
      0|            resultLen += BUF_SIZE;
       |          }
       |
      0|          if (len > 0) {
      0|            utils.arrayCopy(inp, inOff, _buf, 0, len);
      0|            _bufPos = len;
       |          }
       |          break;
       |        }
       |      default:
      0|        throw StateError('');
       |    }
       |
       |    return resultLen;
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
       |    if (null == out) {
      0|      throw ArgumentError('\'out\' cannot be null');
       |    }
      0|    if (outOff < 0) {
      0|      throw ArgumentError('\'outOff\' cannot be negative');
       |    }
       |
      0|    checkData();
       |
      0|    for (var i = 0; i < _mac.length; i++) {
      0|      _mac[i] = 0x00;
       |    }
       |
       |    var resultLen = 0;
       |
      0|    switch (_state) {
      0|      case State.DEC_DATA:
       |        {
      0|          if (_bufPos < MAC_SIZE) {
      0|            throw ArgumentError('data too short');
       |          }
       |
      0|          resultLen = _bufPos - MAC_SIZE;
       |
      0|          if (outOff > (out.length - resultLen)) {
      0|            throw ArgumentError('Output buffer too short');
       |          }
       |
      0|          if (resultLen > 0) {
      0|            poly1305.update(_buf, 0, resultLen);
      0|            processData(_buf, 0, resultLen, out, outOff);
       |          }
       |
      0|          finishData(State.DEC_FINAL);
       |
      0|          if (!utils.constantTimeAreEqualOffset(
      0|              MAC_SIZE, _mac, 0, _buf, resultLen)) {
      0|            throw ArgumentError('mac check in ChaCha20Poly1305 failed');
       |          }
       |
       |          break;
       |        }
      0|      case State.ENC_DATA:
       |        {
      0|          resultLen = _bufPos + MAC_SIZE;
       |
       |          // ignore: invariant_booleans
      0|          if (outOff > (out.length - resultLen)) {
      0|            throw ArgumentError('Output buffer too short');
       |          }
       |
      0|          if (_bufPos > 0) {
      0|            processData(_buf, 0, _bufPos, out, outOff);
      0|            poly1305.update(out, outOff, _bufPos);
       |          }
       |
      0|          finishData(State.ENC_FINAL);
       |
      0|          utils.arrayCopy(_mac, 0, out, outOff + _bufPos, MAC_SIZE);
       |          break;
       |        }
       |      default:
      0|        throw StateError('');
       |    }
       |
      0|    resetBool(false, true);
       |
       |    return resultLen;
       |  }
       |
      0|  @override
       |  void reset() {
      0|    resetBool(true, true);
       |  }
       |
      0|  void resetBool(bool clearMac, bool resetCipher) {
      0|    for (var i = 0; i < _buf.length; i++) {
      0|      _buf[i] = 0;
       |    }
       |
       |    if (clearMac) {
      0|      for (var i = 0; i < _mac.length; i++) {
      0|        _mac[i] = 0x00;
       |      }
       |    }
       |
      0|    _aadCount = 0;
      0|    _dataCount = 0;
      0|    _bufPos = 0;
       |
      0|    switch (_state) {
      0|      case State.DEC_INIT:
      0|      case State.ENC_INIT:
       |        break;
      0|      case State.DEC_AAD:
      0|      case State.DEC_DATA:
      0|      case State.DEC_FINAL:
      0|        _state = State.DEC_INIT;
       |        break;
      0|      case State.ENC_AAD:
      0|      case State.ENC_DATA:
      0|      case State.ENC_FINAL:
      0|        _state = State.ENC_FINAL;
       |        return;
       |      default:
      0|        throw StateError('');
       |    }
       |
       |    if (resetCipher) {
      0|      chacha20.reset();
       |    }
       |
      0|    initMAC();
       |
      0|    if (null != _initialAAD) {
      0|      processAADBytes(_initialAAD, 0, _initialAAD.length);
       |    }
       |  }
       |
      0|  void checkAAD() {
      0|    switch (_state) {
      0|      case State.DEC_INIT:
      0|        _state = State.DEC_AAD;
       |        break;
      0|      case State.ENC_INIT:
      0|        _state = State.ENC_AAD;
       |        break;
      0|      case State.DEC_AAD:
      0|      case State.ENC_AAD:
       |        break;
      0|      case State.ENC_FINAL:
      0|        throw StateError('ChaCha20Poly1305 cannot be reused for encryption');
       |      default:
      0|        throw StateError('');
       |    }
       |  }
       |
      0|  void checkData() {
      0|    switch (_state) {
      0|      case State.DEC_INIT:
      0|      case State.DEC_AAD:
      0|        finishAAD(State.DEC_DATA);
       |        break;
      0|      case State.ENC_INIT:
      0|      case State.ENC_AAD:
      0|        finishAAD(State.ENC_DATA);
       |        break;
      0|      case State.DEC_DATA:
      0|      case State.ENC_DATA:
       |        break;
      0|      case State.ENC_FINAL:
      0|        throw StateError('ChaCha20Poly1305 cannot be reused for encryption');
       |      default:
      0|        throw StateError('');
       |    }
       |  }
       |
      0|  void finishAAD(int nextState) {
      0|    padMAC(_aadCount);
       |
      0|    _state = nextState;
       |  }
       |
      0|  void finishData(int nextState) {
      0|    padMAC(_dataCount);
       |
      0|    var lengths = Uint8List(16);
      0|    pack32(_aadCount, lengths, 0, Endian.little);
      0|    pack32(_dataCount, lengths, 8, Endian.little);
      0|    poly1305.update(lengths, 0, 16);
       |
      0|    poly1305.doFinal(_mac, 0);
       |
      0|    _state = nextState;
       |  }
       |
      0|  int incrementCount(int count, int increment, int limit) {
      0|    if (count + MIN > (limit - increment) + MIN) {
      0|      throw StateError('Limit exceeded');
       |    }
       |
      0|    return count + increment;
       |  }
       |
      0|  void initMAC() {
      0|    var firstBlock = Uint8List(64);
       |    try {
      0|      chacha20.processBytes(firstBlock, 0, 64, firstBlock, 0);
      0|      poly1305.init(KeyParameter.offset(firstBlock, 0, 32));
       |    } finally {
      0|      for (var i = 0; i < firstBlock.length; i++) {
      0|        firstBlock[i] = 0;
       |      }
       |    }
       |  }
       |
      0|  void padMAC(int count) {
      0|    var partial = (count & 4294967295) & (MAC_SIZE - 1);
      0|    if (0 != partial) {
      0|      poly1305.update(ZEROES, 0, MAC_SIZE - partial);
       |    }
       |  }
       |
      0|  void processData(
       |      Uint8List inp, int inOff, int inLen, Uint8List out, int outOff) {
      0|    if (outOff > (out.length - inLen)) {
      0|      throw ArgumentError('Output buffer too short');
       |    }
       |
      0|    chacha20.processBytes(inp, inOff, inLen, out, outOff);
       |
      0|    _dataCount = incrementCount(_dataCount, inLen, DATA_LIMIT);
       |  }
       |}
       |
       |class State {
       |  static const UNINITIALIZED = 0;
       |  static const ENC_INIT = 1;
       |  static const ENC_AAD = 2;
       |  static const ENC_DATA = 3;
       |  static const ENC_FINAL = 4;
       |  static const DEC_INIT = 5;
       |  static const DEC_AAD = 6;
       |  static const DEC_DATA = 7;
       |  static const DEC_FINAL = 8;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/stream/chacha7539.dart
       |library impl.stream_cipher.chacha7539;
       |
       |import 'dart:typed_data';
       |
       |import '../export.dart';
       |import '../api.dart';
       |import '../src/impl/base_stream_cipher.dart';
       |import '../src/registry/registry.dart';
       |import '../src/ufixnum.dart';
       |
       |// ignore_for_file: omit_local_variable_types, prefer_single_quotes
       |// ignore_for_file: non_constant_identifier_names, directives_ordering
       |// ignore_for_file: prefer_typing_uninitialized_variables, camel_case_types
       |// ignore_for_file: annotate_overrides
       |
       |/// RFC version of Daniel J. Bernstein's ChaCha20. This uses a 12 byte IV, among
       |/// other changes.
       |class ChaCha7539Engine extends BaseStreamCipher {
       |  // ignore: non_constant_identifier_names
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.prefix(
       |      StreamCipher,
       |      'ChaCha7539/',
       |          (_, final Match match) => () {
       |        var rounds = int.parse(match.group(1));
       |        return ChaCha7539Engine.fromRounds(rounds);
       |      });
       |
      0|  ChaCha7539Engine () {rounds = 20;}
       |
      0|  ChaCha7539Engine.fromRounds(this.rounds);
       |
       |  int rounds = 20;
       |
       |  static const STATE_SIZE = 16;
       |
      0|  static final _sigma = Uint8List.fromList([
       |    101,
       |    120,
       |    112,
       |    97,
       |    110,
       |    100,
       |    32,
       |    51,
       |    50,
       |    45,
       |    98,
       |    121,
       |    116,
       |    101,
       |    32,
       |    107
       |  ]);
      0|  static final _tau = Uint8List.fromList([
       |    101,
       |    120,
       |    112,
       |    97,
       |    110,
       |    100,
       |    32,
       |    49,
       |    54,
       |    45,
       |    98,
       |    121,
       |    116,
       |    101,
       |    32,
       |    107
       |  ]);
       |
       |  Uint8List _workingKey;
       |  Uint8List _workingIV;
       |
       |  final _state = List<int>(STATE_SIZE);
       |  final _buffer = List<int>(STATE_SIZE);
       |
       |  final _keyStream = Uint8List(STATE_SIZE * 4);
       |  var _keyStreamOffset = 0;
       |
       |  var _initialised = false;
       |
      0|  @override
      0|  String get algorithmName => 'ChaCha7539/$rounds';
       |
      0|  @override
       |  void reset() {
      0|    _state[12] = 0;
      0|    if (_workingKey != null) {
      0|      _setKey(_workingKey, _workingIV);
       |    }
       |  }
       |
      0|  @override
       |  void init(
       |      bool forEncryption, covariant ParametersWithIV<KeyParameter> params) {
      0|    var uparams = params.parameters;
      0|    var iv = params.iv;
      0|    if (iv == null || iv.length != 12) {
      0|      throw ArgumentError('ChaCha20-7539 requires exactly 12 bytes of IV');
       |    }
       |
      0|    _workingIV = iv;
      0|    _workingKey = uparams.key;
       |
      0|    _setKey(_workingKey, _workingIV);
       |  }
       |
      0|  @override
       |  int returnByte(int inp) {
      0|    if (_keyStreamOffset == 0) {
      0|      generateKeyStream(_keyStream);
       |
      0|      if (++_state[12] == 0) {
      0|        ++_state[13];
       |      }
       |    }
       |
      0|    var out = clip8(_keyStream[_keyStreamOffset] ^ inp);
      0|    _keyStreamOffset = (_keyStreamOffset + 1) & 63;
       |
       |    return out;
       |  }
       |
      0|  @override
       |  void processBytes(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      0|    if (!_initialised) {
      0|      throw StateError('ChaCha20 not initialized: please call init() first');
       |    }
       |
      0|    if ((inpOff + len) > inp.length) {
      0|      throw ArgumentError(
       |          'Input buffer too short or requested length too long');
       |    }
       |
      0|    if ((outOff + len) > out.length) {
      0|      throw ArgumentError(
       |          'Output buffer too short or requested length too long');
       |    }
       |
      0|    for (var i = 0; i < len; i++) {
      0|      if (_keyStreamOffset == 0) {
      0|        generateKeyStream(_keyStream);
       |
      0|        if (++_state[12] == 0) throw StateError('Illegal increase of counter');
       |      }
       |
      0|      out[i + outOff] = clip8(_keyStream[_keyStreamOffset] ^ inp[i + inpOff]);
      0|      _keyStreamOffset = (_keyStreamOffset + 1) & 63;
       |    }
       |  }
       |
      0|  void _setKey(Uint8List keyBytes, Uint8List ivBytes) {
      0|    _workingKey = keyBytes;
      0|    _workingIV = ivBytes;
       |
      0|    _keyStreamOffset = 0;
       |    Uint8List constants;
       |
      0|    if (_workingKey.length == 32) {
      0|      constants = _sigma;
       |    } else {
      0|      constants = _tau;
       |    }
       |
       |    //Key
      0|    _state[4] = unpack32(_workingKey, 0, Endian.little);
      0|    _state[5] = unpack32(_workingKey, 4, Endian.little);
      0|    _state[6] = unpack32(_workingKey, 8, Endian.little);
      0|    _state[7] = unpack32(_workingKey, 12, Endian.little);
      0|    _state[8] = unpack32(_workingKey, 16, Endian.little);
      0|    _state[9] = unpack32(_workingKey, 20, Endian.little);
      0|    _state[10] = unpack32(_workingKey, 24, Endian.little);
      0|    _state[11] = unpack32(_workingKey, 28, Endian.little);
       |
      0|    _state[0] = unpack32(constants, 0, Endian.little);
      0|    _state[1] = unpack32(constants, 4, Endian.little);
      0|    _state[2] = unpack32(constants, 8, Endian.little);
      0|    _state[3] = unpack32(constants, 12, Endian.little);
       |
      0|    _state[12] = 0;
       |
       |    // IV
       |    var off = 0;
      0|    for (var i = 0; i < 3; ++i) {
      0|      _state[13 + i] = unpack32(_workingIV, off, Endian.little);
      0|      off += 4;
       |    }
       |
      0|    _initialised = true;
       |  }
       |
      0|  void generateKeyStream(Uint8List output) {
      0|    _core(rounds, _state, _buffer);
       |    var outOff = 0;
      0|    for (var x in _buffer) {
      0|      pack32(x, output, outOff, Endian.little);
      0|      outOff += 4;
       |    }
       |  }
       |
       |  /// The ChaCha20 core function
      0|  void _core(int rounds, List<int> input, List<int> x) {
      0|    var x00 = input[0];
      0|    var x01 = input[1];
      0|    var x02 = input[2];
      0|    var x03 = input[3];
      0|    var x04 = input[4];
      0|    var x05 = input[5];
      0|    var x06 = input[6];
      0|    var x07 = input[7];
      0|    var x08 = input[8];
      0|    var x09 = input[9];
      0|    var x10 = input[10];
      0|    var x11 = input[11];
      0|    var x12 = input[12];
      0|    var x13 = input[13];
      0|    var x14 = input[14];
      0|    var x15 = input[15];
       |
      0|    for (var i = rounds; i > 0; i -= 2) {
      0|      x00 += x04;
      0|      x12 = crotl32(x12 ^ x00, 16);
      0|      x08 += x12;
      0|      x04 = crotl32(x04 ^ x08, 12);
      0|      x00 += x04;
      0|      x12 = crotl32(x12 ^ x00, 8);
      0|      x08 += x12;
      0|      x04 = crotl32(x04 ^ x08, 7);
      0|      x01 += x05;
      0|      x13 = crotl32(x13 ^ x01, 16);
      0|      x09 += x13;
      0|      x05 = crotl32(x05 ^ x09, 12);
      0|      x01 += x05;
      0|      x13 = crotl32(x13 ^ x01, 8);
      0|      x09 += x13;
      0|      x05 = crotl32(x05 ^ x09, 7);
      0|      x02 += x06;
      0|      x14 = crotl32(x14 ^ x02, 16);
      0|      x10 += x14;
      0|      x06 = crotl32(x06 ^ x10, 12);
      0|      x02 += x06;
      0|      x14 = crotl32(x14 ^ x02, 8);
      0|      x10 += x14;
      0|      x06 = crotl32(x06 ^ x10, 7);
      0|      x03 += x07;
      0|      x15 = crotl32(x15 ^ x03, 16);
      0|      x11 += x15;
      0|      x07 = crotl32(x07 ^ x11, 12);
      0|      x03 += x07;
      0|      x15 = crotl32(x15 ^ x03, 8);
      0|      x11 += x15;
      0|      x07 = crotl32(x07 ^ x11, 7);
      0|      x00 += x05;
      0|      x15 = crotl32(x15 ^ x00, 16);
      0|      x10 += x15;
      0|      x05 = crotl32(x05 ^ x10, 12);
      0|      x00 += x05;
      0|      x15 = crotl32(x15 ^ x00, 8);
      0|      x10 += x15;
      0|      x05 = crotl32(x05 ^ x10, 7);
      0|      x01 += x06;
      0|      x12 = crotl32(x12 ^ x01, 16);
      0|      x11 += x12;
      0|      x06 = crotl32(x06 ^ x11, 12);
      0|      x01 += x06;
      0|      x12 = crotl32(x12 ^ x01, 8);
      0|      x11 += x12;
      0|      x06 = crotl32(x06 ^ x11, 7);
      0|      x02 += x07;
      0|      x13 = crotl32(x13 ^ x02, 16);
      0|      x08 += x13;
      0|      x07 = crotl32(x07 ^ x08, 12);
      0|      x02 += x07;
      0|      x13 = crotl32(x13 ^ x02, 8);
      0|      x08 += x13;
      0|      x07 = crotl32(x07 ^ x08, 7);
      0|      x03 += x04;
      0|      x14 = crotl32(x14 ^ x03, 16);
      0|      x09 += x14;
      0|      x04 = crotl32(x04 ^ x09, 12);
      0|      x03 += x04;
      0|      x14 = crotl32(x14 ^ x03, 8);
      0|      x09 += x14;
      0|      x04 = crotl32(x04 ^ x09, 7);
       |    }
      0|    var xup = [
       |      x00,
       |      x01,
       |      x02,
       |      x03,
       |      x04,
       |      x05,
       |      x06,
       |      x07,
       |      x08,
       |      x09,
       |      x10,
       |      x11,
       |      x12,
       |      x13,
       |      x14,
       |      x15
       |    ];
      0|    for (var i = 0; i < STATE_SIZE; ++i) {
      0|      x[i] = csum32(xup[i], input[i]);
       |    }
       |  }
       |
       |  @override
       |  dynamic noSuchMethod(Invocation invocation);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/stream/ctr.dart
       |// See file LICENSE for more information.
       |
       |library impl.stream_cipher.ctr;
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/stream/sic.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Just an alias to be able to create SIC as CTR
       |class CTRStreamCipher extends SICStreamCipher {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      StreamCipher,
       |      '/CTR',
       |      (_, final Match match) => () {
       |            var digestName = match.group(1);
       |            return CTRStreamCipher(BlockCipher(digestName));
       |          });
       |
      0|  CTRStreamCipher(BlockCipher underlyingCipher) : super(underlyingCipher);
      0|  @override
      0|  String get algorithmName => '${underlyingCipher.algorithmName}/CTR';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/stream/salsa20.dart
       |// See file LICENSE for more information.
       |
       |library impl.stream_cipher.salsa20;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_stream_cipher.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |
       |/// Implementation of Daniel J. Bernstein's Salsa20 stream cipher, Snuffle 2005.
       |class Salsa20Engine extends BaseStreamCipher {
      0|  static final FactoryConfig factoryConfig =
       |      StaticFactoryConfig(StreamCipher, 'Salsa20', () => Salsa20Engine());
       |
       |  static const _STATE_SIZE = 16;
       |
      0|  static final _sigma = Uint8List.fromList('expand 32-byte k'.codeUnits);
      0|  static final _tau = Uint8List.fromList('expand 16-byte k'.codeUnits);
       |
       |  Uint8List _workingKey;
       |  Uint8List _workingIV;
       |
       |  final _state = List<int>(_STATE_SIZE);
       |  final _buffer = List<int>(_STATE_SIZE);
       |
       |  final _keyStream = Uint8List(_STATE_SIZE * 4);
       |  var _keyStreamOffset = 0;
       |
       |  var _initialised = false;
       |
       |  @override
       |  final String algorithmName = 'Salsa20';
       |
      0|  @override
       |  void reset() {
      0|    if (_workingKey != null) {
      0|      _setKey(_workingKey, _workingIV);
       |    }
       |  }
       |
      0|  @override
       |  void init(
       |      bool forEncryption, covariant ParametersWithIV<KeyParameter> params) {
      0|    var uparams = params.parameters;
      0|    var iv = params.iv;
      0|    if (iv == null || iv.length != 8) {
      0|      throw ArgumentError('Salsa20 requires exactly 8 bytes of IV');
       |    }
       |
      0|    _workingIV = iv;
      0|    _workingKey = uparams.key;
       |
      0|    _setKey(_workingKey, _workingIV);
       |  }
       |
      0|  @override
       |  int returnByte(int inp) {
      0|    if (_keyStreamOffset == 0) {
      0|      _generateKeyStream(_keyStream);
       |
      0|      if (++_state[8] == 0) {
      0|        ++_state[9];
       |      }
       |    }
       |
      0|    var out = clip8(_keyStream[_keyStreamOffset] ^ inp);
      0|    _keyStreamOffset = (_keyStreamOffset + 1) & 63;
       |
       |    return out;
       |  }
       |
      0|  @override
       |  void processBytes(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      0|    if (!_initialised) {
      0|      throw StateError('Salsa20 not initialized: please call init() first');
       |    }
       |
      0|    if ((inpOff + len) > inp.length) {
      0|      throw ArgumentError(
       |          'Input buffer too short or requested length too long');
       |    }
       |
      0|    if ((outOff + len) > out.length) {
      0|      throw ArgumentError(
       |          'Output buffer too short or requested length too long');
       |    }
       |
      0|    for (var i = 0; i < len; i++) {
      0|      if (_keyStreamOffset == 0) {
      0|        _generateKeyStream(_keyStream);
       |
      0|        if (++_state[8] == 0) {
      0|          ++_state[9];
       |        }
       |      }
       |
      0|      out[i + outOff] = clip8(_keyStream[_keyStreamOffset] ^ inp[i + inpOff]);
      0|      _keyStreamOffset = (_keyStreamOffset + 1) & 63;
       |    }
       |  }
       |
      0|  void _setKey(Uint8List keyBytes, Uint8List ivBytes) {
      0|    _workingKey = keyBytes;
      0|    _workingIV = ivBytes;
       |
      0|    _keyStreamOffset = 0;
       |    var offset = 0;
       |    Uint8List constants;
       |
       |    // Key
      0|    _state[1] = unpack32(_workingKey, 0, Endian.little);
      0|    _state[2] = unpack32(_workingKey, 4, Endian.little);
      0|    _state[3] = unpack32(_workingKey, 8, Endian.little);
      0|    _state[4] = unpack32(_workingKey, 12, Endian.little);
       |
      0|    if (_workingKey.length == 32) {
      0|      constants = _sigma;
       |      offset = 16;
       |    } else {
      0|      constants = _tau;
       |    }
       |
      0|    _state[11] = unpack32(_workingKey, offset, Endian.little);
      0|    _state[12] = unpack32(_workingKey, offset + 4, Endian.little);
      0|    _state[13] = unpack32(_workingKey, offset + 8, Endian.little);
      0|    _state[14] = unpack32(_workingKey, offset + 12, Endian.little);
      0|    _state[0] = unpack32(constants, 0, Endian.little);
      0|    _state[5] = unpack32(constants, 4, Endian.little);
      0|    _state[10] = unpack32(constants, 8, Endian.little);
      0|    _state[15] = unpack32(constants, 12, Endian.little);
       |
       |    // IV
      0|    _state[6] = unpack32(_workingIV, 0, Endian.little);
      0|    _state[7] = unpack32(_workingIV, 4, Endian.little);
      0|    _state[8] = _state[9] = 0;
       |
      0|    _initialised = true;
       |  }
       |
      0|  void _generateKeyStream(Uint8List output) {
      0|    _salsa20Core(20, _state, _buffer);
       |    var outOff = 0;
      0|    for (var x in _buffer) {
      0|      pack32(x, output, outOff, Endian.little);
      0|      outOff += 4;
       |    }
       |  }
       |
       |  /// The Salsa20 core function
      0|  void _salsa20Core(int rounds, List<int> input, List<int> x) {
      0|    x.setAll(0, input);
       |
      0|    for (var i = rounds; i > 0; i -= 2) {
      0|      x[4] ^= crotl32((x[0] + x[12]), 7);
      0|      x[8] ^= crotl32((x[4] + x[0]), 9);
      0|      x[12] ^= crotl32((x[8] + x[4]), 13);
      0|      x[0] ^= crotl32((x[12] + x[8]), 18);
      0|      x[9] ^= crotl32((x[5] + x[1]), 7);
      0|      x[13] ^= crotl32((x[9] + x[5]), 9);
      0|      x[1] ^= crotl32((x[13] + x[9]), 13);
      0|      x[5] ^= crotl32((x[1] + x[13]), 18);
      0|      x[14] ^= crotl32((x[10] + x[6]), 7);
      0|      x[2] ^= crotl32((x[14] + x[10]), 9);
      0|      x[6] ^= crotl32((x[2] + x[14]), 13);
      0|      x[10] ^= crotl32((x[6] + x[2]), 18);
      0|      x[3] ^= crotl32((x[15] + x[11]), 7);
      0|      x[7] ^= crotl32((x[3] + x[15]), 9);
      0|      x[11] ^= crotl32((x[7] + x[3]), 13);
      0|      x[15] ^= crotl32((x[11] + x[7]), 18);
      0|      x[1] ^= crotl32((x[0] + x[3]), 7);
      0|      x[2] ^= crotl32((x[1] + x[0]), 9);
      0|      x[3] ^= crotl32((x[2] + x[1]), 13);
      0|      x[0] ^= crotl32((x[3] + x[2]), 18);
      0|      x[6] ^= crotl32((x[5] + x[4]), 7);
      0|      x[7] ^= crotl32((x[6] + x[5]), 9);
      0|      x[4] ^= crotl32((x[7] + x[6]), 13);
      0|      x[5] ^= crotl32((x[4] + x[7]), 18);
      0|      x[11] ^= crotl32((x[10] + x[9]), 7);
      0|      x[8] ^= crotl32((x[11] + x[10]), 9);
      0|      x[9] ^= crotl32((x[8] + x[11]), 13);
      0|      x[10] ^= crotl32((x[9] + x[8]), 18);
      0|      x[12] ^= crotl32((x[15] + x[14]), 7);
      0|      x[13] ^= crotl32((x[12] + x[15]), 9);
      0|      x[14] ^= crotl32((x[13] + x[12]), 13);
      0|      x[15] ^= crotl32((x[14] + x[13]), 18);
       |    }
       |
      0|    for (var i = 0; i < _STATE_SIZE; ++i) {
      0|      x[i] = sum32(x[i], input[i]);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/stream/sic.dart
       |// See file LICENSE for more information.
       |
       |library impl.stream_cipher.sic;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_stream_cipher.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |/// Implementation of SIC mode of operation as a [StreamCipher]. This implementation uses the IV as the initial nonce value and
       |/// keeps incrementing it by 1 for every block. The counter may overflow and rotate, and that would cause a two-time-pad
       |/// error, but this is so unlikely to happen for usual block sizes that we don't check for that event. It is the responsibility
       |/// of the caller to make sure the counter does not overflow.
       |class SICStreamCipher extends BaseStreamCipher {
       |  /// Intended for internal use.
       |  // ignore: non_constant_identifier_names
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.suffix(
       |      StreamCipher,
       |      '/SIC',
       |      (_, final Match match) => () {
       |            var digestName = match.group(1);
       |            return SICStreamCipher(BlockCipher(digestName));
       |          });
       |
       |  final BlockCipher underlyingCipher;
       |
       |  Uint8List _iv;
       |  Uint8List _counter;
       |  Uint8List _counterOut;
       |  int _consumed;
       |
      0|  SICStreamCipher(this.underlyingCipher) {
      0|    _iv = Uint8List(underlyingCipher.blockSize);
      0|    _counter = Uint8List(underlyingCipher.blockSize);
      0|    _counterOut = Uint8List(underlyingCipher.blockSize);
       |  }
       |
      0|  @override
      0|  String get algorithmName => '${underlyingCipher.algorithmName}/SIC';
       |
      0|  @override
       |  void reset() {
      0|    underlyingCipher.reset();
      0|    _counter.setAll(0, _iv);
      0|    _counterOut.fillRange(0, _counterOut.length, 0);
      0|    _consumed = _counterOut.length;
       |  }
       |
      0|  @override
       |  void init(bool forEncryption, covariant ParametersWithIV params) {
      0|    _iv.setAll(0, params.iv);
      0|    reset();
      0|    underlyingCipher.init(true, params.parameters);
       |  }
       |
      0|  @override
       |  void processBytes(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      0|    for (var i = 0; i < len; i++) {
      0|      out[outOff + i] = returnByte(inp[inpOff + i]);
       |    }
       |  }
       |
      0|  @override
       |  int returnByte(int inp) {
      0|    _feedCounterIfNeeded();
      0|    return clip8(inp) ^ _counterOut[_consumed++];
       |  }
       |
       |  /// Calls [_feedCounter] if all [_counterOut] bytes have been consumed
      0|  void _feedCounterIfNeeded() {
      0|    if (_consumed >= _counterOut.length) {
      0|      _feedCounter();
       |    }
       |  }
       |
       |  // ignore: slash_for_doc_comments
       |  /**
       |   * Fills [_counterOut] with a value got from encrypting [_counter] with
       |   * the _underlyingCipher, resets [_consumed]to 0 and increments the
       |   * [_counter].
       |   */
      0|  void _feedCounter() {
      0|    underlyingCipher.processBlock(_counter, 0, _counterOut, 0);
      0|    _incrementCounter();
      0|    _consumed = 0;
       |  }
       |
       |  /// Increments [_counter] by 1
      0|  void _incrementCounter() {
       |    int i;
      0|    for (i = _counter.lengthInBytes - 1; i >= 0; i--) {
      0|      var val = _counter[i];
      0|      val++;
      0|      _counter[i] = val;
      0|      if (_counter[i] != 0) break;
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_stream_cipher.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.base_stream_cipher;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// Base implementation of [StreamCipher] which provides shared methods.
       |abstract class BaseStreamCipher implements StreamCipher {
      0|  @override
       |  Uint8List process(Uint8List data) {
      0|    var out = Uint8List(data.length);
      0|    processBytes(data, 0, data.length, out, 0);
       |    return out;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/ufixnum.dart
       |// See file LICENSE for more information.
       |
       |library src.ufixnum;
       |
       |import 'dart:typed_data';
       |
       |const _MASK_3 = 0x07;
       |const _MASK_5 = 0x1F;
       |const _MASK_6 = 0x3F;
       |const _MASK_8 = 0xFF;
       |const _MASK_16 = 0xFFFF;
       |const _MASK_32 = 0xFFFFFFFF;
       |
       |// ignore: non_constant_identifier_names
      3|final _MASK32_HI_BITS = [
       |  0xFFFFFFFF,
       |  0x7FFFFFFF,
       |  0x3FFFFFFF,
       |  0x1FFFFFFF,
       |  0x0FFFFFFF,
       |  0x07FFFFFF,
       |  0x03FFFFFF,
       |  0x01FFFFFF,
       |  0x00FFFFFF,
       |  0x007FFFFF,
       |  0x003FFFFF,
       |  0x001FFFFF,
       |  0x000FFFFF,
       |  0x0007FFFF,
       |  0x0003FFFF,
       |  0x0001FFFF,
       |  0x0000FFFF,
       |  0x00007FFF,
       |  0x00003FFF,
       |  0x00001FFF,
       |  0x00000FFF,
       |  0x000007FF,
       |  0x000003FF,
       |  0x000001FF,
       |  0x000000FF,
       |  0x0000007F,
       |  0x0000003F,
       |  0x0000001F,
       |  0x0000000F,
       |  0x00000007,
       |  0x00000003,
       |  0x00000001,
       |  0x00000000
       |];
       |
       |////////////////////////////////////////////////////////////////////////////////////////////////////
       |// 8 bit operations
       |//
      2|int clip8(int x) => (x & _MASK_8);
       |
      0|int csum8(int x, int y) => sum8(clip8(x), clip8(y));
      0|int sum8(int x, int y) {
       |  assert((x >= 0) && (x <= _MASK_8));
       |  assert((y >= 0) && (y <= _MASK_8));
      0|  return ((x + y) & _MASK_8);
       |}
       |
      0|int csub8(int x, int y) => sub8(clip8(x), clip8(y));
      0|int sub8(int x, int y) {
       |  assert((x >= 0) && (x <= _MASK_8));
       |  assert((y >= 0) && (y <= _MASK_8));
      0|  return ((x - y) & _MASK_8);
       |}
       |
      0|int cshiftl8(int x, int n) => shiftl8(clip8(x), n);
      0|int shiftl8(int x, int n) {
       |  assert((x >= 0) && (x <= _MASK_8));
      0|  return ((x << (n & _MASK_3)) & _MASK_8);
       |}
       |
      0|int cshiftr8(int x, int n) => shiftr8(clip8(x), n);
      0|int shiftr8(int x, int n) {
       |  assert((x >= 0) && (x <= _MASK_8));
      0|  return (x >> (n & _MASK_3));
       |}
       |
      0|int cneg8(int x) => neg8(clip8(x));
      0|int neg8(int x) {
       |  assert((x >= 0) && (x <= _MASK_8));
      0|  return (-x & _MASK_8);
       |}
       |
      0|int cnot8(int x) => not8(clip8(x));
      0|int not8(int x) {
       |  assert((x >= 0) && (x <= _MASK_8));
      0|  return (~x & _MASK_8);
       |}
       |
      0|int crotl8(int x, int n) => rotl8(clip8(x), n);
      0|int rotl8(int x, int n) {
       |  assert(n >= 0);
       |  assert((x >= 0) && (x <= _MASK_8));
      0|  n &= _MASK_3;
      0|  return ((x << n) & _MASK_8) | (x >> (8 - n));
       |}
       |
      0|int crotr8(int x, int n) => rotr8(clip8(x), n);
      0|int rotr8(int x, int n) {
       |  assert(n >= 0);
       |  assert((x >= 0) && (x <= _MASK_8));
      0|  n &= _MASK_3;
      0|  return ((x >> n) & _MASK_8) | ((x << (8 - n)) & _MASK_8);
       |}
       |
       |////////////////////////////////////////////////////////////////////////////////////////////////////
       |// 16 bit operations
       |//
      0|int clip16(int x) => (x & _MASK_16);
       |
       |/// Packs a 16 bit integer into a byte buffer. The [out] parameter can be an [Uint8List] or a
       |/// [ByteData] if you will run it several times against the same buffer and want faster execution.
      0|void pack16(int x, dynamic out, int offset, Endian endian) {
       |  assert((x >= 0) && (x <= _MASK_16));
      0|  if (out is! ByteData) {
      0|    out = ByteData.view(out.buffer, out.offsetInBytes, out.length);
       |  }
      0|  (out as ByteData).setUint16(offset, x, endian);
       |}
       |
       |/// Unpacks a 16 bit integer from a byte buffer. The [inp] parameter can be an [Uint8List] or a
       |/// [ByteData] if you will run it several times against the same buffer and want faster execution.
      0|int unpack16(dynamic inp, int offset, Endian endian) {
      0|  if (inp is! ByteData) {
      0|    inp = ByteData.view(
      0|        inp.buffer as ByteBuffer, inp.offsetInBytes as int, inp.length as int);
       |  }
      0|  return (inp as ByteData).getUint16(offset, endian);
       |}
       |
       |////////////////////////////////////////////////////////////////////////////////////////////////////
       |// 32 bit operations
       |//
      2|int clip32(int x) => (x & _MASK_32);
       |
      0|int csum32(int x, int y) => sum32(clip32(x), clip32(y));
      0|int sum32(int x, int y) {
       |  assert((x >= 0) && (x <= _MASK_32));
       |  assert((y >= 0) && (y <= _MASK_32));
      0|  return ((x + y) & _MASK_32);
       |}
       |
      0|int csub32(int x, int y) => sub32(clip32(x), clip32(y));
      0|int sub32(int x, int y) {
       |  assert((x >= 0) && (x <= _MASK_32));
       |  assert((y >= 0) && (y <= _MASK_32));
      0|  return ((x - y) & _MASK_32);
       |}
       |
      0|int cshiftl32(int x, int n) => shiftl32(clip32(x), n);
      1|int shiftl32(int x, int n) {
       |  assert((x >= 0) && (x <= _MASK_32));
      1|  n &= _MASK_5;
      3|  x &= _MASK32_HI_BITS[n];
      2|  return ((x << n) & _MASK_32);
       |}
       |
      0|int cshiftr32(int x, int n) => shiftr32(clip32(x), n);
      1|int shiftr32(int x, int n) {
       |  assert((x >= 0) && (x <= _MASK_32));
      1|  n &= _MASK_5;
      1|  return (x >> n);
       |}
       |
      0|int cneg32(int x) => neg32(clip32(x));
      0|int neg32(int x) {
       |  assert((x >= 0) && (x <= _MASK_32));
      0|  return (-x & _MASK_32);
       |}
       |
      0|int cnot32(int x) => not32(clip32(x));
      0|int not32(int x) {
       |  assert((x >= 0) && (x <= _MASK_32));
      0|  return (~x & _MASK_32);
       |}
       |
      0|int crotl32(int x, int n) => rotl32(clip32(x), n);
      0|int rotl32(int x, int n) {
       |  assert(n >= 0);
       |  assert((x >= 0) && (x <= _MASK_32));
      0|  n &= _MASK_5;
      0|  return shiftl32(x, n) | (x >> (32 - n));
       |}
       |
      0|int crotr32(int x, int n) => rotr32(clip32(x), n);
      1|int rotr32(int x, int n) {
       |  assert(n >= 0);
       |  assert((x >= 0) && (x <= _MASK_32));
      1|  n &= _MASK_5;
      4|  return (x >> n) | shiftl32(x, (32 - n));
       |}
       |
       |/// Packs a 32 bit integer into a byte buffer. The [out] parameter can be an [Uint8List] or a
       |/// [ByteData] if you will run it several times against the same buffer and want faster execution.
      1|void pack32(int x, dynamic out, int offset, Endian endian) {
       |  assert((x >= 0) && (x <= _MASK_32));
      1|  if (out is! ByteData) {
       |    out =
      4|        ByteData.view(out.buffer as ByteBuffer, out.offsetInBytes, out.length);
       |  }
      1|  (out as ByteData).setUint32(offset, x, endian);
       |}
       |
       |/// Unpacks a 32 bit integer from a byte buffer. The [inp] parameter can be an [Uint8List] or a
       |/// [ByteData] if you will run it several times against the same buffer and want faster execution.
      1|int unpack32(dynamic inp, int offset, Endian endian) {
      1|  if (inp is! ByteData) {
      4|    inp = ByteData.view(inp.buffer, inp.offsetInBytes, inp.length);
       |  }
      1|  return (inp as ByteData).getUint32(offset, endian);
       |}
       |
       |////////////////////////////////////////////////////////////////////////////////////////////////////
       |// 64 bit operations
       |//
       |class Register64 {
      0|  static final Register64 _maxValue = Register64(0xFFFFFFFF, 0xFFFFFFFF);
       |
       |  int _hi32;
       |  int _lo32;
       |
      1|  Register64([dynamic hiOrLo32OrY = 0, int lo32]) {
      1|    set(hiOrLo32OrY, lo32);
       |  }
       |
      2|  int get lo32 => _lo32;
      2|  int get hi32 => _hi32;
       |
      0|  @override
       |  bool operator ==(Object y) =>
      0|      y is Register64 ? (((_hi32 == y._hi32) && (_lo32 == y._lo32))) : false;
      0|  bool operator <(Register64 y) =>
      0|      ((_hi32 < y._hi32) || ((_hi32 == y._hi32) && (_lo32 < y._lo32)));
      0|  bool operator <=(Register64 y) => ((this < y) || (this == y));
      0|  bool operator >(Register64 y) =>
      0|      ((_hi32 > y._hi32) || ((_hi32 == y._hi32) && (_lo32 > y._lo32)));
      0|  bool operator >=(Register64 y) => ((this > y) || (this == y));
       |
      1|  void set(dynamic hiOrLo32OrY, [int lo32]) {
       |    if (lo32 == null) {
      1|      if (hiOrLo32OrY is Register64) {
      2|        _hi32 = hiOrLo32OrY._hi32;
      2|        _lo32 = hiOrLo32OrY._lo32;
       |      } else {
       |        assert(hiOrLo32OrY <= _MASK_32);
      1|        _hi32 = 0;
      1|        _lo32 = hiOrLo32OrY;
       |      }
       |    } else {
       |      assert(hiOrLo32OrY <= _MASK_32);
       |      assert(lo32 <= _MASK_32);
      0|      _hi32 = hiOrLo32OrY;
      0|      _lo32 = lo32;
       |    }
       |  }
       |
      1|  void sum(dynamic y) {
      1|    if (y is int) {
      1|      y &= _MASK_32;
      2|      int slo32 = (_lo32 + y);
      2|      _lo32 = (slo32 & _MASK_32);
      2|      if (slo32 != _lo32) {
      0|        _hi32++;
      0|        _hi32 &= _MASK_32;
       |      }
       |    } else {
      0|      int slo32 = (_lo32 + y._lo32);
      0|      _lo32 = (slo32 & _MASK_32);
      0|      var carry = ((slo32 != _lo32) ? 1 : 0);
      0|      _hi32 = (((_hi32 + y._hi32 + carry) as int) & _MASK_32);
       |    }
       |  }
       |
      0|  void sumReg(Register64 y) {
      0|    var slo32 = (_lo32 + y._lo32);
      0|    _lo32 = (slo32 & _MASK_32);
      0|    var carry = ((slo32 != _lo32) ? 1 : 0);
      0|    _hi32 = ((_hi32 + y._hi32 + carry) & _MASK_32);
       |  }
       |
      0|  void sub(dynamic y) {
       |    // TODO: optimize sub() ???
      0|    sum(Register64(y)..neg());
       |  }
       |
      0|  void mul(dynamic y) {
      0|    if (y is int) {
      0|      final lo32 = _lo32 * y;
      0|      final carry = (lo32 ~/
       |          0x100000000); // TODO: use shift right when bug 17715 is fixed
      0|      final hi32 = clip32(_hi32 * y) + carry;
       |
      0|      _hi32 = clip32(hi32);
      0|      _lo32 = clip32(lo32);
       |    } else {
      0|      final lo32 = _lo32 * y._lo32;
      0|      final carry = (lo32 ~/
       |          0x100000000); // TODO: use shift right when bug 17715 is fixed
      0|      final hi32 = clip32(_hi32 * y._lo32) + clip32(_lo32 * y._hi32) + carry;
       |
      0|      _hi32 = clip32(hi32);
      0|      _lo32 = clip32(lo32);
       |    }
       |  }
       |
      0|  void neg() {
      0|    not();
      0|    sum(1);
       |  }
       |
      0|  void not() {
      0|    _hi32 = (~_hi32 & _MASK_32);
      0|    _lo32 = (~_lo32 & _MASK_32);
       |  }
       |
      0|  void and(Register64 y) {
      0|    _hi32 &= y._hi32;
      0|    _lo32 &= y._lo32;
       |  }
       |
      0|  void or(Register64 y) {
      0|    _hi32 |= y._hi32;
      0|    _lo32 |= y._lo32;
       |  }
       |
      0|  void xor(Register64 y) {
      0|    _hi32 ^= y._hi32;
      0|    _lo32 ^= y._lo32;
       |  }
       |
      1|  void shiftl(int n) {
      1|    n &= _MASK_6;
      1|    if (n == 0) {
       |      // do nothing
      1|    } else if (n >= 32) {
      0|      _hi32 = shiftl32(_lo32, (n - 32));
      0|      _lo32 = 0;
       |    } else {
      3|      _hi32 = shiftl32(_hi32, n);
      5|      _hi32 |= _lo32 >> (32 - n);
      3|      _lo32 = shiftl32(_lo32, n);
       |    }
       |  }
       |
      0|  void shiftr(int n) {
      0|    n &= _MASK_6;
      0|    if (n == 0) {
       |      // do nothing
      0|    } else if (n >= 32) {
      0|      _lo32 = _hi32 >> (n - 32);
      0|      _hi32 = 0;
       |    } else {
      0|      _lo32 = _lo32 >> n;
      0|      _lo32 |= shiftl32(_hi32, 32 - n);
      0|      _hi32 = _hi32 >> n;
       |    }
       |  }
       |
      0|  void rotl(int n) {
      0|    n &= _MASK_6;
      0|    if (n == 0) {
       |      // do nothing
       |    } else {
      0|      if (n >= 32) {
      0|        var swap = _hi32;
      0|        _hi32 = _lo32;
      0|        _lo32 = swap;
      0|        n -= 32;
       |      }
       |
      0|      if (n == 0) {
       |        // do nothing
       |      } else {
      0|        var hi32 = _hi32;
      0|        _hi32 = shiftl32(_hi32, n);
      0|        _hi32 |= _lo32 >> (32 - n);
      0|        _lo32 = shiftl32(_lo32, n);
      0|        _lo32 |= hi32 >> (32 - n);
       |      }
       |    }
       |  }
       |
      0|  void rotr(int n) {
      0|    n &= _MASK_6;
      0|    if (n == 0) {
       |      // do nothing
       |    } else {
      0|      if (n >= 32) {
      0|        var swap = _hi32;
      0|        _hi32 = _lo32;
      0|        _lo32 = swap;
      0|        n -= 32;
       |      }
       |
      0|      if (n == 0) {
       |        // do nothing
       |      } else {
      0|        var hi32 = _hi32;
      0|        _hi32 = _hi32 >> n;
      0|        _hi32 |= shiftl32(_lo32, (32 - n));
      0|        _lo32 = _lo32 >> n;
      0|        _lo32 |= shiftl32(hi32, (32 - n));
       |      }
       |    }
       |  }
       |
       |  /// Packs a 64 bit integer into a byte buffer. The [out] parameter can be an [Uint8List] or a
       |  /// [ByteData] if you will run it several times against the same buffer and want faster execution.
      0|  void pack(dynamic out, int offset, Endian endian) {
       |    switch (endian) {
      0|      case Endian.big:
      0|        pack32(hi32, out, offset, endian);
      0|        pack32(lo32, out, offset + 4, endian);
       |        break;
       |
      0|      case Endian.little:
      0|        pack32(hi32, out, offset + 4, endian);
      0|        pack32(lo32, out, offset, endian);
       |        break;
       |
       |      default:
      0|        throw UnsupportedError('Invalid endianness: $endian');
       |    }
       |  }
       |
       |  /// Unpacks a 64 bit integer from a byte buffer. The [inp] parameter can be an [Uint8List] or a
       |  /// [ByteData] if you will run it several times against the same buffer and want faster execution.
      0|  void unpack(dynamic inp, int offset, Endian endian) {
       |    switch (endian) {
      0|      case Endian.big:
      0|        _hi32 = unpack32(inp, offset, endian);
      0|        _lo32 = unpack32(inp, offset + 4, endian);
       |        break;
       |
      0|      case Endian.little:
      0|        _hi32 = unpack32(inp, offset + 4, endian);
      0|        _lo32 = unpack32(inp, offset, endian);
       |        break;
       |
       |      default:
      0|        throw UnsupportedError('Invalid endianness: $endian');
       |    }
       |  }
       |
      0|  @override
       |  String toString() {
      0|    var sb = StringBuffer();
      0|    _padWrite(sb, _hi32);
      0|    _padWrite(sb, _lo32);
      0|    return sb.toString();
       |  }
       |
      0|  void _padWrite(StringBuffer sb, int value) {
      0|    var str = value.toRadixString(16);
      0|    for (var i = (8 - str.length); i > 0; i--) {
      0|      sb.write('0');
       |    }
      0|    sb.write(str);
       |  }
       |
      0|  @override
       |  // TODO: implement hashCode
      0|  int get hashCode => super.hashCode;
       |}
       |
       |class Register64List {
       |  final List<Register64> _list;
       |
      0|  Register64List.from(List<List<int>> values)
      0|      : _list = List<Register64>.generate(
      0|            values.length, (i) => Register64(values[i][0], values[i][1]));
       |
      0|  Register64List(int length)
      0|      : _list = List<Register64>.generate(length, (_) => Register64());
       |
      0|  int get length => _list.length;
       |
      0|  Register64 operator [](int index) => _list[index];
       |
      0|  void fillRange(int start, int end, dynamic hiOrLo32OrY, [int lo32]) {
      0|    for (var i = start; i < end; i++) {
      0|      _list[i].set(hiOrLo32OrY, lo32);
       |    }
       |  }
       |
      0|  void setRange(int start, int end, Register64List list, [int skipCount = 0]) {
      0|    var length = end - start;
      0|    for (var i = 0; i < length; i++) {
      0|      _list[start + i].set(list[skipCount + i]);
       |    }
       |  }
       |
      0|  @override
       |  String toString() {
      0|    var sb = StringBuffer('(');
      0|    for (var i = 0; i < _list.length; i++) {
      0|      if (i > 0) {
      0|        sb.write(', ');
       |      }
      0|      sb.write(_list[i].toString());
       |    }
      0|    sb.write(')');
      0|    return sb.toString();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/adapters/stream_cipher_as_block_cipher.dart
       |// See file LICENSE for more information.
       |
       |library impl.adapters.stream_cipher_as_block_cipher;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/impl/base_block_cipher.dart';
       |
       |/// An adapter to convert an [StreamCipher] to a [BlockCipher]
       |class StreamCipherAsBlockCipher extends BaseBlockCipher {
       |  final StreamCipher streamCipher;
       |  @override
       |  final int blockSize;
       |
       |  /// Create a [BlockCipher] from [streamCipher] simulating the given [blockSize]
      0|  StreamCipherAsBlockCipher(this.blockSize, this.streamCipher);
       |
      0|  @override
      0|  String get algorithmName => streamCipher.algorithmName;
       |
      0|  @override
       |  void reset() {
      0|    streamCipher.reset();
       |  }
       |
      0|  @override
       |  void init(bool forEncryption, CipherParameters params) {
      0|    streamCipher.init(forEncryption, params);
       |  }
       |
      0|  @override
       |  int processBlock(Uint8List inp, int inpOff, Uint8List out, int outOff) {
      0|    streamCipher.processBytes(inp, inpOff, blockSize, out, outOff);
      0|    return blockSize;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/ecc_base.dart
       |// See file LICENSE for more information.
       |
       |library impl.ecc.ecc_base;
       |//TODO I think this stuff might be moved to src/impl
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/ecc/api.dart';
       |import 'package:pointycastle/src/utils.dart' as utils;
       |
       |/// Implementation of [ECDomainParameters]
       |class ECDomainParametersImpl implements ECDomainParameters {
       |  @override
       |  final String domainName;
       |  @override
       |  final ECCurve curve;
       |  @override
       |  final List<int> seed;
       |  @override
       |  final ECPoint G;
       |  @override
       |  final BigInt n;
       |  BigInt _h;
       |
      0|  ECDomainParametersImpl(this.domainName, this.curve, this.G, this.n,
       |      [this._h, this.seed]) {
      0|    _h ??= BigInt.one;
       |  }
       |
      0|  BigInt get h => _h;
       |}
       |
       |/// Base implementation for [ECFieldElement]
       |abstract class ECFieldElementBase implements ECFieldElement {
       |  @override
       |  BigInt toBigInteger();
       |  @override
       |  String get fieldName;
       |  @override
       |  int get fieldSize;
      0|  @override
      0|  int get byteLength => ((fieldSize + 7) ~/ 8);
       |
       |  @override
       |  ECFieldElementBase operator +(covariant ECFieldElementBase b);
       |  @override
       |  ECFieldElementBase operator -(covariant ECFieldElementBase b);
       |  @override
       |  ECFieldElementBase operator *(covariant ECFieldElementBase b);
       |  @override
       |  ECFieldElementBase operator /(covariant ECFieldElementBase b);
       |  @override
       |  ECFieldElementBase operator -();
       |  @override
       |  ECFieldElementBase invert();
       |  @override
       |  ECFieldElementBase square();
       |  @override
       |  ECFieldElementBase sqrt();
      0|  @override
      0|  String toString() => toBigInteger().toString();
       |}
       |
       |/// Base implementation for [ECPoint]
       |abstract class ECPointBase implements ECPoint {
       |  @override
       |  final ECCurveBase curve;
       |  @override
       |  final ECFieldElementBase x;
       |  @override
       |  final ECFieldElementBase y;
       |  @override
       |  final bool isCompressed;
       |  final ECMultiplier _multiplier;
       |
       |  PreCompInfo _preCompInfo;
       |
      0|  ECPointBase(this.curve, this.x, this.y, this.isCompressed,
       |      [this._multiplier = _fpNafMultiplier]);
      0|  @override
      0|  bool get isInfinity => (x == null && y == null);
       |
      0|  set preCompInfo(PreCompInfo preCompInfo) {
      0|    _preCompInfo = preCompInfo;
       |  }
       |
      0|  @override
       |  bool operator ==(other) {
      0|    if (other is ECPointBase) {
      0|      if (isInfinity) {
      0|        return other.isInfinity;
       |      }
      0|      return x == other.x && y == other.y;
       |    }
       |    return false;
       |  }
       |
      0|  @override
      0|  String toString() => '($x,$y)';
      0|  @override
       |  int get hashCode {
      0|    if (isInfinity) {
       |      return 0;
       |    }
      0|    return x.hashCode ^ y.hashCode;
       |  }
       |
       |  @override
       |  Uint8List getEncoded([bool compressed = true]);
       |  @override
       |  ECPointBase operator +(covariant ECPointBase b);
       |  @override
       |  ECPointBase operator -(covariant ECPointBase b);
       |  @override
       |  ECPointBase operator -();
       |  @override
       |  ECPointBase twice();
       |
       |  /// Multiplies this <code>ECPoint</code> by the given number.
       |  /// @param k The multiplicator.
       |  /// @return <code>k * this</code>.
      0|  @override
       |  ECPointBase operator *(BigInt k) {
      0|    if (k.sign < 0) {
      0|      throw ArgumentError('The multiplicator cannot be negative');
       |    }
       |
      0|    if (isInfinity) {
       |      return this;
       |    }
       |
      0|    if (k.sign == 0) {
      0|      return curve.infinity;
       |    }
       |
      0|    return _multiplier(this, k, _preCompInfo);
       |  }
       |}
       |
       |/// Base implementation for [ECCurve]
       |abstract class ECCurveBase implements ECCurve {
       |  ECFieldElementBase _a;
       |  ECFieldElementBase _b;
       |
      0|  ECCurveBase(BigInt a, BigInt b) {
      0|    _a = fromBigInteger(a);
      0|    _b = fromBigInteger(b);
       |  }
      0|  @override
      0|  ECFieldElementBase get a => _a;
      0|  @override
      0|  ECFieldElementBase get b => _b;
       |  @override
       |  int get fieldSize;
       |  @override
       |  ECPointBase get infinity;
       |  @override
       |  ECFieldElementBase fromBigInteger(BigInt x);
       |  @override
       |  ECPointBase createPoint(BigInt x, BigInt y, [bool withCompression = false]);
       |  @override
       |  ECPointBase decompressPoint(int yTilde, BigInt x1);
       |
       |  /// Decode a point on this curve from its ASN.1 encoding. The different
       |  /// encodings are taken account of, including point compression for
       |  /// <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
       |  /// @return The decoded point.
      0|  @override
       |  ECPointBase decodePoint(List<int> encoded) {
       |    ECPointBase p;
      0|    var expectedLength = (fieldSize + 7) ~/ 8;
       |
      0|    switch (encoded[0]) {
      0|      case 0x00: // infinity
      0|        if (encoded.length != 1) {
      0|          throw ArgumentError('Incorrect length for infinity encoding');
       |        }
       |
      0|        p = infinity;
       |        break;
       |
      0|      case 0x02: // compressed
      0|      case 0x03: // compressed
      0|        if (encoded.length != (expectedLength + 1)) {
      0|          throw ArgumentError('Incorrect length for compressed encoding');
       |        }
       |
      0|        var yTilde = encoded[0] & 1;
      0|        var x1 = _fromArray(encoded, 1, expectedLength);
       |
      0|        p = decompressPoint(yTilde, x1);
       |        break;
       |
      0|      case 0x04: // uncompressed
      0|      case 0x06: // hybrid
      0|      case 0x07: // hybrid
      0|        if (encoded.length != (2 * expectedLength + 1)) {
      0|          throw ArgumentError(
       |              'Incorrect length for uncompressed/hybrid encoding');
       |        }
       |
      0|        var x1 = _fromArray(encoded, 1, expectedLength);
      0|        var y1 = _fromArray(encoded, 1 + expectedLength, expectedLength);
       |
      0|        p = createPoint(x1, y1, false);
       |        break;
       |
       |      default:
      0|        throw ArgumentError(
      0|            'Invalid point encoding 0x' + encoded[0].toRadixString(16));
       |    }
       |
       |    return p;
       |  }
       |
      0|  BigInt _fromArray(List<int> buf, int off, int length) {
      0|    return utils.decodeBigInt(buf.sublist(off, off + length));
       |  }
       |}
       |
       |/// Interface for classes storing precomputation data for multiplication algorithms.
       |abstract class PreCompInfo {}
       |
       |/// Interface for functions encapsulating a point multiplication algorithm for [ECPointBase]. Multiplies [p] by [k], i.e. [p] is
       |/// added [k] times to itself.
       |typedef ECMultiplier = ECPointBase Function(
       |    ECPointBase p, BigInt k, PreCompInfo preCompInfo);
       |
      0|bool _testBit(BigInt i, int n) {
      0|  return i & (BigInt.one << n) != BigInt.zero;
       |}
       |
       |/// Function implementing the NAF (Non-Adjacent Form) multiplication algorithm.
      0|ECPointBase _fpNafMultiplier(ECPointBase p, BigInt k, PreCompInfo preCompInfo) {
       |  // TODO Probably should try to add this
       |  // BigInt e = k.mod(n); // n == order of p
       |  var e = k;
      0|  var h = e * BigInt.from(3);
       |
      0|  var neg = -p;
       |  var R = p;
       |
      0|  for (var i = h.bitLength - 2; i > 0; --i) {
      0|    R = R.twice();
       |
      0|    var hBit = _testBit(h, i);
      0|    var eBit = _testBit(e, i);
       |
      0|    if (hBit != eBit) {
      0|      R += (hBit ? p : neg);
       |    }
       |  }
       |
       |  return R;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/signers/pss_signer.dart
       |// See file LICENSE for more information.
       |
       |library impl.signer.pss_signer;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/asymmetric/api.dart';
       |import 'package:pointycastle/asymmetric/rsa.dart';
       |import 'package:pointycastle/src/registry/registry.dart';
       |
       |import '../src/utils.dart';
       |
       |class PSSSigner implements Signer {
       |  /// Intended for internal use.
      0|  static final FactoryConfig factoryConfig =
       |      DynamicFactoryConfig.suffix(Signer, '/PSS', (_, Match match) {
       |    final digestName = match.group(1);
       |    return () => PSSSigner(
       |          RSAEngine(),
       |          Digest(digestName),
       |          Digest(digestName),
       |        );
       |  });
       |
       |  static const int TRAILER_IMPLICIT = 0xBC;
       |
       |  final Digest _contentDigest;
       |  final Digest _mgfDigest;
       |  final AsymmetricBlockCipher _cipher;
       |  final int _hLen;
       |  final int _mgfhLen;
       |  final int _trailer;
       |
       |  bool _sSet;
       |  int _sLen;
       |  Uint8List _salt;
       |  SecureRandom _random;
       |
       |  int _emBits;
       |  Uint8List _block;
       |  Uint8List _mDash;
       |
       |  bool _forSigning;
       |
      0|  PSSSigner(this._cipher, this._contentDigest, this._mgfDigest,
       |      {int trailer = TRAILER_IMPLICIT})
      0|      : _hLen = _contentDigest.digestSize,
      0|        _mgfhLen = _mgfDigest.digestSize,
       |        _trailer = trailer;
       |
      0|  @override
      0|  String get algorithmName => '${_mgfDigest.algorithmName}/PSS';
       |
      0|  @override
       |  void init(bool forSigning, CipherParameters params) {
      0|    _forSigning = forSigning;
       |
       |    AsymmetricKeyParameter akparams;
      0|    if (params is ParametersWithSaltConfiguration) {
      0|      akparams = params.parameters;
      0|      _random = params.random;
      0|      _sSet = false;
      0|      _sLen = params.saltLength;
      0|      _salt = Uint8List(_sLen);
      0|    } else if (params is ParametersWithSalt) {
      0|      akparams = params.parameters;
      0|      _sSet = true;
      0|      _salt = params.salt;
      0|      _sLen = _salt?.length ?? 0;
       |    } else {
      0|      throw ArgumentError(
      0|          'Unsupported parameters type ${params.runtimeType}: should be ParametersWithSaltConfiguration or ParametersWithSalt');
       |    }
       |
      0|    var k = akparams.key as RSAAsymmetricKey;
       |
      0|    if (forSigning && (k is! RSAPrivateKey)) {
      0|      throw ArgumentError('Signing requires private key');
       |    }
       |
      0|    if (!forSigning && (k is! RSAPublicKey)) {
      0|      throw ArgumentError('Verification requires public key');
       |    }
       |
      0|    if (!forSigning && !_sSet) {
      0|      throw ArgumentError('Verification requires salt');
       |    }
       |
      0|    _emBits = k.modulus.bitLength - 1;
       |
      0|    if (_emBits < (8 * _hLen + 8 * _sLen + 9)) {
      0|      throw ArgumentError('Key too small for specified hash and salt lengths');
       |    }
       |
      0|    _mDash = Uint8List(8 + _sLen + _contentDigest.digestSize);
       |
      0|    _cipher.init(forSigning, akparams);
       |
      0|    _block = Uint8List((_emBits + 7) ~/ 8);
       |
      0|    reset();
       |  }
       |
       |  /// Clear possibly sensitive data.
      0|  void _clearBlock(Uint8List block) {
      0|    for (var i = 0; i != block.length; i++) {
      0|      block[i] = 0;
       |    }
       |  }
       |
      0|  @override
       |  void reset() {
      0|    _contentDigest.reset();
       |  }
       |
      0|  @override
       |  PSSSignature generateSignature(Uint8List message) {
      0|    if (!_forSigning) {
      0|      throw StateError('Signer was not initialised for signature generation');
       |    }
       |
      0|    _contentDigest.reset();
      0|    _contentDigest.update(message, 0, message.length);
      0|    _contentDigest.doFinal(_mDash, _mDash.length - _hLen - _sLen);
       |
      0|    if (_sLen != 0) {
      0|      if (!_sSet) {
      0|        _salt = _random.nextBytes(_sLen);
       |      }
       |
      0|      arrayCopy(_salt, 0, _mDash, _mDash.length - _sLen, _sLen);
       |    }
       |
      0|    var h = Uint8List(_hLen);
       |
      0|    _contentDigest.update(_mDash, 0, _mDash.length);
       |
      0|    _contentDigest.doFinal(h, 0);
       |
      0|    _block[_block.length - _sLen - 1 - _hLen - 1] = 0x01;
      0|    arrayCopy(_salt, 0, _block, _block.length - _sLen - _hLen - 1, _sLen);
       |
       |    var dbMask =
      0|        _maskGeneratorFunction1(h, 0, h.length, _block.length - _hLen - 1);
      0|    for (var i = 0; i != dbMask.length; i++) {
      0|      _block[i] ^= dbMask[i];
       |    }
       |
      0|    arrayCopy(h, 0, _block, _block.length - _hLen - 1, _hLen);
       |
      0|    var firstByteMask = 0xff >> ((_block.length * 8) - _emBits);
       |
      0|    _block[0] &= firstByteMask;
      0|    _block[_block.length - 1] = _trailer;
       |
      0|    var b = _cipher.process(_block);
       |
      0|    _clearBlock(_block);
       |
      0|    return PSSSignature(b);
       |  }
       |
      0|  @override
       |  bool verifySignature(Uint8List message, covariant PSSSignature signature) {
      0|    if (_forSigning) {
      0|      throw StateError('Signer was not initialised for signature verification');
       |    }
       |
      0|    _contentDigest.reset();
      0|    _contentDigest.update(message, 0, message.length);
      0|    _contentDigest.doFinal(_mDash, _mDash.length - _hLen - _sLen);
       |
      0|    var b = _cipher.process(signature.bytes);
      0|    _block.fillRange(0, _block.length - b.length, 0);
      0|    arrayCopy(b, 0, _block, _block.length - b.length, b.length);
       |
      0|    var firstByteMask = 0xFF >> ((_block.length * 8) - _emBits);
       |
      0|    if (_block[0] != (_block[0] & firstByteMask) ||
      0|        _block[_block.length - 1] != _trailer) {
      0|      _clearBlock(_block);
       |      return false;
       |    }
       |
      0|    var dbMask = _maskGeneratorFunction1(
      0|        _block, _block.length - _hLen - 1, _hLen, _block.length - _hLen - 1);
       |
      0|    for (var i = 0; i != dbMask.length; i++) {
      0|      _block[i] ^= dbMask[i];
       |    }
       |
      0|    _block[0] &= firstByteMask;
       |
      0|    for (var i = 0; i != _block.length - _hLen - _sLen - 2; i++) {
      0|      if (_block[i] != 0) {
      0|        _clearBlock(_block);
       |        return false;
       |      }
       |    }
       |
      0|    if (_block[_block.length - _hLen - _sLen - 2] != 0x01) {
      0|      _clearBlock(_block);
       |      return false;
       |    }
       |
      0|    if (_sSet) {
      0|      arrayCopy(_salt, 0, _mDash, _mDash.length - _sLen, _sLen);
       |    } else {
      0|      arrayCopy(_block, _block.length - _sLen - _hLen - 1, _mDash,
      0|          _mDash.length - _sLen, _sLen);
       |    }
       |
      0|    _contentDigest.update(_mDash, 0, _mDash.length);
      0|    _contentDigest.doFinal(_mDash, _mDash.length - _hLen);
       |
      0|    for (var i = _block.length - _hLen - 1, j = _mDash.length - _hLen;
      0|        j != _mDash.length;
      0|        i++, j++) {
      0|      if ((_block[i] ^ _mDash[j]) != 0) {
      0|        _clearBlock(_mDash);
      0|        _clearBlock(_block);
       |        return false;
       |      }
       |    }
       |
      0|    _clearBlock(_mDash);
      0|    _clearBlock(_block);
       |    return true;
       |  }
       |
       |  /// Convert int to octet string.
      0|  void _intToOSP(int i, Uint8List sp) {
      0|    sp[0] = i >> 24;
      0|    sp[1] = i >> 16;
      0|    sp[2] = i >> 8;
      0|    sp[3] = i >> 0;
       |  }
       |
      0|  Uint8List _maskGeneratorFunction1(
       |      Uint8List Z, int zOff, int zLen, int length) {
      0|    var mask = Uint8List(length);
      0|    var hashBuf = Uint8List(_mgfhLen);
      0|    var C = Uint8List(4);
       |    var counter = 0;
       |
      0|    _mgfDigest.reset();
       |
      0|    while (counter < (length ~/ _mgfhLen)) {
      0|      _intToOSP(counter, C);
       |
      0|      _mgfDigest.update(Z, zOff, zLen);
      0|      _mgfDigest.update(C, 0, C.length);
      0|      _mgfDigest.doFinal(hashBuf, 0);
       |
      0|      arrayCopy(hashBuf, 0, mask, counter * _mgfhLen, _mgfhLen);
      0|      counter++;
       |    }
       |
      0|    if ((counter * _mgfhLen) < length) {
      0|      _intToOSP(counter, C);
       |
      0|      _mgfDigest.update(Z, zOff, zLen);
      0|      _mgfDigest.update(C, 0, C.length);
      0|      _mgfDigest.doFinal(hashBuf, 0);
       |
      0|      arrayCopy(hashBuf, 0, mask, counter * _mgfhLen,
      0|          mask.length - (counter * _mgfhLen));
       |    }
       |
       |    return mask;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/stream/chacha20.dart
       |library impl.stream_cipher.chacha20;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/export.dart';
       |
       |import '../api.dart';
       |import '../src/impl/base_stream_cipher.dart';
       |import '../src/registry/registry.dart';
       |import '../src/ufixnum.dart';
       |
       |// ignore_for_file: omit_local_variable_types, prefer_single_quotes
       |// ignore_for_file: non_constant_identifier_names, directives_ordering
       |// ignore_for_file: prefer_typing_uninitialized_variables, camel_case_types
       |// ignore_for_file: annotate_overrides
       |
       |/// Implementation of Daniel J. Bernstein's ChaCha20 stream cipher, Snuffle 2005.
       |class ChaCha20Engine extends BaseStreamCipher {
       |  // ignore: non_constant_identifier_names
      0|  static final FactoryConfig factoryConfig = DynamicFactoryConfig.prefix(
       |      StreamCipher,
       |      'ChaCha20/',
       |      (_, final Match match) => () {
       |            var rounds = int.parse(match.group(1));
       |            return ChaCha20Engine.fromRounds(rounds);
       |          });
       |
       |  static const STATE_SIZE = 16;
       |
       |  int rounds = 20;
       |
      0|  static final _sigma = Uint8List.fromList([
       |    101,
       |    120,
       |    112,
       |    97,
       |    110,
       |    100,
       |    32,
       |    51,
       |    50,
       |    45,
       |    98,
       |    121,
       |    116,
       |    101,
       |    32,
       |    107
       |  ]);
      0|  static final _tau = Uint8List.fromList([
       |    101,
       |    120,
       |    112,
       |    97,
       |    110,
       |    100,
       |    32,
       |    49,
       |    54,
       |    45,
       |    98,
       |    121,
       |    116,
       |    101,
       |    32,
       |    107
       |  ]);
       |
       |  Uint8List _workingKey;
       |  Uint8List _workingIV;
       |
       |  final _state = List<int>(STATE_SIZE);
       |  final _buffer = List<int>(STATE_SIZE);
       |
       |  final _keyStream = Uint8List(STATE_SIZE * 4);
       |  var _keyStreamOffset = 0;
       |
       |  var _initialised = false;
       |
      0|  @override
      0|  String get algorithmName => 'ChaCha20/$rounds';
       |
      0|  ChaCha20Engine() {
      0|    rounds = 20;
       |  }
       |
      0|  ChaCha20Engine.fromRounds(this.rounds);
       |
      0|  @override
       |  void reset() {
      0|    if (_workingKey != null) {
      0|      _setKey(_workingKey, _workingIV);
       |    }
       |  }
       |
      0|  @override
       |  void init(
       |      bool forEncryption, covariant ParametersWithIV<KeyParameter> params) {
      0|    var uparams = params.parameters;
      0|    var iv = params.iv;
      0|    if (iv == null || iv.length != 8) {
      0|      throw ArgumentError('ChaCha20 requires exactly 8 bytes of IV');
       |    }
       |
      0|    _workingIV = iv;
      0|    _workingKey = uparams.key;
       |
      0|    _setKey(_workingKey, _workingIV);
       |  }
       |
      0|  @override
       |  int returnByte(int inp) {
      0|    if (_keyStreamOffset == 0) {
      0|      generateKeyStream(_keyStream);
       |
      0|      if (++_state[12] == 0) {
      0|        ++_state[13];
       |      }
       |    }
       |
      0|    var out = clip8(_keyStream[_keyStreamOffset] ^ inp);
      0|    _keyStreamOffset = (_keyStreamOffset + 1) & 63;
       |
       |    return out;
       |  }
       |
      0|  @override
       |  void processBytes(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      0|    if (!_initialised) {
      0|      throw StateError('ChaCha20 not initialized: please call init() first');
       |    }
       |
      0|    if ((inpOff + len) > inp.length) {
      0|      throw ArgumentError(
       |          'Input buffer too short or requested length too long');
       |    }
       |
      0|    if ((outOff + len) > out.length) {
      0|      throw ArgumentError(
       |          'Output buffer too short or requested length too long');
       |    }
       |
      0|    for (var i = 0; i < len; i++) {
      0|      if (_keyStreamOffset == 0) {
      0|        generateKeyStream(_keyStream);
       |
      0|        if (++_state[12] == 0) {
      0|          ++_state[13];
       |        }
       |      }
       |
      0|      out[i + outOff] = clip8(_keyStream[_keyStreamOffset] ^ inp[i + inpOff]);
      0|      _keyStreamOffset = (_keyStreamOffset + 1) & 63;
       |    }
       |  }
       |
      0|  void _setKey(Uint8List keyBytes, Uint8List ivBytes) {
      0|    _workingKey = keyBytes;
      0|    _workingIV = ivBytes;
       |
      0|    _keyStreamOffset = 0;
       |    var offset = 0;
       |    Uint8List constants;
       |
       |    // Key
      0|    _state[4] = unpack32(_workingKey, 0, Endian.little);
      0|    _state[5] = unpack32(_workingKey, 4, Endian.little);
      0|    _state[6] = unpack32(_workingKey, 8, Endian.little);
      0|    _state[7] = unpack32(_workingKey, 12, Endian.little);
       |
      0|    if (_workingKey.length == 32) {
      0|      constants = _sigma;
       |      offset = 16;
       |    } else {
      0|      constants = _tau;
       |    }
       |
      0|    _state[8] = unpack32(_workingKey, offset, Endian.little);
      0|    _state[9] = unpack32(_workingKey, offset + 4, Endian.little);
      0|    _state[10] = unpack32(_workingKey, offset + 8, Endian.little);
      0|    _state[11] = unpack32(_workingKey, offset + 12, Endian.little);
      0|    _state[0] = unpack32(constants, 0, Endian.little);
      0|    _state[1] = unpack32(constants, 4, Endian.little);
      0|    _state[2] = unpack32(constants, 8, Endian.little);
      0|    _state[3] = unpack32(constants, 12, Endian.little);
       |
       |    // IV
      0|    _state[14] = unpack32(_workingIV, 0, Endian.little);
      0|    _state[15] = unpack32(_workingIV, 4, Endian.little);
      0|    _state[12] = _state[13] = 0;
       |
      0|    _initialised = true;
       |  }
       |
      0|  void generateKeyStream(Uint8List output) {
      0|    _core(rounds, _state, _buffer);
       |    var outOff = 0;
      0|    for (var x in _buffer) {
      0|      pack32(x, output, outOff, Endian.little);
      0|      outOff += 4;
       |    }
       |  }
       |
       |  /// The ChaCha20 core function
      0|  void _core(int rounds, List<int> input, List<int> x) {
      0|    var x00 = input[0];
      0|    var x01 = input[1];
      0|    var x02 = input[2];
      0|    var x03 = input[3];
      0|    var x04 = input[4];
      0|    var x05 = input[5];
      0|    var x06 = input[6];
      0|    var x07 = input[7];
      0|    var x08 = input[8];
      0|    var x09 = input[9];
      0|    var x10 = input[10];
      0|    var x11 = input[11];
      0|    var x12 = input[12];
      0|    var x13 = input[13];
      0|    var x14 = input[14];
      0|    var x15 = input[15];
       |
      0|    for (var i = rounds; i > 0; i -= 2) {
      0|      x00 += x04;
      0|      x12 = crotl32(x12 ^ x00, 16);
      0|      x08 += x12;
      0|      x04 = crotl32(x04 ^ x08, 12);
      0|      x00 += x04;
      0|      x12 = crotl32(x12 ^ x00, 8);
      0|      x08 += x12;
      0|      x04 = crotl32(x04 ^ x08, 7);
      0|      x01 += x05;
      0|      x13 = crotl32(x13 ^ x01, 16);
      0|      x09 += x13;
      0|      x05 = crotl32(x05 ^ x09, 12);
      0|      x01 += x05;
      0|      x13 = crotl32(x13 ^ x01, 8);
      0|      x09 += x13;
      0|      x05 = crotl32(x05 ^ x09, 7);
      0|      x02 += x06;
      0|      x14 = crotl32(x14 ^ x02, 16);
      0|      x10 += x14;
      0|      x06 = crotl32(x06 ^ x10, 12);
      0|      x02 += x06;
      0|      x14 = crotl32(x14 ^ x02, 8);
      0|      x10 += x14;
      0|      x06 = crotl32(x06 ^ x10, 7);
      0|      x03 += x07;
      0|      x15 = crotl32(x15 ^ x03, 16);
      0|      x11 += x15;
      0|      x07 = crotl32(x07 ^ x11, 12);
      0|      x03 += x07;
      0|      x15 = crotl32(x15 ^ x03, 8);
      0|      x11 += x15;
      0|      x07 = crotl32(x07 ^ x11, 7);
      0|      x00 += x05;
      0|      x15 = crotl32(x15 ^ x00, 16);
      0|      x10 += x15;
      0|      x05 = crotl32(x05 ^ x10, 12);
      0|      x00 += x05;
      0|      x15 = crotl32(x15 ^ x00, 8);
      0|      x10 += x15;
      0|      x05 = crotl32(x05 ^ x10, 7);
      0|      x01 += x06;
      0|      x12 = crotl32(x12 ^ x01, 16);
      0|      x11 += x12;
      0|      x06 = crotl32(x06 ^ x11, 12);
      0|      x01 += x06;
      0|      x12 = crotl32(x12 ^ x01, 8);
      0|      x11 += x12;
      0|      x06 = crotl32(x06 ^ x11, 7);
      0|      x02 += x07;
      0|      x13 = crotl32(x13 ^ x02, 16);
      0|      x08 += x13;
      0|      x07 = crotl32(x07 ^ x08, 12);
      0|      x02 += x07;
      0|      x13 = crotl32(x13 ^ x02, 8);
      0|      x08 += x13;
      0|      x07 = crotl32(x07 ^ x08, 7);
      0|      x03 += x04;
      0|      x14 = crotl32(x14 ^ x03, 16);
      0|      x09 += x14;
      0|      x04 = crotl32(x04 ^ x09, 12);
      0|      x03 += x04;
      0|      x14 = crotl32(x14 ^ x03, 8);
      0|      x09 += x14;
      0|      x04 = crotl32(x04 ^ x09, 7);
       |    }
      0|    var xup = [
       |      x00,
       |      x01,
       |      x02,
       |      x03,
       |      x04,
       |      x05,
       |      x06,
       |      x07,
       |      x08,
       |      x09,
       |      x10,
       |      x11,
       |      x12,
       |      x13,
       |      x14,
       |      x15
       |    ];
      0|    for (var i = 0; i < STATE_SIZE; ++i) {
      0|      x[i] = csum32(xup[i], input[i]);
       |    }
       |  }
       |
       |  @override
       |  dynamic noSuchMethod(Invocation invocation);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/ec_standard_curve_constructor.dart
       |// See file LICENSE for more information.
       |
       |library src.registry.ec_standard_curve_constructor;
       |
       |import 'package:pointycastle/ecc/ecc_base.dart';
       |import 'package:pointycastle/ecc/ecc_fp.dart' as fp;
       |import 'package:pointycastle/src/utils.dart' as utils;
       |
      0|ECDomainParametersImpl constructFpStandardCurve(
       |    String name, Function constructor,
       |    {BigInt q, BigInt a, BigInt b, BigInt g, BigInt n, BigInt h, BigInt seed}) {
      0|  var curve = fp.ECCurve(q, a, b);
      0|  var seedBytes = (seed == null) ? null : utils.encodeBigInt(seed);
      0|  return constructor(
      0|      name, curve, curve.decodePoint(utils.encodeBigInt(g)), n, h, seedBytes);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/ecc/ecc_fp.dart
       |// See file LICENSE for more information.
       |
       |library impl.ecc.ecc_fp;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/ecc/ecc_base.dart'
       |    hide ECFieldElementBase, ECPointBase, ECCurveBase;
       |import 'package:pointycastle/ecc/ecc_base.dart' as ecc;
       |import 'package:pointycastle/src/utils.dart' as utils;
       |
       |/// return index of lowest 1-bit in x, x < 2^31 */
      0|int _lbit(BigInt x) {
       |  // Implementation borrowed from bignum.BigIntegerDartvm.
      0|  if (x == BigInt.zero) return -1;
       |  var r = 0;
      0|  while ((x & BigInt.from(0xffffffff)) == BigInt.zero) {
      0|    x >>= 32;
      0|    r += 32;
       |  }
      0|  if ((x & BigInt.from(0xffff)) == BigInt.zero) {
      0|    x >>= 16;
      0|    r += 16;
       |  }
      0|  if ((x & BigInt.from(0xff)) == BigInt.zero) {
      0|    x >>= 8;
      0|    r += 8;
       |  }
      0|  if ((x & BigInt.from(0xf)) == BigInt.zero) {
      0|    x >>= 4;
      0|    r += 4;
       |  }
      0|  if ((x & BigInt.from(3)) == BigInt.zero) {
      0|    x >>= 2;
      0|    r += 2;
       |  }
      0|  if ((x & BigInt.one) == BigInt.zero) ++r;
       |  return r;
       |}
       |
      0|bool _testBit(BigInt i, int n) {
      0|  return i & (BigInt.one << n) != BigInt.zero;
       |}
       |
       |class ECFieldElement extends ecc.ECFieldElementBase {
       |  final BigInt q;
       |  final BigInt x;
       |
      0|  ECFieldElement(this.q, this.x) {
      0|    if (x >= q) {
      0|      throw ArgumentError('Value x must be smaller than q');
       |    }
       |  }
       |
      0|  @override
       |  String get fieldName => 'Fp';
      0|  @override
      0|  int get fieldSize => q.bitLength;
       |
      0|  @override
      0|  BigInt toBigInteger() => x;
       |
      0|  @override
       |  ECFieldElement operator +(ECFieldElement b) =>
      0|      ECFieldElement(q, (x + b.toBigInteger()) % q);
      0|  @override
       |  ECFieldElement operator -(ECFieldElement b) =>
      0|      ECFieldElement(q, (x - b.toBigInteger()) % q);
      0|  @override
       |  ECFieldElement operator *(ECFieldElement b) =>
      0|      ECFieldElement(q, (x * b.toBigInteger()) % q);
      0|  @override
       |  ECFieldElement operator /(ECFieldElement b) =>
      0|      ECFieldElement(q, (x * b.toBigInteger().modInverse(q)) % q);
       |
      0|  @override
      0|  ECFieldElement operator -() => ECFieldElement(q, -x % q);
       |
      0|  @override
      0|  ECFieldElement invert() => ECFieldElement(q, x.modInverse(q));
      0|  @override
      0|  ECFieldElement square() => ECFieldElement(q, x.modPow(BigInt.two, q));
       |
       |  // D.1.4 91
       |  /// return a sqrt root - the routine verifies that the calculation
       |  /// returns the right value - if none exists it returns null.
      0|  @override
       |  ECFieldElement sqrt() {
      0|    if (!_testBit(q, 0)) {
      0|      throw UnimplementedError('Not implemented yet');
       |    }
       |
       |    // p % 4 == 3
      0|    if (_testBit(q, 1)) {
       |      // z = g^(u+1) + p, p = 4u + 3
      0|      var z = ECFieldElement(q, x.modPow((q >> 2) + BigInt.one, q));
      0|      return z.square() == this ? z : null;
       |    }
       |
       |    // p % 4 == 1
      0|    var qMinusOne = q - BigInt.one;
       |
      0|    var legendreExponent = qMinusOne >> 1;
      0|    if (x.modPow(legendreExponent, q) != BigInt.one) {
       |      return null;
       |    }
       |
      0|    var u = qMinusOne >> 2;
      0|    var k = (u << 1) + BigInt.one;
       |
      0|    var Q = x;
      0|    var fourQ = (Q >> 2) % q;
       |
       |    BigInt U, V;
      0|    var rand = SecureRandom();
       |    do {
       |      BigInt P;
       |      do {
      0|        P = rand.nextBigInteger(q.bitLength);
      0|      } while ((P >= q) ||
      0|          (((P * P) - fourQ).modPow(legendreExponent, q) != qMinusOne));
       |
      0|      var result = _lucasSequence(q, P, Q, k);
      0|      U = result[0];
      0|      V = result[1];
       |
      0|      if (((V * V) % q) == fourQ) {
       |        // Integer division by 2, mod q
      0|        if (_testBit(V, 0)) {
      0|          V = V + q;
       |        }
       |
      0|        V = (V >> 1);
       |
       |        //assert V.multiply(V).mod(q).equals(x);
       |
      0|        return ECFieldElement(q, V);
       |      }
      0|    } while ((U == BigInt.one) || (U == qMinusOne));
       |
       |    return null;
       |  }
       |
      0|  List<BigInt> _lucasSequence(BigInt p, BigInt P, BigInt Q, BigInt k) {
      0|    var n = k.bitLength;
      0|    var s = _lbit(k);
       |
      0|    var uh = BigInt.one;
      0|    var vl = BigInt.two;
       |    var vh = P;
      0|    var ql = BigInt.one;
      0|    var qh = BigInt.one;
       |
      0|    for (var j = n - 1; j >= (s + 1); j--) {
      0|      ql = (ql * qh) % p;
       |
      0|      if (_testBit(k, j)) {
      0|        qh = (ql * Q) % p;
      0|        uh = (uh * vh) % p;
      0|        vl = ((vh * vl) - (P * ql)) % p;
      0|        vh = ((vh * vh) - (qh << 1)) % p;
       |      } else {
       |        qh = ql;
      0|        uh = ((uh * vl) - ql) % p;
      0|        vh = ((vh * vl) - (P * ql)) % p;
      0|        vl = ((vl * vl) - (ql << 1)) % p;
       |      }
       |    }
       |
      0|    ql = (ql * qh) % p;
      0|    qh = (ql * Q) % p;
      0|    uh = ((uh * vl) - ql) % p;
      0|    vl = ((vh * vl) - (P * ql)) % p;
      0|    ql = (ql * qh) % p;
       |
      0|    for (var j = 1; j <= s; j++) {
      0|      uh = (uh * vl) % p;
      0|      vl = ((vl * vl) - (ql << 1)) % p;
      0|      ql = (ql * ql) % p;
       |    }
       |
      0|    return [uh, vl];
       |  }
       |
      0|  @override
       |  bool operator ==(other) {
      0|    if (other is ECFieldElement) {
      0|      return (q == other.q) && (x == other.x);
       |    }
       |    return false;
       |  }
       |
      0|  @override
      0|  int get hashCode => q.hashCode ^ x.hashCode;
       |}
       |
       |/// Elliptic curve points over Fp
       |class ECPoint extends ecc.ECPointBase {
       |  /// Create a point that encodes with or without point compresion.
       |  ///
       |  /// @param curve the curve to use
       |  /// @param x affine x co-ordinate
       |  /// @param y affine y co-ordinate
       |  /// @param withCompression if true encode with point compression
      0|  ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y,
       |      [bool withCompression = false])
      0|      : super(curve, x, y, withCompression, _wNafMultiplier) {
       |    if ((x != null && y == null) || (x == null && y != null)) {
      0|      throw ArgumentError('Exactly one of the field elements is null');
       |    }
       |  }
       |
       |  /// return the field element encoded with point compression. (S 4.3.6)
      0|  @override
       |  Uint8List getEncoded([bool compressed = true]) {
      0|    if (isInfinity) {
      0|      return Uint8List.fromList([1]);
       |    }
       |
      0|    var qLength = x.byteLength;
       |    if (compressed) {
       |      int pc;
       |
      0|      if (_testBit(y.toBigInteger(), 0)) {
       |        pc = 0x03;
       |      } else {
       |        pc = 0x02;
       |      }
       |
      0|      var X = _x9IntegerToBytes(x.toBigInteger(), qLength);
      0|      var po = Uint8List(X.length + 1);
       |
      0|      po[0] = pc.toInt();
      0|      po.setAll(1, X);
       |
       |      return po;
       |    } else {
      0|      var X = _x9IntegerToBytes(x.toBigInteger(), qLength);
      0|      var Y = _x9IntegerToBytes(y.toBigInteger(), qLength);
      0|      var po = Uint8List(X.length + Y.length + 1);
       |
      0|      po[0] = 0x04;
      0|      po.setAll(1, X);
      0|      po.setAll(X.length + 1, Y);
       |
       |      return po;
       |    }
       |  }
       |
       |  // B.3 pg 62
      0|  @override
       |  ECPoint operator +(ECPoint b) {
      0|    if (isInfinity) {
       |      return b;
       |    }
       |
      0|    if (b.isInfinity) {
       |      return this;
       |    }
       |
       |    // Check if b = this or b = -this
      0|    if (x == b.x) {
      0|      if (y == b.y) {
       |        // this = b, i.e. this must be doubled
      0|        return twice();
       |      }
       |
       |      // this = -b, i.e. the result is the point at infinity
      0|      return curve.infinity;
       |    }
       |
      0|    var gamma = (b.y - y) / (b.x - x);
       |
      0|    var x3 = (gamma.square() - x) - b.x;
      0|    var y3 = (gamma * (x - x3)) - y;
       |
      0|    return ECPoint(curve, x3, y3, isCompressed);
       |  }
       |
       |  // B.3 pg 62
      0|  @override
       |  ECPoint twice() {
      0|    if (isInfinity) {
       |      // Twice identity element (point at infinity) is identity
       |      return this;
       |    }
       |
      0|    if (y.toBigInteger() == 0) {
       |      // if y1 == 0, then (x1, y1) == (x1, -y1)
       |      // and hence this = -this and thus 2(x1, y1) == infinity
      0|      return curve.infinity;
       |    }
       |
      0|    var two = curve.fromBigInteger(BigInt.two);
      0|    var three = curve.fromBigInteger(BigInt.from(3));
      0|    var gamma = ((x.square() * three) + curve.a) / (y * two);
       |
      0|    var x3 = gamma.square() - (x * two);
      0|    var y3 = (gamma * (x - x3)) - y;
       |
      0|    return ECPoint(curve, x3, y3, isCompressed);
       |  }
       |
       |  // D.3.2 pg 102 (see Note:)
      0|  @override
       |  ECPoint operator -(ECPoint b) {
      0|    if (b.isInfinity) {
       |      return this;
       |    }
       |
       |    // Add -b
      0|    return this + (-b);
       |  }
       |
      0|  @override
       |  ECPoint operator -() {
      0|    return ECPoint(curve, x, -y, isCompressed);
       |  }
       |}
       |
       |/// Elliptic curve over Fp
       |class ECCurve extends ecc.ECCurveBase {
       |  final BigInt q;
       |  ECPoint _infinity;
       |
      0|  ECCurve(this.q, BigInt a, BigInt b) : super(a, b) {
      0|    _infinity = ECPoint(this, null, null);
       |  }
       |
      0|  @override
      0|  int get fieldSize => q.bitLength;
      0|  @override
      0|  ECPoint get infinity => _infinity;
       |
      0|  @override
      0|  ECFieldElement fromBigInteger(BigInt x) => ECFieldElement(q, x);
      0|  @override
       |  ECPoint createPoint(BigInt x, BigInt y, [bool withCompression = false]) =>
      0|      ECPoint(this, fromBigInteger(x), fromBigInteger(y), withCompression);
       |
      0|  @override
       |  ECPoint decompressPoint(int yTilde, BigInt x1) {
      0|    var x = fromBigInteger(x1);
      0|    var alpha = (x * ((x * x) + a)) + b;
      0|    var beta = alpha.sqrt();
       |
       |    //
       |    // if we can't find a sqrt we haven't got a point on the
       |    // curve - run!
       |    //
       |    if (beta == null) {
      0|      throw ArgumentError('Invalid point compression');
       |    }
       |
      0|    var betaValue = beta.toBigInteger();
      0|    var bit0 = _testBit(betaValue, 0) ? 1 : 0;
       |
      0|    if (bit0 != yTilde) {
       |      // Use the other root
      0|      beta = fromBigInteger(q - betaValue);
       |    }
       |
      0|    return ECPoint(this, x, beta, true);
       |  }
       |
      0|  @override
       |  bool operator ==(other) {
      0|    if (other is ECCurve) {
      0|      return q == other.q && a == other.a && b == other.b;
       |    }
       |    return false;
       |  }
       |
      0|  @override
      0|  int get hashCode => a.hashCode ^ b.hashCode ^ q.hashCode;
       |}
       |
       |/// Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
       |/// algorithm.
       |class _WNafPreCompInfo implements PreCompInfo {
       |  /// Array holding the precomputed [ECPoint]s used for the Window NAF multiplication.
       |  List<ECPoint> preComp;
       |
       |  /// Holds an [ECPoint] representing twice(this). Used for the Window NAF multiplication.
       |  ECPoint twiceP;
       |}
       |
       |/// Function implementing the WNAF (Window Non-Adjacent Form) multiplication algorithm. Multiplies [p]] by an integer [k] using
       |/// the Window NAF method.
      0|ecc.ECPointBase _wNafMultiplier(
       |    ecc.ECPointBase p, BigInt k, PreCompInfo preCompInfo) {
       |  // Ignore empty PreCompInfo or PreCompInfo of incorrect type
       |  _WNafPreCompInfo wnafPreCompInfo = preCompInfo;
      0|  if ((preCompInfo == null) && (preCompInfo is! _WNafPreCompInfo)) {
      0|    wnafPreCompInfo = _WNafPreCompInfo();
       |  }
       |
       |  // floor(log2(k))
      0|  var m = k.bitLength;
       |
       |  // width of the Window NAF
       |  int width;
       |
       |  // Required length of precomputation array
       |  int reqPreCompLen;
       |
       |  // Determine optimal width and corresponding length of precomputation
       |  // array based on literature values
      0|  if (m < 13) {
       |    width = 2;
       |    reqPreCompLen = 1;
       |  } else {
      0|    if (m < 41) {
       |      width = 3;
       |      reqPreCompLen = 2;
       |    } else {
      0|      if (m < 121) {
       |        width = 4;
       |        reqPreCompLen = 4;
       |      } else {
      0|        if (m < 337) {
       |          width = 5;
       |          reqPreCompLen = 8;
       |        } else {
      0|          if (m < 897) {
       |            width = 6;
       |            reqPreCompLen = 16;
       |          } else {
      0|            if (m < 2305) {
       |              width = 7;
       |              reqPreCompLen = 32;
       |            } else {
       |              width = 8;
       |              reqPreCompLen = 127;
       |            }
       |          }
       |        }
       |      }
       |    }
       |  }
       |
       |  // The length of the precomputation array
       |  var preCompLen = 1;
       |
      0|  var preComp = wnafPreCompInfo.preComp;
      0|  var twiceP = wnafPreCompInfo.twiceP;
       |
       |  // Check if the precomputed ECPoints already exist
       |  if (preComp == null) {
       |    // Precomputation must be performed from scratch, create an empty
       |    // precomputation array of desired length
      0|    preComp = List<ECPoint>.filled(1, p);
       |  } else {
       |    // Take the already precomputed ECPoints to start with
      0|    preCompLen = preComp.length;
       |  }
       |
      0|  twiceP ??= p.twice();
       |
      0|  if (preCompLen < reqPreCompLen) {
       |    // Precomputation array must be made bigger, copy existing preComp
       |    // array into the larger preComp array
       |    var oldPreComp = preComp;
      0|    preComp = List<ECPoint>(reqPreCompLen);
      0|    preComp.setAll(0, oldPreComp);
       |
      0|    for (var i = preCompLen; i < reqPreCompLen; i++) {
       |      // Compute the ECPoints for the precomputation array.
       |      // The values 1, 3, 5, ..., 2^(width-1)-1 times p are
       |      // computed
      0|      preComp[i] = twiceP + (preComp[i - 1]);
       |    }
       |  }
       |
       |  // Compute the Window NAF of the desired width
      0|  var wnaf = _windowNaf(width, k);
      0|  var l = wnaf.length;
       |
       |  // Apply the Window NAF to p using the precomputed ECPoint values.
      0|  var q = p.curve.infinity;
      0|  for (var i = l - 1; i >= 0; i--) {
      0|    q = q.twice();
       |
      0|    if (wnaf[i] != 0) {
      0|      if (wnaf[i] > 0) {
      0|        q += preComp[(wnaf[i] - 1) ~/ 2];
       |      } else {
       |        // wnaf[i] < 0
      0|        q -= preComp[(-wnaf[i] - 1) ~/ 2];
       |      }
       |    }
       |  }
       |
       |  // Set PreCompInfo in ECPoint, such that it is available for next
       |  // multiplication.
      0|  wnafPreCompInfo.preComp = preComp;
      0|  wnafPreCompInfo.twiceP = twiceP;
      0|  p.preCompInfo = wnafPreCompInfo;
       |  return q;
       |}
       |
       |/// Computes the Window NAF (non-adjacent Form) of an integer.
       |/// @param width The width <code>w</code> of the Window NAF. The width is
       |/// defined as the minimal number <code>w</code>, such that for any
       |/// <code>w</code> consecutive digits in the resulting representation, at
       |/// most one is non-zero.
       |/// @param k The integer of which the Window NAF is computed.
       |/// @return The Window NAF of the given width, such that the following holds:
       |/// <code>k = &sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
       |/// </code>, where the <code>k<sub>i</sub></code> denote the elements of the
       |/// returned <code>byte[]</code>.
      0|List<int> _windowNaf(int width, BigInt k) {
       |  // The window NAF is at most 1 element longer than the binary
       |  // representation of the integer k. byte can be used instead of short or
       |  // int unless the window width is larger than 8. For larger width use
       |  // short or int. However, a width of more than 8 is not efficient for
       |  // m = log2(q) smaller than 2305 Bits. Note: Values for m larger than
       |  // 1000 Bits are currently not used in practice.
      0|  var wnaf = List<int>(k.bitLength + 1);
       |
       |  // 2^width as short and BigInt
      0|  var pow2wB = (1 << width);
      0|  var pow2wBI = BigInt.from(pow2wB);
       |
       |  var i = 0;
       |
       |  // The actual length of the WNAF
       |  var length = 0;
       |
       |  // while k >= 1
      0|  while (k.sign > 0) {
       |    // if k is odd
      0|    if (_testBit(k, 0)) {
       |      // k mod 2^width
      0|      var remainder = k % pow2wBI;
       |
       |      // if remainder > 2^(width - 1) - 1
      0|      if (_testBit(remainder, width - 1)) {
      0|        wnaf[i] = remainder.toInt() - pow2wB;
       |      } else {
      0|        wnaf[i] = remainder.toInt();
       |      }
       |
       |      // convert to 'Java byte'
      0|      wnaf[i] %= 0x100;
      0|      if ((wnaf[i] & 0x80) != 0) {
      0|        wnaf[i] = wnaf[i] - 256;
       |      }
       |
       |      // wnaf[i] is now in [-2^(width-1), 2^(width-1)-1]
       |
      0|      k = k - BigInt.from(wnaf[i]);
       |      length = i;
       |    } else {
      0|      wnaf[i] = 0;
       |    }
       |
       |    // k = k/2
      0|    k = k >> 1;
      0|    i++;
       |  }
       |
      0|  length++;
       |
       |  // Reduce the WNAF array to its actual length
      0|  var wnafShort = List<int>(length);
      0|  wnafShort.setAll(0, wnaf.sublist(0, length));
       |  return wnafShort;
       |}
       |
      0|Uint8List _x9IntegerToBytes(BigInt s, int qLength) {
      0|  var bytes = Uint8List.fromList(utils.encodeBigInt(s));
       |
      0|  if (qLength < bytes.length) {
      0|    return bytes.sublist(bytes.length - qLength);
      0|  } else if (qLength > bytes.length) {
      0|    return Uint8List(qLength)..setAll(qLength - bytes.length, bytes);
       |  }
       |
       |  return bytes;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_aead_cipher.dart
       |library src.impl.base_aead_cipher;
       |
       |import 'dart:typed_data';
       |
       |import '../../api.dart';
       |
       |abstract class BaseAEADCipher implements AEADCipher {
      0|  Uint8List process(Uint8List data) {
      0|    var out = Uint8List(data.length);
      0|    processBytes(data, 0, data.length, out, 0);
       |    return out;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_asymmetric_block_cipher.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.base_asymmetric_block_cipher;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// Base implementation of [AsymmetricBlockCipher] which provides shared methods.
       |abstract class BaseAsymmetricBlockCipher implements AsymmetricBlockCipher {
      0|  @override
       |  Uint8List process(Uint8List data) {
      0|    var out = Uint8List(outputBlockSize);
      0|    var len = processBlock(data, 0, data.length, out, 0);
      0|    return out.sublist(0, len);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/secure_random_base.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.random.secure_random_base;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |import 'package:pointycastle/src/ufixnum.dart';
       |import 'package:pointycastle/src/utils.dart' as utils;
       |
       |/// An utility base implementation of [SecureRandom] so that only [nextUint8] method needs to be
       |/// implemented.
       |abstract class SecureRandomBase implements SecureRandom {
      0|  @override
       |  int nextUint16() {
      0|    var b0 = nextUint8();
      0|    var b1 = nextUint8();
      0|    return clip16((b1 << 8) | b0);
       |  }
       |
      0|  @override
       |  int nextUint32() {
      0|    var b0 = nextUint8();
      0|    var b1 = nextUint8();
      0|    var b2 = nextUint8();
      0|    var b3 = nextUint8();
      0|    return clip32((b3 << 24) | (b2 << 16) | (b1 << 8) | b0);
       |  }
       |
      1|  @override
       |  BigInt nextBigInteger(int bitLength) {
      2|    return utils.decodeBigInt(_randomBits(bitLength));
       |  }
       |
      1|  @override
       |  Uint8List nextBytes(int count) {
      1|    var bytes = Uint8List(count);
      2|    for (var i = 0; i < count; i++) {
      2|      bytes[i] = nextUint8();
       |    }
       |    return bytes;
       |  }
       |
      1|  List<int> _randomBits(int numBits) {
      1|    if (numBits < 0) {
      0|      throw ArgumentError('numBits must be non-negative');
       |    }
       |
      2|    var numBytes = (numBits + 7) ~/ 8; // avoid overflow
      1|    var randomBits = Uint8List(numBytes);
       |
       |    // Generate random bytes and mask out any excess bits
      1|    if (numBytes > 0) {
      2|      for (var i = 0; i < numBytes; i++) {
      2|        randomBits[i] = nextUint8();
       |      }
      2|      var excessBits = 8 * numBytes - numBits;
      5|      randomBits[0] &= (1 << (8 - excessBits)) - 1;
       |    }
       |    return randomBits;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_block_cipher.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.base_block_cipher;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// Base implementation of [BlockCipher] which provides shared methods.
       |abstract class BaseBlockCipher implements BlockCipher {
      0|  @override
       |  Uint8List process(Uint8List data) {
      0|    var out = Uint8List(blockSize);
      0|    var len = processBlock(data, 0, out, 0);
      0|    return out.sublist(0, len);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_padding.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.base_padding;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// Base implementation of [Padding] which provides shared methods.
       |abstract class BasePadding implements Padding {
      0|  @override
       |  Uint8List process(bool pad, Uint8List data) {
       |    if (pad) {
      0|      var out = Uint8List.fromList(data);
       |      return out;
       |    } else {
      0|      var len = padCount(data);
      0|      return Uint8List.fromList(data.sublist(0, len));
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_mac.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.base_mac;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// Base implementation of [Mac] which provides shared methods.
       |abstract class BaseMac implements Mac {
      0|  @override
       |  Uint8List process(Uint8List data) {
      0|    update(data, 0, data.length);
      0|    var out = Uint8List(macSize);
      0|    var len = doFinal(out, 0);
      0|    return out.sublist(0, len);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_key_derivator.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.base_key_derivator;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// Base implementation of [KeyDerivator] which provides shared methods.
       |abstract class BaseKeyDerivator implements KeyDerivator {
      0|  @override
       |  Uint8List process(Uint8List data) {
      0|    var out = Uint8List(keySize);
      0|    var len = deriveKey(data, 0, out, 0);
      0|    return out.sublist(0, len);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/md4_family_digest.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.digests.md4_family_digest;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/src/ufixnum.dart';
       |import 'package:pointycastle/src/impl/base_digest.dart';
       |
       |/// Base implementation of MD4 family style digest
       |abstract class MD4FamilyDigest extends BaseDigest {
       |  final _byteCount = Register64(0);
       |
       |  final _wordBuffer = Uint8List(4);
       |  int _wordBufferOffset;
       |
       |  final Endian _endian;
       |  final int _packedStateSize;
       |
       |  final List<int> state;
       |
       |  final List<int> buffer;
       |  int bufferOffset;
       |
      1|  MD4FamilyDigest(this._endian, int stateSize, int bufferSize,
       |      [int packedStateSize])
       |      : _packedStateSize =
       |            (packedStateSize == null) ? stateSize : packedStateSize,
      1|        state = List<int>(stateSize),
      1|        buffer = List<int>(bufferSize) {
      1|    reset();
       |  }
       |
       |  /// Reset state of digest.
       |  void resetState();
       |
       |  /// Process a whole block of data in extender digest.
       |  void processBlock();
       |
      1|  @override
       |  void reset() {
      2|    _byteCount.set(0);
       |
      1|    _wordBufferOffset = 0;
      4|    _wordBuffer.fillRange(0, _wordBuffer.length, 0);
       |
      1|    bufferOffset = 0;
      4|    buffer.fillRange(0, buffer.length, 0);
       |
      1|    resetState();
       |  }
       |
      1|  @override
       |  void updateByte(int inp) {
      5|    _wordBuffer[_wordBufferOffset++] = clip8(inp);
      1|    _processWordIfBufferFull();
      2|    _byteCount.sum(1);
       |  }
       |
      1|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
       |    int nbytes;
       |
      1|    nbytes = _processUntilNextWord(inp, inpOff, len);
      1|    inpOff += nbytes;
      1|    len -= nbytes;
       |
      1|    nbytes = _processWholeWords(inp, inpOff, len);
      1|    inpOff += nbytes;
      1|    len -= nbytes;
       |
      1|    _processBytes(inp, inpOff, len);
       |  }
       |
      1|  @override
       |  int doFinal(Uint8List out, int outOff) {
      3|    var bitLength = Register64(_byteCount)..shiftl(3);
       |
      1|    _processPadding();
      1|    _processLength(bitLength);
      1|    _doProcessBlock();
       |
      1|    _packState(out, outOff);
       |
      1|    reset();
       |
      1|    return digestSize;
       |  }
       |
       |  /// Process a word (4 bytes) of data stored in [inp], starting at [inpOff].
      1|  void _processWord(Uint8List inp, int inpOff) {
      6|    buffer[bufferOffset++] = unpack32(inp, inpOff, _endian);
       |
      2|    if (bufferOffset == 16) {
      1|      _doProcessBlock();
       |    }
       |  }
       |
       |  /// Process a block of data and reset the [buffer].
      1|  void _doProcessBlock() {
      1|    processBlock();
       |
       |    // reset the offset and clean out the word buffer.
      1|    bufferOffset = 0;
      2|    buffer.fillRange(0, 16, 0);
       |  }
       |
       |  /// Process [len] bytes from [inp] starting at [inpOff]
      1|  void _processBytes(Uint8List inp, int inpOff, int len) {
      1|    while (len > 0) {
      2|      updateByte(inp[inpOff]);
       |
      1|      inpOff++;
      1|      len--;
       |    }
       |  }
       |
       |  /// Process data word by word until no more words can be extracted from [inp] and return the number of bytes processed.
      1|  int _processWholeWords(Uint8List inp, int inpOff, int len) {
       |    var processed = 0;
      3|    while (len > _wordBuffer.length) {
      1|      _processWord(inp, inpOff);
       |
      3|      inpOff += _wordBuffer.length;
      3|      len -= _wordBuffer.length;
      4|      _byteCount.sum(_wordBuffer.length);
      1|      processed += 4;
       |    }
       |    return processed;
       |  }
       |
       |  /// Process bytes from [inp] until the word buffer [_wordBuffer] is full and reset and return the number of bytes processed.
      1|  int _processUntilNextWord(Uint8List inp, int inpOff, int len) {
       |    var processed = 0;
       |
      2|    while ((_wordBufferOffset != 0) && (len > 0)) {
      0|      updateByte(inp[inpOff]);
       |
      0|      inpOff++;
      0|      len--;
      0|      processed++;
       |    }
       |
       |    return processed;
       |  }
       |
       |  // ignore: comment_references
       |  /// Process a word in [_xBuff] if it is already full and then reset it
      1|  void _processWordIfBufferFull() {
      4|    if (_wordBufferOffset == _wordBuffer.length) {
      2|      _processWord(_wordBuffer, 0);
      1|      _wordBufferOffset = 0;
       |    }
       |  }
       |
       |  /// Add final padding to the digest
      1|  void _processPadding() {
      1|    updateByte(128);
      2|    while (_wordBufferOffset != 0) {
      1|      updateByte(0);
       |    }
       |  }
       |
       |  // ignore: comment_references
       |  /// Called from [finish] so that extender can process the number of bits processed.
      1|  void _processLength(Register64 bitLength) {
      2|    if (bufferOffset > 14) {
      0|      _doProcessBlock();
       |    }
       |
      1|    switch (_endian) {
      1|      case Endian.little:
      0|        buffer[14] = bitLength.lo32;
      0|        buffer[15] = bitLength.hi32;
       |        break;
       |
      1|      case Endian.big:
      3|        buffer[14] = bitLength.hi32;
      3|        buffer[15] = bitLength.lo32;
       |        break;
       |
       |      default:
      0|        throw StateError('Invalid endianness: $_endian');
       |    }
       |  }
       |
      1|  void _packState(Uint8List out, int outOff) {
      3|    for (var i = 0; i < _packedStateSize; i++) {
      6|      pack32(state[i], out, (outOff + i * 4), _endian);
       |    }
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_digest.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.base_digest;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |/// Base implementation of [Digest] which provides shared methods.
       |abstract class BaseDigest implements Digest {
      0|  @override
       |  Uint8List process(Uint8List data) {
      0|    update(data, 0, data.length);
      0|    var out = Uint8List(digestSize);
      0|    var len = doFinal(out, 0);
      0|    return out.sublist(0, len);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/long_sha2_family_digest.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.digests.long_sha2_family_digest;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/src/ufixnum.dart';
       |import 'package:pointycastle/src/impl/base_digest.dart';
       |
       |/// Base implementation of SHA-2 family algorithms SHA-384 and SHA-512.
       |abstract class LongSHA2FamilyDigest extends BaseDigest {
       |  static const _BYTE_LENGTH = 128;
       |
      0|  static final _maxByteCount1 = Register64(0x1fffffff, 0xffffffff);
       |
       |  final h1 = Register64();
       |  final h2 = Register64();
       |  final h3 = Register64();
       |  final h4 = Register64();
       |  final h5 = Register64();
       |  final h6 = Register64();
       |  final h7 = Register64();
       |  final h8 = Register64();
       |
       |  final _wordBuffer = Uint8List(8);
       |  int _wordBufferOffset = 0;
       |
       |  final _w = Register64List(80);
       |  int _wOff = 0;
       |
       |  final _byteCount1 = Register64(); // TODO: convert to list
       |  final _byteCount2 = Register64();
       |
      0|  LongSHA2FamilyDigest() {
      0|    reset();
       |  }
       |
      0|  @override
       |  int get byteLength => _BYTE_LENGTH;
       |
      0|  @override
       |  void reset() {
      0|    _byteCount1.set(0);
      0|    _byteCount2.set(0);
       |
      0|    _wordBufferOffset = 0;
      0|    _wordBuffer.fillRange(0, _wordBuffer.length, 0);
       |
      0|    _wOff = 0;
      0|    _w.fillRange(0, _w.length, 0);
       |  }
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    _wordBuffer[_wordBufferOffset++] = inp;
       |
      0|    if (_wordBufferOffset == _wordBuffer.length) {
      0|      _processWord(_wordBuffer, 0);
      0|      _wordBufferOffset = 0;
       |    }
       |
      0|    _byteCount1.sum(1);
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
       |    // fill the current word
      0|    while ((_wordBufferOffset != 0) && (len > 0)) {
      0|      updateByte(inp[inpOff]);
       |
      0|      inpOff++;
      0|      len--;
       |    }
       |
       |    // process whole words.
      0|    while (len > _wordBuffer.length) {
      0|      _processWord(inp, inpOff);
       |
      0|      inpOff += _wordBuffer.length;
      0|      len -= _wordBuffer.length;
      0|      _byteCount1.sum(_wordBuffer.length);
       |    }
       |
       |    // load in the remainder.
      0|    while (len > 0) {
      0|      updateByte(inp[inpOff]);
       |
      0|      inpOff++;
      0|      len--;
       |    }
       |  }
       |
      0|  void finish() {
      0|    _adjustByteCounts();
       |
      0|    var lowBitLength = Register64(_byteCount1)..shiftl(3);
      0|    var hiBitLength = _byteCount2;
       |
       |    // add the pad bytes.
      0|    updateByte(128);
       |
      0|    while (_wordBufferOffset != 0) {
      0|      updateByte(0);
       |    }
       |
      0|    _processLength(lowBitLength, hiBitLength);
       |
      0|    _processBlock();
       |  }
       |
      0|  void _processWord(Uint8List inp, int inpOff) {
      0|    _w[_wOff++].unpack(inp, inpOff, Endian.big);
       |
      0|    if (_wOff == 16) {
      0|      _processBlock();
       |    }
       |  }
       |
       |  /// Adjust the byte counts so that byteCount2 represents the upper long (less 3 bits) word of the
       |  /// byte count.
      0|  void _adjustByteCounts() {
      0|    if (_byteCount1 > _maxByteCount1) {
      0|      _byteCount2.sum(Register64(_byteCount1)..shiftr(61));
      0|      _byteCount1.and(_maxByteCount1);
       |    }
       |  }
       |
      0|  void _processLength(Register64 lowW, Register64 hiW) {
      0|    if (_wOff > 14) {
      0|      _processBlock();
       |    }
       |
      0|    _w[14].set(hiW);
      0|    _w[15].set(lowW);
       |  }
       |
      0|  void _processBlock() {
      0|    _adjustByteCounts();
       |
       |    // expand 16 word block into 80 word blocks.
      0|    for (var t = 16; t < 80; t++) {
       |      // _w[t] = _sigma1(_w[t - 2]) + _w[t - 7] + _sigma0(_w[t - 15]) + _w[t - 16];
      0|      _w[t].set(_sigma1(_w[t - 2])
      0|        ..sum(_w[t - 7])
      0|        ..sum(_sigma0(_w[t - 15]))
      0|        ..sum(_w[t - 16]));
       |    }
       |
      0|    var a = Register64(h1);
      0|    var b = Register64(h2);
      0|    var c = Register64(h3);
      0|    var d = Register64(h4);
      0|    var e = Register64(h5);
      0|    var f = Register64(h6);
      0|    var g = Register64(h7);
      0|    var h = Register64(h8);
       |
       |    var t = 0;
      0|    for (var i = 0; i < 10; i++) {
       |      // t = 8 * i
      0|      h..sum(_sum1(e))..sum(_ch(e, f, g))..sum(_k[t])..sum(_w[t++]);
      0|      d.sum(h);
      0|      h..sum(_sum0(a))..sum(_maj(a, b, c));
       |
       |      // t = 8 * i + 1
      0|      g..sum(_sum1(d))..sum(_ch(d, e, f))..sum(_k[t])..sum(_w[t++]);
      0|      c.sum(g);
      0|      g..sum(_sum0(h))..sum(_maj(h, a, b));
       |
       |      // t = 8 * i + 2
      0|      f..sum(_sum1(c))..sum(_ch(c, d, e))..sum(_k[t])..sum(_w[t++]);
      0|      b.sum(f);
      0|      f..sum(_sum0(g))..sum(_maj(g, h, a));
       |
       |      // t = 8 * i + 3
      0|      e..sum(_sum1(b))..sum(_ch(b, c, d))..sum(_k[t])..sum(_w[t++]);
      0|      a.sum(e);
      0|      e..sum(_sum0(f))..sum(_maj(f, g, h));
       |
       |      // t = 8 * i + 4
      0|      d..sum(_sum1(a))..sum(_ch(a, b, c))..sum(_k[t])..sum(_w[t++]);
      0|      h.sum(d);
      0|      d..sum(_sum0(e))..sum(_maj(e, f, g));
       |
       |      // t = 8 * i + 5
      0|      c..sum(_sum1(h))..sum(_ch(h, a, b))..sum(_k[t])..sum(_w[t++]);
      0|      g.sum(c);
      0|      c..sum(_sum0(d))..sum(_maj(d, e, f));
       |
       |      // t = 8 * i + 6
      0|      b..sum(_sum1(g))..sum(_ch(g, h, a))..sum(_k[t])..sum(_w[t++]);
      0|      f.sum(b);
      0|      b..sum(_sum0(c))..sum(_maj(c, d, e));
       |
       |      // t = 8 * i + 7
      0|      a..sum(_sum1(f))..sum(_ch(f, g, h))..sum(_k[t])..sum(_w[t++]);
      0|      e.sum(a);
      0|      a..sum(_sum0(b))..sum(_maj(b, c, d));
       |    }
       |
      0|    h1.sum(a);
      0|    h2.sum(b);
      0|    h3.sum(c);
      0|    h4.sum(d);
      0|    h5.sum(e);
      0|    h6.sum(f);
      0|    h7.sum(g);
      0|    h8.sum(h);
       |
       |    // reset the offset and clean out the word buffer.
      0|    _wOff = 0;
      0|    _w.fillRange(0, 16, 0);
       |  }
       |
      0|  Register64 _ch(Register64 x, Register64 y, Register64 z) {
       |    // r += ((x & y) ^ ((~x) & z));
      0|    var r0 = Register64(x);
      0|    r0.and(y);
       |
      0|    var r1 = Register64(x);
      0|    r1.not();
      0|    r1.and(z);
       |
      0|    r0.xor(r1);
       |    return r0;
       |  }
       |
      0|  Register64 _maj(Register64 x, Register64 y, Register64 z) {
       |    // r += ((x & y) ^ (x & z) ^ (y & z));
      0|    var r0 = Register64(x);
      0|    r0.and(y);
       |
      0|    var r1 = Register64(x);
      0|    r1.and(z);
       |
      0|    var r2 = Register64(y);
      0|    r2.and(z);
       |
      0|    r0.xor(r1);
      0|    r0.xor(r2);
       |
       |    return r0;
       |  }
       |
      0|  Register64 _sum0(Register64 x) {
       |    // r += ((x << 36)|(x >> 28)) ^ ((x << 30)|(x >> 34)) ^ ((x << 25)|(x >> 39));
      0|    var r0 = Register64(x);
      0|    r0.rotl(36);
       |
      0|    var r1 = Register64(x);
      0|    r1.rotl(30);
       |
      0|    var r2 = Register64(x);
      0|    r2.rotl(25);
       |
      0|    r0.xor(r1);
      0|    r0.xor(r2);
       |
       |    return r0;
       |  }
       |
      0|  Register64 _sum1(Register64 x) {
       |    // r += ((x << 50)|(x >> 14)) ^ ((x << 46)|(x >> 18)) ^ ((x << 23)|(x >> 41));
      0|    var r0 = Register64(x);
      0|    r0.rotl(50);
       |
      0|    var r1 = Register64(x);
      0|    r1.rotl(46);
       |
      0|    var r2 = Register64(x);
      0|    r2.rotl(23);
       |
      0|    r0.xor(r1);
      0|    r0.xor(r2);
       |
       |    return r0;
       |  }
       |
      0|  Register64 _sigma0(Register64 x) {
       |    // r = (((x << 63)|(x >> 1)) ^ ((x << 56)|(x >> 8)) ^ (x >> 7));
      0|    var r0 = Register64(x);
      0|    r0.rotl(63);
       |
      0|    var r1 = Register64(x);
      0|    r1.rotl(56);
       |
      0|    var r2 = Register64(x);
      0|    r2.shiftr(7);
       |
      0|    r0.xor(r1);
      0|    r0.xor(r2);
       |
       |    return r0;
       |  }
       |
      0|  Register64 _sigma1(Register64 x) {
       |    // r = (((x << 45)|(x >> 19)) ^ ((x << 3)|(x >> 61)) ^ (x >> 6));
      0|    var r0 = Register64(x);
      0|    r0.rotl(45);
       |
      0|    var r1 = Register64(x);
      0|    r1.rotl(3);
       |
      0|    var r2 = Register64(x);
      0|    r2.shiftr(6);
       |
      0|    r0.xor(r1);
      0|    r0.xor(r2);
       |
       |    return r0;
       |  }
       |
       |  /// SHA-384 and SHA-512 constants: represent the first 64 bits of the fractional parts of the cube
       |  /// roots of the first sixty-four prime numbers)
      0|  static final _k = <Register64>[
       |    Register64(0x428a2f98, 0xd728ae22),
       |    Register64(0x71374491, 0x23ef65cd),
       |    Register64(0xb5c0fbcf, 0xec4d3b2f),
       |    Register64(0xe9b5dba5, 0x8189dbbc),
       |    Register64(0x3956c25b, 0xf348b538),
       |    Register64(0x59f111f1, 0xb605d019),
       |    Register64(0x923f82a4, 0xaf194f9b),
       |    Register64(0xab1c5ed5, 0xda6d8118),
       |    Register64(0xd807aa98, 0xa3030242),
       |    Register64(0x12835b01, 0x45706fbe),
       |    Register64(0x243185be, 0x4ee4b28c),
       |    Register64(0x550c7dc3, 0xd5ffb4e2),
       |    Register64(0x72be5d74, 0xf27b896f),
       |    Register64(0x80deb1fe, 0x3b1696b1),
       |    Register64(0x9bdc06a7, 0x25c71235),
       |    Register64(0xc19bf174, 0xcf692694),
       |    Register64(0xe49b69c1, 0x9ef14ad2),
       |    Register64(0xefbe4786, 0x384f25e3),
       |    Register64(0x0fc19dc6, 0x8b8cd5b5),
       |    Register64(0x240ca1cc, 0x77ac9c65),
       |    Register64(0x2de92c6f, 0x592b0275),
       |    Register64(0x4a7484aa, 0x6ea6e483),
       |    Register64(0x5cb0a9dc, 0xbd41fbd4),
       |    Register64(0x76f988da, 0x831153b5),
       |    Register64(0x983e5152, 0xee66dfab),
       |    Register64(0xa831c66d, 0x2db43210),
       |    Register64(0xb00327c8, 0x98fb213f),
       |    Register64(0xbf597fc7, 0xbeef0ee4),
       |    Register64(0xc6e00bf3, 0x3da88fc2),
       |    Register64(0xd5a79147, 0x930aa725),
       |    Register64(0x06ca6351, 0xe003826f),
       |    Register64(0x14292967, 0x0a0e6e70),
       |    Register64(0x27b70a85, 0x46d22ffc),
       |    Register64(0x2e1b2138, 0x5c26c926),
       |    Register64(0x4d2c6dfc, 0x5ac42aed),
       |    Register64(0x53380d13, 0x9d95b3df),
       |    Register64(0x650a7354, 0x8baf63de),
       |    Register64(0x766a0abb, 0x3c77b2a8),
       |    Register64(0x81c2c92e, 0x47edaee6),
       |    Register64(0x92722c85, 0x1482353b),
       |    Register64(0xa2bfe8a1, 0x4cf10364),
       |    Register64(0xa81a664b, 0xbc423001),
       |    Register64(0xc24b8b70, 0xd0f89791),
       |    Register64(0xc76c51a3, 0x0654be30),
       |    Register64(0xd192e819, 0xd6ef5218),
       |    Register64(0xd6990624, 0x5565a910),
       |    Register64(0xf40e3585, 0x5771202a),
       |    Register64(0x106aa070, 0x32bbd1b8),
       |    Register64(0x19a4c116, 0xb8d2d0c8),
       |    Register64(0x1e376c08, 0x5141ab53),
       |    Register64(0x2748774c, 0xdf8eeb99),
       |    Register64(0x34b0bcb5, 0xe19b48a8),
       |    Register64(0x391c0cb3, 0xc5c95a63),
       |    Register64(0x4ed8aa4a, 0xe3418acb),
       |    Register64(0x5b9cca4f, 0x7763e373),
       |    Register64(0x682e6ff3, 0xd6b2b8a3),
       |    Register64(0x748f82ee, 0x5defb2fc),
       |    Register64(0x78a5636f, 0x43172f60),
       |    Register64(0x84c87814, 0xa1f0ab72),
       |    Register64(0x8cc70208, 0x1a6439ec),
       |    Register64(0x90befffa, 0x23631e28),
       |    Register64(0xa4506ceb, 0xde82bde9),
       |    Register64(0xbef9a3f7, 0xb2c67915),
       |    Register64(0xc67178f2, 0xe372532b),
       |    Register64(0xca273ece, 0xea26619c),
       |    Register64(0xd186b8c7, 0x21c0c207),
       |    Register64(0xeada7dd6, 0xcde0eb1e),
       |    Register64(0xf57d4f7f, 0xee6ed178),
       |    Register64(0x06f067aa, 0x72176fba),
       |    Register64(0x0a637dc5, 0xa2c898a6),
       |    Register64(0x113f9804, 0xbef90dae),
       |    Register64(0x1b710b35, 0x131c471b),
       |    Register64(0x28db77f5, 0x23047d84),
       |    Register64(0x32caab7b, 0x40c72493),
       |    Register64(0x3c9ebe0a, 0x15c9bebc),
       |    Register64(0x431d67c4, 0x9c100d4c),
       |    Register64(0x4cc5d4be, 0xcb3e42b6),
       |    Register64(0x597f299c, 0xfc657e2a),
       |    Register64(0x5fcb6fab, 0x3ad6faec),
       |    Register64(0x6c44198c, 0x4a475817)
       |  ];
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/base_aead_block_cipher.dart
       |library src.impl.base_aead_block_cipher;
       |
       |import 'dart:math' show min;
       |
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/api.dart';
       |
       |abstract class BaseAEADBlockCipher implements AEADBlockCipher {
       |  final BlockCipher _underlyingCipher;
       |
      0|  BaseAEADBlockCipher(this._underlyingCipher);
       |
       |  // These fields are set by init and not modified by processing
       |  bool _forEncryption;
       |  int _macSize;
       |  Uint8List _lastKey;
       |  Uint8List _nonce;
       |  Uint8List _initialAssociatedText;
       |
       |  // These fields are modified during processing
       |  Uint8List _bufBlock;
       |  int _bufOff;
       |  Uint8List _lastMacSizeBytes;
       |  int _lastMacSizeBytesOff;
       |
      0|  @override
      0|  int get blockSize => underlyingCipher.blockSize;
       |
       |  /// The underlying cipher
      0|  BlockCipher get underlyingCipher => _underlyingCipher;
       |
       |  /// True if initialized for encryption
      0|  bool get forEncryption => _forEncryption;
       |
       |  /// The nonce or iv as set by the initialization
      0|  Uint8List get nonce => _nonce;
       |
       |  /// The additional authenticated data as set by the initialization
      0|  Uint8List get aad => _initialAssociatedText;
       |
       |  /// Any remaining input yet to be processed
      0|  Uint8List get remainingInput =>
      0|      Uint8List.view(_bufBlock.buffer, _bufBlock.offsetInBytes, _bufOff);
       |
       |  /// The length in bytes of the authentication tag
      0|  int get macSize => _macSize;
       |
       |  /// The value of the authentication tag associated with the last processed
       |  /// data
       |  Uint8List get mac;
       |
       |  /// Prepare for a stream of data. This method is called during
       |  /// initialization and reset.
       |  void prepare(KeyParameter keyParam);
       |
       |  /// Processes the additional authentication data
       |  void processAADBytes(Uint8List inp, int inpOff, int len);
       |
       |  /// When decrypting, validates the generated authentication tag with the one
       |  /// in the input stream. When not equal throws [InvalidCipherTextException].
       |  /// This method should be called from the [doFinal] method.
      0|  void validateMac() {
      0|    if (forEncryption) {
       |      return;
       |    }
      0|    if (_lastMacSizeBytesOff != macSize) {
      0|      throw InvalidCipherTextException('Input data too short');
       |    }
      0|    if (!_compareLists(mac, _lastMacSizeBytes)) {
      0|      throw InvalidCipherTextException('Authentication tag check failed');
       |    }
       |  }
       |
      0|  bool _compareLists(Uint8List a, Uint8List b) {
      0|    if (a.length != b.length) return false;
      0|    for (var i = 0; i < a.length; i++) {
      0|      if (a[i] != b[i]) return false;
       |    }
       |    return true;
       |  }
       |
      0|  @override
       |  void init(bool forEncryption, CipherParameters params) {
      0|    _forEncryption = forEncryption;
       |
       |    KeyParameter keyParam;
       |    Uint8List newNonce;
       |
      0|    if (params is AEADParameters) {
       |      var param = params;
       |
      0|      newNonce = param.nonce;
      0|      _initialAssociatedText = param.associatedData ?? Uint8List(0);
       |
      0|      var macSizeBits = param.macSize;
      0|      if (macSizeBits < 32 || macSizeBits > 256 || macSizeBits % 8 != 0) {
      0|        throw ArgumentError('Invalid value for MAC size: $macSizeBits');
       |      }
       |
      0|      _macSize = macSizeBits ~/ 8;
      0|      keyParam = param.parameters as KeyParameter;
      0|    } else if (params is ParametersWithIV) {
       |      var param = params;
       |
      0|      newNonce = param.iv;
      0|      _initialAssociatedText = Uint8List(0);
      0|      _macSize = 16;
      0|      keyParam = param.parameters as KeyParameter;
       |    } else {
      0|      throw ArgumentError('invalid parameters passed to AEADBlockCipher');
       |    }
       |
      0|    var bufLength = forEncryption ? blockSize : (blockSize + _macSize);
      0|    _bufBlock = Uint8List(bufLength);
       |
      0|    if (newNonce == null || newNonce.isEmpty) {
      0|      throw ArgumentError('IV must be at least 1 byte');
       |    }
       |
      0|    _nonce = newNonce;
      0|    _lastKey = keyParam.key;
      0|    _lastMacSizeBytes = Uint8List(macSize);
       |
      0|    reset();
       |  }
       |
      0|  @override
       |  Uint8List process(Uint8List data) {
      0|    var out = Uint8List(_getOutputSize(data.length));
       |
      0|    var len = processBytes(data, 0, data.length, out, 0);
       |
      0|    len += doFinal(out, len);
       |
      0|    return Uint8List.view(out.buffer, 0, len);
       |  }
       |
      0|  @override
       |  int processBytes(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      0|    if (len == 0) return 0;
       |
      0|    if (forEncryption) {
       |      // all bytes are plain text bytes
      0|      return _processCipherBytes(inp, inpOff, len, out, outOff);
       |    }
       |
       |    // last macSize bytes are possibly mac bytes and not cipher text bytes
       |    // -> keep them in buffer
      0|    var cipherLen = _lastMacSizeBytesOff + len - macSize;
       |
       |    var resultLen = 0;
       |
      0|    if (cipherLen > 0 && _lastMacSizeBytesOff > 0) {
       |      // at least part of the buffer are actually cipher text bytes
       |      // process them and update the buffer
       |
      1|      var l = min(_lastMacSizeBytesOff, cipherLen);
      0|      resultLen += _processCipherBytes(_lastMacSizeBytes, 0,
      1|          min(_lastMacSizeBytesOff, cipherLen), out, outOff);
      0|      outOff += resultLen;
      0|      cipherLen -= l;
      0|      _lastMacSizeBytes.setRange(0, macSize - l, _lastMacSizeBytes.skip(l));
      0|      _lastMacSizeBytesOff -= l;
       |    }
       |
      0|    if (cipherLen > 0) {
       |      // part of the input are cipher text bytes
      0|      resultLen += _processCipherBytes(inp, inpOff, cipherLen, out, outOff);
       |    }
       |
      0|    _lastMacSizeBytes.setRange(_lastMacSizeBytesOff,
      0|        _lastMacSizeBytesOff + len - cipherLen, inp.skip(inpOff + cipherLen));
      0|    _lastMacSizeBytesOff += len - cipherLen;
       |
       |    return resultLen;
       |  }
       |
      0|  int _processCipherBytes(
       |      Uint8List inp, int inpOff, int len, Uint8List out, int outOff) {
      0|    if (len == 0) return 0;
       |
       |    var resultLen = 0;
       |
      0|    if (_bufOff != 0) {
       |      // add to buffer until full
      0|      var end = blockSize < _bufOff + len ? blockSize : _bufOff + len;
      0|      _bufBlock.setRange(_bufOff, end, inp.skip(inpOff));
      0|      len -= end - _bufOff;
      0|      _bufOff = end;
       |
       |      // if buffer full and has more data -> process buffer
      0|      if (_bufOff == blockSize && len > 0) {
      0|        processBlock(_bufBlock, 0, out, outOff);
      0|        _bufOff = 0;
      0|        resultLen += blockSize;
       |      }
       |    }
       |
       |    // process all full blocks
      0|    while (len > blockSize) {
      0|      processBlock(inp, inpOff, out, outOff + resultLen);
      0|      inpOff += blockSize;
      0|      len -= blockSize;
      0|      resultLen += blockSize;
       |    }
       |
       |    // keep last block in buffer
      0|    if (len > 0) {
      0|      _bufBlock.setRange(0, len, inp.skip(inpOff));
      0|      _bufOff = len;
       |    }
       |
       |    return resultLen;
       |  }
       |
      0|  @override
       |  void reset() {
      0|    _bufOff = 0;
      0|    _lastMacSizeBytesOff = 0;
       |
      0|    if (_lastKey == null) return;
       |
      0|    prepare(KeyParameter(_lastKey));
      0|    processAADBytes(_initialAssociatedText, 0, _initialAssociatedText.length);
       |  }
       |
      0|  int _getOutputSize(int length) =>
      0|      (length + (forEncryption ? macSize : -macSize) + blockSize - 1) ~/
      0|      blockSize *
      0|      blockSize;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/digests/xof_utils.dart
       |library impl.digest.utils;
       |
       |import 'dart:typed_data';
       |
       |class XofUtils {
      0|  static Uint8List leftEncode(int strLen) {
       |    var n = 1;
       |    var v = strLen;
      0|    while ((v >>= 8) != 0) {
      0|      n++;
       |    }
      0|    var b = Uint8List(n + 1);
      0|    b[0] = n;
      0|    for (var i = 1; i <= n; i++) {
      0|      b[i] = strLen >> (8 * (n - i));
       |    }
       |    return b;
       |  }
       |
      0|  static Uint8List rightEncode(int strLen) {
       |    var n = 1;
       |    var v = strLen;
      0|    while ((v >>= 8) != 0) {
      0|      n++;
       |    }
       |
      0|    var b = Uint8List(n + 1);
       |
      0|    b[n] = n;
       |
      0|    for (var i = 0; i < n; i++) {
      0|      b[i] = (strLen >> (8 * (n - i - 1)));
       |    }
       |
       |    return b;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/pointycastle-2.0.0/lib/src/impl/keccak_engine.dart
       |// See file LICENSE for more information.
       |
       |library src.impl.digests.keccak_engine;
       |
       |import 'dart:math';
       |import 'dart:typed_data';
       |
       |import 'package:pointycastle/src/impl/base_digest.dart';
       |
       |import '../ufixnum.dart';
       |
       |// KeccakEngine
       |abstract class KeccakEngine extends BaseDigest {
      0|  static final _keccakRoundConstants = Register64List.from([
       |    [0x00000000, 0x00000001],
       |    [0x00000000, 0x00008082],
       |    [0x80000000, 0x0000808a],
       |    [0x80000000, 0x80008000],
       |    [0x00000000, 0x0000808b],
       |    [0x00000000, 0x80000001],
       |    [0x80000000, 0x80008081],
       |    [0x80000000, 0x00008009],
       |    [0x00000000, 0x0000008a],
       |    [0x00000000, 0x00000088],
       |    [0x00000000, 0x80008009],
       |    [0x00000000, 0x8000000a],
       |    [0x00000000, 0x8000808b],
       |    [0x80000000, 0x0000008b],
       |    [0x80000000, 0x00008089],
       |    [0x80000000, 0x00008003],
       |    [0x80000000, 0x00008002],
       |    [0x80000000, 0x00000080],
       |    [0x00000000, 0x0000800a],
       |    [0x80000000, 0x8000000a],
       |    [0x80000000, 0x80008081],
       |    [0x80000000, 0x00008080],
       |    [0x00000000, 0x80000001],
       |    [0x80000000, 0x80008008]
       |  ]);
       |
      0|  static final _keccakRhoOffsets = [
       |    0x00000000,
       |    0x00000001,
       |    0x0000003e,
       |    0x0000001c,
       |    0x0000001b,
       |    0x00000024,
       |    0x0000002c,
       |    0x00000006,
       |    0x00000037,
       |    0x00000014,
       |    0x00000003,
       |    0x0000000a,
       |    0x0000002b,
       |    0x00000019,
       |    0x00000027,
       |    0x00000029,
       |    0x0000002d,
       |    0x0000000f,
       |    0x00000015,
       |    0x00000008,
       |    0x00000012,
       |    0x00000002,
       |    0x0000003d,
       |    0x00000038,
       |    0x0000000e
       |  ];
       |
       |  final _state = Uint8List(200);
       |  final _dataQueue = Uint8List(192);
       |
       |  int _rate;
       |  int fixedOutputLength;
       |  int _bitsInQueue;
       |  bool _squeezing;
       |
       |  /// dataQueue intended for use by subclasses only.
      0|  Uint8List get dataQueue => _dataQueue;
       |
       |  /// squeezing intended for use by subclasses only.
      0|  bool get squeezing => _squeezing;
       |
      0|  @override
      0|  int get byteLength => _rate ~/ 8;
       |
      0|  @override
      0|  int get digestSize => (fixedOutputLength ~/ 8);
       |
      0|  int get rate => _rate;
       |
      0|  @override
       |  void reset() {
      0|    init(fixedOutputLength);
       |  }
       |
      0|  @override
       |  void updateByte(int inp) {
      0|    _doUpdate(Uint8List.fromList([inp]), 0, 8);
       |  }
       |
      0|  @override
       |  void update(Uint8List inp, int inpOff, int len) {
      0|    _doUpdate(inp, inpOff, len);
       |  }
       |
      0|  void absorb(int data) {
      0|    if ((_bitsInQueue % 8) != 0) {
      0|      throw StateError('attempt to absorb with odd length queue');
       |    }
      0|    if (_squeezing) {
      0|      throw StateError('attempt to absorb while squeezing');
       |    }
       |
      0|    _dataQueue[_bitsInQueue >> 3] = data;
      0|    if ((_bitsInQueue += 8) == _rate) {
      0|      _keccakAbsorb(_dataQueue, 0);
      0|      _bitsInQueue = 0;
       |    }
       |  }
       |
      0|  void absorbBits(int data, int bits) {
      0|    if (bits < 1 || bits > 7) {
      0|      throw StateError('"bits" must be in the range 1 to 7');
       |    }
      0|    if ((_bitsInQueue % 8) != 0) {
      0|      throw StateError('attempt to absorb with odd length queue');
       |    }
      0|    if (_squeezing) {
      0|      throw StateError('attempt to absorb while squeezing');
       |    }
      0|    var mask = (1 << bits) - 1;
      0|    _dataQueue[_bitsInQueue >> 3] = data & mask;
      0|    _bitsInQueue += bits;
       |  }
       |
      0|  void absorbRange(Uint8List data, int off, int len) {
      0|    if ((_bitsInQueue % 8) != 0) {
      0|      throw StateError('attempt to absorb with odd length queue');
       |    }
      0|    if (squeezing) {
      0|      throw StateError('attempt to absorb while squeezing');
       |    }
       |
      0|    var bytesInQueue = _bitsInQueue >> 3;
      0|    var rateBytes = _rate >> 3;
       |
      0|    var available = rateBytes - bytesInQueue;
      0|    if (len < available) {
      0|      _dataQueue.setRange(bytesInQueue, bytesInQueue + len, data, off);
      0|      _bitsInQueue += (len << 3);
       |      return;
       |    }
       |
       |    var count = 0;
      0|    if (bytesInQueue > 0) {
      0|      _dataQueue.setRange(
      0|          bytesInQueue, bytesInQueue + available, data.sublist(off));
      0|      count += available;
      0|      _keccakAbsorb(_dataQueue, 0);
       |    }
       |
       |    int remaining;
      0|    while ((remaining = (len - count)) >= rateBytes) {
      0|      _keccakAbsorb(data, off + count);
      0|      count += rateBytes;
       |    }
       |
      0|    _dataQueue.setRange(0, remaining, data, off + count);
      0|    _bitsInQueue = remaining << 3;
       |  }
       |
      0|  void _clearDataQueueSection(int off, int len) {
      0|    _dataQueue.fillRange(off, off + len, 0);
       |  }
       |
      0|  void _doUpdate(Uint8List data, int off, int databitlen) {
      0|    absorbRange(data, off, databitlen);
       |  }
       |
      0|  void init(int bitlen) {
      0|    _initSponge(1600 - (bitlen << 1));
       |  }
       |
      0|  void _initSponge(int theRate) {
      0|    if ((theRate <= 0) || (theRate >= 1600) || ((theRate % 64) != 0)) {
      0|      throw StateError('invalid rate value');
       |    }
       |
      0|    _rate = theRate;
      0|    _state.fillRange(0, _state.length, 0);
      0|    _dataQueue.fillRange(0, _dataQueue.length, 0);
      0|    _bitsInQueue = 0;
      0|    _squeezing = false;
      0|    fixedOutputLength = (1600 - theRate) ~/ 2;
       |  }
       |
      0|  void _absorb(int data) {
      0|    if ((_bitsInQueue % ~8) != 0) {
      0|      throw StateError('attempt to absorb with odd length queue');
       |    }
      0|    if (squeezing) {
      0|      throw StateError('attempt to absorb while squeezing');
       |    }
       |
      0|    dataQueue[_bitsInQueue >> 3] = data & 0xFF;
      0|    if ((_bitsInQueue += 8) == _rate) {
      0|      _keccakAbsorb(_dataQueue, 0);
      0|      _bitsInQueue = 0;
       |    }
       |  }
       |
      0|  void _keccakAbsorb(Uint8List data, int off) {
      0|    var count = _rate >> 3;
      0|    for (var i = 0; i < count; ++i) {
      0|      _state[i] ^= data[off + i];
       |    }
      0|    _keccakPermutation();
       |  }
       |
      0|  void _keccakExtract() {
      0|    _keccakPermutation();
       |
      0|    _dataQueue.setRange(0, (_rate >> 3), _state);
      0|    _bitsInQueue = _rate;
       |  }
       |
      0|  void squeeze(Uint8List output, int offset, int outputLength) {
      0|    if (!squeezing) {
      0|      _padAndSwitchToSqueezingPhase();
       |    }
       |
      0|    if ((outputLength % 8) != 0) {
      0|      throw StateError('outputLength not a multiple of 8');
       |    }
       |
       |    var i = 0;
      0|    while (i < outputLength) {
      0|      if (_bitsInQueue == 0) {
      0|        _keccakExtract();
       |      }
       |
      1|      var partialBlock = min(_bitsInQueue, outputLength - i);
       |
      0|      output.setRange(
      0|          offset + (i ~/ 8),
      0|          offset + (i ~/ 8) + (partialBlock ~/ 8),
      0|          dataQueue.sublist((_rate - _bitsInQueue) ~/ 8));
       |
       |      //System.arraycopy(dataQueue, (rate - bitsInQueue) / 8, output, offset + (int)(i / 8), partialBlock / 8);
      0|      _bitsInQueue -= partialBlock;
      0|      i += partialBlock;
       |    }
       |  }
       |
      0|  void _padAndSwitchToSqueezingPhase() {
      0|    _dataQueue[_bitsInQueue >> 3] |= (1 << (_bitsInQueue & 7));
      0|    if (++_bitsInQueue == _rate) {
      0|      _keccakAbsorb(_dataQueue, 0);
       |    } else {
      0|      var full = _bitsInQueue >> 3, partial = _bitsInQueue & 63;
       |      var off = 0;
      0|      for (var i = 0; i < full; ++i) {
      0|        _state[i] ^= _dataQueue[i];
      0|        off++;
       |      }
      0|      if (partial > 0) {
      0|        var mask = (1 << partial) - 1;
      0|        _state[full] ^= dataQueue[off] & mask;
       |      }
       |    }
       |
      0|    _state[((_rate - 1) >> 3)] ^= (1 << 7);
      0|    _bitsInQueue = 0;
      0|    _squeezing = true;
       |  }
       |
      0|  void _fromBytesToWords(Register64List stateAsWords, Uint8List state) {
      0|    final r = Register64();
       |
      0|    for (var i = 0; i < (1600 ~/ 64); i++) {
      0|      final index = i * (64 ~/ 8);
       |
      0|      stateAsWords[i].set(0);
       |
      0|      for (var j = 0; j < (64 ~/ 8); j++) {
      0|        r.set(state[index + j]);
      0|        r.shiftl(8 * j);
      0|        stateAsWords[i].or(r);
       |      }
       |    }
       |  }
       |
      0|  void _fromWordsToBytes(Uint8List state, Register64List stateAsWords) {
      0|    final r = Register64();
       |
      0|    for (var i = 0; i < (1600 ~/ 64); i++) {
      0|      final index = i * (64 ~/ 8);
       |
      0|      for (var j = 0; j < (64 ~/ 8); j++) {
      0|        r.set(stateAsWords[i]);
      0|        r.shiftr(8 * j);
      0|        state[index + j] = r.lo32;
       |      }
       |    }
       |  }
       |
      0|  void _keccakPermutation() {
      0|    final longState = Register64List(_state.length ~/ 8);
       |
      0|    _fromBytesToWords(longState, _state);
      0|    _keccakPermutationOnWords(longState);
      0|    _fromWordsToBytes(_state, longState);
       |  }
       |
      0|  void _keccakPermutationOnWords(Register64List state) {
      0|    for (var i = 0; i < 24; i++) {
      0|      theta(state);
      0|      rho(state);
      0|      pi(state);
      0|      chi(state);
      0|      _iota(state, i);
       |    }
       |  }
       |
      0|  void theta(Register64List A) {
      0|    final C = Register64List(5);
      0|    final r0 = Register64();
      0|    final r1 = Register64();
       |
      0|    for (var x = 0; x < 5; x++) {
      0|      C[x].set(0);
       |
      0|      for (var y = 0; y < 5; y++) {
      0|        C[x].xor(A[x + 5 * y]);
       |      }
       |    }
       |
      0|    for (var x = 0; x < 5; x++) {
      0|      r0.set(C[(x + 1) % 5]);
      0|      r0.shiftl(1);
       |
      0|      r1.set(C[(x + 1) % 5]);
      0|      r1.shiftr(63);
       |
      0|      r0.xor(r1);
      0|      r0.xor(C[(x + 4) % 5]);
       |
      0|      for (var y = 0; y < 5; y++) {
      0|        A[x + 5 * y].xor(r0);
       |      }
       |    }
       |  }
       |
      0|  void rho(Register64List A) {
      0|    final r = Register64();
       |
      0|    for (var x = 0; x < 5; x++) {
      0|      for (var y = 0; y < 5; y++) {
      0|        final index = x + 5 * y;
       |
      0|        if (_keccakRhoOffsets[index] != 0) {
      0|          r.set(A[index]);
      0|          r.shiftr(64 - _keccakRhoOffsets[index]);
       |
      0|          A[index].shiftl(_keccakRhoOffsets[index]);
      0|          A[index].xor(r);
       |        }
       |      }
       |    }
       |  }
       |
      0|  void pi(Register64List A) {
      0|    final tempA = Register64List(25);
       |
      0|    tempA.setRange(0, tempA.length, A);
       |
      0|    for (var x = 0; x < 5; x++) {
      0|      for (var y = 0; y < 5; y++) {
      0|        A[y + 5 * ((2 * x + 3 * y) % 5)].set(tempA[x + 5 * y]);
       |      }
       |    }
       |  }
       |
      0|  void chi(Register64List A) {
      0|    final chiC = Register64List(5);
       |
      0|    for (var y = 0; y < 5; y++) {
      0|      for (var x = 0; x < 5; x++) {
      0|        chiC[x].set(A[((x + 1) % 5) + (5 * y)]);
      0|        chiC[x].not();
      0|        chiC[x].and(A[((x + 2) % 5) + (5 * y)]);
      0|        chiC[x].xor(A[x + 5 * y]);
       |      }
      0|      for (var x = 0; x < 5; x++) {
      0|        A[x + 5 * y].set(chiC[x]);
       |      }
       |    }
       |  }
       |
      0|  void _iota(Register64List A, int indexRound) {
      0|    A[(((0) % 5) + 5 * ((0) % 5))].xor(_keccakRoundConstants[indexRound]);
       |  }
       |
      0|  @override
       |  int doFinal(Uint8List out, int outOff) {
      0|    throw UnimplementedError('Subclasses must implement this.');
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/ivmjv-0.1.5/lib/src/jvalid.dart
       |part of '../ivmjv.dart';
       |
       |/// JSON Validator [RFC8259]
       |///
       |/// This class will validate if a string object represents a valid JSON object defined by RFC8259 standard.
       |///
       |/// JavaScript Object Notation (JSON) is a text format for the serialization of structured data.
       |///
       |/// JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays).
       |class JsonValidator {
       |  String json;
       |  bool _validity = false;
       |
      1|  JsonValidator([String json]) {
       |    if (json == null) {
      1|      this.json = '';
      0|    } else if (json.isNotEmpty || json != null) {
      0|      this.json = json.replaceAll(RegExp(r'\s'), '');
       |    } else {
      0|      this.json = '';
       |    }
       |  }
       |
      1|  Future<bool> validate([String nestedJson]) async {
       |    if (nestedJson == null) {
      0|      json = json;
       |    } else {
      2|      final flattenedJson = nestedJson.replaceAll(RegExp(r'\s'), '');
      1|      json = flattenedJson;
       |    }
       |    // An empty string is not a valid json object
      2|    if (json.isEmpty) return false;
       |
       |    // A zero length object is a valid json.
      3|    if (json.length == 2 && json.startsWith('{') && json.endsWith('}')) {
       |      return true;
       |    }
       |
       |    // Do cycling validation of the Name-Value Pairs
      3|    return await _validateNameValuePair(json);
       |  }
       |
       |  /// An object is an unordered collection of zero or more name/value pairs, where:
       |  /// * a name is a string
       |  /// and
       |  /// * a value is a string, number, boolean, null, object, or array.
       |  ///
       |  /// An array is an ordered sequence of zero or more values.
       |  ///
      1|  Future<bool> _validateNameValuePair(String value) async {
      1|    var _value = value.trim();
       |
       |    // define the function exit point
      1|    if (_value.isEmpty) return false;
       |
       |    // Minumum token length (6 chars = {"":n}) check
      2|    if (_value.length < 6) return false;
       |
       |    do {
       |      // cycling validation until the entire string is validated or
       |      // _value 'invalid' is sent.
      2|      _value = await _validateFirstKeyValuePair(_value);
       |
       |      // validate an object
      1|      if (_value == 'invalid') {
      0|        _validity = false;
       |        break;
      1|      } else if (_value.isEmpty) {
      1|        _validity = true;
       |      }
      1|    } while (_value.isNotEmpty);
       |
      1|    return _validity;
       |  }
       |
       |  /// Validate Key-Value Pair
       |  ///
       |  /// This function esentialy validates the first token with key-value pair; If it is valid then the function returns is a string of the rest of the provided string (the first k-v pair removed) that needs to be validate.
       |  ///
      1|  Future<String> _validateFirstKeyValuePair(String value) async {
       |    //Step-0
       |    // <<<< ================ Prep & Analyses =============================>>>>
       |    var _validPairName = false;
       |    var _validPairValue = false;
       |    var _isAnArray = false;
       |    String tokens;
       |    String firstPairName;
       |    String firstPairValue;
       |    String valueStartsWith;
       |    String retValue;
      2|    var spc = _getSuroundingChars(value.trim());
       |
       |    // Verify the array
      1|    if (spc == '[]') {
      0|      tokens = await _getValueObject(value);
       |    }
       |
       |    // Remove the object's lead and closing chars or not
       |    // depending on the surounding chars
      1|    if (spc == '{}') {
      4|      tokens = value.trim().substring(1, value.length - 1);
       |    } else {
      0|      if (tokens.isEmpty) {
       |        return '';
       |      }
       |    }
       |
       |    // Identify the separators positions for the first k-v pair.
      3|    var colonIndex = tokens.trim().indexOf(RegExp(r':(?!//)'));
      2|    var commaIndex = tokens.trim().indexOf(',');
       |
       |    // Get the starting char for the value part of the pair.
       |    valueStartsWith =
      5|        tokens.trim().substring(colonIndex + 1, colonIndex + 2).trim();
      1|    if (valueStartsWith.isEmpty) {
       |      valueStartsWith =
      0|          tokens.trim().substring(colonIndex + 1, colonIndex + 3).trim();
       |    }
       |
       |    // Define a list of chars that Value part of the pair can start with
      1|    final _possibleFC = <String>[
       |      '"',
       |      '[',
       |      '{',
       |      'f',
       |      't',
       |      'n',
       |      '1',
       |      '2',
       |      '3',
       |      '4',
       |      '5',
       |      '6',
       |      '7',
       |      '8',
       |      '9',
       |      '0',
       |      '-'
       |    ];
       |
       |    // Step-1
       |    // <<<<================= Getting first PairName string ================>>>>
      3|    firstPairName = tokens.trim().substring(0, colonIndex).trim();
       |
      2|    if (_getSuroundingChars(firstPairName) == '""') {
       |      _validPairName = true;
       |    } else {
       |      return 'invalid';
       |    }
       |
       |    // Step-2
       |    // <<<<================== Getting first PairValue string ==============>>>>
       |
       |    // Extract the Value part from the key-value token;
      1|    if (_possibleFC.contains(valueStartsWith)) {
       |      firstPairValue =
      6|          await _getValueObject(tokens.trim().substring(colonIndex + 1).trim());
       |
       |      // If the value part starts with '[' the value may be a valid ARRAY and
       |      // the commaIndex needs to be redefined
      1|      if (valueStartsWith == '[') {
       |        _isAnArray = true;
       |      }
       |    } else {
       |      return 'invalid';
       |    }
       |
       |    // Check the extracted firstPairValue for success.
      1|    if (firstPairValue == 'invalid') {
       |      return 'invalid';
       |    } else {
       |      _validPairValue = true;
       |    }
       |
       |    // Step-3
       |    // <<<<==================== Composing the return result ===============>>>>
       |
       |    /// * Note: if the first token (k-v pair) was successfully verified, then
       |    /// * the composing part below should CUT the first token and return as
       |    /// * result the rest of the provided string [value].
       |    /// * If this token has been the last pair in the object AND it has been
       |    /// * successfully verified - the returned result is EMPTY string.
       |    ///
      2|    if (_validPairName && _validPairValue && !_isAnArray && commaIndex != -1) {
      1|      if (spc == '{}') {
      3|        retValue = '{${tokens.substring(commaIndex + 1)}}';
       |      }
       |      return retValue;
       |    } else if (_validPairName && _validPairValue && _isAnArray) {
      1|      if (firstPairValue.isEmpty) {
       |        retValue = '';
       |      } else {
      0|        retValue = '{$firstPairValue}';
       |      }
       |      return retValue;
      2|    } else if (_validPairName && _validPairValue && commaIndex == -1) {
       |      return '';
       |    } else {
       |      return 'invalid';
       |    }
       |  }
       |
      1|  String _getSuroundingChars(String str) {
      2|    if (str.length < 2 || str == null) {
       |      return 'invalid';
       |    }
      5|    return '${str.substring(0, 1)}${str.substring(str.length - 1)}';
       |  }
       |
       |  /// This function will extract the first pair's value
      1|  Future<String> _getValueObject(String restValue) async {
       |    String result;
      1|    var commaIndex = restValue.indexOf(',');
       |
       |    // <<<<================== Local functions =======================>>>>
       |
       |    /// Calculate enclosures
       |    ///
      1|    Map<String, List<int>> _calculateEnclosures(
       |        {@required oBraket, @required cBraket}) {
       |      // commaIndex will NOT work here due to existing commas within the array.
      1|      var openingArrayIndexes = <int>[];
      1|      var closingArrayIndexes = <int>[];
       |
       |      // Calc valid array's enclosures
       |      String char;
       |      var dq = 0;
       |      var i = 0;
       |
       |      do {
      1|        char = restValue[i];
      2|        if (char == '"' && dq == 0) {
      1|          dq++;
      2|        } else if (char == '"' && dq == 1) {
      1|          dq--;
       |        }
      3|        if (char == oBraket && dq == 0) openingArrayIndexes.add(i);
      3|        if (char == cBraket && dq == 0) closingArrayIndexes.add(i);
      1|        i++;
      2|      } while (i < restValue.length);
       |
      1|      return {'oil': openingArrayIndexes, 'cil': closingArrayIndexes};
       |    }
       |
       |    /// Parsing array from the begining of the restValue string
       |    /// This function assumes the string to be parsed BEGINS with
       |    /// [bracketType] either one of '[' or '{'
      1|    String _parseEnclosure(String bracketType, [String toBeParsed]) {
       |      String tmpHolder;
       |      String openBracket;
       |      String closeBracket;
       |
      1|      if (bracketType == '[') {
       |        openBracket = '[';
       |        closeBracket = ']';
      1|      } else if (bracketType == '{') {
       |        openBracket = '{';
       |        closeBracket = '}';
       |      } else {
       |        return 'invalid';
       |      }
       |
       |      if (toBeParsed == null) {
       |        tmpHolder = restValue;
       |      } else {
       |        tmpHolder = toBeParsed;
       |      }
       |
       |      // Calculate currly brakets enclosures
      1|      var _cbIndexMap = _calculateEnclosures(oBraket: '{', cBraket: '}');
      1|      var cbOpenningIndexes = _cbIndexMap['oil'];
      1|      var cbClosingIndexes = _cbIndexMap['cil'];
       |
       |      // Calculate square brakets enclosures
      1|      var _sbIndexMap = _calculateEnclosures(oBraket: '[', cBraket: ']');
      1|      var sbOpenningIndexes = _sbIndexMap['oil'];
      1|      var sbClosingIndexes = _sbIndexMap['cil'];
       |
       |      // Check for correct enclosure
      3|      if (sbOpenningIndexes.length != sbClosingIndexes.length ||
      3|          cbOpenningIndexes.length != cbClosingIndexes.length) {
       |        return 'invalid';
       |      }
       |
       |      // Get the entire array string (find the closing bracket)
       |      var b = 1;
       |      var char = '';
       |      var dq = 0;
       |      int closingBracketIndex;
      1|      while (b != 0) {
       |        // [i] starts from 1 ASSUMING the char at position 0 is already the
       |        // opening bracket ( '[' or '{') thus b=1
      3|        for (var i = 1; i < tmpHolder.length; i++) {
      1|          char = tmpHolder[i];
       |          // make a check for double-quote opennings
      2|          if (char == '"' && dq == 0) {
      1|            dq++;
      2|          } else if (char == '"' && dq == 1) {
      1|            dq--;
       |          }
       |
      2|          if (char == '$openBracket' && dq == 0) {
      0|            b++;
      3|          } else if (char == '$closeBracket' && dq == 0) {
      1|            b--;
      1|            if (b == 0) {
       |              closingBracketIndex = i;
       |              break;
       |            }
       |          }
       |        }
       |        // Force the b to ZERO
      1|        if (b != 0) {
      0|          closingBracketIndex = -1;
       |          b = 0;
       |        }
       |      }
       |
      1|      if (closingBracketIndex > 0 &&
      3|          (tmpHolder.length - 1 >= closingBracketIndex)) {
      2|        var result = tmpHolder.substring(0, closingBracketIndex + 1);
       |
       |        return result;
       |      } else {
       |        return 'invalid';
       |      }
       |    }
       |
       |    /// Validate an Object previously parsed
       |    ///
      0|    Future<bool> _validateObject(String parsedObject) async {
      0|      return await validate(parsedObject);
       |    }
       |
       |    /// Validate an ARRAY previously parsed
       |    ///
      1|    Future<bool> _validateArray(String parsedArray) async {
       |      var validity = false;
       |      String retval;
      3|      var arrayBody = parsedArray.substring(1, parsedArray.length - 1);
      1|      var commaIndex = -1;
       |      do {
      2|        var firstChar = arrayBody.trim().substring(0, 1);
       |
       |        // Process arrayBody that starts with either one of '[' or '{'
      1|        if (firstChar == '{' || firstChar == '[') {
       |          do {
      2|            var nestedElement = _parseEnclosure('$firstChar', arrayBody);
       |
      1|            if (firstChar == '{') {
      1|              var validityNestedElement = validate(nestedElement);
       |
      1|              if (await validityNestedElement) {
      5|                if (arrayBody.trim().length == nestedElement.trim().length) {
       |                  arrayBody = '';
      1|                  validity = await validityNestedElement;
      0|                } else if (arrayBody.length > nestedElement.length + 1) {
       |                  // cutting the first (verified) element
      0|                  arrayBody = arrayBody.substring(nestedElement.length).trim();
       |
       |                  // Check and cut-off the leading and trailing spaces and commas.
      0|                  if (arrayBody.trim().endsWith(',')) {
      0|                    arrayBody = arrayBody.trim().substring(0, arrayBody.length);
      0|                    arrayBody = arrayBody.trim();
       |                  }
      0|                  if (arrayBody.trim().startsWith(',')) {
      0|                    arrayBody = arrayBody.trim().substring(1);
      0|                    arrayBody = arrayBody.trim();
       |                  }
       |
      0|                  firstChar = arrayBody.substring(0, 1);
       |                } else {
       |                  validity = true;
       |                }
       |              } else {
       |                validity = false;
       |                break;
       |              }
      0|            } else if (firstChar == '[') {
      0|              if (await _validateArray(nestedElement)) {
      0|                if (arrayBody.trim().length == nestedElement.length) {
       |                  arrayBody = '';
      0|                } else if (arrayBody.length > nestedElement.length) {
       |                  // cutting the first (verified) element
      0|                  arrayBody = arrayBody.substring(nestedElement.length).trim();
      0|                  firstChar = arrayBody.substring(0, 1);
       |                } else {
       |                  validity = true;
       |                }
       |              } else {
       |                validity = false;
       |                break;
       |              }
       |            }
       |
       |            // Check and cut-off the leading and trailing spaces and commas.
      2|            if (arrayBody.trim().endsWith(',')) {
      0|              arrayBody = arrayBody.trim().substring(0, arrayBody.length);
       |            }
      2|            if (arrayBody.trim().startsWith(',')) {
      0|              arrayBody = arrayBody.trim().substring(1);
       |            }
      2|          } while (arrayBody.startsWith('{') || arrayBody.startsWith('['));
       |
      1|          if (arrayBody.isEmpty) return validity;
       |        }
       |
       |        // After confirmation the element is nor another array or objec
       |        // process the elements further as single pair's value
       |        String arrayElement;
      0|        commaIndex = arrayBody.indexOf(',');
       |
      0|        if (commaIndex > -1) {
      0|          arrayElement = arrayBody.trim().substring(0, commaIndex);
       |        } else {
      0|          arrayElement = arrayBody.substring(0);
       |        }
       |        // there is no nesting - verify the element
      0|        retval = await _getValueObject(arrayElement);
       |
       |        // Cut out the first element
      0|        arrayBody = arrayBody.trim().substring(commaIndex + 1);
      0|        if (retval == 'invalid') {
       |          validity = false;
       |          break;
      0|        } else if (commaIndex == -1 && retval != 'invalid') {
       |          validity = true;
       |        }
      0|      } while (commaIndex != -1);
       |
       |      // Return the final validation result
       |      return validity;
       |    }
       |
       |    /// verify for numbers
       |    ///
      1|    String _isNum() {
      2|      if (commaIndex == -1) {
       |        try {
      3|          num.parse(restValue.trim()).toString();
       |          return restValue;
       |        } catch (e) {
       |          return 'invalid';
       |        }
       |      } else {
       |        try {
      0|          return num.parse(restValue.substring(0, commaIndex)).toString();
       |        } catch (e) {
       |          return 'invalid';
       |        }
       |      }
       |    }
       |
       |    /// handle True, False and Null values
       |    ///
      0|    String _handleTFN() {
      0|      if (commaIndex == -1) {
      0|        if (['true', 'false', 'null'].contains(restValue)) {
       |          result = restValue;
       |        } else {
       |          result = 'invalid';
       |        }
       |      } else {
      0|        result = restValue.substring(0, commaIndex);
       |      }
       |      return result;
       |    }
       |
       |    /// handle values with suroundings double quotes
       |    ///
      1|    String _handleDQ() {
       |      // This is the last token - no comma till the end of the string;
      2|      if (commaIndex == -1) {
       |        // Check for proper surounding double quotes
      3|        if (_getSuroundingChars(restValue.trim()) == '""') {
       |          result = restValue;
       |        } else {
       |          return 'invalid';
       |        }
       |      } else {
      2|        var _extVal = restValue.trim().substring(0, commaIndex);
      2|        if (_getSuroundingChars(_extVal) == '""') {
       |          result = _extVal;
       |        } else {
       |          return 'invalid';
       |        }
       |      }
       |      return result;
       |    }
       |
       |    /// handle ARRAYS / OBJECTS as value from the token
       |    ///
       |    /// Objects
       |    ///
       |    /// An object structure is represented as a pair of curly brackets
       |    /// surrounding zero or more name/value pairs (or members).  A name is a
       |    /// string.  A single colon comes after each name, separating the name
       |    /// from the value.  A single comma separates a value from a following
       |    /// name.  The names within an object SHOULD be unique.
       |    ///
       |    ///  object = begin-object [ member *( value-separator member ) ]
       |    ///           end-object
       |    ///  member = string name-separator value
       |    ///
      0|    Future<String> _handleObject() async {
       |      // Invalidate smaller and not valid
      0|      if (restValue.length == 1 ||
      0|          (restValue.length == 2 && restValue != '{}')) {
       |        return 'invalid';
       |      }
       |
      0|      var parsedObject = _parseEnclosure('{');
       |
       |      // Redefining commaIndex for the comma located after the last closing bracket
      0|      commaIndex = restValue.indexOf(',', parsedObject.length);
       |
       |      // Validate an object and return BOOL for its validity
      0|      if (await _validateObject(parsedObject)) {
      0|        if (commaIndex == -1) {
       |          // Successfully verified object as last pair's value
       |          return '';
       |        } else {
       |          // If the object is valid, but there is remaining part after it - return it
      0|          return restValue.substring(commaIndex + 1).trim();
       |        }
       |      } else {
       |        return 'invalid';
       |      }
       |    }
       |
       |    /// Arrays
       |    ///
       |    /// An array structure is represented as square brackets surrounding zero
       |    /// or more values (or elements).  Elements are separated by commas.
       |    ///
       |    ///  array = begin-array [ value *( value-separator value ) ] end-array
       |    ///
       |    /// There is no requirement that the values in an array be of the same
       |    /// type.
      1|    Future<String> _handleArray() async {
       |      // Identify an empty array ( 0 elements, allowed by the standard)
      1|      if (restValue.startsWith('[') &&
      1|          restValue.endsWith(']') &&
      2|          restValue.length == 2) return '';
       |
      1|      var parsedArray = _parseEnclosure('[');
       |
      1|      if (parsedArray == 'invalid') return 'invalid';
       |
       |      // Redefining commaIndex for the comma located after the last closing bracket
      2|      commaIndex = restValue.indexOf(',', parsedArray.length);
       |
       |      // Validate an array and return BOOL for its validity
      2|      if (await _validateArray(parsedArray)) {
      2|        if (commaIndex == -1) {
       |          // Successfully verified array as last pair's value
       |          return '';
       |        } else {
       |          // If the array is valid, but there is remaining part after it - return it
      0|          return restValue.substring(commaIndex + 1).trim();
       |        }
       |      } else {
       |        return 'invalid';
       |      }
       |    }
       |
       |    // <<<<================================================================>>>>
       |
       |    /// Getting the lead char of the provided restValue
      1|    if (restValue.isEmpty) return '';
      2|    var leadChar = restValue.trim().substring(0, 1);
       |    switch (leadChar) {
      1|      case '"':
      1|        result = _handleDQ();
       |        break;
      1|      case '[':
      2|        result = await _handleArray();
       |        break;
      1|      case '{':
      0|        result = await _handleObject();
       |        break;
      1|      case 't':
      0|        result = _handleTFN();
       |        break;
      1|      case 'f':
      0|        result = _handleTFN();
       |        break;
      1|      case 'n':
      0|        result = _handleTFN();
       |        break;
       |      default:
      2|        if (leadChar.isEmpty || leadChar == ',') {
       |          result = 'invalid';
       |          break;
       |        }
      1|        result = _isNum();
       |        break;
       |    }
       |    return result;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/uuid_type-1.1.1/lib/src/generators.dart
       |// Copyright (c) 2018-2020, Denis Portnov. All rights reserved.
       |// Released under MIT License that can be found in the LICENSE file.
       |
       |library uuid_type.generators;
       |
       |import 'dart:convert' show utf8;
       |import 'dart:math' show Random;
       |import 'dart:typed_data' show Uint8List;
       |import 'package:crypto/crypto.dart' show Hash, sha1;
       |import 'uuid.dart';
       |
       |/// Generator of time-based v1 UUIDs
       |///
       |///
       |class TimeBasedUuidGenerator {
       |  // offset between Gregorian and Unix epochs in milliseconds
       |  static const int _epochOffset = (2440587 - 2299160) * 86400 * 1000;
       |
       |  // RNG used for creating random node & clock sequence
      3|  static final _rng = Random();
       |
       |  //
      3|  static final Stopwatch _sw = Stopwatch();
       |
       |  /// Frequency of the system clock used by this generator
      4|  static final int clockFrequency = _sw.frequency;
       |
       |  // how many ticks system's clock can generate per millisecond
       |  // TODO: notes on firefox (and safari?) weird behaviour
      4|  static final int _ticksPerMillis = clockFrequency ~/ 1000;
       |
       |  // same but per 100ns interval, round up to 1 for low-res system clock
      2|  static final int _ticksPer100Ns =
      4|      (clockFrequency < 10000000) ? 1 : clockFrequency ~/ 10000000;
       |
       |  // "zero" point in time from which all timestamps are calculated
       |  final int _zeroMs = DateTime.now().millisecondsSinceEpoch + _epochOffset;
       |
       |  // clock sequence, initialized with random value
       |  int _clockSeq = _rng.nextInt(1 << 14);
       |
       |  // system clock ticks when last generated UUID
       |  int _lastTicks = 0;
       |
       |  // additional 100ns intervals for low-res clocks
       |  int _extraIntervals = 0;
       |
       |  // 6 bytes of node ID
       |  final Uint8List _nodeId;
       |
       |  //
       |  final Uint8List _byteBuffer = Uint8List(16);
       |
       |  // validate or get new random node ID
      1|  static Uint8List _getValidNodeId(Uint8List nodeId) {
       |    if (nodeId != null) {
      0|      if (nodeId.length != 6) {
      0|        throw ArgumentError("Node Id length should be 6 bytes");
       |      }
       |    } else {
      1|      nodeId = Uint8List(6);
      2|      int u = _rng.nextInt(0xFFFFFFFF);
      3|      nodeId[0] = (u >> 24) | 0x01; // | multicast bit
      2|      nodeId[1] = u >> 16;
      2|      nodeId[2] = u >> 8;
      1|      nodeId[3] = u;
      2|      u = _rng.nextInt(0xFFFF);
      2|      nodeId[4] = u >> 8;
      1|      nodeId[5] = u;
       |    }
       |
       |    return nodeId;
       |  }
       |
       |  /// Creates new time-based generator
       |  ///
       |  /// Clock sequence is initialized with random 14 bit value. If no [nodeId]
       |  /// is provided, it generates random 6 byte node ID
      1|  TimeBasedUuidGenerator([Uint8List nodeId, @deprecated int clockSequence])
      1|      : _nodeId = _getValidNodeId(nodeId) {
       |    // make sure stopwatch is started
      2|    _sw.reset();
      2|    _sw.start();
       |
       |    // init buffer with node ID bytes
      2|    for (int i = 0; i < 6; i++) {
      5|      _byteBuffer[10 + i] = _nodeId[i];
       |    }
       |  }
       |
       |  /// Creates new generator from previously generated [state] UUID.
       |  ///
       |  /// It takes clock sequence and node ID from provided [state].
       |  /// If timestamp of [state] is ahead of current time, clock sequence is
       |  /// increased see (
       |  /// RFC 4122 4.2.1)[https://tools.ietf.org/html/rfc4122#section-4.2.1]
      0|  factory TimeBasedUuidGenerator.fromLastUuid(Uuid state) {
      0|    if (state.version != 1) {
      0|      throw ArgumentError.value(
      0|          state.version, "version", "UUID is not time-based");
       |    }
       |
      0|    var sb = state.bytes;
       |
      0|    final nodeId = Uint8List(6);
      0|    for (int i = 0; i < 6; i++) {
      0|      nodeId[i] = sb[10 + i];
       |    }
       |
       |    // create generator and get timestamp from it
      0|    var g = TimeBasedUuidGenerator(nodeId);
      0|    var gb = g.generate().bytes;
       |
       |    // timestamp of the state UUID
      0|    int utl = (sb[0] << 24) | (sb[1] << 16) | (sb[2] << 8) | sb[3];
      0|    int utmh = (sb[4] << 8) | sb[5] | ((sb[6] << 24) & 0x0F) | (sb[7] << 16);
       |
       |    // timestamp of newly generated UUID
      0|    int gtl = (gb[0] << 24) | (gb[1] << 16) | (gb[2] << 8) | gb[3];
      0|    int gtmh = (gb[4] << 8) | gb[5] | ((gb[6] << 24) & 0x0F) | (gb[7] << 16);
       |
      0|    var clockSeq = ((sb[8] << 8) | sb[9]) & 0x3FFF;
       |
       |    // if state is ahead of this generator, bump up clock sequence
      0|    if ((gtmh & 0xFFFF) - (utmh & 0xFFFF) < 0 ||
      0|        (gtmh >> 16) - (utmh >> 16) < 0 ||
      0|        (gtl - utl) < 0) {
      0|      clockSeq++;
      0|      clockSeq &= 0x3FFF;
       |    }
       |
      0|    g._clockSeq = clockSeq;
       |
       |    return g;
       |  }
       |
       |  /// Returns current clock sequence for this generator
      0|  int get clockSequence => _clockSeq;
       |
       |  /// Returns Node ID for this generator
      0|  Uint8List get nodeId => Uint8List.fromList(_nodeId);
       |
       |  /// Generates UUID for current time
      1|  Uuid generate() {
      2|    int ticks = _sw.elapsedTicks;
      2|    int dt = ticks - _lastTicks;
       |
      1|    if (dt == 0) {
       |      // account for low res clocks
       |      // same tick, bump extra ticks counter
      0|      ++_extraIntervals;
       |    } else {
      1|      if (dt < 0) {
       |        // clock regression, bump clock sequence
      0|        _clockSeq++;
      0|        _clockSeq &= 0x3FFF;
       |      }
      1|      _lastTicks = ticks;
      1|      _extraIntervals = 0;
       |    }
       |
      2|    var ms = (ticks ~/ _ticksPerMillis);
       |    var nsint =
      7|        (ticks - ms * _ticksPerMillis) ~/ _ticksPer100Ns + _extraIntervals;
       |
       |    int timeLo, timeMidHi;
       |    // compiler trick for faster math in Dart VM vs JS
      2|    if ((1 << 32) != 0) {
       |      // timestamp in 100ns intervals
      4|      var ts = (_zeroMs + ms) * 10000 + nsint;
      1|      timeLo = ts & 0xFFFFFFFF;
      1|      timeMidHi = ts >> 32;
       |    } else {
      0|      ms += _zeroMs;
      0|      timeLo = ((ms & 0xFFFFFFF) * 10000 + nsint) % 0x100000000;
      0|      timeMidHi = (ms ~/ 0x100000000 * 10000) & 0xFFFFFFF;
       |    }
       |
      3|    _byteBuffer[0] = timeLo >> 24;
      3|    _byteBuffer[1] = timeLo >> 16;
      3|    _byteBuffer[2] = timeLo >> 8;
      2|    _byteBuffer[3] = timeLo;
      3|    _byteBuffer[4] = timeMidHi >> 8;
      2|    _byteBuffer[5] = timeMidHi;
      5|    _byteBuffer[6] = ((timeMidHi >> 24) & 0x0F) | 0x10; // version 1
      3|    _byteBuffer[7] = timeMidHi >> 16;
      6|    _byteBuffer[8] = ((_clockSeq >> 8) & 0x3F) | 0x80; // variant 1
      3|    _byteBuffer[9] = _clockSeq;
       |    // bytes (10-15) are already set with NodeId bytes
       |
      2|    return Uuid.fromBytes(_byteBuffer);
       |  }
       |}
       |
       |/// Generator for namespace and name-based UUIDs (v5)
       |/// Only SHA1 is supported, MD5 is deprecated
       |class NameBasedUuidGenerator {
       |  /// Name space IDs for some potentially interesting name spaces see
       |  /// [RFC 4122 Appendix C](https://tools.ietf.org/html/rfc4122#appendix-C)
       |
       |  /// Name space for DNS
      0|  static final namespaceDns = Uuid("6ba7b810-9dad-11d1-80b4-00c04fd430c8");
       |
       |  /// Name space for URL
      0|  static final namespaceUrl = Uuid("6ba7b811-9dad-11d1-80b4-00c04fd430c8");
       |
       |  /// Name space for ISO OID
      0|  static final namespaceOid = Uuid("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
       |
       |  /// Name space for X.500 DN
      0|  static final namespaceX500 = Uuid("6ba7b814-9dad-11d1-80b4-00c04fd430c8");
       |
       |  /// `Hash` instance, only `hash.sha1` is supported.
      0|  static final Hash hash = sha1;
       |
       |  // namespace bytes
       |  final Uint8List _nsBytes;
       |
       |  /// Creates generator for [namespace]
      0|  NameBasedUuidGenerator(Uuid namespace) : _nsBytes = namespace.bytes;
       |
       |  /// Returns namespace [Uuid] for this generator
      0|  Uuid get namespace => Uuid.fromBytes(_nsBytes);
       |
       |  //
      0|  static final Uint8List _byteBuffer = Uint8List(16);
       |
       |  /// Generates name-based v5 UUID for [name]
      0|  Uuid generate(String name) {
       |    assert(name != null);
       |
      0|    var digest = hash.convert(_nsBytes + utf8.encode(name)).bytes;
       |    assert(digest.length >= 16);
       |
      0|    for (int i = 0; i < 16; ++i) {
      0|      _byteBuffer[i] = digest[i];
       |    }
       |
      0|    _byteBuffer[8] = (_byteBuffer[8] & 0xBF) | 0x80; // variant 1
      0|    _byteBuffer[6] = (_byteBuffer[6] & 0x0F) | 0x50; // version 5
       |
      0|    return Uuid.fromBytes(_byteBuffer);
       |  }
       |
       |  /// Returns new [NameBasedUuidGenerator] for [namespace]
      0|  NameBasedUuidGenerator withNamespace(Uuid namespace) =>
      0|      NameBasedUuidGenerator(namespace);
       |}
       |
       |/// Generator for random-based UUIDs (v4)
       |class RandomBasedUuidGenerator {
       |  /// Random number generator. By default it uses secure RNG returned
       |  /// by [Random.secure]
       |  final Random rng;
       |
       |  /// Creates instance of generator
       |  ///
       |  /// If no [rng] provided, it uses secure random generator returned by `math`
       |  /// [Random.secure]
      0|  RandomBasedUuidGenerator([Random rng]) : rng = rng ?? Random.secure();
       |
       |  // shared byte buffer for UUIDs created by this generator
      0|  static final Uint8List _byteBuffer = Uint8List(16);
       |
       |  /// Generates random-based v4 UUID
      0|  Uuid generate() {
       |    int u32;
      0|    for (int i = 0; i < 4; i++) {
      0|      u32 = rng.nextInt(0xFFFFFFFF);
       |
      0|      _byteBuffer[i * 4] = (u32 >> 24);
      0|      _byteBuffer[i * 4 + 1] = (u32 >> 16);
      0|      _byteBuffer[i * 4 + 2] = (u32 >> 8);
      0|      _byteBuffer[i * 4 + 3] = u32;
       |    }
       |
      0|    _byteBuffer[8] = (_byteBuffer[8] & 0x3F) | 0x80; // variant 1
      0|    _byteBuffer[6] = (_byteBuffer[6] & 0x0F) | 0x40; // version 4
       |
      0|    return Uuid.fromBytes(_byteBuffer);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/uuid_type-1.1.1/lib/src/util.dart
       |// Copyright (c) 2018-2020, Denis Portnov. All rights reserved.
       |// Released under MIT License that can be found in the LICENSE file.
       |
       |library uuid_type.util;
       |
       |import 'dart:typed_data' show Uint8List;
       |import 'generators.dart';
       |import 'uuid.dart';
       |
       |/// Canonical instance of UUID utility class
      3|final uuid = UuidUtil._();
       |
       |/// UUID utility class for convinient UUID string gemeration
       |class UuidUtil {
       |
      1|  const UuidUtil._();
       |
       |  /// Generates time-based UUID string
      1|  String v1([Uint8List nodeId]) {
      3|    return TimeBasedUuidGenerator(nodeId).generate().toString();
       |  }
       |
       |  /// Generates random-based UUID string
      0|  String v4() {
      0|    return RandomBasedUuidGenerator().generate().toString();
       |  }
       |
       |  /// Generates name-based UUID string
      0|  String v5(String namespace, String name) {
      0|    return NameBasedUuidGenerator(Uuid(namespace)).generate(name).toString();
       |  }
       |  
       |  /// Compares to UUID strings 
      0|  int compare(String uuid1, String uuid2) {
      0|    return Uuid(uuid1).compareTo(Uuid(uuid2));
       |  }
       |
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/uuid_type-1.1.1/lib/src/uuid.dart
       |// Copyright (c) 2018-2020, Denis Portnov. All rights reserved.
       |// Released under MIT License that can be found in the LICENSE file.
       |
       |library uuid_type;
       |
       |import 'dart:typed_data' show Uint8List;
       |
       |/// UUID variant according to RFC4122
      1|enum Variant {
       |  /// Reserved, NCS backward compatibility.
      1|  ncs,
       |
       |  /// The variant specified in RFC 4122
      1|  rfc4122,
       |
       |  /// Reserved, Microsoft Corporation backward compatibility.
      1|  microsoft,
       |
       |  /// Reserved for future definition
      1|  future
       |}
       |
       |/// This object represents an UUID, 128 bit Universal Unique Identifier
       |/// as defined in [RFC 4122](https://tools.ietf.org/html/rfc4122).
       |abstract class Uuid implements Comparable<Uuid> {
       |  /// Nil UUID
       |  /// (see [RFC 4122 4.1.7](https://tools.ietf.org/html/rfc4122#section-4.1.7))
      3|  static Uuid get nil => Uuid.fromBytes(Uint8List(16));
       |
       |  /// Creates a new [Uuid] from canonical string representation
       |  ///
       |  /// If argument is not a valid UUID string `FormatException` is thrown.
       |  /// For parsing various UUID formats use [Uuid.parse]
      1|  factory Uuid(String source) {
      1|    var e = _parseCanonical(source);
       |    if (e != null) throw e;
       |
      2|    return Uuid.fromBytes(_byteBuffer);
       |  }
       |
       |  /// Creates [Uuid] from byte array
       |  ///
       |  /// Optional [offset] is used to read 16 bytes of UUID from larger arrays
       |  /// Would return [Uuid.nil] when zero byte array is provided
       |  factory Uuid.fromBytes(Uint8List bytes, [int offset]) = _Uuid.fromBytes;
       |
       |  /// Byte array representing this UUID
       |  Uint8List get bytes;
       |
       |  @override
       |  int get hashCode;
       |
       |  /// Variant defined in
       |  /// [RFC 4122](https://tools.ietf.org/html/rfc4122#section-4.1.1)
       |  Variant get variant;
       |
       |  /// Version defined in
       |  /// [RFC 4122](https://tools.ietf.org/html/rfc4122#section-4.1.3)
       |  int get version;
       |
       |  @override
       |  bool operator ==(Object other);
       |
       |  /// Greater than operator,  see [compareTo] for rules
       |  bool operator >(Uuid other);
       |
       |  /// Greater than or equal operator, see [compareTo] for rules
       |  bool operator >=(Uuid other);
       |
       |  /// Less than operator, see [compareTo] for rules
       |  bool operator <(Uuid other);
       |
       |  /// Less than or equal operator, see [compareTo] for rules
       |  bool operator <=(Uuid other);
       |
       |  /// Compares this UUID to another [Uuid]
       |  ///
       |  /// First, compares by version
       |  /// then, if it's time-based v1 UUID, compares timestamps,
       |  /// then compares all bytes lexically
      0|  @override
       |  int compareTo(Uuid other) {
      0|    int ver = version;
      0|    int diff = ver - other.version;
      0|    if (diff != 0) return diff;
       |
      0|    var a = bytes;
      0|    var b = other.bytes;
       |
      0|    if (ver == 1) {
      0|      for (int pos in const <int>[7, 4, 5, 0, 1, 2, 3]) {
      0|        diff = a[pos] - b[pos];
      0|        if (diff != 0) return diff;
       |      }
       |      return 0;
       |    }
       |
      0|    for (int pos = 0; pos < 16; pos++) {
      0|      diff = a[pos] - b[pos];
      0|      if (diff != 0) return diff;
       |    }
       |
       |    return 0;
       |  }
       |
       |  /// Returns canonical string representation
       |  @override
       |  String toString();
       |
       |  // parses 2 hex chars into one byte
       |  // returns value < 0 if parsing fails
      1|  static int _parseHexByte(int c1, int c2) {
       |    const List<int> hexBytes = <int>[
       |      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, //
       |      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       |      0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
       |      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       |      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       |      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
       |      0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
       |    ];
       |
      1|    c1 -= 0x30;
      3|    if (c1 < 0 || c1 >= hexBytes.length) return -2;
       |
      1|    c2 -= 0x30;
      3|    if (c2 < 0 || c2 >= hexBytes.length) return -1;
       |
      1|    int b1 = hexBytes[c1];
      1|    if (b1 == 0xFF) return -2;
       |
      1|    int b2 = hexBytes[c2];
      1|    if (b2 == 0xFF) return -1;
       |
      2|    return (b1 << 4) | b2;
       |  }
       |
       |  /// Shared buffer for byte representation for all instances
      3|  static final _byteBuffer = Uint8List(16);
       |
       |  // parses canonical UUID string
      1|  static FormatException _parseCanonical(String source) {
       |    const bytePositions = <int>[
       |      0, 2, 4, 6, 9, 11, 14, 16, 19, 21, 24, 26, 28, 30, 32, 34 //
       |    ];
       |    const dashPositions = <int>[8, 13, 18, 23];
       |
      2|    if (source.length != 36) {
      0|      return FormatException(
      0|          "UUID string has invalid length (${source.length})", source);
       |    }
       |
      1|    var chars = source.codeUnits;
       |
       |    // check '-' positions
      2|    for (int pos in dashPositions) {
      2|      if (chars[pos] != 0x2D) {
      0|        return FormatException("Separator char expected", source, pos);
       |      }
       |    }
       |
       |    int i = 0;
      2|    for (int pos in bytePositions) {
      4|      int b = _parseHexByte(chars[pos], chars[pos + 1]);
      1|      if (b < 0) {
      0|        return FormatException("Invalid hex char", source, pos + b + 2);
       |      }
      3|      _byteBuffer[i++] = b;
       |    }
       |
       |    return null;
       |  }
       |
       |  // Fills _byteBuffer with bytes decoded from hex
       |  // returns FormatException if parsing fails
      0|  static FormatException _parse(String source) {
      0|    if (source.length == 36) {
      0|      return _parseCanonical(source);
      0|    } else if (source.length == 1 + 36 + 1) {
       |      // GUID
      0|      if (!(source[0] == '{' && source[source.length - 1] == '}')) {
      0|        return FormatException("Invalid GUID string", source);
       |      }
      0|      return _parseCanonical(source.substring(1, source.length - 1));
      0|    } else if (source.length == 1 + 32 + 1) {
       |      // hex GUID
      0|      if (!(source[0] == '{' && source[source.length - 1] == '}')) {
      0|        return FormatException("Invalid GUID string", source);
       |      }
      0|      source = source.substring(1, source.length - 1);
      0|    } else if (source.length == 9 + 36) {
       |      // URN
      0|      if (!source.startsWith('urn:uuid:')) {
      0|        return FormatException("Invalid UUID URN string", source);
       |      }
      0|      return _parseCanonical(source.substring(9));
       |    }
       |
      0|    if (source.length != 32) {
      0|      return FormatException("Invalid UUID hex string length", source);
       |    }
       |
       |    // parse 32-char hex
       |
      0|    var chars = source.codeUnits;
       |
      0|    for (int i = 0; i < 16; i++) {
      0|      int b = _parseHexByte(chars[2 * i], chars[2 * i + 1]);
      0|      if (b < 0) {
      0|        return FormatException("Invalid hex char", source, 2 * i + b + 2);
       |      }
      0|      _byteBuffer[i] = b;
       |    }
       |
       |    return null;
       |  }
       |
       |  /// Parses [source] string as [Uuid]. Parsing is case insensitive.
       |  ///
       |  /// Throws [FormatException] in case of invalid UUID representation
       |  ///
       |  /// The [source] must be in one of the following UUID formats
       |  /// - Canonical string: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxx
       |  /// - Hex string (36 chars): xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
       |  /// - URN: urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxx
       |  /// - Canonical GUID: {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxx}
       |  /// - Hex GUID: {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}
      0|  static Uuid parse(String source) {
      0|    var e = _parse(source);
       |    if (e != null) throw e;
      0|    return Uuid.fromBytes(_byteBuffer);
       |  }
       |
       |  /// Parses [source] as [Uuid]. Parsing is case insensitive.
       |  ///
       |  /// Like [parse] except it returns `null` for invalid inputs
       |  //  instead of throwing.
      0|  static Uuid tryParse(String source) {
      0|    if (_parse(source) != null) return null;
      0|    return Uuid.fromBytes(_byteBuffer);
       |  }
       |}
       |
       |class _Uuid implements Uuid {
       |  static const nil = _Uuid._(0, 0, 0, 0);
       |
       |  // Buffer to hold 36 chars of canonical string representation
      3|  static final Uint8List _stringBuffer = Uint8List.fromList(const <int>[
       |    0, 0, 0, 0, 0, 0, 0, 0, 0x2D, //
       |    0, 0, 0, 0, 0x2D,
       |    0, 0, 0, 0, 0x2D,
       |    0, 0, 0, 0, 0x2D,
       |    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
       |  ]); // time_low
       |
       |  // UUID is stored as 4 x 32bit unsigned integers
       |  final int x; // time_low
       |  final int y; // time_mid | time_hi_and_version
       |  final int z; // clk_seq_hi_res | clk_seq_low | node (0-1)
       |  final int w; // node (2-5)
       |
       |  /// Implements [Uuid.fromBytes]
      1|  factory _Uuid.fromBytes(Uint8List bytes, [int offset = 0]) {
       |    assert(bytes != null);
       |
      4|    if (offset < 0 || (offset + 16 > bytes.length)) {
      0|      throw ArgumentError('Invalid offset');
       |    }
       |
      3|    int x = (bytes[offset] << 24) |
      4|        (bytes[offset + 1] << 16) |
      4|        (bytes[offset + 2] << 8) |
      2|        bytes[offset + 3];
      4|    int y = (bytes[offset + 4] << 24) |
      4|        (bytes[offset + 5] << 16) |
      4|        (bytes[offset + 6] << 8) |
      2|        bytes[offset + 7];
      4|    int z = (bytes[offset + 8] << 24) |
      4|        (bytes[offset + 9] << 16) |
      4|        (bytes[offset + 10] << 8) |
      2|        bytes[offset + 11];
      4|    int w = (bytes[offset + 12] << 24) |
      4|        (bytes[offset + 13] << 16) |
      4|        (bytes[offset + 14] << 8) |
      2|        bytes[offset + 15];
       |
      4|    if ((y | z | x | w) == 0) return nil;
       |
      1|    return _Uuid._(x, y, z, w);
       |  }
       |
      1|  const _Uuid._(this.x, this.y, this.z, this.w);
       |
      0|  @override
      0|  Uint8List get bytes => Uint8List.fromList(<int>[
      0|        x >> 24, x >> 16, x >> 8, x, //
      0|        y >> 24, y >> 16, y >> 8, y,
      0|        z >> 24, z >> 16, z >> 8, z,
      0|        w >> 24, w >> 16, w >> 8, w,
       |      ]);
       |
      0|  @override
       |  Variant get variant {
       |    assert((z >> 29) >= 0 && (z >> 29) <= 7);
       |
       |    const variants = <Variant>[
       |      Variant.ncs, // 0 0 0
       |      Variant.ncs, // 0 0 1
       |      Variant.ncs, // 0 1 0
       |      Variant.ncs, // 0 1 1
       |      Variant.rfc4122, // 1 0 0
       |      Variant.rfc4122, // 1 0 1
       |      Variant.microsoft, // 1 1 0
       |      Variant.future, // 1 1 1
       |    ];
       |
      0|    return variants[z >> 29];
       |  }
       |
      0|  @override
      0|  int get version => (y & 0xF000) >> 12;
       |
      0|  @override
      0|  int get hashCode => (x ^ y) ^ (z ^ w);
       |
      0|  @override
       |  bool operator ==(Object other) {
       |    if (identical(this, other)) return true;
      0|    if (other is _Uuid &&
      0|        x == other.x &&
      0|        y == other.y &&
      0|        z == other.z &&
      0|        w == other.w) {
       |      return true;
      0|    } else if (other is Uuid) {
      0|      return compareTo(other) == 0;
       |    }
       |    return false;
       |  }
       |
      0|  @override
      0|  bool operator >(Uuid other) => compareTo(other) > 0;
       |
      0|  @override
      0|  bool operator >=(Uuid other) => compareTo(other) >= 0;
       |
      0|  @override
      0|  bool operator <(Uuid other) => compareTo(other) < 0;
       |
      0|  @override
      0|  bool operator <=(Uuid other) => compareTo(other) <= 0;
       |
      0|  @override
       |  int compareTo(Uuid other) {
      0|    int ver = version;
       |
      0|    int diff = ver - other.version;
      0|    if (diff != 0) return diff;
       |
      0|    if (other is _Uuid) {
       |      // compare timestamps for v1 UUIDs
      0|      if (ver == 1) {
       |        // time hi
      0|        diff = (y & 0xFFFF) - (other.y & 0xFFFF);
      0|        if (diff != 0) return diff;
       |
       |        // time mid
      0|        diff = (y >> 16) - (other.y >> 16);
      0|        if (diff != 0) return diff;
       |
       |        // time lo
      0|        diff = x - other.x;
      0|        if (diff != 0) return diff;
       |      } else {
      0|        diff = x - other.x;
      0|        if (diff != 0) return diff;
       |
      0|        diff = y - other.y;
      0|        if (diff != 0) return diff;
       |      }
       |
      0|      diff = z - other.z;
      0|      if (diff != 0) return diff;
       |
      0|      diff = w - other.w;
      0|      if (diff != 0) return diff;
       |
       |      return 0;
       |    }
       |
      0|    return -1 * other.compareTo(this);
       |  }
       |
      1|  @override
       |  String toString() {
       |    const List<int> hexcu = <int>[
       |      0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, //
       |      0x61, 0x62, 0x63, 0x64, 0x65, 0x66
       |    ];
       |
      7|    _stringBuffer[0] = hexcu[((x >> 24) & 0xFF) >> 4];
      6|    _stringBuffer[1] = hexcu[(x >> 24) & 0x0F];
      7|    _stringBuffer[2] = hexcu[((x >> 16) & 0xFF) >> 4];
      6|    _stringBuffer[3] = hexcu[(x >> 16) & 0x0F];
      7|    _stringBuffer[4] = hexcu[((x >> 8) & 0xFF) >> 4];
      6|    _stringBuffer[5] = hexcu[(x >> 8) & 0x0F];
      6|    _stringBuffer[6] = hexcu[(x & 0xFF) >> 4];
      5|    _stringBuffer[7] = hexcu[x & 0x0F];
       |
      7|    _stringBuffer[9] = hexcu[((y >> 24) & 0xFF) >> 4];
      6|    _stringBuffer[10] = hexcu[(y >> 24) & 0x0F];
      7|    _stringBuffer[11] = hexcu[((y >> 16) & 0xFF) >> 4];
      6|    _stringBuffer[12] = hexcu[(y >> 16) & 0x0F];
       |
      7|    _stringBuffer[14] = hexcu[((y >> 8) & 0xFF) >> 4];
      6|    _stringBuffer[15] = hexcu[(y >> 8) & 0x0F];
      6|    _stringBuffer[16] = hexcu[(y & 0xFF) >> 4];
      5|    _stringBuffer[17] = hexcu[y & 0x0F];
       |
      7|    _stringBuffer[19] = hexcu[((z >> 24) & 0xFF) >> 4];
      6|    _stringBuffer[20] = hexcu[(z >> 24) & 0x0F];
      7|    _stringBuffer[21] = hexcu[((z >> 16) & 0xFF) >> 4];
      6|    _stringBuffer[22] = hexcu[(z >> 16) & 0x0F];
       |
      7|    _stringBuffer[24] = hexcu[((z >> 8) & 0xFF) >> 4];
      6|    _stringBuffer[25] = hexcu[(z >> 8) & 0x0F];
      6|    _stringBuffer[26] = hexcu[(z & 0xFF) >> 4];
      5|    _stringBuffer[27] = hexcu[z & 0x0F];
      7|    _stringBuffer[28] = hexcu[((w >> 24) & 0xFF) >> 4];
      6|    _stringBuffer[29] = hexcu[(w >> 24) & 0x0F];
      7|    _stringBuffer[30] = hexcu[((w >> 16) & 0xFF) >> 4];
      6|    _stringBuffer[31] = hexcu[(w >> 16) & 0x0F];
      7|    _stringBuffer[32] = hexcu[((w >> 8) & 0xFF) >> 4];
      6|    _stringBuffer[33] = hexcu[(w >> 8) & 0x0F];
      6|    _stringBuffer[34] = hexcu[(w & 0xFF) >> 4];
      5|    _stringBuffer[35] = hexcu[w & 0x0F];
       |
      2|    return String.fromCharCodes(_stringBuffer);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/digest.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'package:collection/collection.dart';
       |import 'package:convert/convert.dart';
       |
       |/// A message digest as computed by a `Hash` or `HMAC` function.
       |class Digest {
       |  /// The message digest as an array of bytes.
       |  final List<int> bytes;
       |
      0|  Digest(this.bytes);
       |
       |  /// Returns whether this is equal to another digest.
       |  ///
       |  /// This should be used instead of manual comparisons to avoid leaking
       |  /// information via timing.
      0|  @override
       |  bool operator ==(Object other) {
      0|    if (other is Digest) {
      0|      final a = bytes;
      0|      final b = other.bytes;
      0|      if (a.length != b.length) {
       |        return false;
       |      }
      0|      final n = a.length;
       |      var mismatch = 0;
      0|      for (var i = 0; i < n; i++) {
      0|        mismatch |= a[i] ^ b[i];
       |      }
      0|      return mismatch == 0;
       |    }
       |    return false;
       |  }
       |
      0|  @override
      0|  int get hashCode => const ListEquality().hash(bytes);
       |
       |  /// The message digest as a string of hexadecimal digits.
      0|  @override
      0|  String toString() => hex.encode(bytes);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/hash.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |
       |import 'digest.dart';
       |import 'digest_sink.dart';
       |
       |/// An interface for cryptographic hash functions.
       |///
       |/// Every hash is a converter that takes a list of ints and returns a single
       |/// digest. When used in chunked mode, it will only ever add one digest to the
       |/// inner [Sink].
       |abstract class Hash extends Converter<List<int>, Digest> {
       |  /// The internal block size of the hash in bytes.
       |  ///
       |  /// This is exposed for use by the `Hmac` class, which needs to know the block
       |  /// size for the [Hash] it uses.
       |  int get blockSize;
       |
      0|  const Hash();
       |
      0|  @override
       |  Digest convert(List<int> data) {
      0|    var innerSink = DigestSink();
      0|    var outerSink = startChunkedConversion(innerSink);
      0|    outerSink.add(data);
      0|    outerSink.close();
      0|    return innerSink.value;
       |  }
       |
       |  @override
       |  ByteConversionSink startChunkedConversion(Sink<Digest> sink);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/hmac.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'digest.dart';
       |import 'digest_sink.dart';
       |import 'hash.dart';
       |
       |/// An implementation of [keyed-hash method authentication codes][rfc].
       |///
       |/// [rfc]: https://tools.ietf.org/html/rfc2104
       |///
       |/// HMAC allows messages to be cryptographically authenticated using any
       |/// iterated cryptographic hash function.
       |class Hmac extends Converter<List<int>, Digest> {
       |  /// The hash function used to compute the authentication digest.
       |  final Hash _hash;
       |
       |  /// The secret key shared by the sender and the receiver.
       |  final Uint8List _key;
       |
       |  /// Create an [Hmac] object from a [Hash] and a binary key.
       |  ///
       |  /// The key should be a secret shared between the sender and receiver of the
       |  /// message.
      0|  Hmac(Hash hash, List<int> key)
       |      : _hash = hash,
      0|        _key = Uint8List(hash.blockSize) {
       |    // Hash the key if it's longer than the block size of the hash.
      0|    if (key.length > _hash.blockSize) key = _hash.convert(key).bytes;
       |
       |    // If [key] is shorter than the block size, the rest of [_key] will be
       |    // 0-padded.
      0|    _key.setRange(0, key.length, key);
       |  }
       |
      0|  @override
       |  Digest convert(List<int> data) {
      0|    var innerSink = DigestSink();
      0|    var outerSink = startChunkedConversion(innerSink);
      0|    outerSink.add(data);
      0|    outerSink.close();
      0|    return innerSink.value;
       |  }
       |
      0|  @override
       |  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      0|      _HmacSink(sink, _hash, _key);
       |}
       |
       |/// The concrete implementation of the HMAC algorithm.
       |class _HmacSink extends ByteConversionSink {
       |  /// The sink for the outer hash computation.
       |  final ByteConversionSink _outerSink;
       |
       |  /// The sink that [_innerSink]'s result will be added to when it's available.
       |  final _innerResultSink = DigestSink();
       |
       |  /// The sink for the inner hash computation.
       |  ByteConversionSink _innerSink;
       |
       |  /// Whether [close] has been called.
       |  bool _isClosed = false;
       |
      0|  _HmacSink(Sink<Digest> sink, Hash hash, List<int> key)
      0|      : _outerSink = hash.startChunkedConversion(sink) {
      0|    _innerSink = hash.startChunkedConversion(_innerResultSink);
       |
       |    // Compute outer padding.
      0|    var padding = Uint8List(key.length);
      0|    for (var i = 0; i < padding.length; i++) {
      0|      padding[i] = 0x5c ^ key[i];
       |    }
      0|    _outerSink.add(padding);
       |
       |    // Compute inner padding.
      0|    for (var i = 0; i < padding.length; i++) {
      0|      padding[i] = 0x36 ^ key[i];
       |    }
      0|    _innerSink.add(padding);
       |  }
       |
      0|  @override
       |  void add(List<int> data) {
      0|    if (_isClosed) throw StateError('HMAC is closed');
      0|    _innerSink.add(data);
       |  }
       |
      0|  @override
       |  void addSlice(List<int> data, int start, int end, bool isLast) {
      0|    if (_isClosed) throw StateError('HMAC is closed');
      0|    _innerSink.addSlice(data, start, end, isLast);
       |  }
       |
      0|  @override
       |  void close() {
      0|    if (_isClosed) return;
      0|    _isClosed = true;
       |
      0|    _innerSink.close();
      0|    _outerSink.add(_innerResultSink.value.bytes);
      0|    _outerSink.close();
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/md5.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'digest.dart';
       |import 'hash.dart';
       |import 'hash_sink.dart';
       |import 'utils.dart';
       |
       |/// An instance of [MD5].
       |///
       |/// This instance provides convenient access to the [MD5][rfc] hash function.
       |///
       |/// [rfc]: https://tools.ietf.org/html/rfc1321
       |///
       |/// **Warning**: MD5 has known collisions and should only be used when required
       |/// for backwards compatibility.
      0|final md5 = MD5._();
       |
       |/// An implementation of the [MD5][rfc] hash function.
       |///
       |/// [rfc]: https://tools.ietf.org/html/rfc1321
       |///
       |/// **Warning**: MD5 has known collisions and should only be used when required
       |/// for backwards compatibility.
       |///
       |/// Note that it's almost always easier to use [md5] rather than creating a new
       |/// instance.
       |class MD5 extends Hash {
       |  @override
       |  final int blockSize = 16 * bytesPerWord;
       |
      0|  MD5._();
       |
      0|  @override
       |  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      0|      ByteConversionSink.from(_MD5Sink(sink));
       |}
       |
       |/// Data from a non-linear mathematical function that functions as
       |/// reproducible noise.
       |const _noise = [
       |  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, //
       |  0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
       |  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340,
       |  0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
       |  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8,
       |  0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
       |  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa,
       |  0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
       |  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92,
       |  0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
       |  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
       |];
       |
       |/// Per-round shift amounts.
       |const _shiftAmounts = [
       |  07, 12, 17, 22, 07, 12, 17, 22, 07, 12, 17, 22, 07, 12, 17, 22, 05, 09, 14, //
       |  20, 05, 09, 14, 20, 05, 09, 14, 20, 05, 09, 14, 20, 04, 11, 16, 23, 04, 11,
       |  16, 23, 04, 11, 16, 23, 04, 11, 16, 23, 06, 10, 15, 21, 06, 10, 15, 21, 06,
       |  10, 15, 21, 06, 10, 15, 21
       |];
       |
       |/// The concrete implementation of [MD5].
       |///
       |/// This is separate so that it can extend [HashSink] without leaking additional
       |/// public members.
       |class _MD5Sink extends HashSink {
       |  @override
       |  final digest = Uint32List(4);
       |
      0|  _MD5Sink(Sink<Digest> sink) : super(sink, 16, endian: Endian.little) {
      0|    digest[0] = 0x67452301;
      0|    digest[1] = 0xefcdab89;
      0|    digest[2] = 0x98badcfe;
      0|    digest[3] = 0x10325476;
       |  }
       |
      0|  @override
       |  void updateHash(Uint32List chunk) {
       |    assert(chunk.length == 16);
       |
      0|    var a = digest[0];
      0|    var b = digest[1];
      0|    var c = digest[2];
      0|    var d = digest[3];
       |
       |    int e;
       |    int f;
       |
      0|    for (var i = 0; i < 64; i++) {
      0|      if (i < 16) {
      0|        e = (b & c) | ((~b & mask32) & d);
       |        f = i;
      0|      } else if (i < 32) {
      0|        e = (d & b) | ((~d & mask32) & c);
      0|        f = ((5 * i) + 1) % 16;
      0|      } else if (i < 48) {
      0|        e = b ^ c ^ d;
      0|        f = ((3 * i) + 5) % 16;
       |      } else {
      0|        e = c ^ (b | (~d & mask32));
      0|        f = (7 * i) % 16;
       |      }
       |
       |      var temp = d;
       |      d = c;
       |      c = b;
      0|      b = add32(
       |          b,
      0|          rotl32(add32(add32(a, e), add32(_noise[i], chunk[f])),
      0|              _shiftAmounts[i]));
       |      a = temp;
       |    }
       |
      0|    digest[0] = add32(a, digest[0]);
      0|    digest[1] = add32(b, digest[1]);
      0|    digest[2] = add32(c, digest[2]);
      0|    digest[3] = add32(d, digest[3]);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/sha1.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'digest.dart';
       |import 'hash.dart';
       |import 'hash_sink.dart';
       |import 'utils.dart';
       |
       |/// An instance of [Sha1].
       |///
       |/// This instance provides convenient access to the [SHA-1][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc3174
      0|final sha1 = Sha1._();
       |
       |/// An implementation of the [SHA-1][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc3174
       |class Sha1 extends Hash {
       |  @override
       |  final int blockSize = 16 * bytesPerWord;
       |
      0|  Sha1._();
       |
      0|  @override
       |  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      0|      ByteConversionSink.from(_Sha1Sink(sink));
       |}
       |
       |/// The concrete implementation of [Sha1].
       |///
       |/// This is separate so that it can extend [HashSink] without leaking additional
       |/// public memebers.
       |class _Sha1Sink extends HashSink {
       |  @override
       |  final digest = Uint32List(5);
       |
       |  /// The sixteen words from the original chunk, extended to 80 words.
       |  ///
       |  /// This is an instance variable to avoid re-allocating, but its data isn't
       |  /// used across invocations of [updateHash].
       |  final Uint32List _extended;
       |
      0|  _Sha1Sink(Sink<Digest> sink)
      0|      : _extended = Uint32List(80),
      0|        super(sink, 16) {
      0|    digest[0] = 0x67452301;
      0|    digest[1] = 0xEFCDAB89;
      0|    digest[2] = 0x98BADCFE;
      0|    digest[3] = 0x10325476;
      0|    digest[4] = 0xC3D2E1F0;
       |  }
       |
      0|  @override
       |  void updateHash(Uint32List chunk) {
       |    assert(chunk.length == 16);
       |
      0|    var a = digest[0];
      0|    var b = digest[1];
      0|    var c = digest[2];
      0|    var d = digest[3];
      0|    var e = digest[4];
       |
      0|    for (var i = 0; i < 80; i++) {
      0|      if (i < 16) {
      0|        _extended[i] = chunk[i];
       |      } else {
      0|        _extended[i] = rotl32(
      0|            _extended[i - 3] ^
      0|                _extended[i - 8] ^
      0|                _extended[i - 14] ^
      0|                _extended[i - 16],
       |            1);
       |      }
       |
      0|      var newA = add32(add32(rotl32(a, 5), e), _extended[i]);
      0|      if (i < 20) {
      0|        newA = add32(add32(newA, (b & c) | (~b & d)), 0x5A827999);
      0|      } else if (i < 40) {
      0|        newA = add32(add32(newA, (b ^ c ^ d)), 0x6ED9EBA1);
      0|      } else if (i < 60) {
      0|        newA = add32(add32(newA, (b & c) | (b & d) | (c & d)), 0x8F1BBCDC);
       |      } else {
      0|        newA = add32(add32(newA, b ^ c ^ d), 0xCA62C1D6);
       |      }
       |
       |      e = d;
       |      d = c;
      0|      c = rotl32(b, 30);
       |      b = a;
      0|      a = newA & mask32;
       |    }
       |
      0|    digest[0] = add32(a, digest[0]);
      0|    digest[1] = add32(b, digest[1]);
      0|    digest[2] = add32(c, digest[2]);
      0|    digest[3] = add32(d, digest[3]);
      0|    digest[4] = add32(e, digest[4]);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/sha256.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'digest.dart';
       |import 'hash.dart';
       |import 'hash_sink.dart';
       |import 'utils.dart';
       |
       |/// An instance of [Sha256].
       |///
       |/// This instance provides convenient access to the [Sha256][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc6234
      0|final sha256 = Sha256._();
       |
       |/// An instance of [Sha224].
       |///
       |/// This instance provides convenient access to the [Sha224][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc6234
      0|final sha224 = Sha224._();
       |
       |/// An implementation of the [SHA-256][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc6234
       |///
       |/// Note that it's almost always easier to use [sha256] rather than creating a
       |/// new instance.
       |class Sha256 extends Hash {
       |  @override
       |  final int blockSize = 16 * bytesPerWord;
       |
      0|  Sha256._();
       |
      0|  Sha256 newInstance() => Sha256._();
       |
      0|  @override
       |  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      0|      ByteConversionSink.from(_Sha256Sink(sink));
       |}
       |
       |/// An implementation of the [SHA-224][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc6234
       |///
       |/// Note that it's almost always easier to use [sha224] rather than creating a
       |/// new instance.
       |class Sha224 extends Hash {
       |  @override
       |  final int blockSize = 16 * bytesPerWord;
       |
      0|  Sha224._();
       |
      0|  Sha224 newInstance() => Sha224._();
       |
      0|  @override
       |  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      0|      ByteConversionSink.from(_Sha224Sink(sink));
       |}
       |
       |/// Data from a non-linear function that functions as reproducible noise.
       |const List<int> _noise = [
       |  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, //
       |  0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
       |  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
       |  0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
       |  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
       |  0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
       |  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
       |  0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
       |  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
       |  0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
       |  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
       |];
       |
       |abstract class _Sha32BitSink extends HashSink {
       |  final Uint32List _digest;
       |
       |  /// The sixteen words from the original chunk, extended to 64 words.
       |  ///
       |  /// This is an instance variable to avoid re-allocating, but its data isn't
       |  /// used across invocations of [updateHash].
       |  final _extended = Uint32List(64);
       |
      0|  _Sha32BitSink(Sink<Digest> sink, this._digest) : super(sink, 16);
       |
       |  // The following helper functions are taken directly from
       |  // http://tools.ietf.org/html/rfc6234.
       |
      0|  int _rotr32(int n, int x) => (x >> n) | ((x << (32 - n)) & mask32);
      0|  int _ch(int x, int y, int z) => (x & y) ^ ((~x & mask32) & z);
      0|  int _maj(int x, int y, int z) => (x & y) ^ (x & z) ^ (y & z);
      0|  int _bsig0(int x) => _rotr32(2, x) ^ _rotr32(13, x) ^ _rotr32(22, x);
      0|  int _bsig1(int x) => _rotr32(6, x) ^ _rotr32(11, x) ^ _rotr32(25, x);
      0|  int _ssig0(int x) => _rotr32(7, x) ^ _rotr32(18, x) ^ (x >> 3);
      0|  int _ssig1(int x) => _rotr32(17, x) ^ _rotr32(19, x) ^ (x >> 10);
       |
      0|  @override
       |  void updateHash(Uint32List chunk) {
       |    assert(chunk.length == 16);
       |
       |    // Prepare message schedule.
      0|    for (var i = 0; i < 16; i++) {
      0|      _extended[i] = chunk[i];
       |    }
      0|    for (var i = 16; i < 64; i++) {
      0|      _extended[i] = add32(add32(_ssig1(_extended[i - 2]), _extended[i - 7]),
      0|          add32(_ssig0(_extended[i - 15]), _extended[i - 16]));
       |    }
       |
       |    // Shuffle around the bits.
      0|    var a = _digest[0];
      0|    var b = _digest[1];
      0|    var c = _digest[2];
      0|    var d = _digest[3];
      0|    var e = _digest[4];
      0|    var f = _digest[5];
      0|    var g = _digest[6];
      0|    var h = _digest[7];
       |
      0|    for (var i = 0; i < 64; i++) {
      0|      var temp1 = add32(add32(h, _bsig1(e)),
      0|          add32(_ch(e, f, g), add32(_noise[i], _extended[i])));
      0|      var temp2 = add32(_bsig0(a), _maj(a, b, c));
       |      h = g;
       |      g = f;
       |      f = e;
      0|      e = add32(d, temp1);
       |      d = c;
       |      c = b;
       |      b = a;
      0|      a = add32(temp1, temp2);
       |    }
       |
       |    // Update hash values after iteration.
      0|    _digest[0] = add32(a, _digest[0]);
      0|    _digest[1] = add32(b, _digest[1]);
      0|    _digest[2] = add32(c, _digest[2]);
      0|    _digest[3] = add32(d, _digest[3]);
      0|    _digest[4] = add32(e, _digest[4]);
      0|    _digest[5] = add32(f, _digest[5]);
      0|    _digest[6] = add32(g, _digest[6]);
      0|    _digest[7] = add32(h, _digest[7]);
       |  }
       |}
       |
       |/// The concrete implementation of [Sha256].
       |///
       |/// This is separate so that it can extend [HashSink] without leaking additional
       |/// public members.
       |class _Sha256Sink extends _Sha32BitSink {
      0|  @override
      0|  Uint32List get digest => _digest;
       |
       |  // Initial value of the hash parts. First 32 bits of the fractional parts
       |  // of the square roots of the first 8 prime numbers.
      0|  _Sha256Sink(Sink<Digest> sink)
      0|      : super(
       |            sink,
      0|            Uint32List.fromList([
       |              0x6a09e667,
       |              0xbb67ae85,
       |              0x3c6ef372,
       |              0xa54ff53a,
       |              0x510e527f,
       |              0x9b05688c,
       |              0x1f83d9ab,
       |              0x5be0cd19,
       |            ]));
       |}
       |
       |/// The concrete implementation of [Sha224].
       |///
       |/// This is separate so that it can extend [HashSink] without leaking additional
       |/// public members.
       |class _Sha224Sink extends _Sha32BitSink {
      0|  @override
      0|  Uint32List get digest => _digest.buffer.asUint32List(0, 7);
       |
      0|  _Sha224Sink(Sink<Digest> sink)
      0|      : super(
       |            sink,
      0|            Uint32List.fromList([
       |              0xc1059ed8,
       |              0x367cd507,
       |              0x3070dd17,
       |              0xf70e5939,
       |              0xffc00b31,
       |              0x68581511,
       |              0x64f98fa7,
       |              0xbefa4fa4,
       |            ]));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/sha512.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |
       |import 'digest.dart';
       |import 'hash.dart';
       |// ignore: uri_does_not_exist
       |import 'sha512_fastsinks.dart' if (dart.library.js) 'sha512_slowsinks.dart';
       |import 'utils.dart';
       |
       |/// An instance of [Sha2Sha384].
       |///
       |/// This instance provides convenient access to the [Sha384][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc6234
      0|final sha384 = Sha384._();
       |
       |/// An instance of [Sha2Sha512].
       |///
       |/// This instance provides convenient access to the [Sha512][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc6234
      0|final sha512 = Sha512._();
       |
       |/// An implementation of the [SHA-384][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc6234
       |///
       |/// Note that it's almost always easier to use [sha384] rather than creating a
       |/// new instance.
       |class Sha384 extends Hash {
       |  @override
       |  final int blockSize = 32 * bytesPerWord;
       |
      0|  Sha384._();
       |
      0|  Sha384 newInstance() => Sha384._();
       |
      0|  @override
       |  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      0|      ByteConversionSink.from(Sha384Sink(sink));
       |}
       |
       |/// An implementation of the [SHA-512][rfc] hash function.
       |///
       |/// [rfc]: http://tools.ietf.org/html/rfc6234
       |///
       |/// Note that it's almost always easier to use [sha512] rather than creating a
       |/// new instance.
       |class Sha512 extends Sha384 {
      0|  Sha512._() : super._();
       |
      0|  @override
      0|  Sha512 newInstance() => Sha512._();
       |
      0|  @override
       |  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      0|      ByteConversionSink.from(Sha512Sink(sink));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/sha512_fastsinks.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:typed_data';
       |
       |import 'digest.dart';
       |import 'hash_sink.dart';
       |
       |abstract class _Sha64BitSink extends HashSink {
       |  int get digestBytes;
       |
      0|  @override
       |  Uint32List get digest {
      0|    var unordered = _digest.buffer.asUint32List();
      0|    var ordered = Uint32List(digestBytes);
      0|    for (var i = 0; i < digestBytes; i++) {
      0|      ordered[i] = unordered[i + (i.isEven ? 1 : -1)];
       |    }
       |    return ordered;
       |  }
       |
       |  // Initial value of the hash parts. First 64 bits of the fractional parts
       |  // of the square roots of the ninth through sixteenth prime numbers.
       |  final Uint64List _digest;
       |
       |  /// The sixteen words from the original chunk, extended to 64 words.
       |  ///
       |  /// This is an instance variable to avoid re-allocating, but its data isn't
       |  /// used across invocations of [updateHash].
       |  final _extended = Uint64List(80);
       |
      0|  _Sha64BitSink(Sink<Digest> sink, this._digest)
      0|      : super(sink, 32, signatureBytes: 16);
       |  // The following helper functions are taken directly from
       |  // http://tools.ietf.org/html/rfc6234.
       |
      0|  static int _rotr64(int n, int x) => _shr64(n, x) | (x << (64 - n));
      0|  static int _shr64(int n, int x) => (x >> n) & ~(-1 << (64 - n));
       |
      0|  static int _ch(int x, int y, int z) => (x & y) ^ (~x & z);
      0|  static int _maj(int x, int y, int z) => (x & y) ^ (x & z) ^ (y & z);
      0|  static int _bsig0(int x) => _rotr64(28, x) ^ _rotr64(34, x) ^ _rotr64(39, x);
      0|  static int _bsig1(int x) => _rotr64(14, x) ^ _rotr64(18, x) ^ _rotr64(41, x);
      0|  static int _ssig0(int x) => _rotr64(1, x) ^ _rotr64(8, x) ^ _shr64(7, x);
      0|  static int _ssig1(int x) => _rotr64(19, x) ^ _rotr64(61, x) ^ _shr64(6, x);
       |
      0|  @override
       |  void updateHash(Uint32List chunk) {
       |    assert(chunk.length == 32);
       |
       |    // Prepare message schedule.
      0|    for (var i = 0, x = 0; i < 32; i += 2, x++) {
      0|      _extended[x] = (chunk[i] << 32) | chunk[i + 1];
       |    }
       |
      0|    for (var t = 16; t < 80; t++) {
      0|      _extended[t] = _ssig1(_extended[t - 2]) +
      0|          _extended[t - 7] +
      0|          _ssig0(_extended[t - 15]) +
      0|          _extended[t - 16];
       |    }
       |
       |    // Shuffle around the bits.
      0|    var a = _digest[0];
      0|    var b = _digest[1];
      0|    var c = _digest[2];
      0|    var d = _digest[3];
      0|    var e = _digest[4];
      0|    var f = _digest[5];
      0|    var g = _digest[6];
      0|    var h = _digest[7];
       |
      0|    for (var i = 0; i < 80; i++) {
      0|      var temp1 = h + _bsig1(e) + _ch(e, f, g) + _noise64[i] + _extended[i];
      0|      var temp2 = _bsig0(a) + _maj(a, b, c);
       |      h = g;
       |      g = f;
       |      f = e;
      0|      e = d + temp1;
       |      d = c;
       |      c = b;
       |      b = a;
      0|      a = temp1 + temp2;
       |    }
       |
       |    // Update hash values after iteration.
      0|    _digest[0] += a;
      0|    _digest[1] += b;
      0|    _digest[2] += c;
      0|    _digest[3] += d;
      0|    _digest[4] += e;
      0|    _digest[5] += f;
      0|    _digest[6] += g;
      0|    _digest[7] += h;
       |  }
       |}
       |
       |/// The concrete implementation of [Sha384].
       |///
       |/// This is separate so that it can extend [HashSink] without leaking additional
       |/// public members.
       |class Sha384Sink extends _Sha64BitSink {
       |  @override
       |  final digestBytes = 12;
       |
      0|  Sha384Sink(Sink<Digest> sink)
      0|      : super(
       |            sink,
      0|            Uint64List.fromList([
       |              0xcbbb9d5dc1059ed8,
       |              0x629a292a367cd507,
       |              0x9159015a3070dd17,
       |              0x152fecd8f70e5939,
       |              0x67332667ffc00b31,
       |              0x8eb44a8768581511,
       |              0xdb0c2e0d64f98fa7,
       |              0x47b5481dbefa4fa4,
       |            ]));
       |}
       |
       |/// The concrete implementation of [Sha512].
       |///
       |/// This is separate so that it can extend [HashSink] without leaking additional
       |/// public members.
       |class Sha512Sink extends _Sha64BitSink {
       |  @override
       |  final digestBytes = 16;
       |
      0|  Sha512Sink(Sink<Digest> sink)
      0|      : super(
       |            sink,
      0|            Uint64List.fromList([
       |              // Initial value of the hash parts. First 64 bits of the fractional
       |              // parts of the square roots of the first eight prime numbers.
       |              0x6a09e667f3bcc908,
       |              0xbb67ae8584caa73b,
       |              0x3c6ef372fe94f82b,
       |              0xa54ff53a5f1d36f1,
       |              0x510e527fade682d1,
       |              0x9b05688c2b3e6c1f,
       |              0x1f83d9abfb41bd6b,
       |              0x5be0cd19137e2179,
       |            ]));
       |}
       |
      0|final _noise64 = Uint64List.fromList([
       |  0x428a2f98d728ae22,
       |  0x7137449123ef65cd,
       |  0xb5c0fbcfec4d3b2f,
       |  0xe9b5dba58189dbbc,
       |  0x3956c25bf348b538,
       |  0x59f111f1b605d019,
       |  0x923f82a4af194f9b,
       |  0xab1c5ed5da6d8118,
       |  0xd807aa98a3030242,
       |  0x12835b0145706fbe,
       |  0x243185be4ee4b28c,
       |  0x550c7dc3d5ffb4e2,
       |  0x72be5d74f27b896f,
       |  0x80deb1fe3b1696b1,
       |  0x9bdc06a725c71235,
       |  0xc19bf174cf692694,
       |  0xe49b69c19ef14ad2,
       |  0xefbe4786384f25e3,
       |  0x0fc19dc68b8cd5b5,
       |  0x240ca1cc77ac9c65,
       |  0x2de92c6f592b0275,
       |  0x4a7484aa6ea6e483,
       |  0x5cb0a9dcbd41fbd4,
       |  0x76f988da831153b5,
       |  0x983e5152ee66dfab,
       |  0xa831c66d2db43210,
       |  0xb00327c898fb213f,
       |  0xbf597fc7beef0ee4,
       |  0xc6e00bf33da88fc2,
       |  0xd5a79147930aa725,
       |  0x06ca6351e003826f,
       |  0x142929670a0e6e70,
       |  0x27b70a8546d22ffc,
       |  0x2e1b21385c26c926,
       |  0x4d2c6dfc5ac42aed,
       |  0x53380d139d95b3df,
       |  0x650a73548baf63de,
       |  0x766a0abb3c77b2a8,
       |  0x81c2c92e47edaee6,
       |  0x92722c851482353b,
       |  0xa2bfe8a14cf10364,
       |  0xa81a664bbc423001,
       |  0xc24b8b70d0f89791,
       |  0xc76c51a30654be30,
       |  0xd192e819d6ef5218,
       |  0xd69906245565a910,
       |  0xf40e35855771202a,
       |  0x106aa07032bbd1b8,
       |  0x19a4c116b8d2d0c8,
       |  0x1e376c085141ab53,
       |  0x2748774cdf8eeb99,
       |  0x34b0bcb5e19b48a8,
       |  0x391c0cb3c5c95a63,
       |  0x4ed8aa4ae3418acb,
       |  0x5b9cca4f7763e373,
       |  0x682e6ff3d6b2b8a3,
       |  0x748f82ee5defb2fc,
       |  0x78a5636f43172f60,
       |  0x84c87814a1f0ab72,
       |  0x8cc702081a6439ec,
       |  0x90befffa23631e28,
       |  0xa4506cebde82bde9,
       |  0xbef9a3f7b2c67915,
       |  0xc67178f2e372532b,
       |  0xca273eceea26619c,
       |  0xd186b8c721c0c207,
       |  0xeada7dd6cde0eb1e,
       |  0xf57d4f7fee6ed178,
       |  0x06f067aa72176fba,
       |  0x0a637dc5a2c898a6,
       |  0x113f9804bef90dae,
       |  0x1b710b35131c471b,
       |  0x28db77f523047d84,
       |  0x32caab7b40c72493,
       |  0x3c9ebe0a15c9bebc,
       |  0x431d67c49c100d4c,
       |  0x4cc5d4becb3e42b6,
       |  0x597f299cfc657e2a,
       |  0x5fcb6fab3ad6faec,
       |  0x6c44198c4a475817,
       |]);
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/utils.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// A bitmask that limits an integer to 32 bits.
       |const mask32 = 0xFFFFFFFF;
       |
       |/// The number of bits in a byte.
       |const bitsPerByte = 8;
       |
       |/// The number of bytes in a 32-bit word.
       |const bytesPerWord = 4;
       |
       |/// Adds [x] and [y] with 32-bit overflow semantics.
      0|int add32(int x, int y) => (x + y) & mask32;
       |
       |/// Bitwise rotates [val] to the left by [shift], obeying 32-bit overflow
       |/// semantics.
      0|int rotl32(int val, int shift) {
      0|  var modShift = shift & 31;
      0|  return ((val << modShift) & mask32) | ((val & mask32) >> (32 - modShift));
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/hash_sink.dart
       |// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:typed_data';
       |
       |import 'package:typed_data/typed_data.dart';
       |
       |import 'digest.dart';
       |import 'utils.dart';
       |
       |/// A base class for [Sink] implementations for hash algorithms.
       |///
       |/// Subclasses should override [updateHash] and [digest].
       |abstract class HashSink implements Sink<List<int>> {
       |  /// The inner sink that this should forward to.
       |  final Sink<Digest> _sink;
       |
       |  /// Whether the hash function operates on big-endian words.
       |  final Endian _endian;
       |
       |  /// The words in the current chunk.
       |  ///
       |  /// This is an instance variable to avoid re-allocating, but its data isn't
       |  /// used across invocations of [_iterate].
       |  final Uint32List _currentChunk;
       |
       |  /// Messages with more than 2^53-1 bits are not supported. (This is the
       |  /// largest value that is representable on both JS and the Dart VM.)
       |  /// So the maximum length in bytes is (2^53-1)/8.
       |  static const _maxMessageLengthInBytes = 0x0003ffffffffffff;
       |
       |  /// The length of the input data so far, in bytes.
       |  int _lengthInBytes = 0;
       |
       |  /// Data that has yet to be processed by the hash function.
       |  final _pendingData = Uint8Buffer();
       |
       |  /// Whether [close] has been called.
       |  bool _isClosed = false;
       |
       |  /// The words in the current digest.
       |  ///
       |  /// This should be updated each time [updateHash] is called.
       |  Uint32List get digest;
       |
       |  /// The number of signature bytes emitted at the end of the message.
       |  ///
       |  /// An encrypted message is followed by a signature which depends
       |  /// on the encryption algorithm used. This value specifies the
       |  /// number of bytes used by this signature. It must always be
       |  /// a power of 2 and no less than 8.
       |  final int _signatureBytes;
       |
       |  /// Creates a new hash.
       |  ///
       |  /// [chunkSizeInWords] represents the size of the input chunks processed by
       |  /// the algorithm, in terms of 32-bit words.
      0|  HashSink(this._sink, int chunkSizeInWords,
       |      {Endian endian = Endian.big, int signatureBytes = 8})
       |      : _endian = endian,
       |        assert(signatureBytes >= 8),
       |        _signatureBytes = signatureBytes,
      0|        _currentChunk = Uint32List(chunkSizeInWords);
       |
       |  /// Runs a single iteration of the hash computation, updating [digest] with
       |  /// the result.
       |  ///
       |  /// [chunk] is the current chunk, whose size is given by the
       |  /// `chunkSizeInWords` parameter passed to the constructor.
       |  void updateHash(Uint32List chunk);
       |
      0|  @override
       |  void add(List<int> data) {
      0|    if (_isClosed) throw StateError('Hash.add() called after close().');
      0|    _lengthInBytes += data.length;
      0|    _pendingData.addAll(data);
      0|    _iterate();
       |  }
       |
      0|  @override
       |  void close() {
      0|    if (_isClosed) return;
      0|    _isClosed = true;
       |
      0|    _finalizeData();
      0|    _iterate();
       |    assert(_pendingData.isEmpty);
      0|    _sink.add(Digest(_byteDigest()));
      0|    _sink.close();
       |  }
       |
      0|  Uint8List _byteDigest() {
      0|    if (_endian == Endian.host) return digest.buffer.asUint8List();
       |
       |    // Cache the digest locally as `get` could be expensive.
      0|    final cachedDigest = digest;
      0|    final byteDigest = Uint8List(cachedDigest.lengthInBytes);
      0|    final byteData = byteDigest.buffer.asByteData();
      0|    for (var i = 0; i < cachedDigest.length; i++) {
      0|      byteData.setUint32(i * bytesPerWord, cachedDigest[i]);
       |    }
       |    return byteDigest;
       |  }
       |
       |  /// Iterates through [_pendingData], updating the hash computation for each
       |  /// chunk.
      0|  void _iterate() {
      0|    var pendingDataBytes = _pendingData.buffer.asByteData();
      0|    var pendingDataChunks = _pendingData.length ~/ _currentChunk.lengthInBytes;
      0|    for (var i = 0; i < pendingDataChunks; i++) {
       |      // Copy words from the pending data buffer into the current chunk buffer.
      0|      for (var j = 0; j < _currentChunk.length; j++) {
      0|        _currentChunk[j] = pendingDataBytes.getUint32(
      0|            i * _currentChunk.lengthInBytes + j * bytesPerWord, _endian);
       |      }
       |
       |      // Run the hash function on the current chunk.
      0|      updateHash(_currentChunk);
       |    }
       |
       |    // Remove all pending data up to the last clean chunk break.
      0|    _pendingData.removeRange(
      0|        0, pendingDataChunks * _currentChunk.lengthInBytes);
       |  }
       |
       |  /// Finalizes [_pendingData].
       |  ///
       |  /// This adds a 1 bit to the end of the message, and expands it with 0 bits to
       |  /// pad it out.
      0|  void _finalizeData() {
       |    // Pad out the data with 0x80, eight or sixteen 0s, and as many more 0s
       |    // as we need to land cleanly on a chunk boundary.
      0|    _pendingData.add(0x80);
       |
      0|    final contentsLength = _lengthInBytes + 1 /* 0x80 */ + _signatureBytes;
       |    final finalizedLength =
      0|        _roundUp(contentsLength, _currentChunk.lengthInBytes);
       |
      0|    for (var i = 0; i < finalizedLength - contentsLength; i++) {
      0|      _pendingData.add(0);
       |    }
       |
      0|    if (_lengthInBytes > _maxMessageLengthInBytes) {
      0|      throw UnsupportedError(
       |          'Hashing is unsupported for messages with more than 2^53 bits.');
       |    }
       |
      0|    var lengthInBits = _lengthInBytes * bitsPerByte;
       |
       |    // Add the full length of the input data as a 64-bit value at the end of the
       |    // hash. Note: we're only writing out 64 bits, so skip ahead 8 if the
       |    // signature is 128-bit.
      0|    final offset = _pendingData.length + (_signatureBytes - 8);
       |
      0|    _pendingData.addAll(Uint8List(_signatureBytes));
      0|    var byteData = _pendingData.buffer.asByteData();
       |
       |    // We're essentially doing byteData.setUint64(offset, lengthInBits, _endian)
       |    // here, but that method isn't supported on dart2js so we implement it
       |    // manually instead.
      0|    var highBits = lengthInBits >> 32;
      0|    var lowBits = lengthInBits & mask32;
      0|    if (_endian == Endian.big) {
      0|      byteData.setUint32(offset, highBits, _endian);
      0|      byteData.setUint32(offset + bytesPerWord, lowBits, _endian);
       |    } else {
      0|      byteData.setUint32(offset, lowBits, _endian);
      0|      byteData.setUint32(offset + bytesPerWord, highBits, _endian);
       |    }
       |  }
       |
       |  /// Rounds [val] up to the next multiple of [n], as long as [n] is a power of
       |  /// two.
      0|  int _roundUp(int val, int n) => (val + n - 1) & -n;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/accumulator_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection';
       |
       |/// A sink that provides access to all the [events] that have been passed to it.
       |///
       |/// See also [ChunkedConversionSink.withCallback].
       |class AccumulatorSink<T> implements Sink<T> {
       |  /// An unmodifiable list of events passed to this sink so far.
      0|  List<T> get events => new UnmodifiableListView(_events);
       |  final _events = <T>[];
       |
       |  /// Whether [close] has been called.
      0|  bool get isClosed => _isClosed;
       |  var _isClosed = false;
       |
       |  /// Removes all events from [events].
       |  ///
       |  /// This can be used to avoid double-processing events.
      0|  void clear() {
      0|    _events.clear();
       |  }
       |
      0|  void add(T event) {
      0|    if (_isClosed) {
      0|      throw new StateError("Can't add to a closed sink.");
       |    }
       |
      0|    _events.add(event);
       |  }
       |
      0|  void close() {
      0|    _isClosed = true;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/byte_accumulator_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:typed_data/typed_data.dart';
       |
       |/// A sink that provides access to the concatenated bytes passed to it.
       |///
       |/// See also [ByteConversionSink.withCallback].
       |class ByteAccumulatorSink extends ByteConversionSinkBase {
       |  /// The bytes accumulated so far.
       |  ///
       |  /// The returned [Uint8List] is viewing a shared buffer, so it should not be
       |  /// changed and any bytes outside the view should not be accessed.
      0|  Uint8List get bytes => new Uint8List.view(_buffer.buffer, 0, _buffer.length);
       |
       |  final _buffer = new Uint8Buffer();
       |
       |  /// Whether [close] has been called.
      0|  bool get isClosed => _isClosed;
       |  var _isClosed = false;
       |
       |  /// Removes all bytes from [bytes].
       |  ///
       |  /// This can be used to avoid double-processing data.
      0|  void clear() {
      0|    _buffer.clear();
       |  }
       |
      0|  void add(List<int> bytes) {
      0|    if (_isClosed) {
      0|      throw new StateError("Can't add to a closed sink.");
       |    }
       |
      0|    _buffer.addAll(bytes);
       |  }
       |
      0|  void addSlice(List<int> chunk, int start, int end, bool isLast) {
      0|    if (_isClosed) {
      0|      throw new StateError("Can't add to a closed sink.");
       |    }
       |
      0|    _buffer.addAll(chunk, start, end);
      0|    if (isLast) _isClosed = true;
       |  }
       |
      0|  void close() {
      0|    _isClosed = true;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/hex.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |library convert.hex;
       |
       |import 'dart:convert';
       |
       |import 'hex/encoder.dart';
       |import 'hex/decoder.dart';
       |
       |export 'hex/encoder.dart' hide hexEncoder;
       |export 'hex/decoder.dart' hide hexDecoder;
       |
       |/// The canonical instance of [HexCodec].
       |const hex = const HexCodec._();
       |
       |/// A codec that converts byte arrays to and from hexadecimal strings, following
       |/// [the Base16 spec][rfc].
       |///
       |/// [rfc]: https://tools.ietf.org/html/rfc4648#section-8
       |///
       |/// This should be used via the [hex] field.
       |class HexCodec extends Codec<List<int>, String> {
      0|  HexEncoder get encoder => hexEncoder;
      0|  HexDecoder get decoder => hexDecoder;
       |
      0|  const HexCodec._();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/identity_codec.dart
       |import 'dart:convert';
       |
       |class _IdentityConverter<T> extends Converter<T, T> {
      0|  _IdentityConverter();
      0|  T convert(T input) => input;
       |}
       |
       |/// A [Codec] that performs the identity conversion (changing nothing) in both
       |/// directions.
       |///
       |/// The identity codec passes input directly to output in both directions.
       |/// This class can be used as a base when combining multiple codecs,
       |/// because fusing the identity codec with any other codec gives the other
       |/// codec back.
       |///
       |/// Note, that when fused with another [Codec] the identity codec disppears.
       |class IdentityCodec<T> extends Codec<T, T> {
      0|  const IdentityCodec();
       |
      0|  Converter<T, T> get decoder => new _IdentityConverter<T>();
      0|  Converter<T, T> get encoder => new _IdentityConverter<T>();
       |
       |  /// Fuse with an other codec.
       |  ///
       |  /// Fusing with the identify converter is a no-op, so this always return
       |  /// [other].
      0|  Codec<T, R> fuse<R>(Codec<T, R> other) => other;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/percent.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |library convert.percent;
       |
       |import 'dart:convert';
       |
       |import 'percent/encoder.dart';
       |import 'percent/decoder.dart';
       |
       |export 'percent/encoder.dart' hide percentEncoder;
       |export 'percent/decoder.dart' hide percentDecoder;
       |
       |/// The canonical instance of [PercentCodec].
       |const percent = const PercentCodec._();
       |
       |// TODO(nweiz): Add flags to support generating and interpreting "+" as a space
       |// character. Also add an option for custom sets of unreserved characters.
       |/// A codec that converts byte arrays to and from percent-encoded (also known as
       |/// URL-encoded) strings according to [RFC 3986][rfc].
       |///
       |/// [rfc]: https://tools.ietf.org/html/rfc3986#section-2.1
       |///
       |/// [encoder] encodes all bytes other than ASCII letters, decimal digits, or one
       |/// of `-._~`. This matches the behavior of [Uri.encodeQueryComponent] except
       |/// that it doesn't encode `0x20` bytes to the `+` character.
       |///
       |/// To be maximally flexible, [decoder] will decode any percent-encoded byte and
       |/// will allow any non-percent-encoded byte other than `%`. By default, it
       |/// interprets `+` as `0x2B` rather than `0x20` as emitted by
       |/// [Uri.encodeQueryComponent].
       |class PercentCodec extends Codec<List<int>, String> {
      0|  PercentEncoder get encoder => percentEncoder;
      0|  PercentDecoder get decoder => percentDecoder;
       |
      0|  const PercentCodec._();
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/string_accumulator_sink.dart
       |// Copyright (c) 2016, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |
       |/// A sink that provides access to the concatenated strings passed to it.
       |///
       |/// See also [StringConversionSink.withCallback].
       |class StringAccumulatorSink extends StringConversionSinkBase {
       |  /// The string accumulated so far.
      0|  String get string => _buffer.toString();
       |  final _buffer = new StringBuffer();
       |
       |  /// Whether [close] has been called.
      0|  bool get isClosed => _isClosed;
       |  var _isClosed = false;
       |
       |  /// Empties [string].
       |  ///
       |  /// This can be used to avoid double-processing data.
      0|  void clear() {
      0|    _buffer.clear();
       |  }
       |
      0|  void add(String chunk) {
      0|    if (_isClosed) {
      0|      throw new StateError("Can't add to a closed sink.");
       |    }
       |
      0|    _buffer.write(chunk);
       |  }
       |
      0|  void addSlice(String chunk, int start, int end, bool isLast) {
      0|    if (_isClosed) {
      0|      throw new StateError("Can't add to a closed sink.");
       |    }
       |
      0|    _buffer.write(chunk.substring(start, end));
      0|    if (isLast) _isClosed = true;
       |  }
       |
      0|  void close() {
      0|    _isClosed = true;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/percent/encoder.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |library convert.percent.encoder;
       |
       |import 'dart:convert';
       |
       |import 'package:charcode/ascii.dart';
       |
       |/// The canonical instance of [PercentEncoder].
       |const percentEncoder = const PercentEncoder._();
       |
       |/// A converter that encodes byte arrays into percent-encoded strings.
       |///
       |/// [encoder] encodes all bytes other than ASCII letters, decimal digits, or one
       |/// of `-._~`. This matches the behavior of [Uri.encodeQueryComponent] except
       |/// that it doesn't encode `0x20` bytes to the `+` character.
       |///
       |/// This will throw a [RangeError] if the byte array has any digits that don't
       |/// fit in the gamut of a byte.
       |class PercentEncoder extends Converter<List<int>, String> {
      0|  const PercentEncoder._();
       |
      0|  String convert(List<int> bytes) => _convert(bytes, 0, bytes.length);
       |
      0|  ByteConversionSink startChunkedConversion(Sink<String> sink) =>
      0|      new _PercentEncoderSink(sink);
       |}
       |
       |/// A conversion sink for chunked percentadecimal encoding.
       |class _PercentEncoderSink extends ByteConversionSinkBase {
       |  /// The underlying sink to which decoded byte arrays will be passed.
       |  final Sink<String> _sink;
       |
      0|  _PercentEncoderSink(this._sink);
       |
      0|  void add(List<int> chunk) {
      0|    _sink.add(_convert(chunk, 0, chunk.length));
       |  }
       |
      0|  void addSlice(List<int> chunk, int start, int end, bool isLast) {
      0|    RangeError.checkValidRange(start, end, chunk.length);
      0|    _sink.add(_convert(chunk, start, end));
      0|    if (isLast) _sink.close();
       |  }
       |
      0|  void close() {
      0|    _sink.close();
       |  }
       |}
       |
      0|String _convert(List<int> bytes, int start, int end) {
      0|  var buffer = new StringBuffer();
       |
       |  // A bitwise OR of all bytes in [bytes]. This allows us to check for
       |  // out-of-range bytes without adding more branches than necessary to the
       |  // core loop.
       |  var byteOr = 0;
      0|  for (var i = start; i < end; i++) {
      0|    var byte = bytes[i];
      0|    byteOr |= byte;
       |
       |    // If the byte is an uppercase letter, convert it to lowercase to check if
       |    // it's unreserved. This works because uppercase letters in ASCII are
       |    // exactly `0b100000 = 0x20` less than lowercase letters, so if we ensure
       |    // that that bit is 1 we ensure that the letter is lowercase.
      0|    var letter = 0x20 | byte;
      0|    if ((letter >= $a && letter <= $z) ||
      0|        (byte >= $0 && byte <= $9) ||
      0|        byte == $dash ||
      0|        byte == $dot ||
      0|        byte == $underscore ||
      0|        byte == $tilde) {
       |      // Unreserved characters are safe to write as-is.
      0|      buffer.writeCharCode(byte);
       |      continue;
       |    }
       |
      0|    buffer.writeCharCode($percent);
       |
       |    // The bitwise arithmetic here is equivalent to `byte ~/ 16` and `byte % 16`
       |    // for valid byte values, but is easier for dart2js to optimize given that
       |    // it can't prove that [byte] will always be positive.
      0|    buffer.writeCharCode(_codeUnitForDigit((byte & 0xF0) >> 4));
      0|    buffer.writeCharCode(_codeUnitForDigit(byte & 0x0F));
       |  }
       |
      0|  if (byteOr >= 0 && byteOr <= 255) return buffer.toString();
       |
       |  // If there was an invalid byte, find it and throw an exception.
      0|  for (var i = start; i < end; i++) {
      0|    var byte = bytes[i];
      0|    if (byte >= 0 && byte <= 0xff) continue;
      0|    throw new FormatException(
      0|        "Invalid byte ${byte < 0 ? "-" : ""}0x${byte.abs().toRadixString(16)}.",
       |        bytes,
       |        i);
       |  }
       |
       |  throw 'unreachable';
       |}
       |
       |/// Returns the ASCII/Unicode code unit corresponding to the hexadecimal digit
       |/// [digit].
      0|int _codeUnitForDigit(int digit) => digit < 10 ? digit + $0 : digit + $A - 10;
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/percent/decoder.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |library convert.percent.decoder;
       |
       |import 'dart:convert';
       |
       |import 'package:charcode/ascii.dart';
       |import 'package:typed_data/typed_data.dart';
       |
       |import '../utils.dart';
       |
       |/// The canonical instance of [PercentDecoder].
       |const percentDecoder = const PercentDecoder._();
       |
       |const _lastPercent = -1;
       |
       |/// A converter that decodes percent-encoded strings into byte arrays.
       |///
       |/// To be maximally flexible, this will decode any percent-encoded byte and
       |/// will allow any non-percent-encoded byte other than `%`. By default, it
       |/// interprets `+` as `0x2B` rather than `0x20` as emitted by
       |/// [Uri.encodeQueryComponent].
       |///
       |/// This will throw a [FormatException] if the input string has an incomplete
       |/// percent-encoding, or if it contains non-ASCII code units.
       |class PercentDecoder extends Converter<String, List<int>> {
      0|  const PercentDecoder._();
       |
      0|  List<int> convert(String string) {
      0|    var buffer = new Uint8Buffer();
      0|    var lastDigit = _decode(string.codeUnits, 0, string.length, buffer);
       |
       |    if (lastDigit != null) {
      0|      throw new FormatException(
      0|          "Input ended with incomplete encoded byte.", string, string.length);
       |    }
       |
      0|    return buffer.buffer.asUint8List(0, buffer.length);
       |  }
       |
      0|  StringConversionSink startChunkedConversion(Sink<List<int>> sink) =>
      0|      new _PercentDecoderSink(sink);
       |}
       |
       |/// A conversion sink for chunked percent-encoded decoding.
       |class _PercentDecoderSink extends StringConversionSinkBase {
       |  /// The underlying sink to which decoded byte arrays will be passed.
       |  final Sink<List<int>> _sink;
       |
       |  /// The trailing digit from the previous string.
       |  ///
       |  /// This is `null` if the previous string ended with a complete
       |  /// percent-encoded byte or a literal character. It's [_lastPercent] if the
       |  /// most recent string ended with `%`. Otherwise, the most recent string ended
       |  /// with a `%` followed by a hexadecimal digit, and this is that digit. Since
       |  /// it's the most significant digit, it's always a multiple of 16.
       |  int _lastDigit;
       |
      0|  _PercentDecoderSink(this._sink);
       |
      0|  void addSlice(String string, int start, int end, bool isLast) {
      0|    RangeError.checkValidRange(start, end, string.length);
       |
      0|    if (start == end) {
      0|      if (isLast) _close(string, end);
       |      return;
       |    }
       |
      0|    var buffer = new Uint8Buffer();
      0|    var codeUnits = string.codeUnits;
      0|    if (_lastDigit == _lastPercent) {
      0|      _lastDigit = 16 * digitForCodeUnit(codeUnits, start);
      0|      start++;
       |
      0|      if (start == end) {
      0|        if (isLast) _close(string, end);
       |        return;
       |      }
       |    }
       |
      0|    if (_lastDigit != null) {
      0|      buffer.add(_lastDigit + digitForCodeUnit(codeUnits, start));
      0|      start++;
       |    }
       |
      0|    _lastDigit = _decode(codeUnits, start, end, buffer);
       |
      0|    _sink.add(buffer.buffer.asUint8List(0, buffer.length));
      0|    if (isLast) _close(string, end);
       |  }
       |
      0|  ByteConversionSink asUtf8Sink(bool allowMalformed) =>
      0|      new _PercentDecoderByteSink(_sink);
       |
      0|  void close() => _close();
       |
       |  /// Like [close], but includes [string] and [index] in the [FormatException]
       |  /// if one is thrown.
      0|  void _close([String string, int index]) {
      0|    if (_lastDigit != null) {
      0|      throw new FormatException(
       |          "Input ended with incomplete encoded byte.", string, index);
       |    }
       |
      0|    _sink.close();
       |  }
       |}
       |
       |/// A conversion sink for chunked percent-encoded decoding from UTF-8 bytes.
       |class _PercentDecoderByteSink extends ByteConversionSinkBase {
       |  /// The underlying sink to which decoded byte arrays will be passed.
       |  final Sink<List<int>> _sink;
       |
       |  /// The trailing digit from the previous string.
       |  ///
       |  /// This is `null` if the previous string ended with a complete
       |  /// percent-encoded byte or a literal character. It's [_lastPercent] if the
       |  /// most recent string ended with `%`. Otherwise, the most recent string ended
       |  /// with a `%` followed by a hexadecimal digit, and this is that digit. Since
       |  /// it's the most significant digit, it's always a multiple of 16.
       |  int _lastDigit;
       |
      0|  _PercentDecoderByteSink(this._sink);
       |
      0|  void add(List<int> chunk) => addSlice(chunk, 0, chunk.length, false);
       |
      0|  void addSlice(List<int> chunk, int start, int end, bool isLast) {
      0|    RangeError.checkValidRange(start, end, chunk.length);
       |
      0|    if (start == end) {
      0|      if (isLast) _close(chunk, end);
       |      return;
       |    }
       |
      0|    var buffer = new Uint8Buffer();
      0|    if (_lastDigit == _lastPercent) {
      0|      _lastDigit = 16 * digitForCodeUnit(chunk, start);
      0|      start++;
       |
      0|      if (start == end) {
      0|        if (isLast) _close(chunk, end);
       |        return;
       |      }
       |    }
       |
      0|    if (_lastDigit != null) {
      0|      buffer.add(_lastDigit + digitForCodeUnit(chunk, start));
      0|      start++;
       |    }
       |
      0|    _lastDigit = _decode(chunk, start, end, buffer);
       |
      0|    _sink.add(buffer.buffer.asUint8List(0, buffer.length));
      0|    if (isLast) _close(chunk, end);
       |  }
       |
      0|  void close() => _close();
       |
       |  /// Like [close], but includes [chunk] and [index] in the [FormatException]
       |  /// if one is thrown.
      0|  void _close([List<int> chunk, int index]) {
      0|    if (_lastDigit != null) {
      0|      throw new FormatException(
       |          "Input ended with incomplete encoded byte.", chunk, index);
       |    }
       |
      0|    _sink.close();
       |  }
       |}
       |
       |/// Decodes [codeUnits] and writes the result into [destination].
       |///
       |/// This reads from [codeUnits] between [sourceStart] and [sourceEnd]. It writes
       |/// the result into [destination] starting at [destinationStart].
       |///
       |/// If there's a leftover digit at the end of the decoding, this returns that
       |/// digit. Otherwise it returns `null`.
      0|int _decode(List<int> codeUnits, int start, int end, Uint8Buffer buffer) {
       |  // A bitwise OR of all code units in [codeUnits]. This allows us to check for
       |  // out-of-range code units without adding more branches than necessary to the
       |  // core loop.
       |  var codeUnitOr = 0;
       |
       |  // The beginning of the current slice of adjacent non-% characters. We can add
       |  // all of these to the buffer at once.
       |  var sliceStart = start;
      0|  for (var i = start; i < end; i++) {
       |    // First, loop through non-% characters.
      0|    var codeUnit = codeUnits[i];
      0|    if (codeUnits[i] != $percent) {
      0|      codeUnitOr |= codeUnit;
       |      continue;
       |    }
       |
       |    // We found a %. The slice from `sliceStart` to `i` represents characters
       |    // than can be copied to the buffer as-is.
      0|    if (i > sliceStart) {
      0|      _checkForInvalidCodeUnit(codeUnitOr, codeUnits, sliceStart, i);
      0|      buffer.addAll(codeUnits, sliceStart, i);
       |    }
       |
       |    // Now decode the percent-encoded byte and add it as well.
      0|    i++;
      0|    if (i >= end) return _lastPercent;
       |
      0|    var firstDigit = digitForCodeUnit(codeUnits, i);
      0|    i++;
      0|    if (i >= end) return 16 * firstDigit;
       |
      0|    var secondDigit = digitForCodeUnit(codeUnits, i);
      0|    buffer.add(16 * firstDigit + secondDigit);
       |
       |    // The next iteration will look for non-% characters again.
      0|    sliceStart = i + 1;
       |  }
       |
      0|  if (end > sliceStart) {
      0|    _checkForInvalidCodeUnit(codeUnitOr, codeUnits, sliceStart, end);
      0|    if (start == sliceStart) {
      0|      buffer.addAll(codeUnits);
       |    } else {
      0|      buffer.addAll(codeUnits, sliceStart, end);
       |    }
       |  }
       |
       |  return null;
       |}
       |
      0|void _checkForInvalidCodeUnit(
       |    int codeUnitOr, List<int> codeUnits, int start, int end) {
      0|  if (codeUnitOr >= 0 && codeUnitOr <= 0x7f) return;
       |
      0|  for (var i = start; i < end; i++) {
      0|    var codeUnit = codeUnits[i];
      0|    if (codeUnit >= 0 && codeUnit <= 0x7f) continue;
      0|    throw new FormatException(
       |        "Non-ASCII code unit "
      0|        "U+${codeUnit.toRadixString(16).padLeft(4, '0')}",
       |        codeUnits,
       |        i);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/utils.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |library convert.utils;
       |
       |import 'package:charcode/ascii.dart';
       |
       |/// Returns the digit (0 through 15) corresponding to the hexadecimal code unit
       |/// at index [i] in [codeUnits].
       |///
       |/// If the given code unit isn't valid hexadecimal, throws a [FormatException].
      0|int digitForCodeUnit(List<int> codeUnits, int index) {
       |  // If the code unit is a numeral, get its value. XOR works because 0 in ASCII
       |  // is `0b110000` and the other numerals come after it in ascending order and
       |  // take up at most four bits.
       |  //
       |  // We check for digits first because it ensures there's only a single branch
       |  // for 10 out of 16 of the expected cases. We don't count the `digit >= 0`
       |  // check because branch prediction will always work on it for valid data.
      0|  var codeUnit = codeUnits[index];
      0|  var digit = $0 ^ codeUnit;
      0|  if (digit <= 9) {
      0|    if (digit >= 0) return digit;
       |  } else {
       |    // If the code unit is an uppercase letter, convert it to lowercase. This
       |    // works because uppercase letters in ASCII are exactly `0b100000 = 0x20`
       |    // less than lowercase letters, so if we ensure that that bit is 1 we ensure
       |    // that the letter is lowercase.
      0|    var letter = 0x20 | codeUnit;
      0|    if ($a <= letter && letter <= $f) return letter - $a + 10;
       |  }
       |
      0|  throw new FormatException(
       |      "Invalid hexadecimal code unit "
      0|      "U+${codeUnit.toRadixString(16).padLeft(4, '0')}.",
       |      codeUnits,
       |      index);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/typed_data-1.2.0/lib/src/typed_queue.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import "dart:collection";
       |import "dart:typed_data";
       |
       |import "package:collection/collection.dart";
       |
       |import 'typed_buffer.dart';
       |
       |/// The shared superclass of all the typed queue subclasses.
       |abstract class _TypedQueue<E, L extends List<E>> with ListMixin<E> {
       |  /// The underlying data buffer.
       |  ///
       |  /// This is always both a List<E> and a TypedData, which we don't have a type
       |  /// for that. For example, for a `Uint8Queue`, this is a `Uint8List`.
       |  L _table;
       |
       |  int _head;
       |  int _tail;
       |
       |  /// Create an empty queue.
      0|  _TypedQueue(this._table)
       |      : _head = 0,
       |        _tail = 0;
       |
       |  // Iterable interface.
       |
      0|  int get length => (_tail - _head) & (_table.length - 1);
       |
      0|  List<E> toList({bool growable = true}) {
      0|    var list = growable ? _createBuffer(length) : _createList(length);
      0|    _writeToList(list);
       |    return list;
       |  }
       |
      0|  QueueList<T> cast<T>() {
      0|    if (this is QueueList<T>) return this as QueueList<T>;
      0|    throw UnsupportedError("$this cannot be cast to the desired type.");
       |  }
       |
      0|  @deprecated
      0|  QueueList<T> retype<T>() => cast<T>();
       |
       |  // Queue interface.
       |
      0|  void addLast(E value) {
      0|    _table[_tail] = value;
      0|    _tail = (_tail + 1) & (_table.length - 1);
      0|    if (_head == _tail) _growAtCapacity();
       |  }
       |
      0|  void addFirst(E value) {
      0|    _head = (_head - 1) & (_table.length - 1);
      0|    _table[_head] = value;
      0|    if (_head == _tail) _growAtCapacity();
       |  }
       |
      0|  E removeFirst() {
      0|    if (_head == _tail) throw StateError("No element");
      0|    var result = _table[_head];
      0|    _head = (_head + 1) & (_table.length - 1);
       |    return result;
       |  }
       |
      0|  E removeLast() {
      0|    if (_head == _tail) throw StateError("No element");
      0|    _tail = (_tail - 1) & (_table.length - 1);
      0|    return _table[_tail];
       |  }
       |
       |  // List interface.
       |
      0|  void add(E value) => addLast(value);
       |
      0|  set length(int value) {
      0|    RangeError.checkNotNegative(value, "length");
       |
      0|    var delta = value - length;
      0|    if (delta >= 0) {
      0|      var needsToGrow = _table.length <= value;
      0|      if (needsToGrow) _growTo(value);
      0|      _tail = (_tail + delta) & (_table.length - 1);
       |
       |      // If we didn't copy into a new table, make sure that we overwrite the
       |      // existing data so that users don't accidentally depend on it still
       |      // existing.
      0|      if (!needsToGrow) fillRange(value - delta, value, _defaultValue);
       |    } else {
      0|      removeRange(value, length);
       |    }
       |  }
       |
      0|  E operator [](int index) {
      0|    RangeError.checkValidIndex(index, this, null, length);
      0|    return _table[(_head + index) & (_table.length - 1)];
       |  }
       |
      0|  void operator []=(int index, E value) {
      0|    RangeError.checkValidIndex(index, this);
      0|    _table[(_head + index) & (_table.length - 1)] = value;
       |  }
       |
      0|  void removeRange(int start, int end) {
      0|    var length = this.length;
      0|    RangeError.checkValidRange(start, end, length);
       |
       |    // Special-case removing an initial or final range because we can do it very
       |    // efficiently by adjusting `_head` or `_tail`.
      0|    if (start == 0) {
      0|      _head = (_head + end) & (_table.length - 1);
       |      return;
       |    }
       |
      0|    var elementsAfter = length - end;
      0|    if (elementsAfter == 0) {
      0|      _tail = (_head + start) & (_table.length - 1);
       |      return;
       |    }
       |
       |    // Choose whether to copy from the beginning of the end of the queue based
       |    // on which will require fewer copied elements.
      0|    var removedElements = end - start;
      0|    if (start < elementsAfter) {
      0|      setRange(removedElements, end, this);
      0|      _head = (_head + removedElements) & (_table.length - 1);
       |    } else {
      0|      setRange(start, length - removedElements, this, end);
      0|      _tail = (_tail - removedElements) & (_table.length - 1);
       |    }
       |  }
       |
      0|  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {
      0|    RangeError.checkValidRange(start, end, length);
      0|    if (start == end) return;
       |
      0|    var targetStart = (_head + start) & (_table.length - 1);
      0|    var targetEnd = (_head + end) & (_table.length - 1);
      0|    var targetIsContiguous = targetStart < targetEnd;
       |    if (identical(iterable, this)) {
       |      // If we're copying this queue to itself, we can copy [_table] in directly
       |      // which requires some annoying case analysis but in return bottoms out on
       |      // an extremely efficient `memmove` call. However, we may need to do three
       |      // copies to avoid overwriting data we'll need to use later.
      0|      var sourceStart = (_head + skipCount) & (_table.length - 1);
      0|      var sourceEnd = (sourceStart + (end - start)) & (_table.length - 1);
      0|      if (sourceStart == targetStart) return;
       |
      0|      var sourceIsContiguous = sourceStart < sourceEnd;
       |      if (targetIsContiguous && sourceIsContiguous) {
       |        // If both the source and destination ranges are contiguous, we can
       |        // do a single [setRange]. Hooray!
      0|        _table.setRange(targetStart, targetEnd, _table, sourceStart);
       |      } else if (!targetIsContiguous && !sourceIsContiguous) {
       |        // If neither range is contiguous, we need to do three copies.
      0|        if (sourceStart > targetStart) {
       |          // [=====| targetEnd                 targetStart |======]
       |          // [========| sourceEnd                 sourceStart |===]
       |
       |          // Copy front to back.
      0|          var startGap = sourceStart - targetStart;
      0|          var firstEnd = _table.length - startGap;
      0|          _table.setRange(targetStart, firstEnd, _table, sourceStart);
      0|          _table.setRange(firstEnd, _table.length, _table);
      0|          _table.setRange(0, targetEnd, _table, startGap);
      0|        } else if (sourceEnd < targetEnd) {
       |          // [=====| targetEnd                 targetStart |======]
       |          // [==| sourceEnd                 sourceStart |=========]
       |
       |          // Copy back to front.
      0|          var firstStart = targetEnd - sourceEnd;
      0|          _table.setRange(firstStart, targetEnd, _table);
      0|          _table.setRange(0, firstStart, _table, _table.length - firstStart);
      0|          _table.setRange(targetStart, _table.length, _table, sourceStart);
       |        }
      0|      } else if (sourceStart < targetEnd) {
       |        // Copying twice is safe here as long as we copy front to back.
       |        if (sourceIsContiguous) {
       |          //       [=====| targetEnd            targetStart |======]
       |          //       [  |===========| sourceEnd                      ]
       |          // sourceStart
      0|          _table.setRange(targetStart, _table.length, _table, sourceStart);
      0|          _table.setRange(0, targetEnd, _table,
      0|              sourceStart + (_table.length - targetStart));
       |        } else {
       |          //                                               targetEnd
       |          // [                         targetStart |===========|  ]
       |          // [=====| sourceEnd                 sourceStart |======]
      0|          var firstEnd = _table.length - sourceStart;
      0|          _table.setRange(targetStart, firstEnd, _table, sourceStart);
      0|          _table.setRange(firstEnd, targetEnd, _table);
       |        }
       |      } else {
       |        // Copying twice is safe here as long as we copy back to front. This
       |        // also covers the case where there's no overlap between the source and
       |        // target ranges, in which case the direction doesn't matter.
       |        if (sourceIsContiguous) {
       |          // [=====| targetEnd                 targetStart |======]
       |          // [                         sourceStart |===========|  ]
       |          //                                             sourceEnd
      0|          _table.setRange(0, targetEnd, _table,
      0|              sourceStart + (_table.length - targetStart));
      0|          _table.setRange(targetStart, _table.length, _table, sourceStart);
       |        } else {
       |          // targetStart
       |          //       [  |===========| targetEnd                      ]
       |          //       [=====| sourceEnd            sourceStart |======]
      0|          var firstStart = targetEnd - sourceEnd;
      0|          _table.setRange(firstStart, targetEnd, _table);
      0|          _table.setRange(targetStart, firstStart, _table, sourceStart);
       |        }
       |      }
       |    } else if (targetIsContiguous) {
       |      // If the range is contiguous within the table, we can set it with a single
       |      // underlying [setRange] call.
      0|      _table.setRange(targetStart, targetEnd, iterable, skipCount);
      0|    } else if (iterable is List<E>) {
       |      // If the range isn't contiguous and [iterable] is actually a [List] (but
       |      // not this queue), set it with two underlying [setRange] calls.
      0|      _table.setRange(targetStart, _table.length, iterable, skipCount);
      0|      _table.setRange(
      0|          0, targetEnd, iterable, skipCount + (_table.length - targetStart));
       |    } else {
       |      // If [iterable] isn't a [List], we don't want to make two different
       |      // [setRange] calls because it could materialize a lazy iterable twice.
       |      // Instead we just fall back to the default iteration-based
       |      // implementation.
      0|      super.setRange(start, end, iterable, skipCount);
       |    }
       |  }
       |
      0|  void fillRange(int start, int end, [E value]) {
      0|    var startInTable = (_head + start) & (_table.length - 1);
      0|    var endInTable = (_head + end) & (_table.length - 1);
      0|    if (startInTable <= endInTable) {
      0|      _table.fillRange(startInTable, endInTable, value);
       |    } else {
      0|      _table.fillRange(startInTable, _table.length, value);
      0|      _table.fillRange(0, endInTable, value);
       |    }
       |  }
       |
      0|  L sublist(int start, [int end]) {
      0|    var length = this.length;
      0|    end = RangeError.checkValidRange(start, end, length);
       |
      0|    var list = _createList(end - start);
      0|    _writeToList(list, start, end);
       |    return list;
       |  }
       |
       |  // Internal helper functions.
       |
       |  /// Writes the contents of `this` between [start] (which defaults to 0) and
       |  /// [end] (which defaults to [length]) to the beginning of [target].
       |  ///
       |  /// This is functionally identical to `target.setRange(0, end - start, this,
       |  /// start)`, but it's more efficient when [target] is typed data.
       |  ///
       |  /// Returns the number of elements written to [target].
      0|  int _writeToList(List<E> target, [int start, int end]) {
       |    start ??= 0;
      0|    end ??= length;
       |    assert(target.length >= end - start);
       |    assert(start <= end);
       |
      0|    var elementsToWrite = end - start;
      0|    var startInTable = (_head + start) & (_table.length - 1);
      0|    var endInTable = (_head + end) & (_table.length - 1);
      0|    if (startInTable <= endInTable) {
      0|      target.setRange(0, elementsToWrite, _table, startInTable);
       |    } else {
      0|      var firstPartSize = _table.length - startInTable;
      0|      target.setRange(0, firstPartSize, _table, startInTable);
      0|      target.setRange(firstPartSize, firstPartSize + endInTable, _table, 0);
       |    }
       |    return elementsToWrite;
       |  }
       |
       |  /// Assumes the table is currently full to capacity, and grows it to the next
       |  /// power of two.
      0|  void _growAtCapacity() {
       |    assert(_head == _tail);
       |
      0|    var newTable = _createList(_table.length * 2);
       |
       |    // We can't use [_writeToList] here because when `_head == _tail` it thinks
       |    // the queue is empty rather than full.
      0|    var partitionPoint = _table.length - _head;
      0|    newTable.setRange(0, partitionPoint, _table, _head);
      0|    if (partitionPoint != _table.length) {
      0|      newTable.setRange(partitionPoint, _table.length, _table);
       |    }
      0|    _head = 0;
      0|    _tail = _table.length;
      0|    _table = newTable;
       |  }
       |
       |  /// Grows the tableso it's at least large enough size to include that many
       |  /// elements.
      0|  void _growTo(int newElementCount) {
       |    assert(newElementCount >= length);
       |
       |    // Add some extra room to ensure that there's room for more elements after
       |    // expansion.
      0|    newElementCount += newElementCount >> 1;
      0|    var newTable = _createList(_nextPowerOf2(newElementCount));
      0|    _tail = _writeToList(newTable);
      0|    _table = newTable;
      0|    _head = 0;
       |  }
       |
       |  // Specialization for the specific type.
       |
       |  // Create a new typed list.
       |  L _createList(int size);
       |
       |  // Create a new typed buffer of the given type.
       |  List<E> _createBuffer(int size);
       |
       |  /// The default value used to fill the queue when changing length.
       |  E get _defaultValue;
       |}
       |
       |abstract class _IntQueue<L extends List<int>> extends _TypedQueue<int, L> {
      0|  _IntQueue(L queue) : super(queue);
       |
      0|  int get _defaultValue => 0;
       |}
       |
       |abstract class _FloatQueue<L extends List<double>>
       |    extends _TypedQueue<double, L> {
      0|  _FloatQueue(L queue) : super(queue);
       |
      0|  double get _defaultValue => 0.0;
       |}
       |
       |/// A [QueueList] that efficiently stores 8-bit unsigned integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are truncated to their low eight bits, interpreted
       |/// as an unsigned 8-bit integer with values in the range 0 to 255.
       |class Uint8Queue extends _IntQueue<Uint8List> implements QueueList<int> {
       |  /// Creates an empty [Uint8Queue] with the given initial internal capacity (in
       |  /// elements).
      0|  Uint8Queue([int initialCapacity])
      0|      : super(Uint8List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Uint8Queue] with the same length and contents as [elements].
      0|  factory Uint8Queue.fromList(List<int> elements) =>
      0|      Uint8Queue(elements.length)..addAll(elements);
       |
      0|  Uint8List _createList(int size) => Uint8List(size);
      0|  Uint8Buffer _createBuffer(int size) => Uint8Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores 8-bit signed integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are truncated to their low eight bits, interpreted
       |/// as a signed 8-bit two's complement integer with values in the range -128 to
       |/// +127.
       |class Int8Queue extends _IntQueue<Int8List> implements QueueList<int> {
       |  /// Creates an empty [Int8Queue] with the given initial internal capacity (in
       |  /// elements).
      0|  Int8Queue([int initialCapacity])
      0|      : super(Int8List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Int8Queue] with the same length and contents as [elements].
      0|  factory Int8Queue.fromList(List<int> elements) =>
      0|      Int8Queue(elements.length)..addAll(elements);
       |
      0|  Int8List _createList(int size) => Int8List(size);
      0|  Int8Buffer _createBuffer(int size) => Int8Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores 8-bit unsigned integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are clamped to an unsigned eight bit value. That is,
       |/// all values below zero are stored as zero and all values above 255 are stored
       |/// as 255.
       |class Uint8ClampedQueue extends _IntQueue<Uint8ClampedList>
       |    implements QueueList<int> {
       |  /// Creates an empty [Uint8ClampedQueue] with the given initial internal
       |  /// capacity (in elements).
      0|  Uint8ClampedQueue([int initialCapacity])
      0|      : super(Uint8ClampedList(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Uint8ClampedQueue] with the same length and contents as
       |  /// [elements].
      0|  factory Uint8ClampedQueue.fromList(List<int> elements) =>
      0|      Uint8ClampedQueue(elements.length)..addAll(elements);
       |
      0|  Uint8ClampedList _createList(int size) => Uint8ClampedList(size);
      0|  Uint8ClampedBuffer _createBuffer(int size) => Uint8ClampedBuffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores 16-bit unsigned integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are truncated to their low 16 bits, interpreted as
       |/// an unsigned 16-bit integer with values in the range 0 to 65535.
       |class Uint16Queue extends _IntQueue<Uint16List> implements QueueList<int> {
       |  /// Creates an empty [Uint16Queue] with the given initial internal capacity
       |  /// (in elements).
      0|  Uint16Queue([int initialCapacity])
      0|      : super(Uint16List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Uint16Queue] with the same length and contents as [elements].
      0|  factory Uint16Queue.fromList(List<int> elements) =>
      0|      Uint16Queue(elements.length)..addAll(elements);
       |
      0|  Uint16List _createList(int size) => Uint16List(size);
      0|  Uint16Buffer _createBuffer(int size) => Uint16Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores 16-bit signed integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are truncated to their low 16 bits, interpreted as a
       |/// signed 16-bit two's complement integer with values in the range -32768 to
       |/// +32767.
       |class Int16Queue extends _IntQueue<Int16List> implements QueueList<int> {
       |  /// Creates an empty [Int16Queue] with the given initial internal capacity (in
       |  /// elements).
      0|  Int16Queue([int initialCapacity])
      0|      : super(Int16List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Int16Queue] with the same length and contents as [elements].
      0|  factory Int16Queue.fromList(List<int> elements) =>
      0|      Int16Queue(elements.length)..addAll(elements);
       |
      0|  Int16List _createList(int size) => Int16List(size);
      0|  Int16Buffer _createBuffer(int size) => Int16Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores 32-bit unsigned integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are truncated to their low 32 bits, interpreted as
       |/// an unsigned 32-bit integer with values in the range 0 to 4294967295.
       |class Uint32Queue extends _IntQueue<Uint32List> implements QueueList<int> {
       |  /// Creates an empty [Uint32Queue] with the given initial internal capacity
       |  /// (in elements).
      0|  Uint32Queue([int initialCapacity])
      0|      : super(Uint32List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Uint32Queue] with the same length and contents as [elements].
      0|  factory Uint32Queue.fromList(List<int> elements) =>
      0|      Uint32Queue(elements.length)..addAll(elements);
       |
      0|  Uint32List _createList(int size) => Uint32List(size);
      0|  Uint32Buffer _createBuffer(int size) => Uint32Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores 32-bit signed integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are truncated to their low 32 bits, interpreted as a
       |/// signed 32-bit two's complement integer with values in the range -2147483648
       |/// to 2147483647.
       |class Int32Queue extends _IntQueue<Int32List> implements QueueList<int> {
       |  /// Creates an empty [Int32Queue] with the given initial internal capacity (in
       |  /// elements).
      0|  Int32Queue([int initialCapacity])
      0|      : super(Int32List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Int32Queue] with the same length and contents as [elements].
      0|  factory Int32Queue.fromList(List<int> elements) =>
      0|      Int32Queue(elements.length)..addAll(elements);
       |
      0|  Int32List _createList(int size) => Int32List(size);
      0|  Int32Buffer _createBuffer(int size) => Int32Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores 64-bit unsigned integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are truncated to their low 64 bits, interpreted as
       |/// an unsigned 64-bit integer with values in the range 0 to
       |/// 18446744073709551615.
       |class Uint64Queue extends _IntQueue<Uint64List> implements QueueList<int> {
       |  /// Creates an empty [Uint64Queue] with the given initial internal capacity
       |  /// (in elements).
      0|  Uint64Queue([int initialCapacity])
      0|      : super(Uint64List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Uint64Queue] with the same length and contents as [elements].
      0|  factory Uint64Queue.fromList(List<int> elements) =>
      0|      Uint64Queue(elements.length)..addAll(elements);
       |
      0|  Uint64List _createList(int size) => Uint64List(size);
      0|  Uint64Buffer _createBuffer(int size) => Uint64Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores 64-bit signed integers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Integers stored in this are truncated to their low 64 bits, interpreted as a
       |/// signed 64-bit two's complement integer with values in the range
       |/// -9223372036854775808 to +9223372036854775807.
       |class Int64Queue extends _IntQueue<Int64List> implements QueueList<int> {
       |  /// Creates an empty [Int64Queue] with the given initial internal capacity (in
       |  /// elements).
      0|  Int64Queue([int initialCapacity])
      0|      : super(Int64List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Int64Queue] with the same length and contents as [elements].
      0|  factory Int64Queue.fromList(List<int> elements) =>
      0|      Int64Queue(elements.length)..addAll(elements);
       |
      0|  Int64List _createList(int size) => Int64List(size);
      0|  Int64Buffer _createBuffer(int size) => Int64Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores IEEE 754 single-precision binary
       |/// floating-point numbers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |///
       |/// Doubles stored in this are converted to the nearest single-precision value.
       |/// Values read are converted to a double value with the same value.
       |class Float32Queue extends _FloatQueue<Float32List>
       |    implements QueueList<double> {
       |  /// Creates an empty [Float32Queue] with the given initial internal capacity
       |  /// (in elements).
      0|  Float32Queue([int initialCapacity])
      0|      : super(Float32List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Float32Queue] with the same length and contents as [elements].
      0|  factory Float32Queue.fromList(List<double> elements) =>
      0|      Float32Queue(elements.length)..addAll(elements);
       |
      0|  Float32List _createList(int size) => Float32List(size);
      0|  Float32Buffer _createBuffer(int size) => Float32Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores IEEE 754 double-precision binary
       |/// floating-point numbers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |class Float64Queue extends _FloatQueue<Float64List>
       |    implements QueueList<double> {
       |  /// Creates an empty [Float64Queue] with the given initial internal capacity
       |  /// (in elements).
      0|  Float64Queue([int initialCapacity])
      0|      : super(Float64List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Float64Queue] with the same length and contents as [elements].
      0|  factory Float64Queue.fromList(List<double> elements) =>
      0|      Float64Queue(elements.length)..addAll(elements);
       |
      0|  Float64List _createList(int size) => Float64List(size);
      0|  Float64Buffer _createBuffer(int size) => Float64Buffer(size);
       |}
       |
       |/// A [QueueList] that efficiently stores [Int32x4] numbers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |class Int32x4Queue extends _TypedQueue<Int32x4, Int32x4List>
       |    implements QueueList<Int32x4> {
      0|  static final Int32x4 _zero = Int32x4(0, 0, 0, 0);
       |
       |  /// Creates an empty [Int32x4Queue] with the given initial internal capacity
       |  /// (in elements).
      0|  Int32x4Queue([int initialCapacity])
      0|      : super(Int32x4List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Int32x4Queue] with the same length and contents as [elements].
      0|  factory Int32x4Queue.fromList(List<Int32x4> elements) =>
      0|      Int32x4Queue(elements.length)..addAll(elements);
       |
      0|  Int32x4List _createList(int size) => Int32x4List(size);
      0|  Int32x4Buffer _createBuffer(int size) => Int32x4Buffer(size);
      0|  Int32x4 get _defaultValue => _zero;
       |}
       |
       |/// A [QueueList] that efficiently stores [Float32x4] numbers.
       |///
       |/// For long queues, this implementation can be considerably more space- and
       |/// time-efficient than a default [QueueList] implementation.
       |class Float32x4Queue extends _TypedQueue<Float32x4, Float32x4List>
       |    implements QueueList<Float32x4> {
       |  /// Creates an empty [Float32x4Queue] with the given initial internal capacity (in
       |  /// elements).
      0|  Float32x4Queue([int initialCapacity])
      0|      : super(Float32x4List(_chooseRealInitialCapacity(initialCapacity)));
       |
       |  /// Creates a [Float32x4Queue] with the same length and contents as [elements].
      0|  factory Float32x4Queue.fromList(List<Float32x4> elements) =>
      0|      Float32x4Queue(elements.length)..addAll(elements);
       |
      0|  Float32x4List _createList(int size) => Float32x4List(size);
      0|  Float32x4Buffer _createBuffer(int size) => Float32x4Buffer(size);
      0|  Float32x4 get _defaultValue => Float32x4.zero();
       |}
       |
       |/// The initial capacity of queues if the user doesn't specify one.
       |const _defaultInitialCapacity = 16;
       |
       |/// Choose the next-highest power of two given a user-specified
       |/// [initialCapacity] for a queue.
      0|int _chooseRealInitialCapacity(int initialCapacity) {
      0|  if (initialCapacity == null || initialCapacity < _defaultInitialCapacity) {
       |    return _defaultInitialCapacity;
      0|  } else if (!_isPowerOf2(initialCapacity)) {
      0|    return _nextPowerOf2(initialCapacity);
       |  } else {
       |    return initialCapacity;
       |  }
       |}
       |
       |/// Whether [number] is a power of two.
       |///
       |/// Only works for positive numbers.
      0|bool _isPowerOf2(int number) => (number & (number - 1)) == 0;
       |
       |/// Rounds [number] up to the nearest power of 2.
       |///
       |/// If [number] is a power of 2 already, it is returned.
       |///
       |/// Only works for positive numbers.
      0|int _nextPowerOf2(int number) {
       |  assert(number > 0);
      0|  number = (number << 1) - 1;
       |  for (;;) {
      0|    var nextNumber = number & (number - 1);
      0|    if (nextNumber == 0) return number;
       |    number = nextNumber;
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/typed_data-1.2.0/lib/src/typed_buffer.dart
       |// Copyright (c) 2020, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:collection' show ListBase;
       |import 'dart:typed_data';
       |
       |abstract class TypedDataBuffer<E> extends ListBase<E> {
       |  static const int _initialLength = 8;
       |
       |  /// The underlying data buffer.
       |  ///
       |  /// This is always both a List<E> and a TypedData, which we don't have a type
       |  /// for here. For example, for a `Uint8Buffer`, this is a `Uint8List`.
       |  List<E> _buffer;
       |
       |  /// Returns a view of [_buffer] as a [TypedData].
      0|  TypedData get _typedBuffer => _buffer as TypedData;
       |
       |  /// The length of the list being built.
       |  int _length;
       |
      0|  TypedDataBuffer(List<E> buffer)
       |      : _buffer = buffer,
      0|        _length = buffer.length;
       |
      0|  @override
      0|  int get length => _length;
       |
      0|  @override
       |  E operator [](int index) {
      0|    if (index >= length) throw RangeError.index(index, this);
      0|    return _buffer[index];
       |  }
       |
      0|  @override
       |  void operator []=(int index, E value) {
      0|    if (index >= length) throw RangeError.index(index, this);
      0|    _buffer[index] = value;
       |  }
       |
      0|  @override
       |  set length(int newLength) {
      0|    if (newLength < _length) {
      0|      var defaultValue = _defaultValue;
      0|      for (var i = newLength; i < _length; i++) {
      0|        _buffer[i] = defaultValue;
       |      }
      0|    } else if (newLength > _buffer.length) {
       |      List<E> newBuffer;
      0|      if (_buffer.isEmpty) {
      0|        newBuffer = _createBuffer(newLength);
       |      } else {
      0|        newBuffer = _createBiggerBuffer(newLength);
       |      }
      0|      newBuffer.setRange(0, _length, _buffer);
      0|      _buffer = newBuffer;
       |    }
      0|    _length = newLength;
       |  }
       |
      0|  void _add(E value) {
      0|    if (_length == _buffer.length) _grow(_length);
      0|    _buffer[_length++] = value;
       |  }
       |
       |  // We override the default implementation of `add` because it grows the list
       |  // by setting the length in increments of one. We want to grow by doubling
       |  // capacity in most cases.
      0|  @override
       |  void add(E value) {
      0|    _add(value);
       |  }
       |
       |  /// Appends all objects of [values] to the end of this buffer.
       |  ///
       |  /// This adds values from [start] (inclusive) to [end] (exclusive) in
       |  /// [values]. If [end] is omitted, it defaults to adding all elements of
       |  /// [values] after [start].
       |  ///
       |  /// The [start] value must be non-negative. The [values] iterable must have at
       |  /// least [start] elements, and if [end] is specified, it must be greater than
       |  /// or equal to [start] and [values] must have at least [end] elements.
      0|  @override
       |  void addAll(Iterable<E> values, [int start = 0, int end]) {
      0|    RangeError.checkNotNegative(start, 'start');
      0|    if (end != null && start > end) {
      0|      throw RangeError.range(end, start, null, 'end');
       |    }
       |
      0|    _addAll(values, start, end);
       |  }
       |
       |  /// Inserts all objects of [values] at position [index] in this list.
       |  ///
       |  /// This adds values from [start] (inclusive) to [end] (exclusive) in
       |  /// [values]. If [end] is omitted, it defaults to adding all elements of
       |  /// [values] after [start].
       |  ///
       |  /// The [start] value must be non-negative. The [values] iterable must have at
       |  /// least [start] elements, and if [end] is specified, it must be greater than
       |  /// or equal to [start] and [values] must have at least [end] elements.
      0|  @override
       |  void insertAll(int index, Iterable<E> values, [int start = 0, int end]) {
      0|    RangeError.checkValidIndex(index, this, 'index', _length + 1);
      0|    RangeError.checkNotNegative(start, 'start');
       |    if (end != null) {
      0|      if (start > end) {
      0|        throw RangeError.range(end, start, null, 'end');
       |      }
      0|      if (start == end) return;
       |    }
       |
       |    // If we're adding to the end of the list anyway, use [_addAll]. This lets
       |    // us avoid converting [values] into a list even if [end] is null, since we
       |    // can add values iteratively to the end of the list. We can't do so in the
       |    // center because copying the trailing elements every time is non-linear.
      0|    if (index == _length) {
      0|      _addAll(values, start, end);
       |      return;
       |    }
       |
      0|    if (end == null && values is List) {
      0|      end = values.length;
       |    }
       |    if (end != null) {
      0|      _insertKnownLength(index, values, start, end);
       |      return;
       |    }
       |
       |    // Add elements at end, growing as appropriate, then put them back at
       |    // position [index] using flip-by-double-reverse.
      0|    var writeIndex = _length;
       |    var skipCount = start;
      0|    for (var value in values) {
      0|      if (skipCount > 0) {
      0|        skipCount--;
       |        continue;
       |      }
      0|      if (writeIndex == _buffer.length) {
      0|        _grow(writeIndex);
       |      }
      0|      _buffer[writeIndex++] = value;
       |    }
       |
      0|    if (skipCount > 0) {
      0|      throw StateError('Too few elements');
       |    }
      0|    if (end != null && writeIndex < end) {
      0|      throw RangeError.range(end, start, writeIndex, 'end');
       |    }
       |
       |    // Swap [index.._length) and [_length..writeIndex) by double-reversing.
      0|    _reverse(_buffer, index, _length);
      0|    _reverse(_buffer, _length, writeIndex);
      0|    _reverse(_buffer, index, writeIndex);
      0|    _length = writeIndex;
       |    return;
       |  }
       |
       |  // Reverses the range [start..end) of buffer.
      0|  static void _reverse(List buffer, int start, int end) {
      0|    end--; // Point to last element, not after last element.
      0|    while (start < end) {
      0|      var first = buffer[start];
      0|      var last = buffer[end];
      0|      buffer[end] = first;
      0|      buffer[start] = last;
      0|      start++;
      0|      end--;
       |    }
       |  }
       |
       |  /// Does the same thing as [addAll].
       |  ///
       |  /// This allows [addAll] and [insertAll] to share implementation without a
       |  /// subclass unexpectedly overriding both when it intended to only override
       |  /// [addAll].
      0|  void _addAll(Iterable<E> values, [int start = 0, int end]) {
      0|    if (values is List) end ??= values.length;
       |
       |    // If we know the length of the segment to add, do so with [addRange]. This
       |    // way we know how much to grow the buffer in advance, and it may be even
       |    // more efficient for typed data input.
       |    if (end != null) {
      0|      _insertKnownLength(_length, values, start, end);
       |      return;
       |    }
       |
       |    // Otherwise, just add values one at a time.
       |    var i = 0;
      0|    for (var value in values) {
      0|      if (i >= start) add(value);
      0|      i++;
       |    }
      0|    if (i < start) throw StateError('Too few elements');
       |  }
       |
       |  /// Like [insertAll], but with a guaranteed non-`null` [start] and [end].
      0|  void _insertKnownLength(int index, Iterable<E> values, int start, int end) {
      0|    if (values is List) {
      0|      end ??= values.length;
      0|      if (start > values.length || end > values.length) {
      0|        throw StateError('Too few elements');
       |      }
       |    } else {
       |      assert(end != null);
       |    }
       |
      0|    var valuesLength = end - start;
      0|    var newLength = _length + valuesLength;
      0|    _ensureCapacity(newLength);
       |
      0|    _buffer.setRange(
      0|        index + valuesLength, _length + valuesLength, _buffer, index);
      0|    _buffer.setRange(index, index + valuesLength, values, start);
      0|    _length = newLength;
       |  }
       |
      0|  @override
       |  void insert(int index, E element) {
      0|    if (index < 0 || index > _length) {
      0|      throw RangeError.range(index, 0, _length);
       |    }
      0|    if (_length < _buffer.length) {
      0|      _buffer.setRange(index + 1, _length + 1, _buffer, index);
      0|      _buffer[index] = element;
      0|      _length++;
       |      return;
       |    }
      0|    var newBuffer = _createBiggerBuffer(null);
      0|    newBuffer.setRange(0, index, _buffer);
      0|    newBuffer.setRange(index + 1, _length + 1, _buffer, index);
      0|    newBuffer[index] = element;
      0|    _length++;
      0|    _buffer = newBuffer;
       |  }
       |
       |  /// Ensures that [_buffer] is at least [requiredCapacity] long,
       |  ///
       |  /// Grows the buffer if necessary, preserving existing data.
      0|  void _ensureCapacity(int requiredCapacity) {
      0|    if (requiredCapacity <= _buffer.length) return;
      0|    var newBuffer = _createBiggerBuffer(requiredCapacity);
      0|    newBuffer.setRange(0, _length, _buffer);
      0|    _buffer = newBuffer;
       |  }
       |
       |  /// Create a bigger buffer.
       |  ///
       |  /// This method determines how much bigger a bigger buffer should
       |  /// be. If [requiredCapacity] is not null, it will be at least that
       |  /// size. It will always have at least have double the capacity of
       |  /// the current buffer.
      0|  List<E> _createBiggerBuffer(int requiredCapacity) {
      0|    var newLength = _buffer.length * 2;
      0|    if (requiredCapacity != null && newLength < requiredCapacity) {
       |      newLength = requiredCapacity;
      0|    } else if (newLength < _initialLength) {
       |      newLength = _initialLength;
       |    }
      0|    return _createBuffer(newLength);
       |  }
       |
       |  /// Grows the buffer.
       |  ///
       |  /// This copies the first [length] elements into the new buffer.
      0|  void _grow(int length) {
      0|    _buffer = _createBiggerBuffer(null)..setRange(0, length, _buffer);
       |  }
       |
      0|  @override
       |  void setRange(int start, int end, Iterable<E> source, [int skipCount = 0]) {
      0|    if (end > _length) throw RangeError.range(end, 0, _length);
      0|    _setRange(start, end, source, skipCount);
       |  }
       |
       |  /// Like [setRange], but with no bounds checking.
      0|  void _setRange(int start, int end, Iterable<E> source, int skipCount) {
      0|    if (source is TypedDataBuffer<E>) {
      0|      _buffer.setRange(start, end, source._buffer, skipCount);
       |    } else {
      0|      _buffer.setRange(start, end, source, skipCount);
       |    }
       |  }
       |
       |  // TypedData.
       |
      0|  int get elementSizeInBytes => _typedBuffer.elementSizeInBytes;
       |
      0|  int get lengthInBytes => _length * _typedBuffer.elementSizeInBytes;
       |
      0|  int get offsetInBytes => _typedBuffer.offsetInBytes;
       |
       |  /// Returns the underlying [ByteBuffer].
       |  ///
       |  /// The returned buffer may be replaced by operations that change the [length]
       |  /// of this list.
       |  ///
       |  /// The buffer may be larger than [lengthInBytes] bytes, but never smaller.
      0|  ByteBuffer get buffer => _typedBuffer.buffer;
       |
       |  // Specialization for the specific type.
       |
       |  // Return zero for integers, 0.0 for floats, etc.
       |  // Used to fill buffer when changing length.
       |  E get _defaultValue;
       |
       |  // Create a new typed list to use as buffer.
       |  List<E> _createBuffer(int size);
       |}
       |
       |abstract class _IntBuffer extends TypedDataBuffer<int> {
      0|  _IntBuffer(List<int> buffer) : super(buffer);
       |
      0|  @override
       |  int get _defaultValue => 0;
       |}
       |
       |abstract class _FloatBuffer extends TypedDataBuffer<double> {
      0|  _FloatBuffer(List<double> buffer) : super(buffer);
       |
      0|  @override
       |  double get _defaultValue => 0.0;
       |}
       |
       |class Uint8Buffer extends _IntBuffer {
      0|  Uint8Buffer([int initialLength = 0]) : super(Uint8List(initialLength));
       |
      0|  @override
      0|  Uint8List _createBuffer(int size) => Uint8List(size);
       |}
       |
       |class Int8Buffer extends _IntBuffer {
      0|  Int8Buffer([int initialLength = 0]) : super(Int8List(initialLength));
       |
      0|  @override
      0|  Int8List _createBuffer(int size) => Int8List(size);
       |}
       |
       |class Uint8ClampedBuffer extends _IntBuffer {
      0|  Uint8ClampedBuffer([int initialLength = 0])
      0|      : super(Uint8ClampedList(initialLength));
       |
      0|  @override
      0|  Uint8ClampedList _createBuffer(int size) => Uint8ClampedList(size);
       |}
       |
       |class Uint16Buffer extends _IntBuffer {
      0|  Uint16Buffer([int initialLength = 0]) : super(Uint16List(initialLength));
       |
      0|  @override
      0|  Uint16List _createBuffer(int size) => Uint16List(size);
       |}
       |
       |class Int16Buffer extends _IntBuffer {
      0|  Int16Buffer([int initialLength = 0]) : super(Int16List(initialLength));
       |
      0|  @override
      0|  Int16List _createBuffer(int size) => Int16List(size);
       |}
       |
       |class Uint32Buffer extends _IntBuffer {
      0|  Uint32Buffer([int initialLength = 0]) : super(Uint32List(initialLength));
       |
      0|  @override
      0|  Uint32List _createBuffer(int size) => Uint32List(size);
       |}
       |
       |class Int32Buffer extends _IntBuffer {
      0|  Int32Buffer([int initialLength = 0]) : super(Int32List(initialLength));
       |
      0|  @override
      0|  Int32List _createBuffer(int size) => Int32List(size);
       |}
       |
       |class Uint64Buffer extends _IntBuffer {
      0|  Uint64Buffer([int initialLength = 0]) : super(Uint64List(initialLength));
       |
      0|  @override
      0|  Uint64List _createBuffer(int size) => Uint64List(size);
       |}
       |
       |class Int64Buffer extends _IntBuffer {
      0|  Int64Buffer([int initialLength = 0]) : super(Int64List(initialLength));
       |
      0|  @override
      0|  Int64List _createBuffer(int size) => Int64List(size);
       |}
       |
       |class Float32Buffer extends _FloatBuffer {
      0|  Float32Buffer([int initialLength = 0]) : super(Float32List(initialLength));
       |
      0|  @override
      0|  Float32List _createBuffer(int size) => Float32List(size);
       |}
       |
       |class Float64Buffer extends _FloatBuffer {
      0|  Float64Buffer([int initialLength = 0]) : super(Float64List(initialLength));
       |
      0|  @override
      0|  Float64List _createBuffer(int size) => Float64List(size);
       |}
       |
       |class Int32x4Buffer extends TypedDataBuffer<Int32x4> {
      0|  static final Int32x4 _zero = Int32x4(0, 0, 0, 0);
       |
      0|  Int32x4Buffer([int initialLength = 0]) : super(Int32x4List(initialLength));
       |
      0|  @override
      0|  Int32x4 get _defaultValue => _zero;
       |
      0|  @override
      0|  Int32x4List _createBuffer(int size) => Int32x4List(size);
       |}
       |
       |class Float32x4Buffer extends TypedDataBuffer<Float32x4> {
      0|  Float32x4Buffer([int initialLength = 0])
      0|      : super(Float32x4List(initialLength));
       |
      0|  @override
      0|  Float32x4 get _defaultValue => Float32x4.zero();
       |
      0|  @override
      0|  Float32x4List _createBuffer(int size) => Float32x4List(size);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/hex/encoder.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |library convert.hex.encoder;
       |
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import 'package:charcode/ascii.dart';
       |
       |/// The canonical instance of [HexEncoder].
       |const hexEncoder = const HexEncoder._();
       |
       |/// A converter that encodes byte arrays into hexadecimal strings.
       |///
       |/// This will throw a [RangeError] if the byte array has any digits that don't
       |/// fit in the gamut of a byte.
       |class HexEncoder extends Converter<List<int>, String> {
      0|  const HexEncoder._();
       |
      0|  String convert(List<int> bytes) => _convert(bytes, 0, bytes.length);
       |
      0|  ByteConversionSink startChunkedConversion(Sink<String> sink) =>
      0|      new _HexEncoderSink(sink);
       |}
       |
       |/// A conversion sink for chunked hexadecimal encoding.
       |class _HexEncoderSink extends ByteConversionSinkBase {
       |  /// The underlying sink to which decoded byte arrays will be passed.
       |  final Sink<String> _sink;
       |
      0|  _HexEncoderSink(this._sink);
       |
      0|  void add(List<int> chunk) {
      0|    _sink.add(_convert(chunk, 0, chunk.length));
       |  }
       |
      0|  void addSlice(List<int> chunk, int start, int end, bool isLast) {
      0|    RangeError.checkValidRange(start, end, chunk.length);
      0|    _sink.add(_convert(chunk, start, end));
      0|    if (isLast) _sink.close();
       |  }
       |
      0|  void close() {
      0|    _sink.close();
       |  }
       |}
       |
      0|String _convert(List<int> bytes, int start, int end) {
       |  // A Uint8List is more efficient than a StringBuffer given that we know that
       |  // we're only emitting ASCII-compatible characters, and that we know the
       |  // length ahead of time.
      0|  var buffer = new Uint8List((end - start) * 2);
       |  var bufferIndex = 0;
       |
       |  // A bitwise OR of all bytes in [bytes]. This allows us to check for
       |  // out-of-range bytes without adding more branches than necessary to the
       |  // core loop.
       |  var byteOr = 0;
      0|  for (var i = start; i < end; i++) {
      0|    var byte = bytes[i];
      0|    byteOr |= byte;
       |
       |    // The bitwise arithmetic here is equivalent to `byte ~/ 16` and `byte % 16`
       |    // for valid byte values, but is easier for dart2js to optimize given that
       |    // it can't prove that [byte] will always be positive.
      0|    buffer[bufferIndex++] = _codeUnitForDigit((byte & 0xF0) >> 4);
      0|    buffer[bufferIndex++] = _codeUnitForDigit(byte & 0x0F);
       |  }
       |
      0|  if (byteOr >= 0 && byteOr <= 255) return new String.fromCharCodes(buffer);
       |
       |  // If there was an invalid byte, find it and throw an exception.
      0|  for (var i = start; i < end; i++) {
      0|    var byte = bytes[i];
      0|    if (byte >= 0 && byte <= 0xff) continue;
      0|    throw new FormatException(
      0|        "Invalid byte ${byte < 0 ? "-" : ""}0x${byte.abs().toRadixString(16)}.",
       |        bytes,
       |        i);
       |  }
       |
       |  throw 'unreachable';
       |}
       |
       |/// Returns the ASCII/Unicode code unit corresponding to the hexadecimal digit
       |/// [digit].
      0|int _codeUnitForDigit(int digit) => digit < 10 ? digit + $0 : digit + $a - 10;
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/convert-2.1.1/lib/src/hex/decoder.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |library convert.hex.decoder;
       |
       |import 'dart:convert';
       |import 'dart:typed_data';
       |
       |import '../utils.dart';
       |
       |/// The canonical instance of [HexDecoder].
       |const hexDecoder = const HexDecoder._();
       |
       |/// A converter that decodes hexadecimal strings into byte arrays.
       |///
       |/// Because two hexadecimal digits correspond to a single byte, this will throw
       |/// a [FormatException] if given an odd-length string. It will also throw a
       |/// [FormatException] if given a string containing non-hexadecimal code units.
       |class HexDecoder extends Converter<String, List<int>> {
      0|  const HexDecoder._();
       |
      0|  List<int> convert(String string) {
      0|    if (!string.length.isEven) {
      0|      throw new FormatException(
      0|          "Invalid input length, must be even.", string, string.length);
       |    }
       |
      0|    var bytes = new Uint8List(string.length ~/ 2);
      0|    _decode(string.codeUnits, 0, string.length, bytes, 0);
       |    return bytes;
       |  }
       |
      0|  StringConversionSink startChunkedConversion(Sink<List<int>> sink) =>
      0|      new _HexDecoderSink(sink);
       |}
       |
       |/// A conversion sink for chunked hexadecimal decoding.
       |class _HexDecoderSink extends StringConversionSinkBase {
       |  /// The underlying sink to which decoded byte arrays will be passed.
       |  final Sink<List<int>> _sink;
       |
       |  /// The trailing digit from the previous string.
       |  ///
       |  /// This will be non-`null` if the most recent string had an odd number of
       |  /// hexadecimal digits. Since it's the most significant digit, it's always a
       |  /// multiple of 16.
       |  int _lastDigit;
       |
      0|  _HexDecoderSink(this._sink);
       |
      0|  void addSlice(String string, int start, int end, bool isLast) {
      0|    RangeError.checkValidRange(start, end, string.length);
       |
      0|    if (start == end) {
      0|      if (isLast) _close(string, end);
       |      return;
       |    }
       |
      0|    var codeUnits = string.codeUnits;
       |    Uint8List bytes;
       |    int bytesStart;
      0|    if (_lastDigit == null) {
      0|      bytes = new Uint8List((end - start) ~/ 2);
       |      bytesStart = 0;
       |    } else {
      0|      var hexPairs = (end - start - 1) ~/ 2;
      0|      bytes = new Uint8List(1 + hexPairs);
      0|      bytes[0] = _lastDigit + digitForCodeUnit(codeUnits, start);
      0|      start++;
       |      bytesStart = 1;
       |    }
       |
      0|    _lastDigit = _decode(codeUnits, start, end, bytes, bytesStart);
       |
      0|    _sink.add(bytes);
      0|    if (isLast) _close(string, end);
       |  }
       |
      0|  ByteConversionSink asUtf8Sink(bool allowMalformed) =>
      0|      new _HexDecoderByteSink(_sink);
       |
      0|  void close() => _close();
       |
       |  /// Like [close], but includes [string] and [index] in the [FormatException]
       |  /// if one is thrown.
      0|  void _close([String string, int index]) {
      0|    if (_lastDigit != null) {
      0|      throw new FormatException(
       |          "Input ended with incomplete encoded byte.", string, index);
       |    }
       |
      0|    _sink.close();
       |  }
       |}
       |
       |/// A conversion sink for chunked hexadecimal decoding from UTF-8 bytes.
       |class _HexDecoderByteSink extends ByteConversionSinkBase {
       |  /// The underlying sink to which decoded byte arrays will be passed.
       |  final Sink<List<int>> _sink;
       |
       |  /// The trailing digit from the previous string.
       |  ///
       |  /// This will be non-`null` if the most recent string had an odd number of
       |  /// hexadecimal digits. Since it's the most significant digit, it's always a
       |  /// multiple of 16.
       |  int _lastDigit;
       |
      0|  _HexDecoderByteSink(this._sink);
       |
      0|  void add(List<int> chunk) => addSlice(chunk, 0, chunk.length, false);
       |
      0|  void addSlice(List<int> chunk, int start, int end, bool isLast) {
      0|    RangeError.checkValidRange(start, end, chunk.length);
       |
      0|    if (start == end) {
      0|      if (isLast) _close(chunk, end);
       |      return;
       |    }
       |
       |    Uint8List bytes;
       |    int bytesStart;
      0|    if (_lastDigit == null) {
      0|      bytes = new Uint8List((end - start) ~/ 2);
       |      bytesStart = 0;
       |    } else {
      0|      var hexPairs = (end - start - 1) ~/ 2;
      0|      bytes = new Uint8List(1 + hexPairs);
      0|      bytes[0] = _lastDigit + digitForCodeUnit(chunk, start);
      0|      start++;
       |      bytesStart = 1;
       |    }
       |
      0|    _lastDigit = _decode(chunk, start, end, bytes, bytesStart);
       |
      0|    _sink.add(bytes);
      0|    if (isLast) _close(chunk, end);
       |  }
       |
      0|  void close() => _close();
       |
       |  /// Like [close], but includes [chunk] and [index] in the [FormatException]
       |  /// if one is thrown.
      0|  void _close([List<int> chunk, int index]) {
      0|    if (_lastDigit != null) {
      0|      throw new FormatException(
       |          "Input ended with incomplete encoded byte.", chunk, index);
       |    }
       |
      0|    _sink.close();
       |  }
       |}
       |
       |/// Decodes [codeUnits] and writes the result into [destination].
       |///
       |/// This reads from [codeUnits] between [sourceStart] and [sourceEnd]. It writes
       |/// the result into [destination] starting at [destinationStart].
       |///
       |/// If there's a leftover digit at the end of the decoding, this returns that
       |/// digit. Otherwise it returns `null`.
      0|int _decode(List<int> codeUnits, int sourceStart, int sourceEnd,
       |    List<int> destination, int destinationStart) {
       |  var destinationIndex = destinationStart;
      0|  for (var i = sourceStart; i < sourceEnd - 1; i += 2) {
      0|    var firstDigit = digitForCodeUnit(codeUnits, i);
      0|    var secondDigit = digitForCodeUnit(codeUnits, i + 1);
      0|    destination[destinationIndex++] = 16 * firstDigit + secondDigit;
       |  }
       |
      0|  if ((sourceEnd - sourceStart).isEven) return null;
      0|  return 16 * digitForCodeUnit(codeUnits, sourceEnd - 1);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/crypto-2.1.5/lib/src/digest_sink.dart
       |// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'digest.dart';
       |
       |/// A sink used to get a digest value out of `Hash.startChunkedConversion`.
       |class DigestSink extends Sink<Digest> {
       |  /// The value added to the sink, if any.
      0|  Digest get value {
       |    assert(_value != null);
      0|    return _value;
       |  }
       |
       |  Digest _value;
       |
       |  /// Adds [value] to the sink.
       |  ///
       |  /// Unlike most sinks, this may only be called once.
      0|  @override
       |  void add(Digest value) {
       |    assert(_value == null);
      0|    _value = value;
       |  }
       |
      0|  @override
       |  void close() {
       |    assert(_value != null);
       |  }
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/json_annotation-3.1.0/lib/src/allowed_keys_helpers.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// Helper function used in generated `fromJson` code when
       |/// `JsonSerializable.disallowUnrecognizedKeys` is true for an annotated type or
       |/// `JsonKey.required` is `true` for any annotated fields.
       |///
       |/// Should not be used directly.
      0|void $checkKeys(Map map,
       |    {List<String> allowedKeys,
       |    List<String> requiredKeys,
       |    List<String> disallowNullValues}) {
       |  if (map != null && allowedKeys != null) {
       |    final invalidKeys =
      0|        map.keys.cast<String>().where((k) => !allowedKeys.contains(k)).toList();
      0|    if (invalidKeys.isNotEmpty) {
      0|      throw UnrecognizedKeysException(invalidKeys, map, allowedKeys);
       |    }
       |  }
       |
       |  if (requiredKeys != null) {
       |    final missingKeys =
      0|        requiredKeys.where((k) => !map.keys.contains(k)).toList();
      0|    if (missingKeys.isNotEmpty) {
      0|      throw MissingRequiredKeysException(missingKeys, map);
       |    }
       |  }
       |
       |  if (map != null && disallowNullValues != null) {
      0|    final nullValuedKeys = map.entries
      0|        .where((entry) =>
      0|            disallowNullValues.contains(entry.key) && entry.value == null)
      0|        .map((entry) => entry.key as String)
      0|        .toList();
       |
      0|    if (nullValuedKeys.isNotEmpty) {
      0|      throw DisallowedNullValueException(nullValuedKeys, map);
       |    }
       |  }
       |}
       |
       |/// A base class for exceptions thrown when decoding JSON.
       |abstract class BadKeyException implements Exception {
      0|  BadKeyException._(this.map);
       |
       |  /// The source [Map] that the unrecognized keys were found in.
       |  final Map map;
       |
       |  /// A human-readable message corresponding to the error.
       |  String get message;
       |}
       |
       |/// Exception thrown if there are unrecognized keys in a JSON map that was
       |/// provided during deserialization.
       |class UnrecognizedKeysException extends BadKeyException {
       |  /// The allowed keys for [map].
       |  final List<String> allowedKeys;
       |
       |  /// The keys from [map] that were unrecognized.
       |  final List<String> unrecognizedKeys;
       |
      0|  @override
      0|  String get message =>
      0|      'Unrecognized keys: [${unrecognizedKeys.join(', ')}]; supported keys: '
      0|      '[${allowedKeys.join(', ')}]';
       |
      0|  UnrecognizedKeysException(this.unrecognizedKeys, Map map, this.allowedKeys)
      0|      : super._(map);
       |}
       |
       |/// Exception thrown if there are missing required keys in a JSON map that was
       |/// provided during deserialization.
       |class MissingRequiredKeysException extends BadKeyException {
       |  /// The keys that [map] is missing.
       |  final List<String> missingKeys;
       |
      0|  @override
      0|  String get message => 'Required keys are missing: ${missingKeys.join(', ')}.';
       |
      0|  MissingRequiredKeysException(this.missingKeys, Map map)
       |      : assert(missingKeys.isNotEmpty),
      0|        super._(map);
       |}
       |
       |/// Exception thrown if there are keys with disallowed `null` values in a JSON
       |/// map that was provided during deserialization.
       |class DisallowedNullValueException extends BadKeyException {
       |  final List<String> keysWithNullValues;
       |
      0|  DisallowedNullValueException(this.keysWithNullValues, Map map) : super._(map);
       |
      0|  @override
      0|  String get message => 'These keys had `null` values, '
      0|      'which is not allowed: $keysWithNullValues';
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/json_annotation-3.1.0/lib/src/checked_helpers.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'allowed_keys_helpers.dart';
       |
       |/// Helper function used in generated code when
       |/// `JsonSerializableGenerator.checked` is `true`.
       |///
       |/// Should not be used directly.
      0|T $checkedNew<T>(String className, Map map, T Function() constructor,
       |    {Map<String, String> fieldKeyMap}) {
       |  fieldKeyMap ??= const {};
       |
       |  try {
      0|    return constructor();
      0|  } on CheckedFromJsonException catch (e) {
      0|    if (identical(e.map, map) && e._className == null) {
      0|      e._className = className;
       |    }
       |    rethrow;
       |  } catch (error, stack) {
       |    String key;
      0|    if (error is ArgumentError) {
      0|      key = fieldKeyMap[error.name] ?? error.name;
      0|    } else if (error is MissingRequiredKeysException) {
      0|      key = error.missingKeys.first;
      0|    } else if (error is DisallowedNullValueException) {
      0|      key = error.keysWithNullValues.first;
       |    }
      0|    throw CheckedFromJsonException._(error, stack, map, key,
       |        className: className);
       |  }
       |}
       |
       |/// Helper function used in generated code when
       |/// `JsonSerializableGenerator.checked` is `true`.
       |///
       |/// Should not be used directly.
      0|T $checkedConvert<T>(Map map, String key, T Function(Object) castFunc) {
       |  try {
      0|    return castFunc(map[key]);
      0|  } on CheckedFromJsonException {
       |    rethrow;
       |  } catch (error, stack) {
      0|    throw CheckedFromJsonException._(error, stack, map, key);
       |  }
       |}
       |
       |/// Exception thrown if there is a runtime exception in `fromJson`
       |/// code generated when `JsonSerializableGenerator.checked` is `true`
       |class CheckedFromJsonException implements Exception {
       |  /// The [Error] or [Exception] that triggered this exception.
       |  ///
       |  /// If this instance was created by user code, this field will be `null`.
       |  final Object innerError;
       |
       |  /// The [StackTrace] for the [Error] or [Exception] that triggered this
       |  /// exception.
       |  ///
       |  /// If this instance was created by user code, this field will be `null`.
       |  final StackTrace innerStack;
       |
       |  /// The key from [map] that corresponds to the thrown [innerError].
       |  ///
       |  /// May be `null`.
       |  final String key;
       |
       |  /// The source [Map] that was used for decoding when the [innerError] was
       |  /// thrown.
       |  final Map map;
       |
       |  /// A human-readable message corresponding to [innerError].
       |  ///
       |  /// May be `null`.
       |  final String message;
       |
       |  /// The name of the class being created when [innerError] was thrown.
      0|  String get className => _className;
       |  String _className;
       |
       |  /// If this was thrown due to an invalid or unsupported key, as opposed to an
       |  /// invalid value.
       |  final bool badKey;
       |
       |  /// Creates a new instance of [CheckedFromJsonException].
      0|  CheckedFromJsonException(
       |    this.map,
       |    this.key,
       |    String className,
       |    this.message, {
       |    bool badKey = false,
       |  })  : _className = className,
       |        badKey = badKey ?? false,
       |        innerError = null,
       |        innerStack = null;
       |
      0|  CheckedFromJsonException._(
       |    this.innerError,
       |    this.innerStack,
       |    this.map,
       |    this.key, {
       |    String className,
       |  })  : _className = className,
      0|        badKey = innerError is BadKeyException,
      0|        message = _getMessage(innerError);
       |
      0|  static String _getMessage(Object error) {
      0|    if (error is ArgumentError) {
      0|      return error.message?.toString();
      0|    } else if (error is BadKeyException) {
      0|      return error.message;
      0|    } else if (error is FormatException) {
      0|      var message = error.message;
      0|      if (error.offset != null) {
      0|        message = '$message at offset ${error.offset}.';
       |      }
       |      return message;
       |    }
       |    return null;
       |  }
       |
      0|  @override
      0|  String toString() => <String>[
      0|        'CheckedFromJsonException',
      0|        if (_className != null) 'Could not create `$_className`.',
      0|        if (key != null) 'There is a problem with "$key".',
      0|        if (message != null) message,
      0|        if (message == null && innerError != null) innerError.toString(),
      0|      ].join('\n');
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/json_annotation-3.1.0/lib/src/json_key.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'allowed_keys_helpers.dart';
       |import 'json_serializable.dart';
       |
       |/// An annotation used to specify how a field is serialized.
       |class JsonKey {
       |  /// The value to use if the source JSON does not contain this key or if the
       |  /// value is `null`.
       |  final Object defaultValue;
       |
       |  /// If `true`, generated code will throw a [DisallowedNullValueException] if
       |  /// the corresponding key exists, but the value is `null`.
       |  ///
       |  /// Note: this value does not affect the behavior of a JSON map *without* the
       |  /// associated key.
       |  ///
       |  /// If [disallowNullValue] is `true`, [includeIfNull] will be treated as
       |  /// `false` to ensure compatibility between `toJson` and `fromJson`.
       |  ///
       |  /// If both [includeIfNull] and [disallowNullValue] are set to `true` on the
       |  /// same field, an exception will be thrown during code generation.
       |  final bool disallowNullValue;
       |
       |  /// A [Function] to use when decoding the associated JSON value to the
       |  /// annotated field.
       |  ///
       |  /// Must be a top-level or static [Function] that takes one argument mapping
       |  /// a JSON literal to a value compatible with the type of the annotated field.
       |  ///
       |  /// When creating a class that supports both `toJson` and `fromJson`
       |  /// (the default), you should also set [toJson] if you set [fromJson].
       |  /// Values returned by [toJson] should "round-trip" through [fromJson].
       |  final Function fromJson;
       |
       |  /// `true` if the generator should ignore this field completely.
       |  ///
       |  /// If `null` (the default) or `false`, the field will be considered for
       |  /// serialization.
       |  final bool ignore;
       |
       |  /// Whether the generator should include fields with `null` values in the
       |  /// serialized output.
       |  ///
       |  /// If `true`, the generator should include the field in the serialized
       |  /// output, even if the value is `null`.
       |  ///
       |  /// The default value, `null`, indicates that the behavior should be
       |  /// acquired from the [JsonSerializable.includeIfNull] annotation on the
       |  /// enclosing class.
       |  ///
       |  /// If [disallowNullValue] is `true`, this value is treated as `false` to
       |  /// ensure compatibility between `toJson` and `fromJson`.
       |  ///
       |  /// If both [includeIfNull] and [disallowNullValue] are set to `true` on the
       |  /// same field, an exception will be thrown during code generation.
       |  final bool includeIfNull;
       |
       |  /// The key in a JSON map to use when reading and writing values corresponding
       |  /// to the annotated fields.
       |  ///
       |  /// If `null`, the field name is used.
       |  final String name;
       |
       |  /// When `true`, `null` fields are handled gracefully when encoding to JSON
       |  /// and when decoding `null` and nonexistent values from JSON.
       |  ///
       |  /// Setting to `false` eliminates `null` verification in the generated code
       |  /// for the annotated field, which reduces the code size. Errors may be thrown
       |  /// at runtime if `null` values are encountered, but the original class should
       |  /// also implement `null` runtime validation if it's critical.
       |  ///
       |  /// The default value, `null`, indicates that the behavior should be
       |  /// acquired from the [JsonSerializable.nullable] annotation on the
       |  /// enclosing class.
       |  final bool nullable;
       |
       |  /// When `true`, generated code for `fromJson` will verify that the source
       |  /// JSON map contains the associated key.
       |  ///
       |  /// If the key does not exist, a [MissingRequiredKeysException] exception is
       |  /// thrown.
       |  ///
       |  /// Note: only the existence of the key is checked. A key with a `null` value
       |  /// is considered valid.
       |  final bool required;
       |
       |  /// A [Function] to use when encoding the annotated field to JSON.
       |  ///
       |  /// Must be a top-level or static [Function] with one parameter compatible
       |  /// with the field being serialized that returns a JSON-compatible value.
       |  ///
       |  /// When creating a class that supports both `toJson` and `fromJson`
       |  /// (the default), you should also set [fromJson] if you set [toJson].
       |  /// Values returned by [toJson] should "round-trip" through [fromJson].
       |  final Function toJson;
       |
       |  /// The value to use for an enum field when the value provided is not in the
       |  /// source enum.
       |  ///
       |  /// Valid only on enum fields with a compatible enum value.
       |  final Object unknownEnumValue;
       |
       |  /// Creates a new [JsonKey] instance.
       |  ///
       |  /// Only required when the default behavior is not desired.
      0|  const JsonKey({
       |    this.defaultValue,
       |    this.disallowNullValue,
       |    this.fromJson,
       |    this.ignore,
       |    this.includeIfNull,
       |    this.name,
       |    this.nullable,
       |    this.required,
       |    this.toJson,
       |    this.unknownEnumValue,
       |  });
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/json_annotation-3.1.0/lib/src/json_literal.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation used to generate a private field containing the contents of a
       |/// JSON file.
       |///
       |/// The annotation can be applied to any member, but usually it's applied to
       |/// top-level getter.
       |///
       |/// In this example, the JSON content of `data.json` is populated into a
       |/// top-level, final field `_$glossaryDataJsonLiteral` in the generated file.
       |///
       |/// ```dart
       |/// @JsonLiteral('data.json')
       |/// Map get glossaryData => _$glossaryDataJsonLiteral;
       |/// ```
       |class JsonLiteral {
       |  /// The relative path from the Dart file with the annotation to the file
       |  /// containing the source JSON.
       |  final String path;
       |
       |  /// `true` if the JSON literal should be written as a constant.
       |  final bool asConst;
       |
       |  /// Creates a new [JsonLiteral] instance.
      0|  const JsonLiteral(this.path, {bool asConst = false})
       |      : asConst = asConst ?? false;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/json_annotation-3.1.0/lib/src/json_serializable.dart
       |// Copyright (c) 2017, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'allowed_keys_helpers.dart';
       |import 'checked_helpers.dart';
       |import 'json_key.dart';
       |
       |part 'json_serializable.g.dart';
       |
       |/// Values for the automatic field renaming behavior for [JsonSerializable].
      1|enum FieldRename {
       |  /// Use the field name without changes.
      1|  none,
       |
       |  /// Encodes a field named `kebabCase` with a JSON key `kebab-case`.
      1|  kebab,
       |
       |  /// Encodes a field named `snakeCase` with a JSON key `snake_case`.
      1|  snake,
       |
       |  /// Encodes a field named `pascalCase` with a JSON key `PascalCase`.
      1|  pascal
       |}
       |
       |/// An annotation used to specify a class to generate code for.
       |@JsonSerializable(
       |  checked: true,
       |  disallowUnrecognizedKeys: true,
       |  fieldRename: FieldRename.snake,
       |)
       |class JsonSerializable {
       |  /// If `true`, [Map] types are *not* assumed to be [Map<String, dynamic>]
       |  ///  which is the default type of [Map] instances return by JSON decode in
       |  /// `dart:convert`.
       |  ///
       |  /// This will increase the code size, but allows [Map] types returned
       |  /// from other sources, such as `package:yaml`.
       |  ///
       |  /// *Note: in many cases the key values are still assumed to be [String]*.
       |  final bool anyMap;
       |
       |  /// If `true`, generated `fromJson` functions include extra checks to validate
       |  /// proper deserialization of types.
       |  ///
       |  /// If an exception is thrown during deserialization, a
       |  /// [CheckedFromJsonException] is thrown.
       |  final bool checked;
       |
       |  /// If `true` (the default), a private, static `_$ExampleFromJson` method
       |  /// is created in the generated part file.
       |  ///
       |  /// Call this method from a factory constructor added to the source class:
       |  ///
       |  /// ```dart
       |  /// @JsonSerializable()
       |  /// class Example {
       |  ///   // ...
       |  ///   factory Example.fromJson(Map<String, dynamic> json) =>
       |  ///     _$ExampleFromJson(json);
       |  /// }
       |  /// ```
       |  final bool createFactory;
       |
       |  /// If `true` (the default), A top-level function is created that you can
       |  /// reference from your class.
       |  ///
       |  /// ```dart
       |  /// @JsonSerializable()
       |  /// class Example {
       |  ///   Map<String, dynamic> toJson() => _$ExampleToJson(this);
       |  /// }
       |  /// ```
       |  final bool createToJson;
       |
       |  /// If `false` (the default), then the generated `FromJson` function will
       |  /// ignore unrecognized keys in the provided JSON [Map].
       |  ///
       |  /// If `true`, unrecognized keys will cause an [UnrecognizedKeysException] to
       |  /// be thrown.
       |  final bool disallowUnrecognizedKeys;
       |
       |  /// If `true`, generated `toJson` methods will explicitly call `toJson` on
       |  /// nested objects.
       |  ///
       |  /// When using JSON encoding support in `dart:convert`, `toJson` is
       |  /// automatically called on objects, so the default behavior
       |  /// (`explicitToJson: false`) is to omit the `toJson` call.
       |  ///
       |  /// Example of `explicitToJson: false` (default)
       |  ///
       |  /// ```dart
       |  /// Map<String, dynamic> toJson() => {'child': child};
       |  /// ```
       |  ///
       |  /// Example of `explicitToJson: true`
       |  ///
       |  /// ```dart
       |  /// Map<String, dynamic> toJson() => {'child': child?.toJson()};
       |  /// ```
       |  final bool explicitToJson;
       |
       |  /// Defines the automatic naming strategy when converting class field names
       |  /// into JSON map keys.
       |  ///
       |  /// With a value [FieldRename.none] (the default), the name of the field is
       |  /// used without modification.
       |  ///
       |  /// See [FieldRename] for details on the other options.
       |  ///
       |  /// Note: the value for [JsonKey.name] takes precedence over this option for
       |  /// fields annotated with [JsonKey].
       |  final FieldRename fieldRename;
       |
       |  /// When `true` on classes with type parameters (generic types), extra
       |  /// "helper" parameters will be generated for `fromJson` and/or `toJson` to
       |  /// support serializing values of those types.
       |  ///
       |  /// For example, the generated code for
       |  ///
       |  /// ```dart
       |  /// @JsonSerializable(genericArgumentFactories: true)
       |  /// class Response<T> {
       |  ///   int status;
       |  ///   T value;
       |  /// }
       |  /// ```
       |  ///
       |  /// Looks like
       |  ///
       |  /// ```dart
       |  /// Response<T> _$ResponseFromJson<T>(
       |  ///   Map<String, dynamic> json,
       |  ///   T Function(Object json) fromJsonT,
       |  /// ) {
       |  ///   return Response<T>()
       |  ///     ..status = json['status'] as int
       |  ///     ..value = fromJsonT(json['value']);
       |  /// }
       |  ///
       |  /// Map<String, dynamic> _$ResponseToJson<T>(
       |  ///   Response<T> instance,
       |  ///   Object Function(T value) toJsonT,
       |  /// ) =>
       |  ///     <String, dynamic>{
       |  ///       'status': instance.status,
       |  ///       'value': toJsonT(instance.value),
       |  ///     };
       |  /// ```
       |  ///
       |  /// Note: this option has no effect on classes class without type parameters.
       |  /// A warning is printed in such cases.
       |  ///
       |  /// Note: if this option is set for all classes in a package via `build.yaml`
       |  /// it is only applied to classes with type parameters  so no warning is
       |  /// printed.
       |  final bool genericArgumentFactories;
       |
       |  /// When `true`, only fields annotated with [JsonKey] will have code
       |  /// generated.
       |  ///
       |  /// It will have the same effect as if those fields had been annotated with
       |  /// `@JsonKey(ignore: true)`.
       |  final bool ignoreUnannotated;
       |
       |  /// Whether the generator should include fields with `null` values in the
       |  /// serialized output.
       |  ///
       |  /// If `true` (the default), all fields are written to JSON, even if they are
       |  /// `null`.
       |  ///
       |  /// If a field is annotated with `JsonKey` with a non-`null` value for
       |  /// `includeIfNull`, that value takes precedent.
       |  final bool includeIfNull;
       |
       |  /// When `true` (the default), `null` fields are handled gracefully when
       |  /// encoding to JSON and when decoding `null` and nonexistent values from
       |  /// JSON.
       |  ///
       |  /// Setting to `false` eliminates `null` verification in the generated code,
       |  /// which reduces the code size. Errors may be thrown at runtime if `null`
       |  /// values are encountered, but the original class should also implement
       |  /// `null` runtime validation if it's critical.
       |  final bool nullable;
       |
       |  /// Creates a new [JsonSerializable] instance.
      0|  const JsonSerializable({
       |    this.anyMap,
       |    this.checked,
       |    this.createFactory,
       |    this.createToJson,
       |    this.disallowUnrecognizedKeys,
       |    this.explicitToJson,
       |    this.fieldRename,
       |    this.ignoreUnannotated,
       |    this.includeIfNull,
       |    this.nullable,
       |    this.genericArgumentFactories,
       |  });
       |
      0|  factory JsonSerializable.fromJson(Map<String, dynamic> json) =>
      0|      _$JsonSerializableFromJson(json);
       |
       |  /// An instance of [JsonSerializable] with all fields set to their default
       |  /// values.
       |  static const defaults = JsonSerializable(
       |    anyMap: false,
       |    checked: false,
       |    createFactory: true,
       |    createToJson: true,
       |    disallowUnrecognizedKeys: false,
       |    explicitToJson: false,
       |    fieldRename: FieldRename.none,
       |    ignoreUnannotated: false,
       |    includeIfNull: true,
       |    nullable: true,
       |    genericArgumentFactories: false,
       |  );
       |
       |  /// Returns a new [JsonSerializable] instance with fields equal to the
       |  /// corresponding values in `this`, if not `null`.
       |  ///
       |  /// Otherwise, the returned value has the default value as defined in
       |  /// [defaults].
      0|  JsonSerializable withDefaults() => JsonSerializable(
      0|        anyMap: anyMap ?? defaults.anyMap,
      0|        checked: checked ?? defaults.checked,
      0|        createFactory: createFactory ?? defaults.createFactory,
      0|        createToJson: createToJson ?? defaults.createToJson,
       |        disallowUnrecognizedKeys:
      0|            disallowUnrecognizedKeys ?? defaults.disallowUnrecognizedKeys,
      0|        explicitToJson: explicitToJson ?? defaults.explicitToJson,
      0|        fieldRename: fieldRename ?? defaults.fieldRename,
      0|        ignoreUnannotated: ignoreUnannotated ?? defaults.ignoreUnannotated,
      0|        includeIfNull: includeIfNull ?? defaults.includeIfNull,
      0|        nullable: nullable ?? defaults.nullable,
       |        genericArgumentFactories:
      0|            genericArgumentFactories ?? defaults.genericArgumentFactories,
       |      );
       |
      0|  Map<String, dynamic> toJson() => _$JsonSerializableToJson(this);
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/json_annotation-3.1.0/lib/src/json_serializable.g.dart
       |// GENERATED CODE - DO NOT MODIFY BY HAND
       |
       |part of 'json_serializable.dart';
       |
       |// **************************************************************************
       |// JsonSerializableGenerator
       |// **************************************************************************
       |
      0|JsonSerializable _$JsonSerializableFromJson(Map<String, dynamic> json) {
      0|  return $checkedNew('JsonSerializable', json, () {
      0|    $checkKeys(json, allowedKeys: const [
       |      'any_map',
       |      'checked',
       |      'create_factory',
       |      'create_to_json',
       |      'disallow_unrecognized_keys',
       |      'explicit_to_json',
       |      'field_rename',
       |      'generic_argument_factories',
       |      'ignore_unannotated',
       |      'include_if_null',
       |      'nullable'
       |    ]);
      0|    final val = JsonSerializable(
      0|      anyMap: $checkedConvert(json, 'any_map', (v) => v as bool),
      0|      checked: $checkedConvert(json, 'checked', (v) => v as bool),
      0|      createFactory: $checkedConvert(json, 'create_factory', (v) => v as bool),
      0|      createToJson: $checkedConvert(json, 'create_to_json', (v) => v as bool),
       |      disallowUnrecognizedKeys:
      0|          $checkedConvert(json, 'disallow_unrecognized_keys', (v) => v as bool),
       |      explicitToJson:
      0|          $checkedConvert(json, 'explicit_to_json', (v) => v as bool),
      0|      fieldRename: $checkedConvert(json, 'field_rename',
      0|          (v) => _$enumDecodeNullable(_$FieldRenameEnumMap, v)),
       |      ignoreUnannotated:
      0|          $checkedConvert(json, 'ignore_unannotated', (v) => v as bool),
      0|      includeIfNull: $checkedConvert(json, 'include_if_null', (v) => v as bool),
      0|      nullable: $checkedConvert(json, 'nullable', (v) => v as bool),
       |      genericArgumentFactories:
      0|          $checkedConvert(json, 'generic_argument_factories', (v) => v as bool),
       |    );
       |    return val;
       |  }, fieldKeyMap: const {
       |    'anyMap': 'any_map',
       |    'createFactory': 'create_factory',
       |    'createToJson': 'create_to_json',
       |    'disallowUnrecognizedKeys': 'disallow_unrecognized_keys',
       |    'explicitToJson': 'explicit_to_json',
       |    'fieldRename': 'field_rename',
       |    'ignoreUnannotated': 'ignore_unannotated',
       |    'includeIfNull': 'include_if_null',
       |    'genericArgumentFactories': 'generic_argument_factories'
       |  });
       |}
       |
      0|Map<String, dynamic> _$JsonSerializableToJson(JsonSerializable instance) =>
      0|    <String, dynamic>{
      0|      'any_map': instance.anyMap,
      0|      'checked': instance.checked,
      0|      'create_factory': instance.createFactory,
      0|      'create_to_json': instance.createToJson,
      0|      'disallow_unrecognized_keys': instance.disallowUnrecognizedKeys,
      0|      'explicit_to_json': instance.explicitToJson,
      0|      'field_rename': _$FieldRenameEnumMap[instance.fieldRename],
      0|      'generic_argument_factories': instance.genericArgumentFactories,
      0|      'ignore_unannotated': instance.ignoreUnannotated,
      0|      'include_if_null': instance.includeIfNull,
      0|      'nullable': instance.nullable,
       |    };
       |
      0|T _$enumDecode<T>(
       |  Map<T, dynamic> enumValues,
       |  dynamic source, {
       |  T unknownValue,
       |}) {
       |  if (source == null) {
      0|    throw ArgumentError('A value must be provided. Supported values: '
      0|        '${enumValues.values.join(', ')}');
       |  }
       |
      0|  final value = enumValues.entries
      0|      .singleWhere((e) => e.value == source, orElse: () => null)
      0|      ?.key;
       |
       |  if (value == null && unknownValue == null) {
      0|    throw ArgumentError('`$source` is not one of the supported values: '
      0|        '${enumValues.values.join(', ')}');
       |  }
       |  return value ?? unknownValue;
       |}
       |
      0|T _$enumDecodeNullable<T>(
       |  Map<T, dynamic> enumValues,
       |  dynamic source, {
       |  T unknownValue,
       |}) {
       |  if (source == null) {
       |    return null;
       |  }
      0|  return _$enumDecode<T>(enumValues, source, unknownValue: unknownValue);
       |}
       |
       |const _$FieldRenameEnumMap = {
       |  FieldRename.none: 'none',
       |  FieldRename.kebab: 'kebab',
       |  FieldRename.snake: 'snake',
       |  FieldRename.pascal: 'pascal',
       |};
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/json_annotation-3.1.0/lib/src/json_value.dart
       |// Copyright (c) 2018, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |/// An annotation used to specify how a enum value is serialized.
       |class JsonValue {
       |  /// The value to use when serializing and deserializing.
       |  ///
       |  /// Can be a [String] or an [int].
       |  final dynamic value;
       |
      0|  const JsonValue(this.value);
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/verifyJWT/ivm_check_integrity.dart
       |part of '../../ivmjwt.dart';
       |
       |/// Token integrity check
       |///
       |/// The entry point for JWT validation function
      1|Future<Map<String, dynamic>> _checkTokenIntegrity(String token) async {
       |  var jwtHeader = '';
       |  var jwtPayload = '';
       |  var validHeader = false;
       |  var validPayload = false;
       |
       |  /// Step-1: Check for token integrity (3 parts)
       |  ///
      1|  if (token.isEmpty) {
      0|    throw Exception('Invalid or empty token provided!');
       |  }
       |
       |  /// Check that the JWT is well-formed
       |  /// Ensure that the JWT conforms to the structure of a JWT. If this fails, the token is considered invalid, and the request must be rejected.
       |  ///
       |
       |  /// Parse the JWT to extract its three components. The first segment is the Header, the second is the Payload, and the third is the Signature. Each segment is base64url encoded.
       |  ///
      1|  final tokenSegments = token.split('.');
       |
       |  /// Verify that the JWT contains three segments, separated by two period ('.') characters.
       |  ///
      4|  if (!(tokenSegments.length == 3) || tokenSegments[2].isEmpty) {
       |    // Token does not have 3 inetgrity parts
      0|    throw Exception('Token integrity is broken!');
       |  }
       |
       |  /// Decode and check the header value
       |  ///
       |  /// Base64url-decode the Header, ensuring that no line breaks, whitespace, or other additional characters have been used, and verify that the decoded Header is a valid JSON object.
       |  ///
       |  try {
       |    jwtHeader =
      4|        utf8.decode(base64Url.decode(base64Url.normalize(tokenSegments[0])));
       |  } catch (e) {
      0|    throw Exception('Error decoding header segment! $e.');
       |  }
       |
       |  // Verify if the header is a valid JSON
       |  try {
      1|    final jv = JsonValidator();
      2|    validHeader = await jv.validate(jwtHeader);
       |    // validHeader = await Utilities.validateSegmentToJSON(jwtHeader);
       |  } catch (e) {
      0|    throw Exception('Error validating header segment! $e.');
       |  }
       |
       |  /// Base64url-decode the Payload, ensuring that no line breaks, whitespace, or other additional characters have been used, and verify that the decoded Payload is a valid JSON object.
       |  ///
       |  try {
       |    jwtPayload =
      4|        utf8.decode(base64Url.decode(base64Url.normalize(tokenSegments[1])));
       |  } catch (e) {
      0|    throw Exception('Error decoding payload segment! $e.');
       |  }
       |
       |  // Verify if the payload is a valid JSON
       |  try {
      1|    final jv = JsonValidator();
      2|    validPayload = await jv.validate(jwtPayload);
       |  } catch (e) {
      0|    throw Exception('Error validating payload segment! $e.');
       |  }
       |
       |  // Return the validity check and decoded segments
       |  if (validHeader && validPayload) {
      1|    return {'valid': true, 'header': jwtHeader, 'payload': jwtPayload};
       |  } else {
      0|    return {'valid': false, 'header': null, 'payload': null};
       |  }
       |}
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/verifyJWT/ivm_check_signature.dart
       |part of '../../ivmjwt.dart';
       |
       |/// Check signature
       |
       |/// The last segment of a JWT is the signature, which is used to verify that the token was signed by the sender and not altered in any way. The Signature is created using the Header and Payload segments, a signing algorithm, and a secret or public key (depending on the chosen signing algorithm).
       |///
       |/// * Check the signing algorithm. (Done in ALG_CHECK: in ivm_jwt.dart)
       |/// * Retrieve the alg property from the decoded Header.
       |/// * Ensure that it is an allowed algorithm. Specifically, to avoid certain attacks, make sure you disallow none.
       |/// * Check that it matches the algorithm selected in the verification function name [e.g. verifyRS256].
       |/// * Confirm that the token is correctly signed using the proper key.
       |///
       |/// **To verify the signature, you will need to:**
       |///
      1|Future<bool> _verifyRS256Signature(
       |    {@required String header,
       |    @required String payload,
       |    @required String token,
       |    @required String alg,
       |    @required String kid,
       |    @required String jwks}) async {
       |  // step-PREP-0
      1|  final tokenSegments = token.split('.');
       |  RSAPublicKey _usePKey;
      2|  if (alg.isEmpty || alg == 'none') {
       |    return false;
       |  }
       |
       |  // step-PREP-1: get the public key:
       |  //
       |  try {
       |    /// Replace whitespaces (CRLF, LF, TAB)
      2|    final _jwks = jwks.replaceAll(RegExp(r'\s'), '');
       |
       |    // Work with the JWKS to get the right jwkey and then return the RSAPublicKey from it.
      1|    final jJWKS = json.decode(_jwks) as Map<String, dynamic>;
      1|    final jwkSet = IvmRS256JWKS.fromJson(jJWKS);
      1|    final jKey = jwkSet.getKeyByKid(kid);
      1|    _usePKey = jKey.getRSAPublicKey();
       |  } catch (e) {
      0|    throw Exception(
      0|        'Unable to acquire public key for signature verification! $e.');
       |  }
       |
       |  // Verify if the algorithm matches the
      1|  if (alg == 'RS256') {
       |    // Prepare the token's signature (segment-3) and the header and the payload
       |    // as combined signedData - all in Uint8List format;
       |    final u8lOrgSignature =
      3|        base64Url.decode(base64Url.normalize(tokenSegments[2]));
       |
      3|    final bhd = base64Url.decode(base64Url.normalize(tokenSegments[0]));
      3|    final bpd = base64Url.decode(base64Url.normalize(tokenSegments[1]));
       |
      2|    final bSignedData = <List<int>>[bhd, '.'.codeUnits, bpd];
       |    final signedData =
      4|        Uint8List.fromList(bSignedData.expand((x) => x).toList());
       |
       |    // return the result of Verify the signature
       |    try {
       |      final ivmVerifier =
      1|          IvmVerifierRSA256(_usePKey, signedData, u8lOrgSignature);
      1|      return ivmVerifier.verifyRS256();
       |    } catch (e) {
      0|      throw Exception('Error raised while verifying signature! $e');
       |    }
       |  } else {
      0|    throw Exception('Invalid signature verification algorithm selected!');
       |  }
       |}
       |
       |// 1. To verify that the signature is correct, you need to generate a new Base64url-encoded signature using the public key (RS256) or secret (HS256) and verify that it matches the original Signature included with the JWT:
       |
       |// Take the original Base64url-encoded Header and original Base64url-encoded Payload segments (Base64url-encoded Header + "." + Base64url-encoded Payload), and hash them with SHA-256.
       |
       |// Encrypt using either HMAC or RSA (depending on your selected signing algorithm) and the appropriate key.
       |
       |// Base64url-encode the result.
       |
       |// For RS256: Retrieve the public key from the JSON web key set (JWKS) located by using the Auth0 discovery endpoint. For debugging purposes, you can visually inspect your token at jwt.io; for this purpose, you can also locate your public key in the Auth0 Dashboard. Look in Applications>Settings>Advanced Settings>Certificates and locate the Signing Certificate field.
       |
       |// For HS256: Retrieve the client_secret from Auth0's Management API using the Get a Client endpoint. For debugging purposes, you can visually inspect your token at jwt.io; for this purpose, you can also locate your secret in the Auth0 Dashboard. For applications, look in Settings and locate the Client Secret field. For APIs, look in Settings and locate the Signing Secret field. (Note that this field is only displayed for APIs using the HS256 signing algorithm.)
       |
       |// In the case of RSA, you can also use the following steps:
       |
       |// Calculate current hash value. A hash value of the signed message is calculated. For this calculation, the same hashing algorithm is used as was used during the signing process. The obtained hash value is called the current hash value because it is calculated from the current state of the message.
       |
       |// Calculate the original hash value. The digital signature is decrypted with the same encryption algorithm that was used during the signing process. The decryption is done by the public key that corresponds to the private key used during the signing of the message. As a result, we obtain the original hash value that was calculated from the original message during the previous step of the signing process (the original message digests).
       |
       |// Compare the current and the original hash values. If the two values are identical, the verification is successful and proves that the message has been signed with the private key that corresponds to the public key used in the verification process. If the two values differ, the digital signature is invalid and the verification is unsuccessful.
       |
       |// If the generated signature does not match the original Signature included with the JWT, the token is considered invalid, and the request must be rejected.
/Users/tonevSr/Documents/Programming/_proProjects/dartLibs/ivmjwt/lib/src/verifyJWT/ivm_check_claims.dart
       |part of '../../ivmjwt.dart';
       |
       |/// Check the token claims
       |///
       |/// The main and only mandatory is the time expiration [exp]
       |///
      1|Future<bool> _verifyClaims(SegmentPayload claims) async {
       |  var result = false;
      1|  if (claims.exp == null) {
       |    return result;
       |  }
       |
      1|  final exp = claims.exp;
      1|  final nbf = claims.nbf ?? 0;
      1|  final now = Utilities.currentTimeInSMS();
       |
       |  /// If not_before is active - consider it for time validity
      3|  if (nbf >= 0 && nbf < now + 180) {
      2|    if (exp > now + 180) {
       |      result = true;
       |    }
       |  }
       |
       |  return result;
       |}
/Users/tonevSr/.pub-cache/hosted/pub.dartlang.org/test_core-0.3.11+1/lib/src/runner/coverage.dart
       |// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
       |// for details. All rights reserved. Use of this source code is governed by a
       |// BSD-style license that can be found in the LICENSE file.
       |
       |import 'dart:convert';
       |import 'dart:io';
       |
       |import 'package:path/path.dart' as p;
       |
       |import 'live_suite_controller.dart';
       |
       |/// Collects coverage and outputs to the [coveragePath] path.
      0|Future<void> writeCoverage(
       |    String coveragePath, LiveSuiteController controller) async {
      0|  var suite = controller.liveSuite.suite;
      0|  var coverage = await controller.liveSuite.suite.gatherCoverage();
      0|  final outfile = File(p.join(coveragePath,
      0|      '${suite.path}.${suite.platform.runtime.name.toLowerCase()}.json'))
      0|    ..createSync(recursive: true);
      0|  final out = outfile.openWrite();
      0|  out.write(json.encode(coverage));
      0|  await out.flush();
      0|  await out.close();
       |}
